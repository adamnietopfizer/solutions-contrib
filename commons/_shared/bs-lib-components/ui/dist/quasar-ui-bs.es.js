var _P = Object.defineProperty, IP = Object.defineProperties;
var FP = Object.getOwnPropertyDescriptors;
var Vw = Object.getOwnPropertySymbols;
var LP = Object.prototype.hasOwnProperty, NP = Object.prototype.propertyIsEnumerable;
var Bw = (o, e, t) => e in o ? _P(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, ui = (o, e) => {
  for (var t in e || (e = {}))
    LP.call(e, t) && Bw(o, t, e[t]);
  if (Vw)
    for (var t of Vw(e))
      NP.call(e, t) && Bw(o, t, e[t]);
  return o;
}, cl = (o, e) => IP(o, FP(e));
var Hw = (o, e, t) => new Promise((i, r) => {
  var n = (l) => {
    try {
      a(t.next(l));
    } catch (c) {
      r(c);
    }
  }, s = (l) => {
    try {
      a(t.throw(l));
    } catch (c) {
      r(c);
    }
  }, a = (l) => l.done ? i(l.value) : Promise.resolve(l.value).then(n, s);
  a((t = t.apply(o, e)).next());
});
import GP from "axios";
import { defineComponent as Fe, computed as uR, openBlock as ce, createBlock as _e, Teleport as Dv, renderSlot as Ze, createCommentVNode as Ne, resolveComponent as ue, withCtx as fe, createVNode as Ce, normalizeStyle as Ml, normalizeClass as Rr, createElementVNode as Re, createElementBlock as je, createTextVNode as hR, toDisplayString as Bt, pushScopeId as Zl, popScopeId as Ql, mergeProps as Mr, withDirectives as pa, vShow as Fh, Fragment as Ep, renderList as li, createSlots as nr, normalizeProps as Yt, guardReactiveProps as ei, resolveDirective as dS, render as Ww, h as kP, getCurrentInstance as VP } from "vue";
import { QCard as BP, QBtn as ou, QIcon as Lo, QDrawer as HP, QHeader as WP, QTab as jP, QTooltip as pR, QTabs as UP, QPageContainer as $P, QPage as zP, QLayout as KP, QSelect as YP, QSlider as XP, QRange as qP, QSpinner as ZP, QInput as Ov, QTh as uS, QMenu as fR, QItem as gR, QItemSection as vR, QList as mR, ClosePopup as yR, QTr as hS, QLinearProgress as QP, QTable as JP, QTd as eA, QImg as tA, QCheckbox as iA, QDate as rA, QPopupProxy as nA } from "quasar";
import { isEqual as oA, uniqueId as sA, isUndefined as Pd, isNull as aA, escape as lA, isEmpty as CR } from "lodash";
import { mdiMagnify as Pv, mdiArrowUpThin as cA, mdiSortAscending as Eg, mdiSortDescending as Rg, mdiChevronDown as SR, mdiAlert as dA, mdiTrashCanOutline as bR, mdiCloseCircleMultiple as uA } from "@quasar/extras/mdi-v6";
function hA(o) {
  return o !== null && typeof o == "object" && Array.isArray(o) !== !0;
}
function pA(o, e) {
  e.components !== void 0 && Object.values(e.components).forEach((t) => {
    hA(t) === !0 && t.name !== void 0 && o.component(t.name, t);
  });
}
function fy(o) {
  return new Promise((e, t) => {
    o.then((i) => e(i == null ? void 0 : i.data)).catch((i) => t(i));
  });
}
const xv = class xv {
  static initClient(e) {
    this._restApiEndpoint = e, this.client = GP.create({ baseURL: this._restApiEndpoint }), this.client.interceptors.response.use(
      (t) => t,
      (t) => {
        console.error(t), this.errors.push(t.response);
      }
    );
  }
  static requestWrapper(e) {
    const t = e.bind(this);
    return (...i) => new Promise((r, n) => {
      this.client || n("client not set, init servetApi with the backendUrl"), t(...i).then(r).catch(n);
    });
  }
  static init(e) {
    this.initialized || (this.initClient(e), this.doDelete = this.requestWrapper(this.doDelete), this.doPost = this.requestWrapper(this.doPost), this.doGet = this.requestWrapper(this.doGet), this.doPut = this.requestWrapper(this.doPut), this.initialized = !0);
  }
  static doPost(e, t) {
    return fy(this.client.post(e, t));
  }
  static doPut(e, t) {
    return fy(this.client.put(e, t));
  }
  static doGet(e) {
    return fy(this.client.get(e));
  }
  static doDelete(e) {
    return Hw(this, null, function* () {
      return new Promise((t, i) => {
        this.client.delete(e).then((r) => t(!!r)).catch((r) => i(r));
      });
    });
  }
  static getDatasetChunk(e, t = 1e4, i = 0) {
    return this.doPost("bs_api/dataset/get", {
      dataset_name: e,
      chunksize: t,
      chunk_index: i
    });
  }
  static getDatasetSchema(e) {
    return this.doPost("bs_api/dataset/get_schema", {
      dataset_name: e
    });
  }
  static getFilteredDataset(e, t = 1e4, i = 0, r, n, s) {
    return this.doPost("bs_api/dataset/get_filtered_dataset", {
      dataset_name: e,
      chunksize: t,
      chunk_index: i,
      filters: r || {},
      group_key: n,
      group_rows: s
    });
  }
  static getDatasetGenericData(e) {
    return this.doPost("bs_api/dataset/get_generic_data", {
      dataset_name: e
    });
  }
};
xv.errors = [], xv.initialized = !1;
let xl = xv;
const pS = Fe({
  name: "ProvideMixin",
  methods: {
    providePrefixed(o, e) {
      const { prefix: t, getter: i } = ui({
        prefix: "$",
        getter: (r) => this[r]
      }, e);
      return o.reduce((r, n) => {
        const s = t + n;
        return r[s] = i(n), r;
      }, {});
    },
    createComputedFromKey(o) {
      return uR(() => this[o]);
    },
    provideComputed(o, e) {
      const t = cl(ui({}, e), {
        getter: (i) => this.createComputedFromKey(i)
      });
      return this.providePrefixed(o, t);
    },
    provideStatic(o, e) {
      const t = cl(ui({}, e), {
        getter: (i) => this[i]
      });
      return this.providePrefixed(o, t);
    }
  }
}), fS = Fe({
  name: "CheckSlotComponentsMixin",
  methods: {
    /**
     * Returns an array of the components under a certain slot.
     *
     * It filters the `$slot[slotName]()` by the `componentName`.
     *
     * @param {string} componentName - The name field of the component
     * @param {string} [slotName=\"default\"] - The name of the slot under which to look for the component
     * */
    getSlotComponents(o, e = "default") {
      return ((r) => this.$slots.hasOwnProperty(r) ? this.$slots[r]() : [])(e).filter((r) => {
        const n = r.type;
        return (n == null ? void 0 : n.name) && n.name === o;
      });
    }
  }
});
function fA(...o) {
  o.forEach(([e, t]) => {
    setTimeout(() => {
      e();
    }, t);
  });
}
function wR(o, e, t, i, r = 50) {
  fA(
    [o, r * +!t],
    [e, i * +t]
  );
}
const ER = (o) => `bs-menu-tab-${o}`, RR = (o) => `tab-content-id-${o}`, gA = Fe({
  name: "BsTabPageChildWrapper",
  inject: ["$qPageMounted", "$tabId"],
  computed: {
    contentCSSSelector() {
      return `#${this.tabContentId}`;
    },
    tabContentId() {
      return RR(this.tabId);
    },
    tabId() {
      return this == null ? void 0 : this.$tabId;
    },
    qPageMounted() {
      return this == null ? void 0 : this.$qPageMounted;
    }
  }
}), He = (o, e) => {
  const t = o.__vccOpts || o;
  for (const [i, r] of e)
    t[i] = r;
  return t;
};
function vA(o, e, t, i, r, n) {
  return o.qPageMounted ? (ce(), _e(Dv, {
    key: 0,
    to: o.contentCSSSelector
  }, [
    Ze(o.$slots, "default")
  ], 8, ["to"])) : Ne("", !0);
}
const gS = /* @__PURE__ */ He(gA, [["render", vA]]), mA = Fe({
  name: "BsContent",
  components: {
    BsTabPageChildWrapper: gS
  }
});
function yA(o, e, t, i, r, n) {
  const s = ue("BsTabPageChildWrapper");
  return ce(), _e(s, null, {
    default: fe(() => [
      Ze(o.$slots, "default")
    ]),
    _: 3
  });
}
const dC = /* @__PURE__ */ He(mA, [["render", yA]]), CA = Fe({
  name: "BsDocumentation",
  components: {
    QCard: BP,
    QBtn: ou,
    BsTabPageChildWrapper: gS
  },
  data() {
    return {
      open: !1,
      docHidden: !0,
      docHide: !0,
      defaultDocsPropValues: {
        docIcon: "help",
        docTitle: "Documentation",
        docImageDimensions: {
          width: 36,
          height: 40
        }
      }
    };
  },
  props: {
    modelValue: {
      type: Boolean,
      default: !1
    },
    docIcon: {
      type: String
    },
    docTitle: {
      type: String
    },
    docImageDimensions: {
      type: Object
    }
  },
  inject: [
    // docs props
    "$tabDocsProps",
    "$layoutDocsProps"
  ],
  computed: {
    closed() {
      return !this.open;
    },
    mDocsProps() {
      return ui(ui(ui(ui({}, this.defaultDocsPropValues), this.layoutDocsProps), this.tabDocsProps), this.docsProps);
    },
    docsProps() {
      return this.clearObjectFromUndefined({
        docImageDimensions: this.docImageDimensions,
        docTitle: this.docTitle,
        docIcon: this.docIcon
      });
    },
    tabDocsProps() {
      const o = (this == null ? void 0 : this.$tabDocsProps) || {};
      return this.clearObjectFromUndefined(o);
    },
    layoutDocsProps() {
      const o = (this == null ? void 0 : this.$layoutDocsProps) || {};
      return this.clearObjectFromUndefined(o);
    },
    docContentStyleVariables() {
      return {
        "--doc-content-hide-transition-duration": ".345s"
      };
    }
  },
  methods: {
    toggleDoc(o) {
      o === void 0 && (o = !this.open), this.open = o, this.$emit("update:model-value", o);
    },
    clearObjectFromUndefined(o) {
      return Object.entries(o).reduce((t, [i, r]) => (r !== void 0 && (t[i] = r), t), {});
    }
  },
  watch: {
    modelValue() {
      this.open = this.modelValue;
    },
    open() {
      wR(
        () => this.docHide = this.closed,
        () => this.docHidden = this.closed,
        this.closed,
        500
      );
    }
  },
  mounted() {
    this.open = this.modelValue;
  }
}), TR = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTMiIHZpZXdCb3g9IjAgMCAxNCAxMyIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEuNjQ2IDAuNzAzNjEzQzAuNzM2ODU3IDAuNzAzNjEzIDAgMS40MTMxOCAwIDIuMjg4NjVWNy43ODUyNEMwIDguNjYwNzEgMC43MzY4NTcgOS4zNzAyOCAxLjY0NiA5LjM3MDI4SDQuMDkwNjVDNC4wMzExMSA5LjA1ODAyIDQgOC43MzYxNyA0IDguNDA3MzJIMy43NVYxLjY2NjU4SDEwLjM1NEMxMC43MTA5IDEuNjY2NTggMTEgMS45NDUwMSAxMSAyLjI4ODY1VjMuMzEwMzFDMTEuMzQ4NiAzLjQwNTI0IDExLjY4MzIgMy41MzI0NCAxMiAzLjY4ODM1VjIuMjg4NjVDMTIgMS40MTMxOCAxMS4yNjMxIDAuNzAzNjEzIDEwLjM1NCAwLjcwMzYxM0gxLjY0NlpNMi43NSAxLjY2NjU4VjguNDA3MzJIMS42NDZDMS4yODkxNCA4LjQwNzMyIDEgOC4xMjg4OCAxIDcuNzg1MjRWMi4yODg2NUMxIDEuOTQ1MDEgMS4yODkxNCAxLjY2NjU4IDEuNjQ2IDEuNjY2NThIMi43NVoiIGZpbGw9IiMwMUIyQUEiLz4KPHBhdGggZD0iTTkuNDk5OSA3LjUxODVDOC45ODk5IDcuNTE4NSA4LjU3Njg5IDcuOTE2MjEgOC41NzY4OSA4LjQwNzMyQzguNTc2ODkgOC44OTg0MyA4Ljk4OTkgOS4yOTYxMyA5LjQ5OTkgOS4yOTYxM0MxMC4wMDk5IDkuMjk2MTMgMTAuNDIyOSA4Ljg5ODQzIDEwLjQyMjkgOC40MDczMkMxMC40MjI5IDcuOTE2MjEgMTAuMDA5OSA3LjUxODUgOS40OTk5IDcuNTE4NVoiIGZpbGw9IiMwMUIyQUEiLz4KPHBhdGggZD0iTTkuNSAxMi43NDA2QzExLjk4NSAxMi43NDA2IDE0IDEwLjgwMDMgMTQgOC40MDczMkMxNCA2LjAxNDM1IDExLjk4NSA0LjA3Mzk4IDkuNSA0LjA3Mzk4QzcuMDE1IDQuMDczOTggNSA2LjAxNDM1IDUgOC40MDczMkM1IDEwLjgwMDMgNy4wMTUgMTIuNzQwNiA5LjUgMTIuNzQwNlpNOS41MDI5IDUuNTE4NDNDOS43Mjg5IDUuNTIxMzIgOS45NTM5IDUuNTQ2MzUgMTAuMTczOSA1LjU5MzU0QzEwLjI2OTkgNS42MTM3NiAxMC4zNDE5IDUuNjkxNzYgMTAuMzUyOSA1Ljc4NjEzTDEwLjQwNDkgNi4yMzg3MkMxMC40Mjg5IDYuNDQ2NzIgMTAuNjEwOSA2LjYwMzY5IDEwLjgyNzkgNi42MDM2OUMxMC44ODU5IDYuNjAzNjkgMTAuOTQzOSA2LjU5MjEzIDEwLjk5NzkgNi41NjkwMkwxMS40Mjg5IDYuMzg3MDJDMTEuNTE4OSA2LjM0OTQ3IDExLjYyMjkgNi4zNjk2OSAxMS42ODk5IDYuNDM5MDJDMTIuMDAwOSA2Ljc1OTY5IDEyLjIzMjkgNy4xNDM5MSAxMi4zNjc5IDcuNTYyOEMxMi4zOTY5IDcuNjUzMzIgMTIuMzYzOSA3Ljc1MTU0IDEyLjI4NDkgNy44MDczOUwxMS45MDI5IDguMDc4OTVDMTEuNzkzOSA4LjE1NTk4IDExLjcyOTkgOC4yNzgyOCAxMS43Mjk5IDguNDA4MjhDMTEuNzI5OSA4LjUzODI4IDExLjc5MzkgOC42NjA1OCAxMS45MDM5IDguNzM4NThMMTIuMjg1OSA5LjAxMDEzQzEyLjM2NDkgOS4wNjU5OCAxMi4zOTg5IDkuMTY0MjEgMTIuMzY5OSA5LjI1NDcyQzEyLjIzNDkgOS42NzM2MSAxMi4wMDI5IDEwLjA1NzggMTEuNjkxOSAxMC4zNzg1QzExLjYyNDkgMTAuNDQ2OSAxMS41MTk5IDEwLjQ2ODEgMTEuNDMwOSAxMC40MzA1TDEwLjk5NzkgMTAuMjQ3NUMxMC44NzM5IDEwLjE5NTUgMTAuNzMxOSAxMC4yMDMyIDEwLjYxNDkgMTAuMjY3OEMxMC40OTc5IDEwLjMzMzIgMTAuNDE5OSAxMC40NDc4IDEwLjQwNDkgMTAuNTc2OUwxMC4zNTI5IDExLjAyOTVDMTAuMzQxOSAxMS4xMjI5IDEwLjI3MTkgMTEuMTk5OSAxMC4xNzY5IDExLjIyMTFDOS43MzA5IDExLjMyMzIgOS4yNjY5IDExLjMyMzIgOC44MjA5IDExLjIyMTFDOC43MjU5IDExLjE5ODkgOC42NTU5IDExLjEyMjkgOC42NDQ5IDExLjAyOTVMOC41OTI5IDEwLjU3NzhDOC41Nzc5IDEwLjQ0ODggOC40OTk5IDEwLjMzNDIgOC4zODI5IDEwLjI2OTdDOC4yNjU5IDEwLjIwNTIgOC4xMjM5IDEwLjE5NzUgOC4wMDA5IDEwLjI0OTVMNy41Njc4OSAxMC40MzI0QzcuNDc3OSAxMC40NyA3LjM3MzkgMTAuNDQ5OCA3LjMwNjkgMTAuMzgwNEM2Ljk5NTkgMTAuMDU5OCA2Ljc2MzkgOS42NzU1NCA2LjYyODg5IDkuMjU1NjlDNi41OTk5IDkuMTY1MTcgNi42MzM5IDkuMDY2OTUgNi43MTI5IDkuMDExMDlMNy4wOTU4OSA4LjczOTU0QzcuMjA0OSA4LjY2MjUgNy4yNjg5IDguNTQwMjEgNy4yNjg5IDguNDEwMjFDNy4yNjg5IDguMjgwMjEgNy4yMDQ5IDguMTU3OTEgNy4wOTU4OSA4LjA3OTkxTDYuNzEzODkgNy44MDkzMkM2LjYzNDkgNy43NTM0NiA2LjYwMDkgNy42NTUyNCA2LjYyOTkgNy41NjQ3MkM2Ljc2NDkgNy4xNDU4MyA2Ljk5Njg5IDYuNzYxNjEgNy4zMDc4OSA2LjQ0MDk1QzcuMzc0OSA2LjM3MjU4IDcuNDc5OSA2LjM1MTM5IDcuNTY4OSA2LjM4ODk1TDcuOTk5OSA2LjU3MDk1QzguMTIzOSA2LjYyMjk1IDguMjY1ODkgNi42MTUyNCA4LjM4Mzg5IDYuNTQ5NzZDOC41MDA5IDYuNDg0MjggOC41Nzg5IDYuMzY5NjkgOC41OTM4OSA2LjIzOTY5TDguNjQ1OSA1Ljc4ODA2QzguNjU2OSA1LjY5MzY5IDguNzI4OSA1LjYxNjY1IDguODI0OSA1LjU5NTQ2QzkuMDQ1OSA1LjU0ODI4IDkuMjcwOSA1LjUyMzI0IDkuNTAxOSA1LjUyMDM1TDkuNTAyOSA1LjUxODQzWiIgZmlsbD0iIzAxQjJBQSIvPgo8L3N2Zz4K";
const xR = (o) => (Zl("data-v-47db9d18"), o = o(), Ql(), o), SA = /* @__PURE__ */ xR(() => /* @__PURE__ */ Re("div", { class: "row items-center q-gutter-sm no-wrap" }, [
  /* @__PURE__ */ Re("img", {
    src: TR,
    width: "15",
    height: "16"
  }),
  /* @__PURE__ */ Re("span", { class: "btn-solution-text" }, "Dataiku Solutions")
], -1)), bA = { class: "flex row items-center q-gutter-sm q-mb-lg" }, wA = ["src", "width", "height"], EA = { class: "dku-large-title-sb" }, RA = { class: "doc-body" }, TA = /* @__PURE__ */ xR(() => /* @__PURE__ */ Re("div", { class: "doc-footer flex row items-center" }, [
  /* @__PURE__ */ Re("span", { class: "doc-footer__icon" }, [
    /* @__PURE__ */ Re("img", {
      src: TR,
      width: "14",
      height: "12.5"
    })
  ]),
  /* @__PURE__ */ Re("span", { class: "doc-footer__text dku-tiny-text-sb" }, "Dataiku Solutions")
], -1));
function xA(o, e, t, i, r, n) {
  const s = ue("QBtn"), a = ue("QCard"), l = ue("BsTabPageChildWrapper");
  return ce(), _e(l, null, {
    default: fe(() => [
      Ce(s, {
        unelevated: "",
        outline: "",
        "no-caps": "",
        "no-wrap": "",
        class: "btn-solution absolute",
        square: "",
        onClick: e[0] || (e[0] = (c) => o.toggleDoc())
      }, {
        default: fe(() => [
          SA
        ]),
        _: 1
      }),
      Ce(a, {
        style: Ml(o.docContentStyleVariables),
        class: Rr([
          "doc-content",
          "flex",
          "row",
          o.docHide && "doc-hide",
          o.docHidden && "doc-hidden"
        ])
      }, {
        default: fe(() => [
          Re("div", bA, [
            o.mDocsProps.docIcon ? (ce(), je("img", {
              key: 0,
              src: o.mDocsProps.docIcon,
              width: o.mDocsProps.docImageDimensions.width,
              height: o.mDocsProps.docImageDimensions.height
            }, null, 8, wA)) : Ne("", !0),
            Re("span", EA, [
              o.$slots.title ? Ze(o.$slots, "title", { key: 0 }, void 0, !0) : Ne("", !0),
              hR(" " + Bt(o.$slots.title ? "" : o.mDocsProps.docTitle), 1)
            ])
          ]),
          Re("div", RA, [
            Ze(o.$slots, "default", {}, void 0, !0)
          ]),
          TA
        ]),
        _: 3
      }, 8, ["style", "class"])
    ]),
    _: 3
  });
}
const uC = /* @__PURE__ */ He(CA, [["render", xA], ["__scopeId", "data-v-47db9d18"]]), Rp = Fe({
  inject: ["$isTabSelected", "$qLayoutMounted"],
  computed: {
    showComponent() {
      const o = this == null ? void 0 : this.$isTabSelected;
      return o === void 0 || o;
    },
    qLayoutMounted() {
      return this.$qLayoutMounted;
    }
  }
}), DA = Fe({
  name: "BsTabTitle",
  extends: Rp,
  inject: ["$tabName", "$defaultTabUsed"],
  emits: ["calculated"],
  props: {
    calculateWidth: {
      type: Boolean,
      default: !1
    }
  },
  data() {
    return {
      tabTitleWidth: "0px"
    };
  },
  computed: {
    tabName() {
      return this.$tabName;
    },
    defaultDrawer() {
      return this.$defaultDrawer;
    },
    defaultTabUsed() {
      return this.$defaultTabUsed;
    },
    tabTitleWidthSet() {
      return !this.widthNotSet(this.tabTitleWidth);
    }
  },
  methods: {
    calculateTabTitleWidth() {
      const { width: o } = this.$el ? getComputedStyle(this.$el) : { width: "0px" };
      this.widthNotSet(o) || (this.tabTitleWidth = o, this.$emit("calculated", o));
    },
    widthNotSet(o) {
      return ["0px", "auto"].includes(o);
    },
    calculateWidthIfNeeded() {
      !this.calculateWidth || !this.showComponent || this.tabTitleWidthSet || this.$nextTick(() => this.calculateTabTitleWidth());
    }
  },
  watch: {
    showComponent() {
      this.calculateWidthIfNeeded();
    },
    calculateWidth() {
      this.calculateWidthIfNeeded();
    }
  }
});
function OA(o, e, t, i, r, n) {
  return o.defaultTabUsed ? Ne("", !0) : (ce(), je("div", Mr({ key: 0 }, o.$attrs, { class: "text-primary bs-tab-title dku-medium-title-sb q-px-md" }), Bt(o.tabName), 17));
}
const vS = /* @__PURE__ */ He(DA, [["render", OA], ["__scopeId", "data-v-9ace8c82"]]), PA = Fe({
  name: "BsDrawer",
  extends: Rp,
  components: {
    BsTabTitle: vS
  }
});
const AA = { class: "bs-drawer-container" };
function MA(o, e, t, i, r, n) {
  const s = ue("BsTabTitle");
  return o.qLayoutMounted ? (ce(), _e(Dv, {
    key: 0,
    to: ".q-drawer"
  }, [
    pa(Re("div", AA, [
      Ce(s),
      Ze(o.$slots, "default", {}, void 0, !0)
    ], 512), [
      [Fh, o.showComponent]
    ])
  ])) : Ne("", !0);
}
const Sh = /* @__PURE__ */ He(PA, [["render", MA], ["__scopeId", "data-v-ef244777"]]), _A = Fe({
  name: "BsHeader",
  components: {
    BsTabTitle: vS
  },
  extends: Rp,
  inject: ["$defaultTabUsed", "$drawerOpen"],
  data() {
    return {
      headerTabTitleWidth: "0px",
      wrapperTransitions: !1,
      calculateHeaderTabTitleWidth: !1
    };
  },
  computed: {
    appendTabTitleToHeader() {
      return !this.defaultTabUsed;
    },
    defaultTabUsed() {
      return this.$defaultTabUsed;
    },
    drawerOpen() {
      return this.$drawerOpen;
    },
    tabHeaderStyles() {
      return {
        "--header-tab-title-width": this.headerTabTitleWidth
      };
    },
    headerTabTitleWidthExists() {
      return !this.widthNonExistant(this.headerTabTitleWidth);
    }
  },
  methods: {
    widthUpdated() {
      this.toggleTransitions();
    },
    toggleTransitions() {
      setTimeout(() => {
        this.wrapperTransitions = !0;
      }, 0);
    },
    widthNonExistant(o) {
      return ["0px", "auto"].includes(o);
    },
    updateHeaderTabTitleWidth(o) {
      this.headerTabTitleWidth = o, this.widthUpdated();
    }
  }
});
function IA(o, e, t, i, r, n) {
  const s = ue("BsTabTitle");
  return o.qLayoutMounted ? (ce(), _e(Dv, {
    key: 0,
    to: ".bs-header"
  }, [
    pa(Re("div", {
      onVnodeMounted: e[0] || (e[0] = (a) => o.calculateHeaderTabTitleWidth = !0),
      style: Ml(o.tabHeaderStyles),
      class: Rr([
        "bs-header-wrapper",
        o.wrapperTransitions && "bs-header-wrapper--transition",
        o.showComponent && o.drawerOpen && o.headerTabTitleWidthExists && "bs-header-wrapper--hide-tab-name"
      ])
    }, [
      pa(Ce(s, {
        ref: "headerTabTitle",
        "calculate-width": o.calculateHeaderTabTitleWidth,
        onCalculated: o.updateHeaderTabTitleWidth
      }, null, 8, ["calculate-width", "onCalculated"]), [
        [Fh, o.appendTabTitleToHeader]
      ]),
      Ze(o.$slots, "default", {}, void 0, !0)
    ], 6), [
      [Fh, o.showComponent]
    ])
  ])) : Ne("", !0);
}
const bh = /* @__PURE__ */ He(_A, [["render", IA], ["__scopeId", "data-v-f4a44855"]]), FA = Fe({
  name: "BsTabIcon",
  inject: ["$menuTabsMounted", "$tabId"],
  components: {
    QIcon: Lo
  },
  props: {
    name: String
  },
  computed: {
    iconName() {
      return this.name === void 0 ? this.$slots.default ? void 0 : "tab" : this.name;
    },
    menuTabsMounted() {
      return this.$menuTabsMounted;
    },
    tabId() {
      return this == null ? void 0 : this.$tabId;
    },
    bsMenuTabId() {
      return ER(this.tabId);
    },
    bsMenuTabCSSSelector() {
      return `#${this.bsMenuTabId}`;
    }
  }
});
function LA(o, e, t, i, r, n) {
  const s = ue("q-icon");
  return o.menuTabsMounted ? (ce(), _e(Dv, {
    key: 0,
    to: o.bsMenuTabCSSSelector
  }, [
    o.iconName ? (ce(), _e(s, Mr({ key: 0 }, o.$attrs, { name: o.iconName }), null, 16, ["name"])) : Ne("", !0),
    Ze(o.$slots, "default")
  ], 8, ["to"])) : Ne("", !0);
}
const dg = /* @__PURE__ */ He(FA, [["render", LA]]), NA = Fe({
  name: "BsDrawerBtn",
  extends: Rp,
  props: {
    modelValue: {
      type: Boolean,
      required: !0
    },
    show: {
      type: Boolean,
      default: !0
    }
  },
  data() {
    return {
      hide: !1,
      hidden: !1,
      hideTransitionDuration: 200
    };
  },
  watch: {
    show() {
      this.toggleShown(this.show);
    }
  },
  methods: {
    toggleLeftPanel() {
      this.$emit("update:modelValue", !this.modelValue);
    },
    toggleShown(o) {
      const e = !o;
      wR(
        () => this.hide = e,
        () => this.hidden = e,
        e,
        this.hideTransitionDuration
      );
    }
  }
}), GA = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTYgMTAwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMCAwSDRDMTAuNjI3NCAwIDE2IDUuMzcyNTggMTYgMTJWODhDMTYgOTQuNjI3NCAxMC42Mjc0IDEwMCA0IDEwMEgwVjBaIiBmaWxsPSIjQ0NDQ0NDIi8+CjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIwX2RfMV8xNjY4KSI+CjxyZWN0IHg9IjUiIHk9IjIwIiB3aWR0aD0iMSIgaGVpZ2h0PSI2MCIgZmlsbD0iI0Y1RjVGNSIvPgo8L2c+CjxnIGZpbHRlcj0idXJsKCNmaWx0ZXIxX2RfMV8xNjY4KSI+CjxyZWN0IHg9IjkiIHk9IjIwIiB3aWR0aD0iMSIgaGVpZ2h0PSI2MCIgZmlsbD0iI0Y1RjVGNSIvPgo8L2c+CjxkZWZzPgo8ZmlsdGVyIGlkPSJmaWx0ZXIwX2RfMV8xNjY4IiB4PSI1IiB5PSIyMCIgd2lkdGg9IjIiIGhlaWdodD0iNjAiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KPGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz4KPGZlQ29sb3JNYXRyaXggaW49IlNvdXJjZUFscGhhIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAiIHJlc3VsdD0iaGFyZEFscGhhIi8+CjxmZU9mZnNldCBkeD0iMSIvPgo8ZmVDb21wb3NpdGUgaW4yPSJoYXJkQWxwaGEiIG9wZXJhdG9yPSJvdXQiLz4KPGZlQ29sb3JNYXRyaXggdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMTEgMCIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9ImVmZmVjdDFfZHJvcFNoYWRvd18xXzE2NjgiLz4KPGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJlZmZlY3QxX2Ryb3BTaGFkb3dfMV8xNjY4IiByZXN1bHQ9InNoYXBlIi8+CjwvZmlsdGVyPgo8ZmlsdGVyIGlkPSJmaWx0ZXIxX2RfMV8xNjY4IiB4PSI5IiB5PSIyMCIgd2lkdGg9IjIiIGhlaWdodD0iNjAiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KPGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz4KPGZlQ29sb3JNYXRyaXggaW49IlNvdXJjZUFscGhhIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAiIHJlc3VsdD0iaGFyZEFscGhhIi8+CjxmZU9mZnNldCBkeD0iMSIvPgo8ZmVDb21wb3NpdGUgaW4yPSJoYXJkQWxwaGEiIG9wZXJhdG9yPSJvdXQiLz4KPGZlQ29sb3JNYXRyaXggdHlwZT0ibWF0cml4IiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMTEgMCIvPgo8ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluMj0iQmFja2dyb3VuZEltYWdlRml4IiByZXN1bHQ9ImVmZmVjdDFfZHJvcFNoYWRvd18xXzE2NjgiLz4KPGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJlZmZlY3QxX2Ryb3BTaGFkb3dfMV8xNjY4IiByZXN1bHQ9InNoYXBlIi8+CjwvZmlsdGVyPgo8L2RlZnM+Cjwvc3ZnPgo=";
const kA = (o) => (Zl("data-v-9969ac6c"), o = o(), Ql(), o), VA = /* @__PURE__ */ kA(() => /* @__PURE__ */ Re("img", { src: GA }, null, -1)), BA = [
  VA
];
function HA(o, e, t, i, r, n) {
  return pa((ce(), je("div", {
    onClick: e[0] || (e[0] = (...s) => o.toggleLeftPanel && o.toggleLeftPanel(...s)),
    class: Rr([o.hide && "hide", o.hidden && "hidden", "toggle-left-button"]),
    style: Ml({
      "--hide-transition-duration": `.${o.hideTransitionDuration}s`
    })
  }, BA, 6)), [
    [Fh, o.showComponent]
  ]);
}
const DR = /* @__PURE__ */ He(NA, [["render", HA], ["__scopeId", "data-v-9969ac6c"]]), WA = Fe({
  name: "BsLayoutDrawer",
  components: {
    QDrawer: HP,
    BsDrawerBtn: DR
  },
  props: {
    collapsedWidth: {
      type: Number,
      default: 50
    },
    panelWidth: {
      type: Number,
      default: 300
    },
    mini: {
      type: Boolean,
      default: !1
    },
    expandable: {
      type: Boolean,
      default: !0
    },
    modelValue: Boolean
  },
  data() {
    return {
      expand: !0
    };
  },
  computed: {
    collapsed() {
      return !this.displayExpanded;
    },
    displayExpanded() {
      return this.expand && this.expandable;
    },
    expandedWidth() {
      return +this.mini * this.collapsedWidth + this.panelWidth;
    },
    miniDrawerProps() {
      return {
        mini: this.collapsed,
        modelValue: !0
      };
    },
    defaultDrawerProps() {
      return {
        modelValue: this.displayExpanded
      };
    },
    drawerProps() {
      return this.mini ? this.miniDrawerProps : this.defaultDrawerProps;
    }
  },
  watch: {
    modelValue() {
      this.expand = this.modelValue;
    }
  },
  methods: {
    toggleDrawer(o) {
      this.expand = o, this.$emit("update:model-value", o);
    }
  },
  mounted() {
    this.modelValue !== void 0 && (this.expand = !0);
  }
});
function jA(o, e, t, i, r, n) {
  const s = ue("BsDrawerBtn"), a = ue("QDrawer");
  return ce(), _e(a, Mr(o.drawerProps, {
    "mini-width": o.collapsedWidth,
    width: o.expandedWidth,
    side: "left",
    behavior: "desktop",
    bordered: ""
  }), {
    default: fe(() => [
      Ce(s, {
        "model-value": o.expand,
        "onUpdate:modelValue": o.toggleDrawer,
        show: o.expandable
      }, null, 8, ["model-value", "onUpdate:modelValue", "show"])
    ]),
    _: 1
  }, 16, ["mini-width", "width"]);
}
const OR = /* @__PURE__ */ He(WA, [["render", jA], ["__scopeId", "data-v-8f8c14f8"]]), UA = Fe({
  name: "BsLayoutHeader",
  components: {
    QHeader: WP
  }
});
function $A(o, e, t, i, r, n) {
  const s = ue("QHeader");
  return ce(), _e(s, {
    bordered: "",
    class: "bg-white bs-header"
  });
}
const PR = /* @__PURE__ */ He(UA, [["render", $A], ["__scopeId", "data-v-9ba496fa"]]), zA = Fe({
  name: "BsMenuTab",
  components: {
    QTab: jP,
    QTooltip: pR
  },
  props: {
    name: {
      type: String
    },
    icon: {
      type: String
    },
    tabIndex: {
      type: Number
    },
    tabId: {
      type: String
    }
  },
  methods: {
    getBsMenuTabId(o) {
      return o = o || `${this.tabIndex}` || "", ER(o);
    }
  }
});
const KA = { class: "tab-name-tooltip" }, YA = ["id"];
function XA(o, e, t, i, r, n) {
  const s = ue("QTooltip"), a = ue("QTab");
  return ce(), _e(a, {
    name: o.tabIndex,
    icon: o.icon,
    ripple: !1
  }, {
    default: fe(() => [
      Ce(s, {
        offset: [9, 10],
        anchor: "center right",
        self: "center left",
        "transition-show": "jump-right",
        "transition-hide": "jump-left"
      }, {
        default: fe(() => [
          Re("span", KA, Bt(o.name), 1)
        ]),
        _: 1
      }),
      o.tabId ? (ce(), je("span", {
        key: 0,
        id: o.getBsMenuTabId(o.tabId)
      }, null, 8, YA)) : Ne("", !0)
    ]),
    _: 1
  }, 8, ["name", "icon"]);
}
const AR = /* @__PURE__ */ He(zA, [["render", XA], ["__scopeId", "data-v-61b2252d"]]), qA = Fe({
  name: "BsMenuTabs",
  components: {
    QTabs: UP
  },
  props: {
    modelValue: [Number, String]
  },
  data() {
    return {
      leftPanelFull: !0
    };
  },
  methods: {
    emitUpdatedValue(o) {
      this.$emit("update:model-value", o);
    }
  }
});
const ZA = { class: "tabs-container" };
function QA(o, e, t, i, r, n) {
  const s = ue("q-tabs");
  return ce(), je("div", ZA, [
    Ce(s, {
      "model-value": o.modelValue,
      "onUpdate:modelValue": e[0] || (e[0] = (a) => o.$emit("update:model-value", a)),
      vertical: "",
      "active-color": "primary",
      "indicator-color": "primary",
      "active-bg-color": "white"
    }, {
      default: fe(() => [
        Ze(o.$slots, "default", {}, void 0, !0)
      ]),
      _: 3
    }, 8, ["model-value"])
  ]);
}
const MR = /* @__PURE__ */ He(qA, [["render", QA], ["__scopeId", "data-v-0b4a6261"]]);
class _R {
  constructor() {
    this.seen = {}, this.seen = {};
  }
  serialize(e) {
    return e.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */
  getNextSafeSlug(e, t) {
    let i = e, r = 0;
    if (this.seen.hasOwnProperty(i)) {
      r = this.seen[e];
      do
        r++, i = e + "-" + r;
      while (this.seen.hasOwnProperty(i));
    }
    return t || (this.seen[e] = r, this.seen[i] = 0), i;
  }
  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
  */
  slug(e, t = {}) {
    const i = { dryrun: !!t.dryrun }, r = this.serialize(e);
    return this.getNextSafeSlug(r, i.dryrun);
  }
}
const Sd = class Sd {
  constructor(e = "default") {
    typeof e != "string" && (console.error("instanceKey param should be of type string! Using default instance."), e = "default"), Sd.instances.hasOwnProperty(e) || (Sd.instances[e] = new _R()), this.instance = Sd.instances[e];
  }
  slug(e, t = {}) {
    return this.instance.slug(e, t);
  }
};
Sd.instances = {};
let hC = Sd;
const JA = new hC("tabs"), eM = Fe({
  name: "BsTab",
  mixins: [fS, pS],
  components: {
    BsDrawer: Sh,
    BsHeader: bh,
    BsDocumentation: uC,
    BsContent: dC,
    BsTabIcon: dg,
    QPageContainer: $P,
    QPage: zP
  },
  data() {
    return {
      index: 0,
      tabId: JA.slug(this.name),
      isActive: !1,
      openDoc: !1,
      qPageMounted: !1
    };
  },
  inject: ["$tabs", "$selectedTab", "$defaultTabUsed", "$defaultDrawer", "$defaultHeader"],
  provide() {
    return this.provideComputed([
      "isTabSelected",
      "tabName",
      // documention
      "tabDocsProps",
      "tabId",
      "qPageMounted"
    ]);
  },
  props: {
    name: {
      type: String,
      default: "tab-name-not-set"
    },
    icon: {
      type: String
    },
    docTitle: {
      type: String
    },
    docIcon: {
      type: String
    },
    docImageDimensions: {
      type: Object
    }
  },
  computed: {
    tabContentId() {
      return RR(this.tabId);
    },
    tabName() {
      return this.name;
    },
    tabDocsProps() {
      return {
        docImageDimensions: this.docImageDimensions,
        docTitle: this.docTitle,
        docIcon: this.docIcon
      };
    },
    isTabSelected() {
      var o;
      return ((o = this.selectedTab) == null ? void 0 : o.tabId) === this.tabId;
    },
    selectedTab() {
      return this.$selectedTab;
    },
    defaultDrawer() {
      return this.$defaultDrawer;
    },
    defaultHeader() {
      return this.$defaultHeader;
    },
    defaultTabUsed() {
      return this.$defaultTabUsed;
    },
    tabs() {
      return this.$tabs;
    },
    tab() {
      const { tabId: o, drawer: e, header: t, name: i } = this;
      return {
        tabId: o,
        drawer: e,
        header: t,
        name: i,
        icon: uR(() => this.tabIcon)
      };
    },
    header() {
      return this.usingComponent(bh) || this.usingSlotHeader || this.defaultHeader;
    },
    drawer() {
      return this.usingComponent(Sh) || this.usingSlotDrawer || this.defaultDrawer;
    },
    tabIcon() {
      return this.usingComponent(dg) || this.usingSlotTabIcon ? void 0 : this.icon;
    },
    usingSlotHeader() {
      return this.usingSlot(bh, "header", "head");
    },
    usingSlotDrawer() {
      return this.usingSlot(Sh, "leftpanel", "drawer");
    },
    usingSlotDocumentation() {
      return this.usingSlot(uC, "documentation");
    },
    usingSlotContent() {
      return this.usingSlot(dC, "content");
    },
    usingSlotTabIcon() {
      return this.usingSlot(dg, "tabicon");
    },
    appendTabTitleToHeader() {
      return !this.defaultTabUsed;
    },
    slotsKeys() {
      return Object.keys(this.$slots);
    }
  },
  methods: {
    registerTab() {
      this.tabs.push(this.tab);
    },
    unregisterTab() {
      const o = this.tabs.indexOf(this.tab);
      o !== -1 && this.tabs.splice(o, 1);
    },
    onQPageMounted() {
      this.qPageMounted = !0, this.$emit("mounted:q-page");
    },
    usingComponent(o) {
      return !!this.getSlotComponents(o.name || "").length;
    },
    usingSlot(o, ...e) {
      return this.usingComponent(o) ? !1 : e.reduce((i, r) => i && this.slotsKeys.includes(r), !0);
    }
  },
  emits: ["mounted:q-page"],
  mounted() {
    this.registerTab();
  },
  unmounted() {
    this.unregisterTab();
  }
});
const tM = ["id"];
function iM(o, e, t, i, r, n) {
  const s = ue("BsHeader"), a = ue("BsDrawer"), l = ue("BsDocumentation"), c = ue("BsTabIcon"), d = ue("BsContent"), u = ue("QPage"), h = ue("QPageContainer");
  return ce(), je(Ep, null, [
    o.usingSlotHeader || !(o.header || o.defaultTabUsed) ? (ce(), _e(s, { key: 0 }, {
      default: fe(() => [
        o.$slots.header ? Ne("", !0) : Ze(o.$slots, "head", { key: 0 }, void 0, !0),
        Ze(o.$slots, "header", {}, void 0, !0)
      ]),
      _: 3
    })) : Ne("", !0),
    o.usingSlotDrawer ? (ce(), _e(a, { key: 1 }, {
      default: fe(() => [
        o.$slots.drawer ? Ne("", !0) : Ze(o.$slots, "leftpanel", { key: 0 }, void 0, !0),
        Ze(o.$slots, "drawer", {}, void 0, !0)
      ]),
      _: 3
    })) : Ne("", !0),
    o.usingSlotDocumentation ? (ce(), _e(l, {
      key: 2,
      modelValue: o.openDoc,
      "onUpdate:modelValue": e[0] || (e[0] = (p) => o.openDoc = p)
    }, {
      default: fe(() => [
        Ze(o.$slots, "documentation", {}, void 0, !0)
      ]),
      _: 3
    }, 8, ["modelValue"])) : Ne("", !0),
    !o.defaultTabUsed && o.usingSlotTabIcon ? (ce(), _e(c, { key: 3 }, {
      default: fe(() => [
        Ze(o.$slots, "tabicon", {}, void 0, !0)
      ]),
      _: 3
    })) : Ne("", !0),
    pa(Ce(h, null, {
      default: fe(() => [
        Ce(u, { onVnodeMounted: o.onQPageMounted }, {
          default: fe(() => [
            Re("div", {
              class: "content",
              id: o.tabContentId
            }, [
              o.usingSlotContent ? (ce(), _e(d, { key: 0 }, {
                default: fe(() => [
                  Ze(o.$slots, "content", {}, void 0, !0)
                ]),
                _: 3
              })) : Ne("", !0)
            ], 8, tM)
          ]),
          _: 3
        }, 8, ["onVnodeMounted"])
      ]),
      _: 3
    }, 512), [
      [Fh, o.isTabSelected]
    ]),
    Ze(o.$slots, "default", {}, void 0, !0)
  ], 64);
}
const IR = /* @__PURE__ */ He(eM, [["render", iM], ["__scopeId", "data-v-694ef9e9"]]), rM = new _R(), nM = Fe({
  name: "BsLayoutDefault",
  mixins: [pS, fS],
  components: {
    BsTab: IR,
    BsMenuTab: AR,
    BsMenuTabs: MR,
    BsLayoutDrawer: OR,
    BsLayoutHeader: PR,
    QLayout: KP
  },
  props: {
    docTitle: {
      type: String
    },
    docIcon: {
      type: String
    },
    docImageDimensions: {
      type: Object
    },
    tabMenuWidth: {
      type: Number,
      default: 50
    },
    leftPanelWidth: {
      type: Number,
      default: 300
    }
  },
  data() {
    return {
      tabIndex: 0,
      tabs: [],
      mounted: !1,
      headerMounted: !1,
      drawerMounted: !1,
      qPageMounted: !1,
      menuTabsMounted: !1,
      drawerOpen: !0,
      tabSlotNames: [
        "header",
        "head",
        "leftpanel",
        "drawer",
        "documentation",
        "content"
      ],
      defaultLayoutTabName: "Layout Default",
      defaultTabUsed: !0
    };
  },
  provide() {
    let o = this.provideComputed([
      "tabs",
      "selectedTab",
      "qLayoutMounted",
      "menuTabsMounted",
      "layoutDocsProps",
      "defaultTabUsed",
      "drawerOpen"
    ]);
    if (this.defaultTabUsed) {
      const t = this.provideComputed([
        "tabContentId",
        "qPageMounted",
        "defaultDrawer",
        "defaultHeader"
      ]);
      o = ui(ui({}, o), t);
    }
    return o;
  },
  methods: {
    getTabIndex(o) {
      return this.tabs.findIndex(({ tabId: e }) => o === e);
    }
  },
  computed: {
    tabContentId() {
      return `tab-content-id-${rM.slug(this.defaultLayoutTabName)}`;
    },
    activeTabSlots() {
      return Object.keys(this.$slots).filter((o) => this.tabSlotNames.includes(o));
    },
    selectedTab() {
      return this.tabs[this.tabIndex];
    },
    selectedTabDrawer() {
      var o;
      return (o = this.selectedTab) == null ? void 0 : o.drawer;
    },
    layoutDocsProps() {
      const { docTitle: o, docIcon: e, docImageDimensions: t } = this;
      return { docTitle: o, docIcon: e, docImageDimensions: t };
    },
    qLayoutMounted() {
      return this.drawerMounted && this.headerMounted;
    },
    defaultDrawer() {
      return !!this.getSlotComponents(Sh.name).length;
    },
    defaultHeader() {
      return !!this.getSlotComponents(bh.name).length;
    },
    layoutStyles() {
      return {
        "--bs-drawer-width": `${this.leftPanelWidth}px`
      };
    }
  },
  watch: {
    "tabs.length"(o) {
      this.defaultTabUsed = o === 0 || o === 1 && this.tabs[0].name === this.defaultLayoutTabName;
    }
  },
  mounted() {
    this.mounted = !0;
  }
});
function oM(o, e, t, i, r, n) {
  const s = ue("BsLayoutDrawer"), a = ue("BsLayoutHeader"), l = ue("BsMenuTab"), c = ue("BsMenuTabs"), d = ue("BsTab"), u = ue("QLayout");
  return ce(), _e(u, {
    view: "lHh LpR lFf",
    class: "bg-white",
    style: Ml(o.layoutStyles)
  }, {
    default: fe(() => [
      Ce(s, {
        modelValue: o.drawerOpen,
        "onUpdate:modelValue": e[0] || (e[0] = (h) => o.drawerOpen = h),
        onVnodeMounted: e[1] || (e[1] = (h) => o.drawerMounted = !0),
        expandable: o.selectedTabDrawer,
        "collapsed-width": o.tabMenuWidth,
        "panel-width": o.leftPanelWidth,
        mini: !o.defaultTabUsed
      }, null, 8, ["modelValue", "expandable", "collapsed-width", "panel-width", "mini"]),
      Ce(a, {
        onVnodeMounted: e[2] || (e[2] = (h) => o.headerMounted = !0)
      }, null, 512),
      o.mounted && !o.defaultTabUsed ? (ce(), _e(c, {
        key: 0,
        modelValue: o.tabIndex,
        "onUpdate:modelValue": e[3] || (e[3] = (h) => o.tabIndex = h),
        onVnodeMounted: e[4] || (e[4] = (h) => o.menuTabsMounted = !0)
      }, {
        default: fe(() => [
          (ce(!0), je(Ep, null, li(o.tabs, ({ name: h, icon: p, tabId: f }, g) => (ce(), _e(l, {
            name: h,
            "tab-id": f,
            icon: p,
            "tab-index": g
          }, null, 8, ["name", "tab-id", "icon", "tab-index"]))), 256))
        ]),
        _: 1
      }, 8, ["modelValue"])) : Ne("", !0),
      o.mounted && o.defaultTabUsed ? (ce(), _e(d, {
        key: 1,
        "onMounted:qPage": e[5] || (e[5] = (h) => o.qPageMounted = !0),
        name: o.defaultLayoutTabName
      }, nr({
        default: fe(() => [
          Ze(o.$slots, "default")
        ]),
        _: 2
      }, [
        li(o.activeTabSlots, (h) => ({
          name: h,
          fn: fe(() => [
            Ze(o.$slots, h)
          ])
        }))
      ]), 1032, ["name"])) : Ze(o.$slots, "default", { key: 2 })
    ]),
    _: 3
  }, 8, ["style"]);
}
const sM = /* @__PURE__ */ He(nM, [["render", oM]]), aM = {
  xs: 18,
  sm: 22,
  md: 26,
  lg: 30,
  xl: 34
}, lM = function(o, e = aM) {
  return o !== void 0 ? o in e ? `${e[o]}px` : o : null;
}, cM = {
  size: {
    type: String,
    default: "sm"
  },
  modelValue: {
    required: !0,
    default: null
  },
  val: {},
  trueValue: { default: !0 },
  falseValue: { default: !1 },
  labelLeft: String,
  labelRight: String,
  labelClass: { type: String, default: "dku-text" },
  color: { type: String, default: "rgba(111, 125, 137, 0.8)" },
  disable: Boolean,
  tabindex: [String, Number]
}, dM = ["update:modelValue"];
function jw(o) {
  o.cancelable !== !1 && o.preventDefault(), o.stopPropagation();
}
const uM = Fe({
  name: "BsToggle",
  data() {
    return {};
  },
  props: ui({}, cM),
  emits: dM,
  computed: {
    modelIsArray() {
      return this.val !== void 0 && Array.isArray(this.modelValue);
    },
    index() {
      const o = this.val;
      return this.modelIsArray === !0 ? this.modelValue.findIndex((e) => e === o) : -1;
    },
    isTrue() {
      return this.modelIsArray === !0 ? this.index > -1 : this.modelValue === this.trueValue;
    },
    isFalse() {
      return this.modelIsArray === !0 ? this.index === -1 : this.modelValue === this.falseValue;
    },
    tabIndex() {
      return this.disable === !0 ? -1 : this.tabindex || 0;
    },
    fontSize() {
      return lM(this.size);
    }
  },
  methods: {
    getNextValue() {
      if (this.modelIsArray === !0) {
        if (this.isTrue === !0) {
          const o = this.modelValue.slice();
          return o.splice(this.index, 1), o;
        }
        return this.modelValue.concat([this.val]);
      }
      if (this.isTrue === !0)
        return this.falseValue;
      if (this.isFalse === !0)
        return this.trueValue;
    },
    onClick(o) {
      o !== void 0 && jw(o), this.disable !== !0 && (console.log("next value"), console.log(this.isTrue), console.log(this.getNextValue()), this.$emit("update:modelValue", this.getNextValue(), o));
    },
    onKeydown(o) {
      (o.keyCode === 13 || o.keyCode === 32) && jw(o);
    },
    onKeyup(o) {
      (o.keyCode === 13 || o.keyCode === 32) && this.onClick(o);
    }
  }
}), hM = ["checked", "value"], pM = ["aria-checked", "aria-disabled", "aria-readonly", "tabindex"];
function fM(o, e, t, i, r, n) {
  return ce(), je("div", {
    class: Rr([{
      "bs-toggle--is-disabled": o.disable
    }, "bs-toggle"]),
    style: Ml({ "font-size": o.fontSize })
  }, [
    o.labelLeft ? (ce(), je("label", {
      key: 0,
      class: Rr(["bs-toggle__label", [o.labelClass]])
    }, Bt(o.labelLeft), 3)) : Ne("", !0),
    Re("input", {
      type: "checkbox",
      checked: o.isTrue === !0,
      value: o.modelIsArray === !0 ? o.val : o.trueValue,
      class: "bs-toggle__input"
    }, null, 8, hM),
    Re("div", {
      "aria-checked": o.isTrue === !0,
      "aria-disabled": o.disable,
      "aria-readonly": o.disable,
      class: Rr([
        "bs-toggle__content",
        o.isTrue === !0 ? "bs-toggle__content__active" : ""
      ]),
      style: Ml({ "background-color": o.isTrue === !0 ? o.color : "" }),
      role: "checkbox",
      onClick: e[0] || (e[0] = (...s) => o.onClick && o.onClick(...s)),
      onKeydown: e[1] || (e[1] = (...s) => o.onKeydown && o.onKeydown(...s)),
      onKeyup: e[2] || (e[2] = (...s) => o.onKeyup && o.onKeyup(...s)),
      tabindex: o.tabIndex
    }, null, 46, pM),
    o.labelRight ? (ce(), je("label", {
      key: 1,
      class: Rr(["bs-toggle__label", [o.labelClass]])
    }, Bt(o.labelRight), 3)) : Ne("", !0)
  ], 6);
}
const gM = /* @__PURE__ */ He(uM, [["render", fM]]), vM = Fe({
  name: "BsSelect",
  data() {
    return {
      width: 0
    };
  },
  props: {
    bsLabel: {
      type: String
    },
    placeHolder: {
      type: String
    }
  },
  components: {
    QSelect: YP
  },
  methods: {
    popupShow() {
      this.width = this.$refs.bsSelect.$el.offsetWidth;
    },
    popupHide() {
      this.width = 0;
    }
  },
  computed: {
    popupStyle() {
      return {
        width: this.width,
        maxWidth: this.width,
        wordBreak: "break-all"
      };
    },
    computedLabel() {
      if (this.placeHolder && !this.$attrs.modelValue)
        return this.placeHolder;
    }
  }
}), mM = {
  key: 0,
  class: "bs-select__label dss-caption-400 q-mb-xs"
};
function yM(o, e, t, i, r, n) {
  const s = ue("QSelect");
  return ce(), je("div", null, [
    o.bsLabel ? (ce(), je("label", mM, Bt(o.bsLabel), 1)) : Ne("", !0),
    Ce(s, Mr({ ref: "bsSelect" }, o.$attrs, {
      "dropdown-icon": "r_expand_more",
      class: "bs-select",
      outlined: "",
      dense: "",
      "popup-content-class": "bs-select__popup dds-text-400",
      onPopupShow: o.popupShow,
      onPopupHide: o.popupHide,
      "popup-content-style": o.popupStyle,
      label: o.computedLabel,
      "label-color": "#CCCCCC"
    }), nr({ _: 2 }, [
      li(o.$slots, (a, l) => ({
        name: l,
        fn: fe((c) => [
          Ze(o.$slots, l, Yt(ei(c || {})))
        ])
      }))
    ]), 1040, ["onPopupShow", "onPopupHide", "popup-content-style", "label"])
  ]);
}
const CM = /* @__PURE__ */ He(vM, [["render", yM]]), SM = Fe({
  name: "BsButton",
  components: {
    QBtn: ou
  }
});
function bM(o, e, t, i, r, n) {
  const s = ue("QBtn");
  return ce(), _e(s, Mr(o.$attrs, { unelevated: "" }), nr({ _: 2 }, [
    li(o.$slots, (a, l) => ({
      name: l,
      fn: fe((c) => [
        Ze(o.$slots, l, Yt(ei(c || {})))
      ])
    }))
  ]), 1040);
}
const wM = /* @__PURE__ */ He(SM, [["render", bM]]), EM = Fe({
  name: "BsTooltip",
  components: {
    QTooltip: pR
  }
});
function RM(o, e, t, i, r, n) {
  const s = ue("QTooltip");
  return ce(), _e(s, Yt(ei(o.$attrs)), nr({ _: 2 }, [
    li(o.$slots, (a, l) => ({
      name: l,
      fn: fe((c) => [
        Ze(o.$slots, l, Yt(ei(c || {})))
      ])
    }))
  ]), 1040);
}
const TM = /* @__PURE__ */ He(EM, [["render", RM]]), xM = Fe({
  name: "BsSlider",
  components: {
    QSlider: XP
  },
  props: {
    sliderWidth: {
      type: Number,
      default: 192
    }
  },
  computed: {
    inputData() {
      return {
        value: this.$attrs.modelValue,
        min: this.$attrs.min,
        max: this.$attrs.max,
        step: this.$attrs.step
      };
    }
  },
  methods: {
    // TODO : Round to step in needed
    updateSliderFromInput(o) {
      let e = Number(o.target.value);
      e < this.$attrs.min && (e = this.$attrs.min), e > this.$attrs.max && (e = this.$attrs.max), this.$emit("update:model-value", e);
    }
  }
}), DM = { class: "flex row bs-slider no-wrap" }, OM = ["value", "min", "max", "step"];
function PM(o, e, t, i, r, n) {
  const s = ue("QSlider");
  return ce(), je("div", DM, [
    Ce(s, Mr(o.$attrs, {
      style: { width: o.sliderWidth + "px" },
      "thumb-size": "15px",
      "track-size": "3.5px"
    }), nr({ _: 2 }, [
      li(o.$slots, (a, l) => ({
        name: l,
        fn: fe((c) => [
          Ze(o.$slots, l, Yt(ei(c || {})))
        ])
      }))
    ]), 1040, ["style"]),
    Re("input", {
      class: "bs-slider__input dku-text",
      type: "number",
      value: o.inputData.value,
      onInput: e[0] || (e[0] = (...a) => o.updateSliderFromInput && o.updateSliderFromInput(...a)),
      min: o.inputData.min,
      max: o.inputData.max,
      step: o.inputData.step
    }, null, 40, OM)
  ]);
}
const AM = /* @__PURE__ */ He(xM, [["render", PM]]), MM = Fe({
  name: "BsRange",
  components: {
    QRange: qP
  }
});
function _M(o, e, t, i, r, n) {
  const s = ue("QRange");
  return ce(), _e(s, Yt(ei(o.$attrs)), nr({ _: 2 }, [
    li(o.$slots, (a, l) => ({
      name: l,
      fn: fe((c) => [
        Ze(o.$slots, l, Yt(ei(c || {})))
      ])
    }))
  ]), 1040);
}
const IM = /* @__PURE__ */ He(MM, [["render", _M]]), FM = Fe({
  name: "BsSpinner",
  components: {
    QSpinner: ZP
  }
});
function LM(o, e, t, i, r, n) {
  const s = ue("QSpinner");
  return ce(), _e(s, Yt(ei(o.$attrs)), nr({ _: 2 }, [
    li(o.$slots, (a, l) => ({
      name: l,
      fn: fe((c) => [
        Ze(o.$slots, l, Yt(ei(c || {})))
      ])
    }))
  ]), 1040);
}
const NM = /* @__PURE__ */ He(FM, [["render", LM]]), GM = Fe({
  name: "BsDSSTable",
  props: {
    dssTableName: {
      type: String
    },
    serverSidePagination: Object,
    filters: Object
  },
  emits: ["update:fetching", "update:rows", "update:columns", "update:columns-count"],
  data() {
    return {
      DSSColumns: void 0,
      DSSData: void 0,
      fetchingChunk: !1,
      fetchingSchema: !1
    };
  },
  watch: {
    dssTableName(o, e) {
      this.updateTableDataOnWatchedChanged(o, e);
    },
    "serverSidePagination.batchSize"(o, e) {
      this.updateTableDataOnWatchedChanged(o, e);
    },
    "serverSidePagination.batchOffset"(o, e) {
      this.updateTableDataOnWatchedChanged(o, e);
    },
    filters(o, e) {
      this.updateTableDataOnWatchedChanged(o, e);
    }
  },
  methods: {
    setFetching({ fetchingChunk: o, fetchingSchema: e }) {
      o !== void 0 && (this.fetchingChunk = o), e !== void 0 && (this.fetchingSchema = e);
      const t = this.fetchingChunk || this.fetchingSchema;
      this.$emit("update:fetching", t);
    },
    setFetchingSchema(o) {
      this.setFetching({ fetchingSchema: o });
    },
    setFetchingChunk(o) {
      this.setFetching({ fetchingChunk: o });
    },
    fetchDSSData(...o) {
      return new Promise((e, t) => {
        this.setFetchingChunk(!0), xl.getDatasetChunk(...o).then((i) => {
          const r = this.transformDSSDataToQTableRow(i);
          e(r);
        }).catch(t).finally(() => {
          this.setFetchingChunk(!1);
        });
      });
    },
    fetchFilteredDSSDataset(...o) {
      return new Promise((e, t) => {
        this.setFetchingChunk(!0), xl.getFilteredDataset(
          ...o
        ).then((i) => {
          const r = this.transformDSSDataToQTableRow(i);
          e(r);
        }).catch(t).finally(() => {
          this.setFetchingChunk(!1);
        });
      });
    },
    fetchDSSColumns(...o) {
      return this.setFetchingSchema(!0), new Promise((e, t) => {
        xl.getDatasetGenericData(...o).then(({ schema: i, columnsCount: r }) => {
          const s = i.columns.map((a) => this.createBsTableCol({ name: a.name, dataType: a.type }));
          e({ columns: s, columnsCount: r });
        }).catch(t).finally(() => {
          this.setFetchingSchema(!1);
        });
      });
    },
    updateColumns(...o) {
      this.fetchDSSColumns(...o).then(({ columns: e, columnsCount: t }) => {
        this.$emit("update:columns", e), this.$emit("update:columns-count", t);
      });
    },
    updateRows(...o) {
      this.fetchFilteredDSSDataset(...o).then((e) => {
        this.$emit("update:rows", e);
      });
    },
    parseDSSColumn(o) {
      return o === "index" ? "in_dss_index" : o;
    },
    createBsTableCol(o) {
      const e = (o == null ? void 0 : o.name) || "default";
      return ui({
        name: e,
        label: e,
        field: e,
        sortable: !0,
        align: "left"
      }, o);
    },
    transformDSSDataToQTableRow(o) {
      if (o === "None")
        return;
      const e = Object.entries(o);
      if (!(e != null && e.length))
        return;
      const t = Object.entries(e[0][1]).length, i = Array(t).fill(void 0).map((r, n) => ({}));
      return e.forEach(([r, n]) => {
        r = this.parseDSSColumn(r), Object.values(n).forEach((a, l) => {
          const c = i[l];
          c[r] = a;
        });
      }), i;
    },
    updateTableData() {
      const { batchSize: o, batchOffset: e } = this.serverSidePagination || {};
      this.dssTableName && o && e !== void 0 && (this.updateColumns(this.dssTableName), this.updateRows(this.dssTableName, o, e, this.filters));
    },
    updateTableDataOnWatchedChanged(o, e) {
      oA(o, e) || this.updateTableData();
    }
  },
  mounted() {
    this.updateTableData();
  }
});
function kM(o, e, t, i, r, n) {
  return null;
}
const VM = /* @__PURE__ */ He(GM, [["render", kM]]), BM = 45, HM = 250;
let pC = () => {
};
{
  let o = function(i, r, n, ...s) {
    n === void 0 && (n = i), e.set(n, Date.now()), t.set(n, r), setTimeout(() => {
      if (!e.has(n))
        return;
      const a = t.get(n), l = e.get(n);
      (a < HM || Date.now() - l > a - BM) && (s ? i(...s) : i(), e.delete(n));
    }, r);
  };
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
  pC = o;
}
function FR(o, e, t, ...i) {
  return i ? pC(o, e, t, ...i) : pC(o, e, t);
}
function WM(o, e, t = !1) {
  let i = o.length, r = 0, n = [];
  if (i) {
    const s = (a = 0) => e.indexOf(o, a);
    t || (e = e.toLowerCase(), o = o.toLowerCase());
    for (let a = s(r); a > -1; a = s(r))
      n.push(a), r = a + i;
  }
  return n;
}
function jM(o, e) {
  return o.hasOwnProperty(e) ? o[e] : void 0;
}
function Uw(o, e, t, i) {
  {
    const r = i(o, e) + "";
    return (r === "undefined" || r === "null" ? "" : r.toLowerCase()).includes(t);
  }
}
function UM(o) {
  return o ? `${o}`.toLowerCase() : "";
}
function $M(o, { columns: e, searchVal: t }, i, r) {
  let n = o;
  const s = Object.keys(e);
  if (s.length) {
    const a = i.filter((l) => s.includes(l.name));
    n = n.filter((l) => a.every((c) => {
      const d = e[c.name];
      return Uw(c, l, d, r);
    }));
  }
  return t && (n = n.filter((a) => i.some((l) => Uw(l, a, t, r)))), n;
}
const zM = Fe({
  name: "BsInputDebounce",
  props: {
    modelValue: {
      type: [String, Number],
      default: null
    },
    valueSearchDebounce: {
      type: [Number, String],
      default: 500
    },
    formatInput: {
      type: Boolean,
      default: !1
    },
    formatInputMethod: {
      type: Function,
      default: UM
    }
  },
  components: { QInput: Ov },
  emits: ["update:model-value", "update:loading", "update:formatted-value", "update:no-debounce:formatted-value"],
  data() {
    return {
      inputDebouncing: !1,
      value: null,
      id: sA("bs-input-debounce-")
    };
  },
  watch: {
    modelValue() {
      this.syncModelValue();
    }
  },
  methods: {
    setLoading(o) {
      this.inputDebouncing = o, this.$emit("update:loading", o);
    },
    updateSearchedValue(o) {
      this.$emit("update:model-value", o), this.updateFormattedValue(o);
    },
    updateFormattedValue(o) {
      this.formatInput && this.$emit("update:formatted-value", this.formatInputMethod(o));
    },
    updateValueDebounce(o) {
      this.updateValueNoDebounce(o), this.setLoading(!0), FR(
        () => {
          this.updateSearchedValue(o), this.setLoading(!1);
        },
        +this.valueSearchDebounce,
        this.id
      );
    },
    updateValueNoDebounce(o) {
      this.value = o, this.$emit("update:no-debounce:formatted-value", this.formatInputMethod(o));
    },
    syncModelValue() {
      this.updateValueNoDebounce(this.modelValue), this.updateFormattedValue(this.modelValue);
    }
  },
  mounted() {
    this.syncModelValue();
  }
});
function KM(o, e, t, i, r, n) {
  const s = ue("QInput");
  return ce(), _e(s, Mr({
    "model-value": o.value,
    "onUpdate:modelValue": o.updateValueDebounce,
    loading: o.inputDebouncing
  }, o.$attrs), nr({ _: 2 }, [
    li(o.$slots, (a, l) => ({
      name: l,
      fn: fe((c) => [
        Ze(o.$slots, l, Yt(ei(c || {})))
      ])
    }))
  ]), 1040, ["model-value", "onUpdate:modelValue", "loading"]);
}
const LR = /* @__PURE__ */ He(zM, [["render", KM]]), YM = Fe({
  name: "BsSearchTable",
  components: {
    QIcon: Lo,
    BsInputDebounce: LR
  },
  data() {
    return {
      searchColIcon: Pv
    };
  }
});
const XM = { class: "bs-search-table-container" };
function qM(o, e, t, i, r, n) {
  const s = ue("q-icon"), a = ue("BsInputDebounce");
  return ce(), je("div", XM, [
    Ce(a, Mr({
      width: "190",
      label: "Search items",
      filled: "",
      dense: "",
      "format-input": ""
    }, o.$attrs), nr({
      append: fe(() => [
        Ce(s, {
          name: o.searchColIcon,
          size: "1rem"
        }, null, 8, ["name"])
      ]),
      _: 2
    }, [
      li(o.$slots, (l, c) => ({
        name: c,
        fn: fe((d) => [
          Ze(o.$slots, c, Yt(ei(d || {})), void 0, !0)
        ])
      }))
    ]), 1040)
  ]);
}
const ZM = /* @__PURE__ */ He(YM, [["render", qM], ["__scopeId", "data-v-02144179"]]), QM = Fe({
  name: "BSTableColHeader",
  components: {
    QIcon: Lo,
    QTh: uS,
    QMenu: fR,
    QItem: gR,
    QItemSection: vR,
    QList: mR
  },
  directives: {
    ClosePopup: yR
  },
  emits: ["search-col"],
  data() {
    return {
      mdiArrowUpThin: cA,
      mdiSortAscending: Eg,
      mdiSortDescending: Rg,
      mdiChevronDown: SR,
      searchColIcon: Pv,
      noDebounceValue: "",
      sortAsc: !1,
      sorted: !1
    };
  },
  computed: {
    sortable() {
      var o;
      return !!((o = this.col) != null && o._sortable);
    },
    sortColIcon() {
      return this.sortAsc ? Eg : Rg;
    },
    sortText() {
      return this.sortAsc ? "descending" : "ascending";
    }
  },
  props: {
    sort: Function,
    col: Object,
    sortedCol: String
  },
  methods: {
    sortColumn() {
      this.sortable && this.sort && this.sort(this.col), this.sortAsc = this.sorted ? !this.sortAsc : !0;
    },
    searchColumn() {
      var o;
      this.$emit("search-col", (o = this.col) == null ? void 0 : o.name);
    }
  },
  watch: {
    sortedCol(o) {
      var e;
      o === ((e = this.col) == null ? void 0 : e.name) ? (this.sortAsc = this.sorted ? !this.sortAsc : !0, this.sorted = !0) : (this.sorted = !1, this.sortAsc = !1);
    }
  }
});
const JM = (o) => (Zl("data-v-24b689ca"), o = o(), Ql(), o), e_ = { class: "bs-table-col-header-container" }, t_ = {
  class: "bs-table-col-header-title-container",
  ref: "BsTableColHeaderTitleContainer"
}, i_ = { class: "bs-table-col-header-title" }, r_ = { class: "bs-table-col-header-title-label" }, n_ = { class: "bs-table-col-header-title-icon" }, o_ = /* @__PURE__ */ JM(() => /* @__PURE__ */ Re("div", null, "Search", -1)), s_ = {
  key: 0,
  class: "bs-table-col-header-data-type"
};
function a_(o, e, t, i, r, n) {
  var h, p, f, g;
  const s = ue("q-icon"), a = ue("q-item-section"), l = ue("q-item"), c = ue("q-list"), d = ue("q-menu"), u = dS("close-popup");
  return ce(), je("div", e_, [
    Re("div", t_, [
      Re("div", i_, [
        Re("div", r_, Bt(((h = o.col) == null ? void 0 : h.label) || ((p = o.col) == null ? void 0 : p.name) || ""), 1),
        Re("div", n_, [
          Ce(s, {
            name: o.mdiChevronDown,
            size: "1rem"
          }, {
            default: fe(() => [
              Ce(d, {
                anchor: "bottom middle",
                self: "top middle",
                "transition-show": "scale",
                "transition-hide": "scale",
                offset: [0, 10]
              }, {
                default: fe(() => [
                  Ce(c, {
                    ref: "BsTableColHeaderActions",
                    class: "bs-table-col-header-actions q-py-xs q-px-sm rounded-borders"
                  }, {
                    default: fe(() => [
                      o.sortable ? (ce(), _e(l, { key: 0 }, {
                        default: fe(() => [
                          Ce(a, null, {
                            default: fe(() => [
                              Re("div", {
                                class: "bs-table-col-header-action-section cursor-pointer",
                                onClick: e[0] || (e[0] = (...v) => o.sortColumn && o.sortColumn(...v))
                              }, [
                                Ce(s, {
                                  name: o.sortColIcon,
                                  size: "0.8rem",
                                  class: Rr(["sort-icon", { sorted: o.sorted }])
                                }, null, 8, ["name", "class"]),
                                Re("div", null, " Sort " + Bt(o.sortText), 1)
                              ])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })) : Ne("", !0),
                      pa((ce(), _e(l, null, {
                        default: fe(() => [
                          Ce(a, null, {
                            default: fe(() => [
                              Re("div", {
                                class: "bs-table-col-header-action-section cursor-pointer",
                                onClick: e[1] || (e[1] = (...v) => o.searchColumn && o.searchColumn(...v))
                              }, [
                                Ce(s, {
                                  name: o.searchColIcon,
                                  size: "0.8rem"
                                }, null, 8, ["name"]),
                                o_
                              ])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })), [
                        [u]
                      ])
                    ]),
                    _: 1
                  }, 512)
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["name"])
        ])
      ]),
      (f = o.col) != null && f.dataType ? (ce(), je("div", s_, Bt((g = o.col) == null ? void 0 : g.dataType), 1)) : Ne("", !0)
    ], 512)
  ]);
}
const l_ = /* @__PURE__ */ He(QM, [["render", a_], ["__scopeId", "data-v-24b689ca"]]), c_ = Fe({
  name: "BSTableHeader",
  components: {
    QTr: hS,
    QTh: uS,
    BsTableColHeader: l_
  },
  props: {
    props: {
      type: Object,
      required: !0
    }
  },
  data() {
    return {
      sortedCol: "",
      sortedDesc: !1
    };
  },
  emits: ["search-col"],
  methods: {
    activateSearchCol(o) {
      this.$emit("search-col", o);
    },
    sort(o) {
      const e = this.sortedCol;
      this.sortedCol = e !== o.name ? o.name : this.sortedDesc ? "" : o.name, this.sortedDesc = e !== o.name ? !1 : !this.sortedDesc, this.props.sort(o);
    }
  },
  computed: {
    cols() {
      return this.props.cols.filter((o) => o.name !== "clearAllCol");
    }
  }
});
function d_(o, e, t, i, r, n) {
  const s = ue("BsTableColHeader"), a = ue("q-th"), l = ue("q-tr");
  return ce(), _e(l, { props: o.props }, {
    default: fe(() => [
      (ce(!0), je(Ep, null, li(o.cols, (c) => (ce(), _e(a, {
        key: c.name,
        props: o.props
      }, {
        default: fe(() => [
          Ce(s, {
            sort: o.sort,
            col: c,
            "sorted-col": o.sortedCol,
            onSearchCol: o.activateSearchCol
          }, null, 8, ["sort", "col", "sorted-col", "onSearchCol"])
        ]),
        _: 2
      }, 1032, ["props"]))), 128)),
      (ce(), _e(a, {
        "auto-width": "",
        key: "clearAllCol"
      }))
    ]),
    _: 1
  }, 8, ["props"]);
}
const u_ = /* @__PURE__ */ He(c_, [["render", d_], ["__scopeId", "data-v-6897aae9"]]), h_ = Fe({
  name: "BsTextHighlight",
  components: {},
  data() {
    return {};
  },
  props: {
    queries: Array,
    text: [String, Number, Boolean]
  },
  computed: {
    highlightedText() {
      let o = Pd(this.text) || aA(this.text) ? "" : lA(`${this.text}`);
      const e = (this.queries || []).filter((c) => !Pd(c));
      if (!(o && e.length))
        return o;
      let t = /* @__PURE__ */ new Map([
        [0, { from: [], to: [] }],
        [o.length, { from: [], to: [] }]
      ]);
      e.forEach(
        (c, d) => WM(c, o).forEach((u) => {
          const h = u, p = u + c.length;
          t.has(h) || t.set(h, { from: [], to: [] }), t.has(p) || t.set(p, { from: [], to: [] });
          const f = t.get(h), g = t.get(p);
          f.from.push(d), g.to.push(d);
        })
      );
      const i = Array.from(t.keys()).sort((c, d) => c - d);
      if (!i.length)
        return o;
      const r = i.length - 1, n = [], s = new Array(r).fill("").map((c, d) => o.substring(i[d], i[d + 1]));
      let a = 0;
      for (; a < r; ) {
        const { from: c, to: d } = t.get(i[a]);
        c.forEach((h) => {
          n.includes(h) || n.push(h);
          const p = d.indexOf(h);
          p !== -1 && n.splice(p, 1);
        }), d.forEach((h) => {
          const p = n.indexOf(h);
          p !== -1 && n.splice(p, 1);
        });
        const u = this.createClassesFromQueries(n);
        s[a] = `<span class="text-underline ${u}">${s[a]}</span>`, a++;
      }
      return s.join("");
    }
  },
  methods: {
    createClassesFromQueries(o) {
      return o.map((e) => `resolved-query-${e}`).join(" ");
    }
  }
});
const p_ = ["innerHTML"];
function f_(o, e, t, i, r, n) {
  return ce(), je("span", { innerHTML: o.highlightedText }, null, 8, p_);
}
const $w = /* @__PURE__ */ He(h_, [["render", f_]]), g_ = Fe({
  name: "BsTablePagination",
  components: {
    QBtn: ou
  },
  props: {
    scope: {
      type: Object,
      required: !0
    },
    serverSidePagination: Object,
    startOfThePage: {
      type: Function,
      required: !0
    }
  },
  data() {
    return {
      batchSize: 0,
      batchOffset: 0,
      recordsCount: 0
    };
  },
  computed: {
    pagination() {
      return this.scope.pagination;
    },
    recordsShown() {
      const o = this.pagination.rowsPerPage;
      let e = this.pagination.page * o + this.batchSize * this.batchOffset;
      const t = e - o;
      return this.recordsCount && (e = Math.min(e, this.recordsCount)), `${t} - ${e}`;
    }
  },
  watch: {
    "serverSidePagination.batchOffset"() {
      this.syncServerSidePagination();
    },
    "serverSidePagination.batchSize"() {
      this.syncServerSidePagination();
    },
    "serverSidePagination.recordsCount"() {
      this.syncServerSidePagination();
    }
  },
  methods: {
    syncServerSidePagination() {
      var o, e, t, i, r;
      Pd((o = this.serverSidePagination) == null ? void 0 : o.batchOffset) || (this.batchOffset = this.serverSidePagination.batchOffset), (e = this.serverSidePagination) != null && e.batchSize && (this.batchSize = (t = this.serverSidePagination) == null ? void 0 : t.batchSize), (i = this.serverSidePagination) != null && i.recordsCount && (this.recordsCount = (r = this.serverSidePagination) == null ? void 0 : r.recordsCount);
    },
    executeAndGoToTop(o) {
      o(), this.startOfThePage && this.startOfThePage();
    }
  }
});
const v_ = { class: "bs-table-pagination" }, m_ = { class: "bs-table-pagination-controls" }, y_ = { class: "bs-table-records-info" };
function C_(o, e, t, i, r, n) {
  const s = ue("q-btn");
  return ce(), je("div", v_, [
    Re("div", m_, [
      o.scope.pagesNumber > 2 ? (ce(), _e(s, {
        key: 0,
        icon: "first_page",
        color: "grey-8",
        round: "",
        dense: "",
        flat: "",
        disable: o.scope.isFirstPage,
        onClick: e[0] || (e[0] = (a) => o.executeAndGoToTop(o.scope.firstPage))
      }, null, 8, ["disable"])) : Ne("", !0),
      Ce(s, {
        icon: "chevron_left",
        color: "grey-8",
        round: "",
        dense: "",
        flat: "",
        disable: o.scope.isFirstPage,
        onClick: e[1] || (e[1] = (a) => o.executeAndGoToTop(o.scope.prevPage))
      }, null, 8, ["disable"]),
      Re("div", y_, Bt(o.recordsShown), 1),
      Ce(s, {
        icon: "chevron_right",
        color: "grey-8",
        round: "",
        dense: "",
        flat: "",
        disable: o.scope.isLastPage,
        onClick: e[2] || (e[2] = (a) => o.executeAndGoToTop(o.scope.nextPage))
      }, null, 8, ["disable"]),
      o.scope.pagesNumber > 2 ? (ce(), _e(s, {
        key: 1,
        icon: "last_page",
        color: "grey-8",
        round: "",
        dense: "",
        flat: "",
        disable: o.scope.isLastPage,
        onClick: e[3] || (e[3] = (a) => o.executeAndGoToTop(o.scope.lastPage))
      }, null, 8, ["disable"])) : Ne("", !0)
    ])
  ]);
}
const S_ = /* @__PURE__ */ He(g_, [["render", C_], ["__scopeId", "data-v-4c15147d"]]), b_ = Fe({
  name: "BsTableVirtualScrollIndicator",
  components: {
    QLinearProgress: QP
  },
  props: {
    fetchedRowsLength: Number,
    serverSidePagination: Object,
    scrollDetails: Object
  },
  data() {
    return {
      progress: 0,
      showProgressBar: !1
    };
  },
  computed: {},
  methods: {
    updateProgress() {
      FR(() => {
        this.showProgressBar = this.scrollDetails ? this.scrollDetails.scrollHeight > 0 : !1, this.progress = this.showProgressBar && this.scrollDetails ? this.scrollDetails.scrollTop / this.scrollDetails.scrollHeight : 1;
      }, 250, "bs-table-scroll-update-indicator");
    }
  },
  mounted() {
    this.updateProgress();
  },
  watch: {
    "serverSidePagination.batchOffset"() {
      this.updateProgress();
    },
    "serverSidePagination.batchSize"() {
      this.updateProgress();
    },
    "serverSidePagination.recordsCount"() {
      this.updateProgress();
    },
    scrollDetails(o) {
      this.updateProgress();
    }
  }
});
const w_ = { class: "bs-table-virtual-scroll-progress-bar" };
function E_(o, e, t, i, r, n) {
  const s = ue("q-linear-progress");
  return ce(), je("div", {
    class: Rr(["bs-table-virtual-scroll", o.showProgressBar && "bs-table-virtual-scroll--active"])
  }, [
    Re("div", w_, [
      Ce(s, {
        value: o.progress,
        rounded: "",
        size: "5px"
      }, null, 8, ["value"])
    ])
  ], 2);
}
const R_ = /* @__PURE__ */ He(b_, [["render", E_], ["__scopeId", "data-v-195a0692"]]), T_ = Fe({
  name: "BsTableBottom",
  components: {
    BsTablePagination: S_,
    BsTableVirtualScrollIndicator: R_,
    QIcon: Lo
  },
  props: {
    scope: {
      type: Object,
      required: !0
    },
    serverSidePagination: Object,
    searching: Boolean,
    virtualScroll: {
      type: Boolean,
      required: !0
    },
    fetchedRowsLength: Number,
    startOfThePage: {
      type: Function,
      required: !0
    },
    scrollDetails: Object || void 0
  },
  data() {
    return {
      recordsCount: 0,
      mdiAlert: dA,
      recordsNumber: 0,
      virtualScrollOn: !1
    };
  },
  computed: {
    pagination() {
      return this.scope.pagination;
    },
    isFullDataset() {
      return Pd(this.serverSidePagination);
    },
    recordsTotal() {
      if (this.recordsCount)
        return this.recordsCount;
      if (this.isFullDataset)
        return this.fetchedRowsLength;
    }
  },
  watch: {
    "serverSidePagination.recordsCount"() {
      this.syncServerSidePagination();
    },
    "serverSidePagination.batchOffset"() {
      this.updateRecordNumber(0);
    },
    scrollDetails(o) {
      this.virtualScrollOn = o.scrollHeight > 0, this.updateRecordNumber(o.index);
    }
  },
  methods: {
    syncServerSidePagination() {
      var o, e;
      (o = this.serverSidePagination) != null && o.recordsCount && (this.recordsCount = (e = this.serverSidePagination) == null ? void 0 : e.recordsCount);
    },
    updateRecordNumber(o) {
      this.serverSidePagination ? this.recordsNumber = o + 1 + this.serverSidePagination.batchOffset * this.serverSidePagination.batchSize : this.fetchedRowsLength ? this.recordsNumber = o + 1 : this.recordsNumber = 0;
    }
  },
  mounted() {
    this.syncServerSidePagination();
  }
});
const x_ = (o) => (Zl("data-v-79b28020"), o = o(), Ql(), o), D_ = { class: "bs-table-bottom-container" }, O_ = /* @__PURE__ */ x_(() => /* @__PURE__ */ Re("div", { class: "bs-table-warning-text" }, "the search is applied only to the sampled records!", -1)), P_ = {
  key: 3,
  class: "bs-table-records-total"
}, A_ = { key: 0 };
function M_(o, e, t, i, r, n) {
  const s = ue("q-icon"), a = ue("BsTablePagination"), l = ue("BsTableVirtualScrollIndicator");
  return ce(), je("div", D_, [
    o.isFullDataset ? Ne("", !0) : (ce(), je("div", {
      key: 0,
      class: Rr(["bs-table-warning", o.searching && "bs-table-warning-active"])
    }, [
      Ce(s, { name: o.mdiAlert }, null, 8, ["name"]),
      O_
    ], 2)),
    o.virtualScroll ? o.virtualScrollOn ? (ce(), _e(l, {
      key: 2,
      "server-side-pagination": o.serverSidePagination,
      "scroll-details": o.scrollDetails,
      "fetched-rows-length": o.fetchedRowsLength
    }, null, 8, ["server-side-pagination", "scroll-details", "fetched-rows-length"])) : Ne("", !0) : (ce(), _e(a, {
      key: 1,
      scope: o.scope,
      "server-side-pagination": o.serverSidePagination,
      "start-of-the-page": o.startOfThePage
    }, null, 8, ["scope", "server-side-pagination", "start-of-the-page"])),
    o.recordsTotal && o.virtualScroll ? (ce(), je("div", P_, [
      o.virtualScrollOn ? (ce(), je("span", A_, Bt(o.recordsNumber) + " on  ", 1)) : Ne("", !0),
      hR(Bt(o.recordsTotal) + " rows", 1)
    ])) : Ne("", !0)
  ]);
}
const __ = /* @__PURE__ */ He(T_, [["render", M_], ["__scopeId", "data-v-79b28020"]]), I_ = Fe({
  name: "default",
  components: {
    QBtn: ou
  },
  emits: ["update:batch-offset"],
  data() {
    return {
      batchSize: 0,
      batchOffset: 0,
      recordsCount: 0
    };
  },
  props: {
    serverSidePagination: Object
  },
  computed: {
    sampleFrom() {
      return this.batchSize * this.batchOffset;
    },
    sampleTo() {
      let o = this.sampleFrom + this.batchSize;
      return this.recordsCount && (o = Math.min(o, this.recordsCount)), o;
    },
    isFirstBatch() {
      return this.batchOffset === 0;
    },
    isLastBatch() {
      return !(Pd(this.lastBatchIndex) || this.batchOffset !== this.lastBatchIndex);
    },
    lastBatchIndex() {
      if (this.recordsCount && this.batchSize)
        return Math.floor((this.recordsCount - 1) / this.batchSize);
    }
  },
  watch: {
    "serverSidePagination.batchOffset"() {
      this.syncServerSidePagination();
    },
    "serverSidePagination.batchSize"() {
      this.syncServerSidePagination();
    },
    "serverSidePagination.recordsCount"() {
      this.syncServerSidePagination();
    }
  },
  methods: {
    prevBatch() {
      this.changeCurrentBatchOffsetBy(-1);
    },
    nextBatch() {
      this.changeCurrentBatchOffsetBy(1);
    },
    changeCurrentBatchOffsetBy(o) {
      this.$emit("update:batch-offset", this.batchOffset + o);
    },
    syncServerSidePagination() {
      var o, e, t, i, r;
      Pd((o = this.serverSidePagination) == null ? void 0 : o.batchOffset) || (this.batchOffset = this.serverSidePagination.batchOffset), (e = this.serverSidePagination) != null && e.batchSize && (this.batchSize = (t = this.serverSidePagination) == null ? void 0 : t.batchSize), (i = this.serverSidePagination) != null && i.recordsCount && (this.recordsCount = (r = this.serverSidePagination) == null ? void 0 : r.recordsCount);
    }
  },
  mounted() {
    this.syncServerSidePagination();
  }
});
const F_ = (o) => (Zl("data-v-b7be3388"), o = o(), Ql(), o), L_ = {
  key: 0,
  class: "bs-table-server-side-pagination"
}, N_ = { class: "bs-table-server-side-pagination-controls" }, G_ = { class: "bs-table-server-side-pagination-offset" }, k_ = /* @__PURE__ */ F_(() => /* @__PURE__ */ Re("div", { class: "bs-table-server-side-pagination-label" }, " sampled rows ", -1));
function V_(o, e, t, i, r, n) {
  const s = ue("q-btn");
  return o.lastBatchIndex !== 0 ? (ce(), je("div", L_, [
    Re("div", N_, [
      Ce(s, {
        icon: "chevron_left",
        color: "grey-8",
        round: "",
        dense: "",
        flat: "",
        disable: o.isFirstBatch,
        onClick: o.prevBatch
      }, null, 8, ["disable", "onClick"]),
      Re("div", G_, Bt(o.sampleFrom) + " - " + Bt(o.sampleTo), 1),
      Ce(s, {
        icon: "chevron_right",
        color: "grey-8",
        round: "",
        dense: "",
        flat: "",
        disable: o.isLastBatch,
        onClick: o.nextBatch
      }, null, 8, ["disable", "onClick"])
    ]),
    k_
  ])) : Ne("", !0);
}
const B_ = /* @__PURE__ */ He(I_, [["render", V_], ["__scopeId", "data-v-b7be3388"]]), H_ = Fe({
  name: "BsSearchTableCol",
  components: { BsInputDebounce: LR, QIcon: Lo },
  props: {
    icon: String,
    clear: Boolean,
    colName: String,
    searchedCols: Object
  },
  data() {
    return {
      value: null,
      mdiTrashCanOutline: bR
    };
  },
  emits: ["clear-search"],
  watch: {
    clear() {
      this.value = null;
    },
    searchedCols(o) {
      this.colName && o.hasOwnProperty(this.colName) ? this.value = o[this.colName] : this.value = "";
    }
  },
  methods: {
    clearField() {
      this.$emit("clear-search", this.colName);
    }
  }
});
const W_ = { class: "bs-search-table-col-search-box" };
function j_(o, e, t, i, r, n) {
  const s = ue("q-icon"), a = ue("BsInputDebounce");
  return ce(), je("div", W_, [
    Ce(a, Mr({
      class: "bs-search-table-col-input",
      width: "102",
      label: "Search",
      clearable: "",
      "clear-icon": "close",
      borderless: "",
      dense: "",
      "format-input": "",
      autofocus: "",
      modelValue: o.value,
      "onUpdate:modelValue": e[0] || (e[0] = (l) => o.value = l)
    }, o.$attrs), nr({
      prepend: fe(() => [
        Ce(s, {
          name: o.icon,
          size: "1rem"
        }, null, 8, ["name"])
      ]),
      _: 2
    }, [
      li(o.$slots, (l, c) => ({
        name: c,
        fn: fe((d) => [
          Ze(o.$slots, c, Yt(ei(d || {})), void 0, !0)
        ])
      }))
    ]), 1040, ["modelValue"]),
    Re("div", null, [
      Ce(s, {
        name: o.mdiTrashCanOutline,
        onClick: o.clearField,
        size: "1rem",
        class: "cursor-pointer"
      }, null, 8, ["name", "onClick"])
    ])
  ]);
}
const U_ = /* @__PURE__ */ He(H_, [["render", j_], ["__scopeId", "data-v-79755b04"]]), $_ = Fe({
  name: "BSTableSearchHeader",
  components: {
    QTr: hS,
    QTh: uS,
    BsSearchTableCol: U_
  },
  props: {
    props: {
      type: Object,
      required: !0
    },
    searchedCols: Object,
    searchedCol: String || void 0
  },
  emits: ["search-col", "clear-all"],
  data() {
    return {
      noDebounceValue: "",
      searchColIcon: Pv
    };
  },
  watch: {
    searchedCol(o) {
      o && this.activateSearchCol(o);
    }
  },
  methods: {
    activateSearchCol(o) {
      var e;
      (e = this.searchedCols) != null && e.hasOwnProperty(o) || this.$emit("search-col", o, "");
    },
    searchColumn(o, e) {
      this.$emit("search-col", o, e);
    },
    clearAll() {
      this.$emit("clear-all");
    }
  },
  computed: {
    noSearches() {
      return CR(this.searchedCols);
    },
    cols() {
      return this.props.cols.filter((o) => o.name !== "clearAllCol");
    }
  }
});
const z_ = { class: "bs-table-search-header" };
function K_(o, e, t, i, r, n) {
  const s = ue("BsSearchTableCol"), a = ue("q-th"), l = ue("q-tr");
  return o.noSearches ? Ne("", !0) : (ce(), _e(l, {
    key: 0,
    props: o.props
  }, {
    default: fe(() => [
      (ce(!0), je(Ep, null, li(o.cols, (c) => (ce(), _e(a, {
        key: c.name,
        style: Ml({ "text-align": c.align ? c.align : "left" })
      }, {
        default: fe(() => {
          var d;
          return [
            Re("div", z_, [
              (d = o.searchedCols) != null && d.hasOwnProperty(c.name) ? (ce(), _e(s, {
                key: 0,
                icon: o.searchColIcon,
                searchedCols: o.searchedCols,
                "col-name": c.name,
                "onUpdate:formattedValue": (u) => o.searchColumn(c.name, u),
                "onUpdate:noDebounce:formattedValue": e[0] || (e[0] = (u) => o.noDebounceValue = u),
                onClearSearch: (u) => o.searchColumn(c.name, null)
              }, null, 8, ["icon", "searchedCols", "col-name", "onUpdate:formattedValue", "onClearSearch"])) : Ne("", !0)
            ])
          ];
        }),
        _: 2
      }, 1032, ["style"]))), 128)),
      o.noSearches ? Ne("", !0) : (ce(), _e(a, { key: "clearAllCol" }, {
        default: fe(() => [
          Re("span", {
            onClick: e[1] || (e[1] = (...c) => o.clearAll && o.clearAll(...c)),
            class: "bs-table-header-clear-all-btn"
          }, " Clear all ")
        ]),
        _: 1
      }))
    ]),
    _: 1
  }, 8, ["props"]));
}
const Y_ = /* @__PURE__ */ He($_, [["render", K_], ["__scopeId", "data-v-431163c8"]]), X_ = Fe({
  name: "BsTable",
  components: {
    QTable: JP,
    QTr: hS,
    QTd: eA,
    QBtn: ou,
    BsDSSTableFunctional: VM,
    BsSearchWholeTable: ZM,
    BSTableHeader: u_,
    BsTextHighlight: $w,
    BsTableBottom: __,
    BsTableServerSidePagination: B_,
    BSTableSearchHeader: Y_
  },
  emits: ["update:rows", "update:columns", "update:loading", "update:server-side-pagination", "virtual-scroll"],
  inheritAttrs: !1,
  props: {
    dssTableName: String,
    title: String,
    serverSidePagination: [Object, Boolean],
    loading: {
      type: Boolean,
      default: !1
    },
    rows: Array,
    columns: Array,
    virtualScroll: {
      type: Boolean,
      default: !0
    },
    stickyHeader: {
      type: Boolean,
      default: !0
    },
    globalSearch: {
      type: Boolean,
      default: !0
    },
    serverSidePaginationControls: {
      type: Boolean,
      default: !0
    },
    style: [Object, String],
    class: [Array, String],
    filters: Object
  },
  data() {
    return {
      searching: !1,
      fetching: !1,
      searchedCols: {},
      searchedCol: void 0,
      searchedValue: null,
      searchedValueFormatted: "",
      _serverSidePagination: void 0,
      _rows: void 0,
      _columns: void 0,
      lastBatchIndex: -1,
      scrollDetails: { from: 0 },
      passedRowsLength: 0,
      tableEl: void 0,
      mdiCloseCircleMultiple: uA
    };
  },
  computed: {
    isDSSTable() {
      return this.dssTableName !== void 0;
    },
    isLoading() {
      return this.loading || this.searching || this.fetching;
    },
    anyColumnSearched() {
      return !(!this.searchedValue && CR(this.searchedCols));
    },
    isServerSidePaginationObject() {
      return typeof this.serverSidePagination != "boolean";
    },
    passedRows() {
      return this.isDSSTable ? this._rows : this.rows;
    },
    passedColumns() {
      return this.isDSSTable ? this._columns : this.columns;
    },
    colSlotsUsed() {
      if (this.passedColumns)
        return this.passedColumns.filter((o) => this.colBodySlotUsed(o));
    },
    formattedColumns() {
      if (this.passedColumns) {
        const o = this.passedColumns.map((t) => cl(ui({}, t), { sortable: !1, _sortable: t.sortable })), e = {
          name: "clearAllCol",
          required: !0,
          label: "",
          field: "",
          sortable: !1,
          _sortable: !1
        };
        return o.push(e), o;
      }
    },
    filter() {
      return {
        columns: this.searchedCols,
        searchVal: this.searchedValueFormatted
      };
    },
    classParsed() {
      let o = this.class || "";
      return typeof o == "string" && (o = [o]), o;
    },
    tableClasses() {
      return ["bs-table", this.stickyHeader && "bs-table-sticky"];
    },
    filteredSlots() {
      const o = ["top"];
      return Object.fromEntries(
        Object.entries(this.$slots).filter(
          ([e]) => !(o.includes(e) || e.includes("body-cell"))
        )
      );
    }
  },
  watch: {
    "serverSidePagination.batchOffset"() {
      this.syncServerSidePagination();
    },
    "serverSidePagination.batchSize"() {
      this.syncServerSidePagination();
    },
    "serverSidePagination.recordsCount"() {
      this.syncServerSidePagination();
    },
    "passedRows.length"(o) {
      this.passedRowsLength = o;
    },
    isLoading(o) {
      this.$emit("update:loading", o);
    }
  },
  methods: {
    updateDSSRows(o) {
      o || (o = []);
      const { batchSize: e, batchOffset: t } = this._serverSidePagination, i = Object.keys(o).length;
      if (i < e) {
        const r = {};
        r.recordsCount = t * e + i, i == 0 && (r.batchOffset = t - 1), this.setServerSidePagination(r, !0);
      }
      this._rows = o, this.$emit("update:rows", this._rows);
    },
    updateDSSColumns(o) {
      this._columns = o, this.$emit("update:columns", this._columns);
    },
    searchTableFilter(...o) {
      return $M(...o);
    },
    updateSearchedCols(o, e) {
      e == null ? (delete this.searchedCols[o], o === this.searchedCol && (this.searchedCol = void 0)) : this.searchedCols[o] = e;
    },
    searchCol(o) {
      this.searchedCol = o;
    },
    colBodySlotUsed(o) {
      return this.$slots.hasOwnProperty(this.getColBodySlot(o));
    },
    getColBodySlot(o) {
      return `body-cell-${o.name}`;
    },
    getColSearchedValue(o) {
      return jM(this.searchedCols, o);
    },
    setBatchOffset(o, e = !1) {
      this.setServerSidePagination({ batchOffset: o }, e), this.startOfTheTable();
    },
    setBatchSize(o, e = !1) {
      this.setServerSidePagination({ batchSize: o }, e);
    },
    setRecordsCount(o, e = !1) {
      this.setServerSidePagination({ recordsCount: o }, e);
    },
    setServerSidePagination(o, e = !1) {
      o = ui({}, o), Object.entries(o).forEach(([t, i]) => {
        i < 0 && (i = 0), o[t] = i, this._serverSidePagination[t] = i;
      }), e && this.$emit("update:server-side-pagination", o);
    },
    syncServerSidePagination() {
      this.isServerSidePaginationObject && this.setServerSidePagination(this.serverSidePagination);
    },
    createServerSidePagination() {
      this._serverSidePagination = {
        batchOffset: 0,
        batchSize: 100,
        recordsCount: void 0
      };
    },
    clearAllSearch() {
      this.searchedValue = null, this.searchedCol = void 0, this.searchedCols = {};
    },
    onVirtualScroll(o) {
      var t;
      const e = (t = this.tableEl) == null ? void 0 : t.getElementsByClassName("q-table__middle")[0];
      this.scrollDetails = cl(ui({}, o), { scrollHeight: e.scrollHeight - e.clientHeight, scrollTop: e.scrollTop }), console.log(this.scrollDetails), this.$emit("virtual-scroll", this.scrollDetails);
    },
    startOfTheTable() {
      this.virtualScroll || this.firstPage(), this.startOfThePage();
    },
    startOfThePage() {
      this.scrollTo(0);
    },
    firstPage() {
      return this.$refs.qTable.firstPage();
    },
    scrollTo(o, e) {
      return this.$refs.qTable.scrollTo(o, e);
    },
    getBodyCellProps(o) {
      return cl(ui({}, o), {
        cellValueComponent: $w,
        cellValueComponentProps: {
          queries: [this.searchedValueFormatted, this.getColSearchedValue(o.col.name)],
          text: o.value
        }
      });
    }
  },
  mounted() {
    var o, e;
    (this.dssTableName || this.serverSidePagination) && (this.createServerSidePagination(), this.syncServerSidePagination()), this.passedRowsLength = ((o = this.passedRows) == null ? void 0 : o.length) || 0, this.tableEl = (e = this.$refs.qTable) == null ? void 0 : e.$el;
  }
});
const q_ = (o) => (Zl("data-v-9ddccf95"), o = o(), Ql(), o), Z_ = { class: "bs-table-top-container bs-table-name bordered" }, Q_ = { key: 1 }, J_ = { class: "bs-table-search-container bordered" }, eI = { class: "bs-table-top-slot-container bordered" }, tI = /* @__PURE__ */ q_(() => /* @__PURE__ */ Re("div", { class: "my-table-details" }, null, -1));
function iI(o, e, t, i, r, n) {
  const s = ue("BsDSSTableFunctional"), a = ue("BsSearchWholeTable"), l = ue("q-btn"), c = ue("BsTableServerSidePagination"), d = ue("BsTextHighlight"), u = ue("q-td"), h = ue("BSTableHeader"), p = ue("BSTableSearchHeader"), f = ue("BsTableBottom"), g = ue("QTable");
  return ce(), je(Ep, null, [
    o.isDSSTable ? (ce(), _e(s, {
      key: 0,
      "dss-table-name": o.dssTableName,
      "server-side-pagination": o._serverSidePagination,
      filters: o.filters,
      "onUpdate:fetching": e[0] || (e[0] = (v) => o.fetching = v),
      "onUpdate:rows": o.updateDSSRows,
      "onUpdate:columns": o.updateDSSColumns,
      "onUpdate:columnsCount": e[1] || (e[1] = (v) => o.setRecordsCount(v, !0))
    }, null, 8, ["dss-table-name", "server-side-pagination", "filters", "onUpdate:rows", "onUpdate:columns"])) : Ne("", !0),
    Ce(g, Mr({
      ref: "qTable",
      rows: o.passedRows,
      columns: o.formattedColumns,
      filter: o.filter,
      "filter-method": o.searchTableFilter,
      loading: o.isLoading
    }, o.$attrs, {
      "header-align": "left",
      "virtual-scroll": o.virtualScroll,
      "rows-per-page-options": o.virtualScroll ? [0] : void 0,
      class: [...o.classParsed, ...o.tableClasses],
      onVirtualScroll: o.onVirtualScroll
    }), nr({
      top: fe(() => [
        Re("div", Z_, [
          o.$slots.title ? Ze(o.$slots, "title", { key: 0 }, void 0, !0) : (ce(), je("span", Q_, Bt(o.title || o.dssTableName || ""), 1))
        ]),
        Re("div", J_, [
          o.globalSearch ? (ce(), _e(a, {
            key: 0,
            modelValue: o.searchedValue,
            "onUpdate:modelValue": e[2] || (e[2] = (v) => o.searchedValue = v),
            "onUpdate:formattedValue": e[3] || (e[3] = (v) => o.searchedValueFormatted = v),
            "onUpdate:loading": e[4] || (e[4] = (v) => o.searching = v)
          }, null, 8, ["modelValue"])) : Ne("", !0),
          Re("div", {
            class: Rr(["bs-table-clear-all-btn", o.anyColumnSearched && "bs-table-clear-all-btn--active"])
          }, [
            Ce(l, {
              flat: "",
              round: "",
              color: "primary",
              icon: o.mdiCloseCircleMultiple,
              onClick: o.clearAllSearch
            }, null, 8, ["icon", "onClick"])
          ], 2)
        ]),
        o._serverSidePagination && o.serverSidePaginationControls && o.passedColumns ? (ce(), _e(c, {
          key: 0,
          "server-side-pagination": o._serverSidePagination,
          "onUpdate:batchOffset": e[5] || (e[5] = (v) => o.setBatchOffset(v, !0)),
          class: "bordered"
        }, null, 8, ["server-side-pagination"])) : Ne("", !0),
        Re("div", eI, [
          Ze(o.$slots, "top", {}, void 0, !0)
        ])
      ]),
      "body-cell": fe((v) => [
        o.$slots.hasOwnProperty("body-cell") ? Ze(o.$slots, "body-cell", Yt(Mr({ key: 0 }, o.getBodyCellProps(v))), void 0, !0) : (ce(), _e(u, {
          key: 1,
          props: v
        }, {
          default: fe(() => [
            Ce(d, {
              queries: [o.searchedValueFormatted, o.getColSearchedValue(v.col.name)],
              text: v.value
            }, null, 8, ["queries", "text"])
          ]),
          _: 2
        }, 1032, ["props"]))
      ]),
      "body-cell-clearAllCol": fe((v) => [
        Ce(u, { props: v }, {
          default: fe(() => [
            tI
          ]),
          _: 2
        }, 1032, ["props"])
      ]),
      header: fe((v) => [
        o.passedColumns ? (ce(), _e(h, {
          key: 0,
          props: v,
          onSearchCol: o.searchCol
        }, null, 8, ["props", "onSearchCol"])) : Ne("", !0),
        o.passedColumns ? (ce(), _e(p, {
          key: 1,
          class: "bordered",
          props: v,
          "searched-cols": o.searchedCols,
          "searched-col": o.searchedCol,
          onSearchCol: o.updateSearchedCols,
          onClearAll: o.clearAllSearch
        }, null, 8, ["props", "searched-cols", "searched-col", "onSearchCol", "onClearAll"])) : Ne("", !0)
      ]),
      bottom: fe((v) => [
        Ce(f, {
          scope: v,
          "server-side-pagination": o._serverSidePagination,
          "start-of-the-page": o.startOfThePage,
          searching: o.anyColumnSearched,
          "virtual-scroll": o.virtualScroll,
          "scroll-details": o.scrollDetails,
          "fetched-rows-length": o.passedRowsLength
        }, null, 8, ["scope", "server-side-pagination", "start-of-the-page", "searching", "virtual-scroll", "scroll-details", "fetched-rows-length"])
      ]),
      _: 2
    }, [
      li(o.colSlotsUsed, (v) => ({
        name: o.getColBodySlot(v),
        fn: fe((y) => [
          Ze(o.$slots, o.getColBodySlot(v), Yt(ei(o.getBodyCellProps(y))), void 0, !0)
        ])
      })),
      li(o.filteredSlots, (v, y) => ({
        name: y,
        fn: fe((m) => [
          Ze(o.$slots, y, Yt(ei(m || {})), void 0, !0)
        ])
      }))
    ]), 1040, ["rows", "columns", "filter", "filter-method", "loading", "virtual-scroll", "rows-per-page-options", "class", "onVirtualScroll"])
  ], 64);
}
const rI = /* @__PURE__ */ He(X_, [["render", iI], ["__scopeId", "data-v-9ddccf95"]]), nI = Fe({
  name: "BsImg",
  components: {
    QImg: tA
  }
});
function oI(o, e, t, i, r, n) {
  const s = ue("QImg");
  return ce(), _e(s, Yt(ei(o.$attrs)), nr({ _: 2 }, [
    li(o.$slots, (a, l) => ({
      name: l,
      fn: fe((c) => [
        Ze(o.$slots, l, Yt(ei(c || {})))
      ])
    }))
  ]), 1040);
}
const sI = /* @__PURE__ */ He(nI, [["render", oI]]), aI = Fe({
  name: "BsIcon",
  components: {
    QIcon: Lo
  }
});
function lI(o, e, t, i, r, n) {
  const s = ue("QIcon");
  return ce(), _e(s, Yt(ei(o.$attrs)), nr({ _: 2 }, [
    li(o.$slots, (a, l) => ({
      name: l,
      fn: fe((c) => [
        Ze(o.$slots, l, Yt(ei(c || {})))
      ])
    }))
  ]), 1040);
}
const cI = /* @__PURE__ */ He(aI, [["render", lI]]), dI = Fe({
  name: "BsCheckbox",
  components: {
    QCheckbox: iA
  },
  props: {
    hint: {
      type: String
    }
  },
  computed: {
    labelFromHint() {
      return this.$attrs.label ? this.$attrs.label : this.hint ? this.hint : null;
    },
    isHintOnly() {
      return !this.$attrs.label && this.hint;
    },
    isDisabled() {
      return this.$attrs.disable != null;
    }
  }
}), uI = {
  key: 0,
  class: "dku-tiny-text bs-checkbox__hint"
};
function hI(o, e, t, i, r, n) {
  const s = ue("QCheckbox");
  return ce(), je("div", {
    class: Rr(["bs-checkbox", { hint: o.isHintOnly, disabled: o.isDisabled }])
  }, [
    Ce(s, Mr(o.$attrs, {
      size: "29.57px",
      tabindex: 0,
      label: o.labelFromHint
    }), nr({ _: 2 }, [
      li(o.$slots, (a, l) => ({
        name: l,
        fn: fe((c) => [
          Ze(o.$slots, l, Yt(ei(c || {})))
        ])
      }))
    ]), 1040, ["label"]),
    o.hint && o.$attrs.label ? (ce(), je("div", uI, Bt(o.hint), 1)) : Ne("", !0)
  ], 2);
}
const pI = /* @__PURE__ */ He(dI, [["render", hI]]), fI = Fe({
  name: "BsDateRange",
  components: {
    QInput: Ov,
    QDate: rA,
    QPopupProxy: nA,
    QIcon: Lo,
    QBtn: ou
  },
  props: {
    bsLabel: {
      type: String
    }
  },
  computed: {
    inputValue() {
      return this.$attrs.modelValue && this.$attrs.modelValue.from && this.$attrs.modelValue.to ? this.$attrs.modelValue.from + " - " + this.$attrs.modelValue.to : "";
    }
  }
}), gI = {
  key: 0,
  class: "bs-date-range__label dss-caption-400 q-mb-xs"
}, vI = { class: "row items-center justify-end" };
function mI(o, e, t, i, r, n) {
  const s = ue("QBtn"), a = ue("QDate"), l = ue("QPopupProxy"), c = ue("QIcon"), d = ue("QInput"), u = dS("close-popup");
  return ce(), je("div", null, [
    o.bsLabel ? (ce(), je("label", gI, Bt(o.bsLabel), 1)) : Ne("", !0),
    Ce(d, {
      dense: "",
      outlined: "",
      readonly: "",
      modelValue: o.inputValue,
      "onUpdate:modelValue": e[0] || (e[0] = (h) => o.inputValue = h)
    }, {
      append: fe(() => [
        Ce(c, {
          name: "event",
          class: "cursor-pointer"
        }, {
          default: fe(() => [
            Ce(l, {
              cover: "",
              "transition-show": "scale",
              "transition-hide": "scale"
            }, {
              default: fe(() => [
                Ce(a, Mr({ range: "" }, o.$attrs), {
                  default: fe(() => [
                    Re("div", vI, [
                      pa(Ce(s, {
                        label: "Close",
                        color: "primary",
                        flat: ""
                      }, null, 512), [
                        [u]
                      ])
                    ])
                  ]),
                  _: 1
                }, 16)
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["modelValue"])
  ]);
}
const yI = /* @__PURE__ */ He(fI, [["render", mI]]);
/**
          * @ag-grid-community/all-modules - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue * @version v30.0.5
          * @link https://www.ag-grid.com/
          * @license MIT
          */
function ca(o) {
  return o == null || o === "" ? null : o;
}
function z(o, e = !1) {
  return o != null && (o !== "" || e);
}
function Se(o) {
  return !z(o);
}
function br(o) {
  return o == null || o.length === 0;
}
function Lh(o) {
  return o != null && typeof o.toString == "function" ? o.toString() : null;
}
function sn(o) {
  if (o === void 0)
    return;
  if (o === null || o === "")
    return null;
  if (typeof o == "number")
    return isNaN(o) ? void 0 : o;
  const e = parseInt(o, 10);
  return isNaN(e) ? void 0 : e;
}
function po(o) {
  if (o !== void 0)
    return o === null || o === "" ? !1 : typeof o == "boolean" ? o : /true/i.test(o);
}
function CI(o) {
  if (!(o == null || o === ""))
    return o;
}
function SI(o, e) {
  return o == null && e == null ? !0 : o == null && e != null || o != null && e == null ? !1 : o === e;
}
function bI(o, e) {
  const t = o ? JSON.stringify(o) : null, i = e ? JSON.stringify(e) : null;
  return t === i;
}
function wI(o, e, t = !1) {
  const i = o == null, r = e == null;
  if (o && o.toNumber && (o = o.toNumber()), e && e.toNumber && (e = e.toNumber()), i && r)
    return 0;
  if (i)
    return -1;
  if (r)
    return 1;
  function n(s, a) {
    return s > a ? 1 : s < a ? -1 : 0;
  }
  if (typeof o != "string" || !t)
    return n(o, e);
  try {
    return o.localeCompare(e);
  } catch (s) {
    return n(o, e);
  }
}
function Dl(o) {
  if (o instanceof Set || o instanceof Map) {
    const e = [];
    return o.forEach((t) => e.push(t)), e;
  }
  return Object.values(o);
}
var EI = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  makeNull: ca,
  exists: z,
  missing: Se,
  missingOrEmpty: br,
  toStringOrNull: Lh,
  attrToNumber: sn,
  attrToBoolean: po,
  attrToString: CI,
  referenceCompare: SI,
  jsonEquals: bI,
  defaultComparator: wI,
  values: Dl
});
class RI {
  constructor() {
    this.existingKeys = {};
  }
  addExistingKeys(e) {
    for (let t = 0; t < e.length; t++)
      this.existingKeys[e[t]] = !0;
  }
  getUniqueKey(e, t) {
    e = Lh(e);
    let i = 0;
    for (; ; ) {
      let r;
      if (e ? (r = e, i !== 0 && (r += "_" + i)) : t ? (r = t, i !== 0 && (r += "_" + i)) : r = "" + i, !this.existingKeys[r])
        return this.existingKeys[r] = !0, r;
      i++;
    }
  }
}
function Ct(o, e) {
  o != null && (Array.isArray(o) ? o.forEach((t, i) => e(`${i}`, t)) : Object.keys(o).forEach((t) => e(t, o[t])));
}
function mS(o) {
  const e = {}, t = Object.keys(o);
  for (let i = 0; i < t.length; i++) {
    const r = t[i], n = o[r];
    e[r] = n;
  }
  return e;
}
function TI(o) {
  return JSON.parse(JSON.stringify(o));
}
function Tg(o, e) {
  if (!o)
    return;
  const t = o, i = {};
  return Object.keys(t).forEach((r) => {
    if (e && e.indexOf(r) >= 0)
      return;
    const n = t[r];
    xg(n) && n.constructor === Object ? i[r] = Tg(n) : i[r] = n;
  }), i;
}
function NR(o, e) {
  return o[e];
}
function GR(o, e, t) {
  o[e] = t;
}
function xI(o, e, ...t) {
  t.forEach((i) => kR(o, e, i));
}
function kR(o, e, t, i) {
  const r = NR(o, t);
  r !== void 0 && GR(e, t, i ? i(r) : r);
}
function VR(o) {
  const e = {};
  return o.filter((t) => t != null).forEach((t) => {
    Object.keys(t).forEach((i) => e[i] = null);
  }), Object.keys(e);
}
function To(o) {
  if (!o)
    return [];
  const e = Object;
  if (typeof e.values == "function")
    return e.values(o);
  const t = [];
  for (const i in o)
    o.hasOwnProperty(i) && o.propertyIsEnumerable(i) && t.push(o[i]);
  return t;
}
function Tr(o, e, t = !0, i = !1) {
  z(e) && Ct(e, (r, n) => {
    let s = o[r];
    s !== n && (i && s == null && n != null && typeof n == "object" && n.constructor === Object && (s = {}, o[r] = s), xg(n) && xg(s) && !Array.isArray(s) ? Tr(s, n, t, i) : (t || n !== void 0) && (o[r] = n));
  });
}
function DI(o) {
  return Se(o) || Object.keys(o).length === 0;
}
function OI(o, e, t) {
  if (o == null)
    return t;
  const i = e.split(".");
  let r = o;
  for (; i.length > 1; )
    if (r = r[i.shift()], r == null)
      return t;
  const n = r[i[0]];
  return n != null ? n : t;
}
function PI(o, e, t) {
  if (o == null)
    return;
  const i = e.split(".");
  let r = o;
  i.forEach((n, s) => {
    r[n] || (r[n] = {}), s < i.length - 1 && (r = r[n]);
  }), r[i[i.length - 1]] = t;
}
function bd(o, e, t) {
  if (!e || !o)
    return;
  if (!t)
    return o[e];
  const i = e.split(".");
  let r = o;
  for (let n = 0; n < i.length; n++) {
    if (r == null)
      return;
    r = r[i[n]];
  }
  return r;
}
function BR(o, e) {
  Object.keys(o).forEach((r) => {
    typeof o[r] == "object" && (o[r] = void 0);
  });
  const t = Object.getPrototypeOf(o), i = {};
  Object.keys(t).forEach((r) => {
    if (typeof t[r] == "function") {
      const s = () => {
        console.warn(`AG Grid: ${e} function ${r}() cannot be called as the grid has been destroyed.
                     Please don't call grid API functions on destroyed grids - as a matter of fact you shouldn't
                     be keeping the API reference, your application has a memory leak! Remove the API reference
                     when the grid is destroyed.`);
      };
      i[r] = { value: s, writable: !0 };
    }
  }), Object.defineProperties(o, i);
}
function xg(o) {
  return typeof o == "object" && o !== null;
}
var AI = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  iterateObject: Ct,
  cloneObject: mS,
  deepCloneObject: TI,
  deepCloneDefinition: Tg,
  getProperty: NR,
  setProperty: GR,
  copyPropertiesIfPresent: xI,
  copyPropertyIfPresent: kR,
  getAllKeysInObjects: VR,
  getAllValuesInObject: To,
  mergeDeep: Tr,
  missingOrEmptyObject: DI,
  get: OI,
  set: PI,
  getValueUsingField: bd,
  removeAllReferences: BR,
  isNonNullObject: xg
});
const zw = {};
function tt(o, e) {
  zw[e] || (o(), zw[e] = !0);
}
function Av(o) {
  if (o.name)
    return o.name;
  const e = /function\s+([^\(]+)/.exec(o.toString());
  return e && e.length === 2 ? e[1].trim() : null;
}
function Mv(o) {
  return !!(o && o.constructor && o.call && o.apply);
}
function HR(o) {
  WR(o, 400);
}
const gy = [];
let vy = !1;
function fC(o) {
  gy.push(o), !vy && (vy = !0, window.setTimeout(() => {
    const e = gy.slice();
    gy.length = 0, vy = !1, e.forEach((t) => t());
  }, 0));
}
function WR(o, e = 0) {
  o.length > 0 && window.setTimeout(() => o.forEach((t) => t()), e);
}
function Co(o, e) {
  let t;
  return function(...i) {
    const r = this;
    window.clearTimeout(t), t = window.setTimeout(function() {
      o.apply(r, i);
    }, e);
  };
}
function gC(o, e) {
  let t = 0;
  return function(...i) {
    const r = this, n = (/* @__PURE__ */ new Date()).getTime();
    n - t < e || (t = n, o.apply(r, i));
  };
}
function yS(o, e, t = 100, i) {
  const r = (/* @__PURE__ */ new Date()).getTime();
  let n = null, s = !1;
  const a = () => {
    const l = (/* @__PURE__ */ new Date()).getTime() - r > t;
    (o() || l) && (e(), s = !0, n != null && (window.clearInterval(n), n = null), l && i && console.warn(i));
  };
  a(), s || (n = window.setInterval(a, 10));
}
function MI(...o) {
  return (e) => o.reduce((t, i) => i(t), e);
}
function jR(o) {
  o && o();
}
const _I = () => {
};
var II = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  doOnce: tt,
  getFunctionName: Av,
  isFunction: Mv,
  executeInAWhile: HR,
  executeNextVMTurn: fC,
  executeAfter: WR,
  debounce: Co,
  throttle: gC,
  waitUntil: yS,
  compose: MI,
  callIfPresent: jR,
  noop: _I
}), Q;
(function(o) {
  o.CommunityCoreModule = "@ag-grid-community/core", o.InfiniteRowModelModule = "@ag-grid-community/infinite-row-model", o.ClientSideRowModelModule = "@ag-grid-community/client-side-row-model", o.CsvExportModule = "@ag-grid-community/csv-export", o.EnterpriseCoreModule = "@ag-grid-enterprise/core", o.RowGroupingModule = "@ag-grid-enterprise/row-grouping", o.ColumnsToolPanelModule = "@ag-grid-enterprise/column-tool-panel", o.FiltersToolPanelModule = "@ag-grid-enterprise/filter-tool-panel", o.MenuModule = "@ag-grid-enterprise/menu", o.SetFilterModule = "@ag-grid-enterprise/set-filter", o.MultiFilterModule = "@ag-grid-enterprise/multi-filter", o.StatusBarModule = "@ag-grid-enterprise/status-bar", o.SideBarModule = "@ag-grid-enterprise/side-bar", o.RangeSelectionModule = "@ag-grid-enterprise/range-selection", o.MasterDetailModule = "@ag-grid-enterprise/master-detail", o.RichSelectModule = "@ag-grid-enterprise/rich-select", o.GridChartsModule = "@ag-grid-enterprise/charts", o.ViewportRowModelModule = "@ag-grid-enterprise/viewport-row-model", o.ServerSideRowModelModule = "@ag-grid-enterprise/server-side-row-model", o.ExcelExportModule = "@ag-grid-enterprise/excel-export", o.ClipboardModule = "@ag-grid-enterprise/clipboard", o.SparklinesModule = "@ag-grid-enterprise/sparklines", o.AngularModule = "@ag-grid-community/angular", o.ReactModule = "@ag-grid-community/react", o.VueModule = "@ag-grid-community/vue";
})(Q || (Q = {}));
class Z {
  /**
   * Globally register the given module for all grids.
   * @param module - module to register
   */
  static register(e) {
    Z.__register(e, !0, void 0);
  }
  /**
   * Globally register the given modules for all grids.
   * @param modules - modules to register
   */
  static registerModules(e) {
    Z.__registerModules(e, !0, void 0);
  }
  /** AG GRID INTERNAL - Module registration helper. */
  static __register(e, t, i) {
    Z.runVersionChecks(e), i !== void 0 ? (Z.areGridScopedModules = !0, Z.gridModulesMap[i] === void 0 && (Z.gridModulesMap[i] = {}), Z.gridModulesMap[i][e.moduleName] = e) : Z.globalModulesMap[e.moduleName] = e, Z.setModuleBased(t);
  }
  /** AG GRID INTERNAL - Unregister grid scoped module. */
  static __unRegisterGridModules(e) {
    delete Z.gridModulesMap[e];
  }
  /** AG GRID INTERNAL - Module registration helper. */
  static __registerModules(e, t, i) {
    Z.setModuleBased(t), e && e.forEach((r) => Z.__register(r, t, i));
  }
  static isValidModuleVersion(e) {
    const [t, i] = e.version.split(".") || [], [r, n] = Z.currentModuleVersion.split(".") || [];
    return t === r && i === n;
  }
  static runVersionChecks(e) {
    if (Z.currentModuleVersion || (Z.currentModuleVersion = e.version), e.version ? Z.isValidModuleVersion(e) || console.error(`AG Grid: You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. '${e.moduleName}' is version ${e.version} but the other modules are version ${this.currentModuleVersion}. Please update all modules to the same version.`) : console.error(`AG Grid: You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. '${e.moduleName}' is incompatible. Please update all modules to the same version.`), e.validate) {
      const t = e.validate();
      t.isValid || console.error(`AG Grid: ${t.message}`);
    }
  }
  static setModuleBased(e) {
    Z.moduleBased === void 0 ? Z.moduleBased = e : Z.moduleBased !== e && tt(() => {
      console.warn("AG Grid: You are mixing modules (i.e. @ag-grid-community/core) and packages (ag-grid-community) - you can only use one or the other of these mechanisms."), console.warn("Please see https://www.ag-grid.com/javascript-grid/packages-modules/ for more information.");
    }, "ModulePackageCheck");
  }
  /**
   * AG GRID INTERNAL - Set if files are being served from a single UMD bundle to provide accurate enterprise upgrade steps.
   */
  static __setIsBundled() {
    Z.isBundled = !0;
  }
  /** AG GRID INTERNAL - Assert a given module has been register, globally or individually with this grid. */
  static __assertRegistered(e, t, i) {
    var r;
    if (this.__isRegistered(e, i))
      return !0;
    const n = t + e;
    let s;
    if (Z.isBundled)
      s = `AG Grid: unable to use ${t} as 'ag-grid-enterprise' has not been loaded. Check you are using the Enterprise bundle:
        
        <script src="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@AG_GRID_VERSION/dist/ag-grid-enterprise.min.js"><\/script>
        
For more info see: https://ag-grid.com/javascript-data-grid/getting-started/#getting-started-with-ag-grid-enterprise`;
    else if (Z.moduleBased || Z.moduleBased === void 0) {
      let a = (r = Object.entries(Q).find(([l, c]) => c === e)) === null || r === void 0 ? void 0 : r[0];
      s = `AG Grid: unable to use ${t} as the ${a} is not registered${Z.areGridScopedModules ? ` for gridId: ${i}` : ""}. Check if you have registered the module:
           
    import { ModuleRegistry } from '@ag-grid-community/core';
    import { ${a} } from '${e}';
    
    ModuleRegistry.registerModules([ ${a} ]);

For more info see: https://www.ag-grid.com/javascript-grid/modules/`;
    } else
      s = `AG Grid: unable to use ${t} as package 'ag-grid-enterprise' has not been imported. Check that you have imported the package:
            
    import 'ag-grid-enterprise';
            
For more info see: https://www.ag-grid.com/javascript-grid/packages/`;
    return tt(() => {
      console.warn(s);
    }, n), !1;
  }
  /** AG GRID INTERNAL - Is the given module registered, globally or individually with this grid. */
  static __isRegistered(e, t) {
    var i;
    return !!Z.globalModulesMap[e] || !!(!((i = Z.gridModulesMap[t]) === null || i === void 0) && i[e]);
  }
  /** AG GRID INTERNAL - Get all registered modules globally / individually for this grid. */
  static __getRegisteredModules(e) {
    return [...Dl(Z.globalModulesMap), ...Dl(Z.gridModulesMap[e] || {})];
  }
  /** AG GRID INTERNAL - Get the list of modules registered individually for this grid. */
  static __getGridRegisteredModules(e) {
    var t;
    return Dl((t = Z.gridModulesMap[e]) !== null && t !== void 0 ? t : {}) || [];
  }
  /** INTERNAL */
  static __isPackageBased() {
    return !Z.moduleBased;
  }
}
Z.globalModulesMap = {};
Z.gridModulesMap = {};
Z.areGridScopedModules = !1;
class FI {
  constructor(e, t) {
    if (this.beanWrappers = {}, this.destroyed = !1, !e || !e.beanClasses)
      return;
    this.contextParams = e, this.logger = t, this.logger.log(">> creating ag-Application Context"), this.createBeans();
    const i = this.getBeanInstances();
    this.wireBeans(i), this.logger.log(">> ag-Application Context ready - component is alive");
  }
  getBeanInstances() {
    return Dl(this.beanWrappers).map((e) => e.beanInstance);
  }
  createBean(e, t) {
    if (!e)
      throw Error("Can't wire to bean since it is null");
    return this.wireBeans([e], t), e;
  }
  wireBeans(e, t) {
    this.autoWireBeans(e), this.methodWireBeans(e), this.callLifeCycleMethods(e, "preConstructMethods"), z(t) && e.forEach(t), this.callLifeCycleMethods(e, "postConstructMethods");
  }
  createBeans() {
    this.contextParams.beanClasses.forEach(this.createBeanWrapper.bind(this)), Ct(this.beanWrappers, (t, i) => {
      let r;
      i.bean.__agBeanMetaData && i.bean.__agBeanMetaData.autowireMethods && i.bean.__agBeanMetaData.autowireMethods.agConstructor && (r = i.bean.__agBeanMetaData.autowireMethods.agConstructor);
      const n = this.getBeansForParameters(r, i.bean.name), s = new (i.bean.bind.apply(i.bean, [null, ...n]))();
      i.beanInstance = s;
    });
    const e = Object.keys(this.beanWrappers).join(", ");
    this.logger.log(`created beans: ${e}`);
  }
  // tslint:disable-next-line
  createBeanWrapper(e) {
    const t = e.__agBeanMetaData;
    if (!t) {
      let r;
      e.prototype.constructor ? r = Av(e.prototype.constructor) : r = "" + e, console.error(`Context item ${r} is not a bean`);
      return;
    }
    const i = {
      bean: e,
      beanInstance: null,
      beanName: t.beanName
    };
    this.beanWrappers[t.beanName] = i;
  }
  autoWireBeans(e) {
    e.forEach((t) => {
      this.forEachMetaDataInHierarchy(t, (i, r) => {
        const n = i.agClassAttributes;
        n && n.forEach((s) => {
          const a = this.lookupBeanInstance(r, s.beanName, s.optional);
          t[s.attributeName] = a;
        });
      });
    });
  }
  methodWireBeans(e) {
    e.forEach((t) => {
      this.forEachMetaDataInHierarchy(t, (i, r) => {
        Ct(i.autowireMethods, (n, s) => {
          if (n === "agConstructor")
            return;
          const a = this.getBeansForParameters(s, r);
          t[n].apply(t, a);
        });
      });
    });
  }
  forEachMetaDataInHierarchy(e, t) {
    let i = Object.getPrototypeOf(e);
    for (; i != null; ) {
      const r = i.constructor;
      if (r.hasOwnProperty("__agBeanMetaData")) {
        const n = r.__agBeanMetaData, s = this.getBeanName(r);
        t(n, s);
      }
      i = Object.getPrototypeOf(i);
    }
  }
  getBeanName(e) {
    if (e.__agBeanMetaData && e.__agBeanMetaData.beanName)
      return e.__agBeanMetaData.beanName;
    const t = e.toString();
    return t.substring(9, t.indexOf("("));
  }
  getBeansForParameters(e, t) {
    const i = [];
    return e && Ct(e, (r, n) => {
      const s = this.lookupBeanInstance(t, n);
      i[Number(r)] = s;
    }), i;
  }
  lookupBeanInstance(e, t, i = !1) {
    if (this.destroyed)
      return this.logger.log(`AG Grid: bean reference ${t} is used after the grid is destroyed!`), null;
    if (t === "context")
      return this;
    if (this.contextParams.providedBeanInstances && this.contextParams.providedBeanInstances.hasOwnProperty(t))
      return this.contextParams.providedBeanInstances[t];
    const r = this.beanWrappers[t];
    return r ? r.beanInstance : (i || console.error(`AG Grid: unable to find bean reference ${t} while initialising ${e}`), null);
  }
  callLifeCycleMethods(e, t) {
    e.forEach((i) => this.callLifeCycleMethodsOnBean(i, t));
  }
  callLifeCycleMethodsOnBean(e, t, i) {
    const r = {};
    this.forEachMetaDataInHierarchy(e, (s) => {
      const a = s[t];
      a && a.forEach((l) => {
        l != i && (r[l] = !0);
      });
    }), Object.keys(r).forEach((s) => e[s]());
  }
  getBean(e) {
    return this.lookupBeanInstance("getBean", e, !0);
  }
  destroy() {
    if (this.destroyed)
      return;
    this.logger.log(">> Shutting down ag-Application Context");
    const e = this.getBeanInstances();
    this.destroyBeans(e), this.contextParams.providedBeanInstances = null, Z.__unRegisterGridModules(this.contextParams.gridId), this.destroyed = !0, this.logger.log(">> ag-Application Context shut down - component is dead");
  }
  destroyBean(e) {
    e && this.destroyBeans([e]);
  }
  destroyBeans(e) {
    return e ? (e.forEach((t) => {
      this.callLifeCycleMethodsOnBean(t, "preDestroyMethods", "destroy");
      const i = t;
      typeof i.destroy == "function" && i.destroy();
    }), []) : [];
  }
  isDestroyed() {
    return this.destroyed;
  }
  getGridId() {
    return this.contextParams.gridId;
  }
}
function su(o, e, t) {
  const i = _l(o.constructor);
  i.preConstructMethods || (i.preConstructMethods = []), i.preConstructMethods.push(e);
}
function B(o, e, t) {
  const i = _l(o.constructor);
  i.postConstructMethods || (i.postConstructMethods = []), i.postConstructMethods.push(e);
}
function dt(o, e, t) {
  const i = _l(o.constructor);
  i.preDestroyMethods || (i.preDestroyMethods = []), i.preDestroyMethods.push(e);
}
function q(o) {
  return (e) => {
    const t = _l(e);
    t.beanName = o;
  };
}
function S(o) {
  return (e, t, i) => {
    UR(e, o, !1, e, t, null);
  };
}
function Ve(o) {
  return (e, t, i) => {
    UR(e, o, !0, e, t, null);
  };
}
function UR(o, e, t, i, r, n) {
  if (e === null) {
    console.error("AG Grid: Autowired name should not be null");
    return;
  }
  if (typeof n == "number") {
    console.error("AG Grid: Autowired should be on an attribute");
    return;
  }
  const s = _l(o.constructor);
  s.agClassAttributes || (s.agClassAttributes = []), s.agClassAttributes.push({
    attributeName: r,
    beanName: e,
    optional: t
  });
}
function qi(o) {
  return (e, t, i) => {
    const r = typeof e == "function" ? e : e.constructor;
    let n;
    if (typeof i == "number") {
      let s;
      t ? (n = _l(r), s = t) : (n = _l(r), s = "agConstructor"), n.autowireMethods || (n.autowireMethods = {}), n.autowireMethods[s] || (n.autowireMethods[s] = {}), n.autowireMethods[s][i] = o;
    }
  };
}
function _l(o) {
  return o.hasOwnProperty("__agBeanMetaData") || (o.__agBeanMetaData = {}), o.__agBeanMetaData;
}
var $R = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, Bf = function(o, e) {
  return function(t, i) {
    e(t, i, o);
  };
};
let _r = class {
  constructor() {
    this.allSyncListeners = /* @__PURE__ */ new Map(), this.allAsyncListeners = /* @__PURE__ */ new Map(), this.globalSyncListeners = /* @__PURE__ */ new Set(), this.globalAsyncListeners = /* @__PURE__ */ new Set(), this.asyncFunctionsQueue = [], this.scheduled = !1, this.firedEvents = {};
  }
  // because this class is used both inside the context and outside the context, we do not
  // use autowired attributes, as that would be confusing, as sometimes the attributes
  // would be wired, and sometimes not.
  //
  // the global event servers used by AG Grid is autowired by the context once, and this
  // setBeans method gets called once.
  //
  // the times when this class is used outside of the context (eg RowNode has an instance of this
  // class) then it is not a bean, and this setBeans method is not called.
  setBeans(e, t, i, r = null) {
    if (this.frameworkOverrides = i, this.gridOptionsService = t, r) {
      const n = t.useAsyncEvents();
      this.addGlobalListener(r, n);
    }
  }
  getListeners(e, t, i) {
    const r = t ? this.allAsyncListeners : this.allSyncListeners;
    let n = r.get(e);
    return !n && i && (n = /* @__PURE__ */ new Set(), r.set(e, n)), n;
  }
  noRegisteredListenersExist() {
    return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
  }
  addEventListener(e, t, i = !1) {
    this.getListeners(e, i, !0).add(t);
  }
  removeEventListener(e, t, i = !1) {
    const r = this.getListeners(e, i, !1);
    r && (r.delete(t), r.size === 0 && (i ? this.allAsyncListeners : this.allSyncListeners).delete(e));
  }
  addGlobalListener(e, t = !1) {
    (t ? this.globalAsyncListeners : this.globalSyncListeners).add(e);
  }
  removeGlobalListener(e, t = !1) {
    (t ? this.globalAsyncListeners : this.globalSyncListeners).delete(e);
  }
  dispatchEvent(e) {
    let t = e;
    if (this.gridOptionsService) {
      const { api: i, columnApi: r, context: n } = this.gridOptionsService;
      t.api = i, t.columnApi = r, t.context = n;
    }
    this.dispatchToListeners(t, !0), this.dispatchToListeners(t, !1), this.firedEvents[t.type] = !0;
  }
  dispatchEventOnce(e) {
    this.firedEvents[e.type] || this.dispatchEvent(e);
  }
  dispatchToListeners(e, t) {
    const i = e.type;
    if (t && "event" in e) {
      const a = e.event;
      a instanceof Event && (e.eventPath = a.composedPath());
    }
    const r = (a) => a.forEach((l) => {
      t ? this.dispatchAsync(() => l(e)) : l(e);
    }), n = new Set(this.getListeners(i, t, !1));
    n && r(n), new Set(t ? this.globalAsyncListeners : this.globalSyncListeners).forEach((a) => {
      t ? this.dispatchAsync(() => this.frameworkOverrides.dispatchEvent(i, () => a(i, e), !0)) : this.frameworkOverrides.dispatchEvent(i, () => a(i, e), !0);
    });
  }
  // this gets called inside the grid's thread, for each event that it
  // wants to set async. the grid then batches the events into one setTimeout()
  // because setTimeout() is an expensive operation. ideally we would have
  // each event in it's own setTimeout(), but we batch for performance.
  dispatchAsync(e) {
    this.asyncFunctionsQueue.push(e), this.scheduled || (window.setTimeout(this.flushAsyncQueue.bind(this), 0), this.scheduled = !0);
  }
  // this happens in the next VM turn only, and empties the queue of events
  flushAsyncQueue() {
    this.scheduled = !1;
    const e = this.asyncFunctionsQueue.slice();
    this.asyncFunctionsQueue = [], e.forEach((t) => t());
  }
};
$R([
  Bf(0, qi("loggerFactory")),
  Bf(1, qi("gridOptionsService")),
  Bf(2, qi("frameworkOverrides")),
  Bf(3, qi("globalEventListener"))
], _r.prototype, "setBeans", null);
_r = $R([
  q("eventService")
], _r);
var _v = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let LI = 0;
function zR() {
  return LI++;
}
class me {
  constructor(e, t, i, r) {
    this.instanceId = zR(), this.autoHeaderHeight = null, this.moving = !1, this.menuVisible = !1, this.filterActive = !1, this.eventService = new _r(), this.tooltipEnabled = !1, this.rowGroupActive = !1, this.pivotActive = !1, this.aggregationActive = !1, this.colDef = e, this.userProvidedColDef = t, this.colId = i, this.primary = r, this.setState(e);
  }
  getInstanceId() {
    return this.instanceId;
  }
  setState(e) {
    e.sort !== void 0 ? (e.sort === "asc" || e.sort === "desc") && (this.sort = e.sort) : (e.initialSort === "asc" || e.initialSort === "desc") && (this.sort = e.initialSort);
    const t = sn(e.sortIndex), i = sn(e.initialSortIndex);
    t !== void 0 ? t !== null && (this.sortIndex = t) : i !== null && (this.sortIndex = i);
    const r = po(e.hide), n = po(e.initialHide);
    r !== void 0 ? this.visible = !r : this.visible = !n, e.pinned !== void 0 ? this.setPinned(e.pinned) : this.setPinned(e.initialPinned);
    const s = sn(e.flex), a = sn(e.initialFlex);
    s !== void 0 ? this.flex = s : a !== void 0 && (this.flex = a);
  }
  // gets called when user provides an alternative colDef, eg
  setColDef(e, t) {
    this.colDef = e, this.userProvidedColDef = t, this.initMinAndMaxWidths(), this.initDotNotation(), this.eventService.dispatchEvent(this.createColumnEvent("colDefChanged", "api"));
  }
  /**
   * Returns the column definition provided by the application.
   * This may not be correct, as items can be superseded by default column options.
   * However it's useful for comparison, eg to know which application column definition matches that column.
   */
  getUserProvidedColDef() {
    return this.userProvidedColDef;
  }
  setParent(e) {
    this.parent = e;
  }
  /** Returns the parent column group, if column grouping is active. */
  getParent() {
    return this.parent;
  }
  setOriginalParent(e) {
    this.originalParent = e;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  // this is done after constructor as it uses gridOptionsService
  initialise() {
    this.initMinAndMaxWidths(), this.resetActualWidth("gridInitializing"), this.initDotNotation(), this.initTooltip(), this.validate();
  }
  initDotNotation() {
    const e = this.gridOptionsService.is("suppressFieldDotNotation");
    this.fieldContainsDots = z(this.colDef.field) && this.colDef.field.indexOf(".") >= 0 && !e, this.tooltipFieldContainsDots = z(this.colDef.tooltipField) && this.colDef.tooltipField.indexOf(".") >= 0 && !e;
  }
  initMinAndMaxWidths() {
    const e = this.colDef;
    this.minWidth = this.columnUtils.calculateColMinWidth(e), this.maxWidth = this.columnUtils.calculateColMaxWidth(e);
  }
  initTooltip() {
    this.tooltipEnabled = z(this.colDef.tooltipField) || z(this.colDef.tooltipValueGetter) || z(this.colDef.tooltipComponent);
  }
  resetActualWidth(e = "api") {
    const t = this.columnUtils.calculateColInitialWidth(this.colDef);
    this.setActualWidth(t, e, !0);
  }
  isEmptyGroup() {
    return !1;
  }
  isRowGroupDisplayed(e) {
    if (Se(this.colDef) || Se(this.colDef.showRowGroup))
      return !1;
    const t = this.colDef.showRowGroup === !0, i = this.colDef.showRowGroup === e;
    return t || i;
  }
  /** Returns `true` if column is a primary column, `false` if secondary. Secondary columns are used for pivoting. */
  isPrimary() {
    return this.primary;
  }
  /** Returns `true` if column filtering is allowed. */
  isFilterAllowed() {
    return !!this.colDef.filter;
  }
  isFieldContainsDots() {
    return this.fieldContainsDots;
  }
  isTooltipEnabled() {
    return this.tooltipEnabled;
  }
  isTooltipFieldContainsDots() {
    return this.tooltipFieldContainsDots;
  }
  validate() {
    const e = this.colDef;
    function t(r, n, s) {
      tt(() => {
        s ? console.warn(r, s) : tt(() => console.warn(r), n);
      }, n);
    }
    if (this.gridOptionsService.isRowModelType("clientSide") && !Z.__isRegistered(Q.RowGroupingModule, this.gridOptionsService.getGridId())) {
      const n = ["enableRowGroup", "rowGroup", "rowGroupIndex", "enablePivot", "enableValue", "pivot", "pivotIndex", "aggFunc"].filter((s) => z(e[s]));
      n.length > 0 && Z.__assertRegistered(Q.RowGroupingModule, n.map((s) => "colDef." + s).join(", "), this.gridOptionsService.getGridId());
    }
    if ((this.colDef.cellEditor === "agRichSelect" || this.colDef.cellEditor === "agRichSelectCellEditor") && Z.__assertRegistered(Q.RichSelectModule, this.colDef.cellEditor, this.gridOptionsService.getGridId()), this.gridOptionsService.isTreeData()) {
      const n = ["rowGroup", "rowGroupIndex", "pivot", "pivotIndex"].filter((s) => z(e[s]));
      n.length > 0 && t(`AG Grid: ${n.join()} is not possible when doing tree data, your column definition should not have ${n.join()}`, "TreeDataCannotRowGroup");
    }
    if (z(e.menuTabs))
      if (Array.isArray(e.menuTabs)) {
        const r = ["filterMenuTab"], n = ["columnsMenuTab", "generalMenuTab"], s = n.filter((a) => e.menuTabs.includes(a));
        s.length > 0 && Z.__assertRegistered(Q.MenuModule, `menuTab(s): ${s.map((a) => `'${a}'`).join()}`, this.gridOptionsService.getGridId()), e.menuTabs.forEach((a) => {
          !n.includes(a) && !r.includes(a) && t(`AG Grid: '${a}' is not valid for 'colDef.menuTabs'. Valid values are: ${[...r, ...n].map((l) => `'${l}'`).join()}.`, "wrongValue_menuTabs_" + a);
        });
      } else
        t("AG Grid: The typeof 'colDef.menuTabs' should be an array not:" + typeof e.menuTabs, "wrongType_menuTabs");
    z(e.columnsMenuParams) && Z.__assertRegistered(Q.MenuModule, "columnsMenuParams", this.gridOptionsService.getGridId()), z(e.columnsMenuParams) && Z.__assertRegistered(Q.ColumnsToolPanelModule, "columnsMenuParams", this.gridOptionsService.getGridId()), z(this.colDef.width) && typeof this.colDef.width != "number" && t("AG Grid: colDef.width should be a number, not " + typeof this.colDef.width, "ColumnCheck"), z(e.columnGroupShow) && e.columnGroupShow !== "closed" && e.columnGroupShow !== "open" && t(`AG Grid: '${e.columnGroupShow}' is not valid for columnGroupShow. Valid values are 'open', 'closed', undefined, null`, "columnGroupShow_invalid");
  }
  /** Add an event listener to the column. */
  addEventListener(e, t) {
    this.eventService.addEventListener(e, t);
  }
  /** Remove event listener from the column. */
  removeEventListener(e, t) {
    this.eventService.removeEventListener(e, t);
  }
  createColumnFunctionCallbackParams(e) {
    return {
      node: e,
      data: e.data,
      column: this,
      colDef: this.colDef,
      context: this.gridOptionsService.context,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi
    };
  }
  isSuppressNavigable(e) {
    if (typeof this.colDef.suppressNavigable == "boolean")
      return this.colDef.suppressNavigable;
    if (typeof this.colDef.suppressNavigable == "function") {
      const t = this.createColumnFunctionCallbackParams(e), i = this.colDef.suppressNavigable;
      return i(t);
    }
    return !1;
  }
  /**
   * Returns `true` if the cell for this column is editable for the given `rowNode`, otherwise `false`.
   */
  isCellEditable(e) {
    return e.group && !this.gridOptionsService.is("enableGroupEdit") ? !1 : this.isColumnFunc(e, this.colDef.editable);
  }
  isSuppressFillHandle() {
    return !!po(this.colDef.suppressFillHandle);
  }
  isAutoHeight() {
    return !!po(this.colDef.autoHeight);
  }
  isAutoHeaderHeight() {
    return !!po(this.colDef.autoHeaderHeight);
  }
  isRowDrag(e) {
    return this.isColumnFunc(e, this.colDef.rowDrag);
  }
  isDndSource(e) {
    return this.isColumnFunc(e, this.colDef.dndSource);
  }
  isCellCheckboxSelection(e) {
    return this.isColumnFunc(e, this.colDef.checkboxSelection);
  }
  isSuppressPaste(e) {
    return this.isColumnFunc(e, this.colDef ? this.colDef.suppressPaste : null);
  }
  isResizable() {
    return !!po(this.colDef.resizable);
  }
  isColumnFunc(e, t) {
    if (typeof t == "boolean")
      return t;
    if (typeof t == "function") {
      const i = this.createColumnFunctionCallbackParams(e);
      return t(i);
    }
    return !1;
  }
  setMoving(e, t = "api") {
    this.moving = e, this.eventService.dispatchEvent(this.createColumnEvent("movingChanged", t));
  }
  createColumnEvent(e, t) {
    return {
      type: e,
      column: this,
      columns: [this],
      source: t,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context
    };
  }
  isMoving() {
    return this.moving;
  }
  /** If sorting is active, returns the sort direction e.g. `'asc'` or `'desc'`. */
  getSort() {
    return this.sort;
  }
  setSort(e, t = "api") {
    this.sort !== e && (this.sort = e, this.eventService.dispatchEvent(this.createColumnEvent("sortChanged", t))), this.dispatchStateUpdatedEvent("sort");
  }
  setMenuVisible(e, t = "api") {
    this.menuVisible !== e && (this.menuVisible = e, this.eventService.dispatchEvent(this.createColumnEvent("menuVisibleChanged", t)));
  }
  isMenuVisible() {
    return this.menuVisible;
  }
  isSortAscending() {
    return this.sort === "asc";
  }
  isSortDescending() {
    return this.sort === "desc";
  }
  isSortNone() {
    return Se(this.sort);
  }
  isSorting() {
    return z(this.sort);
  }
  getSortIndex() {
    return this.sortIndex;
  }
  setSortIndex(e) {
    this.sortIndex = e, this.dispatchStateUpdatedEvent("sortIndex");
  }
  setAggFunc(e) {
    this.aggFunc = e, this.dispatchStateUpdatedEvent("aggFunc");
  }
  /** If aggregation is set for the column, returns the aggregation function. */
  getAggFunc() {
    return this.aggFunc;
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  getRight() {
    return this.left + this.actualWidth;
  }
  setLeft(e, t = "api") {
    this.oldLeft = this.left, this.left !== e && (this.left = e, this.eventService.dispatchEvent(this.createColumnEvent("leftChanged", t)));
  }
  /** Returns `true` if filter is active on the column. */
  isFilterActive() {
    return this.filterActive;
  }
  // additionalEventAttributes is used by provided simple floating filter, so it can add 'floatingFilter=true' to the event
  setFilterActive(e, t = "api", i) {
    this.filterActive !== e && (this.filterActive = e, this.eventService.dispatchEvent(this.createColumnEvent("filterActiveChanged", t)));
    const r = this.createColumnEvent("filterChanged", t);
    i && Tr(r, i), this.eventService.dispatchEvent(r);
  }
  /** Returns `true` when this `Column` is hovered, otherwise `false` */
  isHovered() {
    return this.columnHoverService.isHovered(this);
  }
  setPinned(e) {
    e === !0 || e === "left" ? this.pinned = "left" : e === "right" ? this.pinned = "right" : this.pinned = null, this.dispatchStateUpdatedEvent("pinned");
  }
  setFirstRightPinned(e, t = "api") {
    this.firstRightPinned !== e && (this.firstRightPinned = e, this.eventService.dispatchEvent(this.createColumnEvent("firstRightPinnedChanged", t)));
  }
  setLastLeftPinned(e, t = "api") {
    this.lastLeftPinned !== e && (this.lastLeftPinned = e, this.eventService.dispatchEvent(this.createColumnEvent("lastLeftPinnedChanged", t)));
  }
  isFirstRightPinned() {
    return this.firstRightPinned;
  }
  isLastLeftPinned() {
    return this.lastLeftPinned;
  }
  isPinned() {
    return this.pinned === "left" || this.pinned === "right";
  }
  isPinnedLeft() {
    return this.pinned === "left";
  }
  isPinnedRight() {
    return this.pinned === "right";
  }
  getPinned() {
    return this.pinned;
  }
  setVisible(e, t = "api") {
    const i = e === !0;
    this.visible !== i && (this.visible = i, this.eventService.dispatchEvent(this.createColumnEvent("visibleChanged", t))), this.dispatchStateUpdatedEvent("hide");
  }
  isVisible() {
    return this.visible;
  }
  isSpanHeaderHeight() {
    const e = this.getColDef();
    return !e.suppressSpanHeaderHeight && !e.autoHeaderHeight;
  }
  /** Returns the column definition for this column.
   * The column definition will be the result of merging the application provided column definition with any provided defaults
   * (e.g. `defaultColDef` grid option, or column types.
   *
   * Equivalent: `getDefinition` */
  getColDef() {
    return this.colDef;
  }
  getColumnGroupShow() {
    return this.colDef.columnGroupShow;
  }
  /**
   * Returns the unique ID for the column.
   *
   * Equivalent: `getId`, `getUniqueId` */
  getColId() {
    return this.colId;
  }
  /**
   * Returns the unique ID for the column.
   *
   * Equivalent: `getColId`, `getUniqueId` */
  getId() {
    return this.colId;
  }
  /**
   * Returns the unique ID for the column.
   *
   * Equivalent: `getColId`, `getId` */
  getUniqueId() {
    return this.colId;
  }
  getDefinition() {
    return this.colDef;
  }
  /** Returns the current width of the column. If the column is resized, the actual width is the new size. */
  getActualWidth() {
    return this.actualWidth;
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  /** Returns true if the header height has changed */
  setAutoHeaderHeight(e) {
    const t = e !== this.autoHeaderHeight;
    return this.autoHeaderHeight = e, t;
  }
  createBaseColDefParams(e) {
    return {
      node: e,
      data: e.data,
      colDef: this.colDef,
      column: this,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context
    };
  }
  getColSpan(e) {
    if (Se(this.colDef.colSpan))
      return 1;
    const t = this.createBaseColDefParams(e), i = this.colDef.colSpan(t);
    return Math.max(i, 1);
  }
  getRowSpan(e) {
    if (Se(this.colDef.rowSpan))
      return 1;
    const t = this.createBaseColDefParams(e), i = this.colDef.rowSpan(t);
    return Math.max(i, 1);
  }
  setActualWidth(e, t = "api", i = !1) {
    this.minWidth != null && (e = Math.max(e, this.minWidth)), this.maxWidth != null && (e = Math.min(e, this.maxWidth)), this.actualWidth !== e && (this.actualWidth = e, this.flex && t !== "flex" && t !== "gridInitializing" && (this.flex = null), i || this.fireColumnWidthChangedEvent(t)), this.dispatchStateUpdatedEvent("width");
  }
  fireColumnWidthChangedEvent(e) {
    this.eventService.dispatchEvent(this.createColumnEvent("widthChanged", e));
  }
  isGreaterThanMax(e) {
    return this.maxWidth != null ? e > this.maxWidth : !1;
  }
  getMinWidth() {
    return this.minWidth;
  }
  getMaxWidth() {
    return this.maxWidth;
  }
  getFlex() {
    return this.flex || 0;
  }
  // this method should only be used by the columnModel to
  // change flex when required by the applyColumnState method.
  setFlex(e) {
    this.flex !== e && (this.flex = e), this.dispatchStateUpdatedEvent("flex");
  }
  setMinimum(e = "api") {
    z(this.minWidth) && this.setActualWidth(this.minWidth, e);
  }
  setRowGroupActive(e, t = "api") {
    this.rowGroupActive !== e && (this.rowGroupActive = e, this.eventService.dispatchEvent(this.createColumnEvent("columnRowGroupChanged", t))), this.dispatchStateUpdatedEvent("rowGroup");
  }
  /** Returns `true` if row group is currently active for this column. */
  isRowGroupActive() {
    return this.rowGroupActive;
  }
  setPivotActive(e, t = "api") {
    this.pivotActive !== e && (this.pivotActive = e, this.eventService.dispatchEvent(this.createColumnEvent("columnPivotChanged", t))), this.dispatchStateUpdatedEvent("pivot");
  }
  /** Returns `true` if pivot is currently active for this column. */
  isPivotActive() {
    return this.pivotActive;
  }
  isAnyFunctionActive() {
    return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
  }
  isAnyFunctionAllowed() {
    return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
  }
  setValueActive(e, t = "api") {
    this.aggregationActive !== e && (this.aggregationActive = e, this.eventService.dispatchEvent(this.createColumnEvent("columnValueChanged", t)));
  }
  /** Returns `true` if value (aggregation) is currently active for this column. */
  isValueActive() {
    return this.aggregationActive;
  }
  isAllowPivot() {
    return this.colDef.enablePivot === !0;
  }
  isAllowValue() {
    return this.colDef.enableValue === !0;
  }
  isAllowRowGroup() {
    return this.colDef.enableRowGroup === !0;
  }
  getMenuTabs(e) {
    let t = this.getColDef().menuTabs;
    return t == null && (t = e), t;
  }
  dispatchStateUpdatedEvent(e) {
    this.eventService.dispatchEvent({
      type: me.EVENT_STATE_UPDATED,
      key: e
    });
  }
}
me.EVENT_MOVING_CHANGED = "movingChanged";
me.EVENT_LEFT_CHANGED = "leftChanged";
me.EVENT_WIDTH_CHANGED = "widthChanged";
me.EVENT_LAST_LEFT_PINNED_CHANGED = "lastLeftPinnedChanged";
me.EVENT_FIRST_RIGHT_PINNED_CHANGED = "firstRightPinnedChanged";
me.EVENT_VISIBLE_CHANGED = "visibleChanged";
me.EVENT_FILTER_CHANGED = "filterChanged";
me.EVENT_FILTER_ACTIVE_CHANGED = "filterActiveChanged";
me.EVENT_SORT_CHANGED = "sortChanged";
me.EVENT_COL_DEF_CHANGED = "colDefChanged";
me.EVENT_MENU_VISIBLE_CHANGED = "menuVisibleChanged";
me.EVENT_ROW_GROUP_CHANGED = "columnRowGroupChanged";
me.EVENT_PIVOT_CHANGED = "columnPivotChanged";
me.EVENT_VALUE_CHANGED = "columnValueChanged";
me.EVENT_STATE_UPDATED = "columnStateUpdated";
_v([
  S("gridOptionsService")
], me.prototype, "gridOptionsService", void 0);
_v([
  S("columnUtils")
], me.prototype, "columnUtils", void 0);
_v([
  S("columnHoverService")
], me.prototype, "columnHoverService", void 0);
_v([
  B
], me.prototype, "initialise", null);
var NI = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Be {
  constructor(e, t, i, r) {
    this.localEventService = new _r(), this.expandable = !1, this.instanceId = zR(), this.expandableListenerRemoveCallback = null, this.colGroupDef = e, this.groupId = t, this.expanded = !!e && !!e.openByDefault, this.padding = i, this.level = r;
  }
  destroy() {
    this.expandableListenerRemoveCallback && this.reset(null, void 0);
  }
  reset(e, t) {
    this.colGroupDef = e, this.level = t, this.originalParent = null, this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback(), this.children = void 0, this.expandable = void 0;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setOriginalParent(e) {
    this.originalParent = e;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  getLevel() {
    return this.level;
  }
  isVisible() {
    return this.children ? this.children.some((e) => e.isVisible()) : !1;
  }
  isPadding() {
    return this.padding;
  }
  setExpanded(e) {
    this.expanded = e === void 0 ? !1 : e;
    const t = {
      type: Be.EVENT_EXPANDED_CHANGED
    };
    this.localEventService.dispatchEvent(t);
  }
  isExpandable() {
    return this.expandable;
  }
  isExpanded() {
    return this.expanded;
  }
  getGroupId() {
    return this.groupId;
  }
  getId() {
    return this.getGroupId();
  }
  setChildren(e) {
    this.children = e;
  }
  getChildren() {
    return this.children;
  }
  getColGroupDef() {
    return this.colGroupDef;
  }
  getLeafColumns() {
    const e = [];
    return this.addLeafColumns(e), e;
  }
  addLeafColumns(e) {
    this.children && this.children.forEach((t) => {
      t instanceof me ? e.push(t) : t instanceof Be && t.addLeafColumns(e);
    });
  }
  getColumnGroupShow() {
    const e = this.colGroupDef;
    if (e)
      return e.columnGroupShow;
  }
  // need to check that this group has at least one col showing when both expanded and contracted.
  // if not, then we don't allow expanding and contracting on this group
  setupExpandable() {
    this.setExpandable(), this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback();
    const e = this.onColumnVisibilityChanged.bind(this);
    this.getLeafColumns().forEach((t) => t.addEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = () => {
      this.getLeafColumns().forEach((t) => t.removeEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = null;
    };
  }
  setExpandable() {
    if (this.isPadding())
      return;
    let e = !1, t = !1, i = !1;
    const r = this.findChildrenRemovingPadding();
    for (let s = 0, a = r.length; s < a; s++) {
      const l = r[s];
      if (!l.isVisible())
        continue;
      const c = l.getColumnGroupShow();
      c === "open" ? (e = !0, i = !0) : c === "closed" ? (t = !0, i = !0) : (e = !0, t = !0);
    }
    const n = e && t && i;
    if (this.expandable !== n) {
      this.expandable = n;
      const s = {
        type: Be.EVENT_EXPANDABLE_CHANGED
      };
      this.localEventService.dispatchEvent(s);
    }
  }
  findChildrenRemovingPadding() {
    const e = [], t = (i) => {
      i.forEach((r) => {
        r instanceof Be && r.isPadding() ? t(r.children) : e.push(r);
      });
    };
    return t(this.children), e;
  }
  onColumnVisibilityChanged() {
    this.setExpandable();
  }
  addEventListener(e, t) {
    this.localEventService.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.localEventService.removeEventListener(e, t);
  }
}
Be.EVENT_EXPANDED_CHANGED = "expandedChanged";
Be.EVENT_EXPANDABLE_CHANGED = "expandableChanged";
NI([
  dt
], Be.prototype, "destroy", null);
const GI = {
  numericColumn: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  },
  rightAligned: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  }
};
function KR(...o) {
  for (let e = 0; e < o.length; e++) {
    const t = o[e];
    if (z(t))
      return t;
  }
  return null;
}
function kI(o) {
  return o != null && o.length > 0;
}
function at(o) {
  if (!(!o || !o.length))
    return o[o.length - 1];
}
function ia(o, e, t) {
  return o == null && e == null ? !0 : o != null && e != null && o.length === e.length && o.every((i, r) => t ? t(i, e[r]) : e[r] === i);
}
function VI(o, e) {
  return ia(o, e);
}
function YR(o) {
  return o.sort((e, t) => e - t);
}
function BI(o, e) {
  if (o)
    for (let t = o.length - 2; t >= 0; t--) {
      const i = o[t] === e, r = o[t + 1] === e;
      i && r && o.splice(t + 1, 1);
    }
}
function Ni(o, e) {
  const t = o.indexOf(e);
  t >= 0 && o.splice(t, 1);
}
function CS(o, e) {
  e.forEach((t) => Ni(o, t));
}
function Nh(o, e, t) {
  o.splice(t, 0, e);
}
function HI(o, e, t) {
  if (!(o == null || e == null))
    for (let i = e.length - 1; i >= 0; i--) {
      const r = e[i];
      Nh(o, r, t);
    }
}
function vC(o, e, t) {
  CS(o, e), e.slice().reverse().forEach((i) => Nh(o, i, t));
}
function ln(o, e) {
  return o.indexOf(e) > -1;
}
function XR(o) {
  return [].concat.apply([], o);
}
function mC(o, e) {
  e == null || o == null || e.forEach((t) => o.push(t));
}
function WI(o) {
  return o.map(Lh);
}
function jI(o, e) {
  if (o != null)
    for (let t = o.length - 1; t >= 0; t--)
      e(o[t], t);
}
var UI = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  firstExistingValue: KR,
  existsAndNotEmpty: kI,
  last: at,
  areEqual: ia,
  shallowCompare: VI,
  sortNumerically: YR,
  removeRepeatsFromArray: BI,
  removeFromArray: Ni,
  removeAllFromArray: CS,
  insertIntoArray: Nh,
  insertArrayIntoArray: HI,
  moveInArray: vC,
  includes: ln,
  flatten: XR,
  pushAll: mC,
  toStrings: WI,
  forEachReverse: jI
});
const qR = "__ag_Grid_Stop_Propagation", $I = ["touchstart", "touchend", "touchmove", "touchcancel", "scroll"], my = {};
function Ss(o) {
  o[qR] = !0;
}
function Eo(o) {
  return o[qR] === !0;
}
const SS = (() => {
  const o = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  return (t) => {
    if (typeof my[t] == "boolean")
      return my[t];
    const i = document.createElement(o[t] || "div");
    return t = "on" + t, my[t] = t in i;
  };
})();
function Dg(o, e, t) {
  let i = e;
  for (; i; ) {
    const r = o.getDomData(i, t);
    if (r)
      return r;
    i = i.parentElement;
  }
  return null;
}
function Og(o, e) {
  return !e || !o ? !1 : QR(e).indexOf(o) >= 0;
}
function ZR(o) {
  const e = [];
  let t = o.target;
  for (; t; )
    e.push(t), t = t.parentElement;
  return e;
}
function QR(o) {
  const e = o;
  return e.path ? e.path : e.composedPath ? e.composedPath() : ZR(e);
}
function JR(o, e, t, i) {
  const n = ln($I, t) ? { passive: !0 } : void 0;
  o && o.addEventListener && o.addEventListener(e, t, i, n);
}
var zI = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  stopPropagationForAgGrid: Ss,
  isStopPropagationForAgGrid: Eo,
  isEventSupported: SS,
  getCtrlForEventTarget: Dg,
  isElementInEventPath: Og,
  createEventPath: ZR,
  getEventPath: QR,
  addSafePassiveEventListener: JR
}), Jl = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class H {
  constructor() {
    this.destroyFunctions = [], this.destroyed = !1, this.__v_skip = !0, this.isAlive = () => !this.destroyed;
  }
  // this was a test constructor niall built, when active, it prints after 5 seconds all beans/components that are
  // not destroyed. to use, create a new grid, then api.destroy() before 5 seconds. then anything that gets printed
  // points to a bean or component that was not properly disposed of.
  // constructor() {
  //     setTimeout(()=> {
  //         if (this.isAlive()) {
  //             let prototype: any = Object.getPrototypeOf(this);
  //             const constructor: any = prototype.constructor;
  //             const constructorString = constructor.toString();
  //             const beanName = constructorString.substring(9, constructorString.indexOf("("));
  //             console.log('is alive ' + beanName);
  //         }
  //     }, 5000);
  // }
  // CellComp and GridComp and override this because they get the FrameworkOverrides from the Beans bean
  getFrameworkOverrides() {
    return this.frameworkOverrides;
  }
  getContext() {
    return this.context;
  }
  destroy() {
    this.destroyFunctions.forEach((e) => e()), this.destroyFunctions.length = 0, this.destroyed = !0, this.dispatchEvent({ type: H.EVENT_DESTROYED });
  }
  addEventListener(e, t) {
    this.localEventService || (this.localEventService = new _r()), this.localEventService.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.localEventService && this.localEventService.removeEventListener(e, t);
  }
  dispatchEventAsync(e) {
    window.setTimeout(() => this.dispatchEvent(e), 0);
  }
  dispatchEvent(e) {
    this.localEventService && this.localEventService.dispatchEvent(e);
  }
  addManagedListener(e, t, i) {
    if (this.destroyed)
      return;
    e instanceof HTMLElement ? JR(this.getFrameworkOverrides(), e, t, i) : e.addEventListener(t, i);
    const r = () => (e.removeEventListener(t, i), this.destroyFunctions = this.destroyFunctions.filter((n) => n !== r), null);
    return this.destroyFunctions.push(r), r;
  }
  addManagedPropertyListener(e, t) {
    if (this.destroyed)
      return;
    this.gridOptionsService.addEventListener(e, t);
    const i = () => (this.gridOptionsService.removeEventListener(e, t), this.destroyFunctions = this.destroyFunctions.filter((r) => r !== i), null);
    return this.destroyFunctions.push(i), i;
  }
  addDestroyFunc(e) {
    this.isAlive() ? this.destroyFunctions.push(e) : e();
  }
  createManagedBean(e, t) {
    const i = this.createBean(e, t);
    return this.addDestroyFunc(this.destroyBean.bind(this, e, t)), i;
  }
  createBean(e, t, i) {
    return (t || this.getContext()).createBean(e, i);
  }
  destroyBean(e, t) {
    return (t || this.getContext()).destroyBean(e);
  }
  destroyBeans(e, t) {
    return e && e.forEach((i) => this.destroyBean(i, t)), [];
  }
}
H.EVENT_DESTROYED = "destroyed";
Jl([
  S("frameworkOverrides")
], H.prototype, "frameworkOverrides", void 0);
Jl([
  S("context")
], H.prototype, "context", void 0);
Jl([
  S("eventService")
], H.prototype, "eventService", void 0);
Jl([
  S("gridOptionsService")
], H.prototype, "gridOptionsService", void 0);
Jl([
  S("localeService")
], H.prototype, "localeService", void 0);
Jl([
  S("environment")
], H.prototype, "environment", void 0);
Jl([
  dt
], H.prototype, "destroy", null);
var Iv = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, KI = function(o, e) {
  return function(t, i) {
    e(t, i, o);
  };
};
let Ad = class extends H {
  setBeans(e) {
    this.logger = e.create("ColumnFactory");
  }
  createColumnTree(e, t, i) {
    const r = new RI(), { existingCols: n, existingGroups: s, existingColKeys: a } = this.extractExistingTreeData(i);
    r.addExistingKeys(a);
    const l = this.recursivelyCreateColumns(e, 0, t, n, r, s), c = this.findMaxDept(l, 0);
    this.logger.log("Number of levels for grouped columns is " + c);
    const d = this.balanceColumnTree(l, 0, c, r), u = (h, p) => {
      h instanceof Be && h.setupExpandable(), h.setOriginalParent(p);
    };
    return this.columnUtils.depthFirstOriginalTreeSearch(null, d, u), {
      columnTree: d,
      treeDept: c
    };
  }
  extractExistingTreeData(e) {
    const t = [], i = [], r = [];
    return e && this.columnUtils.depthFirstOriginalTreeSearch(null, e, (n) => {
      if (n instanceof Be) {
        const s = n;
        i.push(s);
      } else {
        const s = n;
        r.push(s.getId()), t.push(s);
      }
    }), { existingCols: t, existingGroups: i, existingColKeys: r };
  }
  createForAutoGroups(e, t) {
    return e.map((i) => this.createAutoGroupTreeItem(t, i));
  }
  createAutoGroupTreeItem(e, t) {
    const i = this.findDepth(e);
    let r = t;
    for (let n = i - 1; n >= 0; n--) {
      const s = new Be(null, `FAKE_PATH_${t.getId()}}_${n}`, !0, n);
      this.createBean(s), s.setChildren([r]), r.setOriginalParent(s), r = s;
    }
    return r;
  }
  findDepth(e) {
    let t = 0, i = e;
    for (; i && i[0] && i[0] instanceof Be; )
      t++, i = i[0].getChildren();
    return t;
  }
  balanceColumnTree(e, t, i, r) {
    const n = [];
    for (let s = 0; s < e.length; s++) {
      const a = e[s];
      if (a instanceof Be) {
        const l = a, c = this.balanceColumnTree(l.getChildren(), t + 1, i, r);
        l.setChildren(c), n.push(l);
      } else {
        let l, c;
        for (let d = i - 1; d >= t; d--) {
          const u = r.getUniqueKey(null, null), h = this.createMergedColGroupDef(null), p = new Be(h, u, !0, t);
          this.createBean(p), c && c.setChildren([p]), c = p, l || (l = c);
        }
        if (l && c)
          if (n.push(l), e.some((u) => u instanceof Be)) {
            c.setChildren([a]);
            continue;
          } else {
            c.setChildren(e);
            break;
          }
        n.push(a);
      }
    }
    return n;
  }
  findMaxDept(e, t) {
    let i = t;
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      if (n instanceof Be) {
        const s = n, a = this.findMaxDept(s.getChildren(), t + 1);
        i < a && (i = a);
      }
    }
    return i;
  }
  recursivelyCreateColumns(e, t, i, r, n, s) {
    return (e || []).map((a) => this.isColumnGroup(a) ? this.createColumnGroup(i, a, t, r, n, s) : this.createColumn(i, a, r, n));
  }
  createColumnGroup(e, t, i, r, n, s) {
    const a = this.createMergedColGroupDef(t), l = n.getUniqueKey(a.groupId || null, null), c = new Be(a, l, !1, i);
    this.createBean(c);
    const d = this.findExistingGroup(t, s);
    d && Ni(s, d), d && d.isExpanded() && c.setExpanded(!0);
    const u = this.recursivelyCreateColumns(a.children, i + 1, e, r, n, s);
    return c.setChildren(u), c;
  }
  createMergedColGroupDef(e) {
    const t = {};
    return Object.assign(t, this.gridOptionsService.get("defaultColGroupDef")), Object.assign(t, e), t;
  }
  createColumn(e, t, i, r) {
    let n = this.findExistingColumn(t, i);
    if (i && n && Ni(i, n), n) {
      const s = this.mergeColDefs(t, n.getColId());
      n.setColDef(s, t), this.applyColumnState(n, s);
    } else {
      const s = r.getUniqueKey(t.colId, t.field), a = this.mergeColDefs(t, s);
      n = new me(a, t, s, e), this.context.createBean(n);
    }
    return this.dataTypeService.addColumnListeners(n), n;
  }
  applyColumnState(e, t) {
    const i = sn(t.flex);
    if (i !== void 0 && e.setFlex(i), e.getFlex() <= 0) {
      const a = sn(t.width);
      if (a != null)
        e.setActualWidth(a);
      else {
        const l = e.getActualWidth();
        e.setActualWidth(l);
      }
    }
    t.sort !== void 0 && (t.sort == "asc" || t.sort == "desc" ? e.setSort(t.sort) : e.setSort(void 0));
    const n = sn(t.sortIndex);
    n !== void 0 && e.setSortIndex(n);
    const s = po(t.hide);
    s !== void 0 && e.setVisible(!s), t.pinned !== void 0 && e.setPinned(t.pinned);
  }
  findExistingColumn(e, t) {
    return (t || []).find((i) => {
      const r = i.getUserProvidedColDef();
      if (!r)
        return !1;
      const n = e.colId != null, s = e.field != null;
      return n ? i.getId() === e.colId : s ? r.field === e.field : r === e;
    });
  }
  findExistingGroup(e, t) {
    return t.find((i) => i.getColGroupDef() && e.groupId != null ? i.getId() === e.groupId : !1);
  }
  mergeColDefs(e, t) {
    const i = {}, r = this.gridOptionsService.get("defaultColDef");
    Tr(i, r, !1, !0);
    const n = this.dataTypeService.updateColDefAndGetColumnType(i, e, t);
    n && this.assignColumnTypes(n, i), Tr(i, e, !1, !0);
    const s = this.gridOptionsService.get("autoGroupColumnDef"), a = this.gridOptionsService.isColumnsSortingCoupledToGroup();
    return e.rowGroup && s && a && Tr(i, { sort: s.sort, initialSort: s.initialSort }, !1, !0), this.dataTypeService.validateColDef(i), i;
  }
  assignColumnTypes(e, t) {
    if (!e.length)
      return;
    const i = Object.assign({}, GI), r = this.gridOptionsService.get("columnTypes") || {};
    Ct(r, (n, s) => {
      n in i ? console.warn(`AG Grid: the column type '${n}' is a default column type and cannot be overridden.`) : i[n] = s;
    }), e.forEach((n) => {
      const s = i[n.trim()];
      s ? Tr(t, s, !1, !0) : console.warn("AG Grid: colDef.type '" + n + "' does not correspond to defined gridOptions.columnTypes");
    });
  }
  // if object has children, we assume it's a group
  isColumnGroup(e) {
    return e.children !== void 0;
  }
};
Iv([
  S("columnUtils")
], Ad.prototype, "columnUtils", void 0);
Iv([
  S("dataTypeService")
], Ad.prototype, "dataTypeService", void 0);
Iv([
  KI(0, qi("loggerFactory"))
], Ad.prototype, "setBeans", null);
Ad = Iv([
  q("columnFactory")
], Ad);
var YI = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class pt {
  constructor(e, t, i, r) {
    this.displayedChildren = [], this.localEventService = new _r(), this.groupId = t, this.partId = i, this.providedColumnGroup = e, this.pinned = r;
  }
  // this is static, a it is used outside of this class
  static createUniqueId(e, t) {
    return e + "_" + t;
  }
  // as the user is adding and removing columns, the groups are recalculated.
  // this reset clears out all children, ready for children to be added again
  reset() {
    this.parent = null, this.children = null, this.displayedChildren = null;
  }
  getParent() {
    return this.parent;
  }
  setParent(e) {
    this.parent = e;
  }
  getUniqueId() {
    return pt.createUniqueId(this.groupId, this.partId);
  }
  isEmptyGroup() {
    return this.displayedChildren.length === 0;
  }
  isMoving() {
    const e = this.getProvidedColumnGroup().getLeafColumns();
    return !e || e.length === 0 ? !1 : e.every((t) => t.isMoving());
  }
  checkLeft() {
    if (this.displayedChildren.forEach((e) => {
      e instanceof pt && e.checkLeft();
    }), this.displayedChildren.length > 0)
      if (this.gridOptionsService.is("enableRtl")) {
        const t = at(this.displayedChildren).getLeft();
        this.setLeft(t);
      } else {
        const e = this.displayedChildren[0].getLeft();
        this.setLeft(e);
      }
    else
      this.setLeft(null);
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  setLeft(e) {
    this.oldLeft = e, this.left !== e && (this.left = e, this.localEventService.dispatchEvent(this.createAgEvent(pt.EVENT_LEFT_CHANGED)));
  }
  getPinned() {
    return this.pinned;
  }
  createAgEvent(e) {
    return { type: e };
  }
  addEventListener(e, t) {
    this.localEventService.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.localEventService.removeEventListener(e, t);
  }
  getGroupId() {
    return this.groupId;
  }
  getPartId() {
    return this.partId;
  }
  isChildInThisGroupDeepSearch(e) {
    let t = !1;
    return this.children.forEach((i) => {
      e === i && (t = !0), i instanceof pt && i.isChildInThisGroupDeepSearch(e) && (t = !0);
    }), t;
  }
  getActualWidth() {
    let e = 0;
    return this.displayedChildren && this.displayedChildren.forEach((t) => {
      e += t.getActualWidth();
    }), e;
  }
  isResizable() {
    if (!this.displayedChildren)
      return !1;
    let e = !1;
    return this.displayedChildren.forEach((t) => {
      t.isResizable() && (e = !0);
    }), e;
  }
  getMinWidth() {
    let e = 0;
    return this.displayedChildren.forEach((t) => {
      e += t.getMinWidth() || 0;
    }), e;
  }
  addChild(e) {
    this.children || (this.children = []), this.children.push(e);
  }
  getDisplayedChildren() {
    return this.displayedChildren;
  }
  getLeafColumns() {
    const e = [];
    return this.addLeafColumns(e), e;
  }
  getDisplayedLeafColumns() {
    const e = [];
    return this.addDisplayedLeafColumns(e), e;
  }
  getDefinition() {
    return this.providedColumnGroup.getColGroupDef();
  }
  getColGroupDef() {
    return this.providedColumnGroup.getColGroupDef();
  }
  isPadding() {
    return this.providedColumnGroup.isPadding();
  }
  isExpandable() {
    return this.providedColumnGroup.isExpandable();
  }
  isExpanded() {
    return this.providedColumnGroup.isExpanded();
  }
  setExpanded(e) {
    this.providedColumnGroup.setExpanded(e);
  }
  addDisplayedLeafColumns(e) {
    this.displayedChildren.forEach((t) => {
      t instanceof me ? e.push(t) : t instanceof pt && t.addDisplayedLeafColumns(e);
    });
  }
  addLeafColumns(e) {
    this.children.forEach((t) => {
      t instanceof me ? e.push(t) : t instanceof pt && t.addLeafColumns(e);
    });
  }
  getChildren() {
    return this.children;
  }
  getColumnGroupShow() {
    return this.providedColumnGroup.getColumnGroupShow();
  }
  getProvidedColumnGroup() {
    return this.providedColumnGroup;
  }
  getPaddingLevel() {
    const e = this.getParent();
    return !this.isPadding() || !e || !e.isPadding() ? 0 : 1 + e.getPaddingLevel();
  }
  calculateDisplayedColumns() {
    this.displayedChildren = [];
    let e = this;
    for (; e != null && e.isPadding(); )
      e = e.getParent();
    if (!(e ? e.providedColumnGroup.isExpandable() : !1)) {
      this.displayedChildren = this.children, this.localEventService.dispatchEvent(this.createAgEvent(pt.EVENT_DISPLAYED_CHILDREN_CHANGED));
      return;
    }
    this.children.forEach((i) => {
      if (i instanceof pt && (!i.displayedChildren || !i.displayedChildren.length))
        return;
      switch (i.getColumnGroupShow()) {
        case "open":
          e.providedColumnGroup.isExpanded() && this.displayedChildren.push(i);
          break;
        case "closed":
          e.providedColumnGroup.isExpanded() || this.displayedChildren.push(i);
          break;
        default:
          this.displayedChildren.push(i);
          break;
      }
    }), this.localEventService.dispatchEvent(this.createAgEvent(pt.EVENT_DISPLAYED_CHILDREN_CHANGED));
  }
}
pt.EVENT_LEFT_CHANGED = "leftChanged";
pt.EVENT_DISPLAYED_CHILDREN_CHANGED = "displayedChildrenChanged";
YI([
  S("gridOptionsService")
], pt.prototype, "gridOptionsService", void 0);
class w {
}
w.EVENT_COLUMN_EVERYTHING_CHANGED = "columnEverythingChanged";
w.EVENT_NEW_COLUMNS_LOADED = "newColumnsLoaded";
w.EVENT_COLUMN_PIVOT_MODE_CHANGED = "columnPivotModeChanged";
w.EVENT_COLUMN_ROW_GROUP_CHANGED = "columnRowGroupChanged";
w.EVENT_EXPAND_COLLAPSE_ALL = "expandOrCollapseAll";
w.EVENT_COLUMN_PIVOT_CHANGED = "columnPivotChanged";
w.EVENT_GRID_COLUMNS_CHANGED = "gridColumnsChanged";
w.EVENT_COLUMN_VALUE_CHANGED = "columnValueChanged";
w.EVENT_COLUMN_MOVED = "columnMoved";
w.EVENT_COLUMN_VISIBLE = "columnVisible";
w.EVENT_COLUMN_PINNED = "columnPinned";
w.EVENT_COLUMN_GROUP_OPENED = "columnGroupOpened";
w.EVENT_COLUMN_RESIZED = "columnResized";
w.EVENT_DISPLAYED_COLUMNS_CHANGED = "displayedColumnsChanged";
w.EVENT_VIRTUAL_COLUMNS_CHANGED = "virtualColumnsChanged";
w.EVENT_ASYNC_TRANSACTIONS_FLUSHED = "asyncTransactionsFlushed";
w.EVENT_ROW_GROUP_OPENED = "rowGroupOpened";
w.EVENT_ROW_DATA_CHANGED = "rowDataChanged";
w.EVENT_ROW_DATA_UPDATED = "rowDataUpdated";
w.EVENT_PINNED_ROW_DATA_CHANGED = "pinnedRowDataChanged";
w.EVENT_RANGE_SELECTION_CHANGED = "rangeSelectionChanged";
w.EVENT_CHART_CREATED = "chartCreated";
w.EVENT_CHART_RANGE_SELECTION_CHANGED = "chartRangeSelectionChanged";
w.EVENT_CHART_OPTIONS_CHANGED = "chartOptionsChanged";
w.EVENT_CHART_DESTROYED = "chartDestroyed";
w.EVENT_TOOL_PANEL_VISIBLE_CHANGED = "toolPanelVisibleChanged";
w.EVENT_TOOL_PANEL_SIZE_CHANGED = "toolPanelSizeChanged";
w.EVENT_COLUMN_PANEL_ITEM_DRAG_START = "columnPanelItemDragStart";
w.EVENT_COLUMN_PANEL_ITEM_DRAG_END = "columnPanelItemDragEnd";
w.EVENT_MODEL_UPDATED = "modelUpdated";
w.EVENT_CUT_START = "cutStart";
w.EVENT_CUT_END = "cutEnd";
w.EVENT_PASTE_START = "pasteStart";
w.EVENT_PASTE_END = "pasteEnd";
w.EVENT_FILL_START = "fillStart";
w.EVENT_FILL_END = "fillEnd";
w.EVENT_RANGE_DELETE_START = "rangeDeleteStart";
w.EVENT_RANGE_DELETE_END = "rangeDeleteEnd";
w.EVENT_UNDO_STARTED = "undoStarted";
w.EVENT_UNDO_ENDED = "undoEnded";
w.EVENT_REDO_STARTED = "redoStarted";
w.EVENT_REDO_ENDED = "redoEnded";
w.EVENT_KEY_SHORTCUT_CHANGED_CELL_START = "keyShortcutChangedCellStart";
w.EVENT_KEY_SHORTCUT_CHANGED_CELL_END = "keyShortcutChangedCellEnd";
w.EVENT_CELL_CLICKED = "cellClicked";
w.EVENT_CELL_DOUBLE_CLICKED = "cellDoubleClicked";
w.EVENT_CELL_MOUSE_DOWN = "cellMouseDown";
w.EVENT_CELL_CONTEXT_MENU = "cellContextMenu";
w.EVENT_CELL_VALUE_CHANGED = "cellValueChanged";
w.EVENT_CELL_EDIT_REQUEST = "cellEditRequest";
w.EVENT_ROW_VALUE_CHANGED = "rowValueChanged";
w.EVENT_CELL_FOCUSED = "cellFocused";
w.EVENT_CELL_FOCUS_CLEARED = "cellFocusCleared";
w.EVENT_FULL_WIDTH_ROW_FOCUSED = "fullWidthRowFocused";
w.EVENT_ROW_SELECTED = "rowSelected";
w.EVENT_SELECTION_CHANGED = "selectionChanged";
w.EVENT_CELL_KEY_DOWN = "cellKeyDown";
w.EVENT_CELL_MOUSE_OVER = "cellMouseOver";
w.EVENT_CELL_MOUSE_OUT = "cellMouseOut";
w.EVENT_FILTER_CHANGED = "filterChanged";
w.EVENT_FILTER_MODIFIED = "filterModified";
w.EVENT_FILTER_OPENED = "filterOpened";
w.EVENT_SORT_CHANGED = "sortChanged";
w.EVENT_VIRTUAL_ROW_REMOVED = "virtualRowRemoved";
w.EVENT_ROW_CLICKED = "rowClicked";
w.EVENT_ROW_DOUBLE_CLICKED = "rowDoubleClicked";
w.EVENT_GRID_READY = "gridReady";
w.EVENT_GRID_SIZE_CHANGED = "gridSizeChanged";
w.EVENT_VIEWPORT_CHANGED = "viewportChanged";
w.EVENT_SCROLLBAR_WIDTH_CHANGED = "scrollbarWidthChanged";
w.EVENT_FIRST_DATA_RENDERED = "firstDataRendered";
w.EVENT_DRAG_STARTED = "dragStarted";
w.EVENT_DRAG_STOPPED = "dragStopped";
w.EVENT_CHECKBOX_CHANGED = "checkboxChanged";
w.EVENT_ROW_EDITING_STARTED = "rowEditingStarted";
w.EVENT_ROW_EDITING_STOPPED = "rowEditingStopped";
w.EVENT_CELL_EDITING_STARTED = "cellEditingStarted";
w.EVENT_CELL_EDITING_STOPPED = "cellEditingStopped";
w.EVENT_BODY_SCROLL = "bodyScroll";
w.EVENT_BODY_SCROLL_END = "bodyScrollEnd";
w.EVENT_HEIGHT_SCALE_CHANGED = "heightScaleChanged";
w.EVENT_PAGINATION_CHANGED = "paginationChanged";
w.EVENT_COMPONENT_STATE_CHANGED = "componentStateChanged";
w.EVENT_STORE_REFRESHED = "storeRefreshed";
w.EVENT_BODY_HEIGHT_CHANGED = "bodyHeightChanged";
w.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED = "displayedColumnsWidthChanged";
w.EVENT_SCROLL_VISIBILITY_CHANGED = "scrollVisibilityChanged";
w.EVENT_COLUMN_HOVER_CHANGED = "columnHoverChanged";
w.EVENT_FLASH_CELLS = "flashCells";
w.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED = "paginationPixelOffsetChanged";
w.EVENT_DISPLAYED_ROWS_CHANGED = "displayedRowsChanged";
w.EVENT_LEFT_PINNED_WIDTH_CHANGED = "leftPinnedWidthChanged";
w.EVENT_RIGHT_PINNED_WIDTH_CHANGED = "rightPinnedWidthChanged";
w.EVENT_ROW_CONTAINER_HEIGHT_CHANGED = "rowContainerHeightChanged";
w.EVENT_HEADER_HEIGHT_CHANGED = "headerHeightChanged";
w.EVENT_COLUMN_HEADER_HEIGHT_CHANGED = "columnHeaderHeightChanged";
w.EVENT_ROW_DRAG_ENTER = "rowDragEnter";
w.EVENT_ROW_DRAG_MOVE = "rowDragMove";
w.EVENT_ROW_DRAG_LEAVE = "rowDragLeave";
w.EVENT_ROW_DRAG_END = "rowDragEnd";
w.EVENT_GRID_STYLES_CHANGED = "gridStylesChanged";
w.EVENT_POPUP_TO_FRONT = "popupToFront";
w.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST = "columnRowGroupChangeRequest";
w.EVENT_COLUMN_PIVOT_CHANGE_REQUEST = "columnPivotChangeRequest";
w.EVENT_COLUMN_VALUE_CHANGE_REQUEST = "columnValueChangeRequest";
w.EVENT_COLUMN_AGG_FUNC_CHANGE_REQUEST = "columnAggFuncChangeRequest";
w.EVENT_KEYBOARD_FOCUS = "keyboardFocus";
w.EVENT_MOUSE_FOCUS = "mouseFocus";
w.EVENT_STORE_UPDATED = "storeUpdated";
w.EVENT_FILTER_DESTROYED = "filterDestroyed";
w.EVENT_ROW_DATA_UPDATE_STARTED = "rowDataUpdateStarted";
class eT {
  constructor() {
    this.existingIds = {};
  }
  getInstanceIdForKey(e) {
    const t = this.existingIds[e];
    let i;
    return typeof t != "number" ? i = 0 : i = t + 1, this.existingIds[e] = i, i;
  }
}
var bS = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const bs = "ag-Grid-AutoColumn";
let Gh = class extends H {
  createAutoGroupColumns(e, t) {
    const i = [], r = this.gridOptionsService.isTreeData();
    let n = this.gridOptionsService.isGroupMultiAutoColumn();
    return r && n && (console.warn('AG Grid: you cannot mix groupDisplayType = "multipleColumns" with treeData, only one column can be used to display groups when doing tree data'), n = !1), n ? t.forEach((s, a) => {
      i.push(this.createOneAutoGroupColumn(e, s, a));
    }) : i.push(this.createOneAutoGroupColumn(e)), i;
  }
  // rowGroupCol and index are missing if groupDisplayType != "multipleColumns"
  createOneAutoGroupColumn(e, t, i) {
    let r = this.generateDefaultColDef(t), n;
    t ? n = `${bs}-${t.getId()}` : n = bs;
    const s = this.gridOptionsService.get("autoGroupColumnDef");
    Tr(r, s), r = this.columnFactory.mergeColDefs(r, n), r.colId = n, this.gridOptionsService.isTreeData() || Se(r.field) && Se(r.valueGetter) && Se(r.filterValueGetter) && r.filter !== "agGroupColumnFilter" && (r.filter = !1), i && i > 0 && (r.headerCheckboxSelection = !1);
    const a = e.find((d) => d.getId() == n), l = this.gridOptionsService.isColumnsSortingCoupledToGroup();
    if (a)
      return l && (r.sort = void 0, r.sortIndex = void 0), a.setColDef(r, null), this.columnFactory.applyColumnState(a, r), a;
    l && (r.sort || r.initialSort || "sortIndex" in r) && !r.field && (r.sort = null, r.sortIndex = null, r.initialSort = null);
    const c = new me(r, null, n, !0);
    return this.context.createBean(c), c;
  }
  generateDefaultColDef(e) {
    const t = this.gridOptionsService.get("autoGroupColumnDef"), r = {
      headerName: this.localeService.getLocaleTextFunc()("group", "Group")
    };
    if (t && (t.cellRenderer || t.cellRendererSelector) || (r.cellRenderer = "agGroupCellRenderer"), e) {
      const s = e.getColDef();
      Object.assign(r, {
        // cellRendererParams.groupKey: colDefToCopy.field;
        headerName: this.columnModel.getDisplayNameForColumn(e, "header"),
        headerValueGetter: s.headerValueGetter
      }), s.cellRenderer && Object.assign(r, {
        cellRendererParams: {
          innerRenderer: s.cellRenderer,
          innerRendererParams: s.cellRendererParams
        }
      }), r.showRowGroup = e.getColId();
    } else
      r.showRowGroup = !0;
    return r;
  }
};
bS([
  S("columnModel")
], Gh.prototype, "columnModel", void 0);
bS([
  S("columnFactory")
], Gh.prototype, "columnFactory", void 0);
Gh = bS([
  q("autoGroupColService")
], Gh);
const XI = /[&<>"']/g, qI = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function ZI(o) {
  const e = String.fromCharCode;
  function t(u) {
    const h = [];
    if (!u)
      return [];
    const p = u.length;
    let f = 0, g, v;
    for (; f < p; )
      g = u.charCodeAt(f++), g >= 55296 && g <= 56319 && f < p ? (v = u.charCodeAt(f++), (v & 64512) == 56320 ? h.push(((g & 1023) << 10) + (v & 1023) + 65536) : (h.push(g), f--)) : h.push(g);
    return h;
  }
  function i(u) {
    if (u >= 55296 && u <= 57343)
      throw Error("Lone surrogate U+" + u.toString(16).toUpperCase() + " is not a scalar value");
  }
  function r(u, h) {
    return e(u >> h & 63 | 128);
  }
  function n(u) {
    if (u >= 0 && u <= 31 && u !== 10)
      return `_x${u.toString(16).toUpperCase().padStart(4, "0")}_`;
    if (!(u & 4294967168))
      return e(u);
    let h = "";
    return u & 4294965248 ? u & 4294901760 ? u & 4292870144 || (h = e(u >> 18 & 7 | 240), h += r(u, 12), h += r(u, 6)) : (i(u), h = e(u >> 12 & 15 | 224), h += r(u, 6)) : h = e(u >> 6 & 31 | 192), h += e(u & 63 | 128), h;
  }
  const s = t(o), a = s.length;
  let l = -1, c, d = "";
  for (; ++l < a; )
    c = s[l], d += n(c);
  return d;
}
function tT(o) {
  return o[0].toUpperCase() + o.substr(1).toLowerCase();
}
function xo(o, e) {
  if (o == null)
    return null;
  const t = o.toString().toString();
  return e ? t : t.replace(XI, (i) => qI[i]);
}
function iT(o) {
  if (!o || o == null)
    return null;
  const e = /([a-z])([A-Z])/g, t = /([A-Z]+)([A-Z])([a-z])/g;
  return o.replace(e, "$1 $2").replace(t, "$1 $2$3").replace(/\./g, " ").split(" ").map((r) => r.substring(0, 1).toUpperCase() + (r.length > 1 ? r.substring(1, r.length) : "")).join(" ");
}
function rT(o) {
  return o.replace(/[A-Z]/g, (e) => `-${e.toLocaleLowerCase()}`);
}
var QI = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  utf8_encode: ZI,
  capitalise: tT,
  escapeString: xo,
  camelCaseToHumanText: iT,
  camelCaseToHyphenated: rT
});
function us(o) {
  const e = /* @__PURE__ */ new Map();
  return o.forEach((t) => e.set(t[0], t[1])), e;
}
function JI(o, e) {
  const t = /* @__PURE__ */ new Map();
  return o.forEach((i) => t.set(e(i), i)), t;
}
function eF(o) {
  const e = [];
  return o.forEach((t, i) => e.push(i)), e;
}
var tF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  convertToMap: us,
  mapById: JI,
  keys: eF
});
class Pg {
}
Pg.ColDefPropertyMap = {
  headerName: void 0,
  columnGroupShow: void 0,
  headerClass: void 0,
  toolPanelClass: void 0,
  headerValueGetter: void 0,
  pivotKeys: void 0,
  groupId: void 0,
  colId: void 0,
  sort: void 0,
  initialSort: void 0,
  field: void 0,
  type: void 0,
  cellDataType: void 0,
  tooltipComponent: void 0,
  tooltipField: void 0,
  headerTooltip: void 0,
  cellClass: void 0,
  showRowGroup: void 0,
  filter: void 0,
  initialAggFunc: void 0,
  defaultAggFunc: void 0,
  aggFunc: void 0,
  pinned: void 0,
  initialPinned: void 0,
  chartDataType: void 0,
  cellEditorPopupPosition: void 0,
  headerGroupComponent: void 0,
  headerGroupComponentParams: void 0,
  cellStyle: void 0,
  cellRenderer: void 0,
  cellRendererParams: void 0,
  cellEditor: void 0,
  cellEditorParams: void 0,
  filterParams: void 0,
  pivotValueColumn: void 0,
  headerComponent: void 0,
  headerComponentParams: void 0,
  floatingFilterComponent: void 0,
  floatingFilterComponentParams: void 0,
  tooltipComponentParams: void 0,
  refData: void 0,
  columnsMenuParams: void 0,
  children: void 0,
  sortingOrder: void 0,
  allowedAggFuncs: void 0,
  menuTabs: void 0,
  pivotTotalColumnIds: void 0,
  cellClassRules: void 0,
  icons: void 0,
  sortIndex: void 0,
  initialSortIndex: void 0,
  flex: void 0,
  initialFlex: void 0,
  width: void 0,
  initialWidth: void 0,
  minWidth: void 0,
  maxWidth: void 0,
  rowGroupIndex: void 0,
  initialRowGroupIndex: void 0,
  pivotIndex: void 0,
  initialPivotIndex: void 0,
  suppressCellFlash: void 0,
  suppressColumnsToolPanel: void 0,
  suppressFiltersToolPanel: void 0,
  openByDefault: void 0,
  marryChildren: void 0,
  suppressStickyLabel: void 0,
  hide: void 0,
  initialHide: void 0,
  rowGroup: void 0,
  initialRowGroup: void 0,
  pivot: void 0,
  initialPivot: void 0,
  checkboxSelection: void 0,
  showDisabledCheckboxes: void 0,
  headerCheckboxSelection: void 0,
  headerCheckboxSelectionFilteredOnly: void 0,
  headerCheckboxSelectionCurrentPageOnly: void 0,
  suppressMenu: void 0,
  suppressMovable: void 0,
  lockPosition: void 0,
  lockVisible: void 0,
  lockPinned: void 0,
  unSortIcon: void 0,
  suppressSizeToFit: void 0,
  suppressAutoSize: void 0,
  enableRowGroup: void 0,
  enablePivot: void 0,
  enableValue: void 0,
  editable: void 0,
  suppressPaste: void 0,
  suppressNavigable: void 0,
  enableCellChangeFlash: void 0,
  rowDrag: void 0,
  dndSource: void 0,
  autoHeight: void 0,
  wrapText: void 0,
  sortable: void 0,
  resizable: void 0,
  singleClickEdit: void 0,
  floatingFilter: void 0,
  cellEditorPopup: void 0,
  suppressFillHandle: void 0,
  wrapHeaderText: void 0,
  autoHeaderHeight: void 0,
  dndSourceOnRowDrag: void 0,
  valueGetter: void 0,
  valueSetter: void 0,
  filterValueGetter: void 0,
  keyCreator: void 0,
  valueFormatter: void 0,
  valueParser: void 0,
  comparator: void 0,
  equals: void 0,
  pivotComparator: void 0,
  suppressKeyboardEvent: void 0,
  suppressHeaderKeyboardEvent: void 0,
  colSpan: void 0,
  rowSpan: void 0,
  getQuickFilterText: void 0,
  onCellValueChanged: void 0,
  onCellClicked: void 0,
  onCellDoubleClicked: void 0,
  onCellContextMenu: void 0,
  rowDragText: void 0,
  tooltipValueGetter: void 0,
  cellRendererSelector: void 0,
  cellEditorSelector: void 0,
  suppressSpanHeaderHeight: void 0,
  useValueFormatterForExport: void 0,
  useValueParserForImport: void 0
};
Pg.ALL_PROPERTIES = Object.keys(Pg.ColDefPropertyMap);
class vt {
}
vt.STRING_PROPERTIES = [
  "rowSelection",
  "overlayLoadingTemplate",
  "overlayNoRowsTemplate",
  "gridId",
  "quickFilterText",
  "rowModelType",
  "editType",
  "domLayout",
  "clipboardDelimiter",
  "rowGroupPanelShow",
  "multiSortKey",
  "pivotColumnGroupTotals",
  "pivotRowTotals",
  "pivotPanelShow",
  "fillHandleDirection",
  "serverSideStoreType",
  "groupDisplayType",
  "treeDataDisplayType",
  "colResizeDefault"
];
vt.OBJECT_PROPERTIES = [
  "components",
  "rowStyle",
  "context",
  "autoGroupColumnDef",
  "localeText",
  "icons",
  "datasource",
  "serverSideDatasource",
  "viewportDatasource",
  "groupRowRendererParams",
  "aggFuncs",
  "fullWidthCellRendererParams",
  "defaultColGroupDef",
  "defaultColDef",
  "defaultCsvExportParams",
  "defaultExcelExportParams",
  "columnTypes",
  "rowClassRules",
  "detailCellRendererParams",
  "loadingCellRendererParams",
  "loadingOverlayComponentParams",
  "noRowsOverlayComponentParams",
  "popupParent",
  "statusBar",
  "sideBar",
  "chartThemeOverrides",
  "customChartThemes",
  "chartToolPanelsDef",
  "dataTypeDefinitions"
];
vt.ARRAY_PROPERTIES = [
  "sortingOrder",
  "alignedGrids",
  "rowData",
  "columnDefs",
  "excelStyles",
  "pinnedTopRowData",
  "pinnedBottomRowData",
  "chartThemes",
  "rowClass"
];
vt.NUMBER_PROPERTIES = [
  "rowHeight",
  "detailRowHeight",
  "rowBuffer",
  "headerHeight",
  "groupHeaderHeight",
  "floatingFiltersHeight",
  "pivotHeaderHeight",
  "pivotGroupHeaderHeight",
  "groupDefaultExpanded",
  "viewportRowModelPageSize",
  "viewportRowModelBufferSize",
  "autoSizePadding",
  "maxBlocksInCache",
  "maxConcurrentDatasourceRequests",
  "tooltipShowDelay",
  "tooltipHideDelay",
  "cacheOverflowSize",
  "paginationPageSize",
  "cacheBlockSize",
  "infiniteInitialRowCount",
  "serverSideInitialRowCount",
  "scrollbarWidth",
  "asyncTransactionWaitMillis",
  "blockLoadDebounceMillis",
  "keepDetailRowsCount",
  "undoRedoCellEditingLimit",
  "cellFlashDelay",
  "cellFadeDelay",
  "tabIndex"
];
vt.BOOLEAN_PROPERTIES = [
  "suppressMakeColumnVisibleAfterUnGroup",
  "suppressRowClickSelection",
  "suppressCellFocus",
  "suppressHorizontalScroll",
  "alwaysShowHorizontalScroll",
  "alwaysShowVerticalScroll",
  "debug",
  "enableBrowserTooltips",
  "enableCellExpressions",
  "groupSelectsChildren",
  "groupIncludeFooter",
  "groupIncludeTotalFooter",
  "groupSuppressBlankHeader",
  "suppressMenuHide",
  "suppressRowDeselection",
  "unSortIcon",
  "suppressMultiSort",
  "alwaysMultiSort",
  "singleClickEdit",
  "suppressLoadingOverlay",
  "suppressNoRowsOverlay",
  "suppressAutoSize",
  "skipHeaderOnAutoSize",
  "suppressParentsInRowNodes",
  "suppressColumnMoveAnimation",
  "suppressMovableColumns",
  "suppressFieldDotNotation",
  "enableRangeSelection",
  "enableRangeHandle",
  "enableFillHandle",
  "suppressClearOnFillReduction",
  "deltaSort",
  "suppressTouch",
  "suppressAsyncEvents",
  "allowContextMenuWithControlKey",
  "suppressContextMenu",
  "rememberGroupStateWhenNewData",
  "enableCellChangeFlash",
  "suppressDragLeaveHidesColumns",
  "suppressRowGroupHidesColumns",
  "suppressMiddleClickScrolls",
  "suppressPreventDefaultOnMouseWheel",
  "suppressCopyRowsToClipboard",
  "copyHeadersToClipboard",
  "copyGroupHeadersToClipboard",
  "pivotMode",
  "suppressAggFuncInHeader",
  "suppressColumnVirtualisation",
  "alwaysAggregateAtRootLevel",
  "suppressAggAtRootLevel",
  "suppressFocusAfterRefresh",
  "functionsPassive",
  "functionsReadOnly",
  "animateRows",
  "groupSelectsFiltered",
  "groupRemoveSingleChildren",
  "groupRemoveLowestSingleChildren",
  "enableRtl",
  "suppressClickEdit",
  "rowDragEntireRow",
  "rowDragManaged",
  "suppressRowDrag",
  "suppressMoveWhenRowDragging",
  "rowDragMultiRow",
  "enableGroupEdit",
  "embedFullWidthRows",
  "suppressPaginationPanel",
  "groupHideOpenParents",
  "groupAllowUnbalanced",
  "pagination",
  "paginationAutoPageSize",
  "suppressScrollOnNewData",
  "suppressScrollWhenPopupsAreOpen",
  "purgeClosedRowNodes",
  "cacheQuickFilter",
  "includeHiddenColumnsInQuickFilter",
  "excludeHiddenColumnsFromQuickFilter",
  "ensureDomOrder",
  "accentedSort",
  "suppressChangeDetection",
  "valueCache",
  "valueCacheNeverExpires",
  "aggregateOnlyChangedColumns",
  "suppressAnimationFrame",
  "suppressExcelExport",
  "suppressCsvExport",
  "treeData",
  "masterDetail",
  "suppressMultiRangeSelection",
  "enterMovesDown",
  "enterMovesDownAfterEdit",
  "enterNavigatesVerticallyAfterEdit",
  "enterNavigatesVertically",
  "suppressPropertyNamesCheck",
  "rowMultiSelectWithClick",
  "suppressRowHoverHighlight",
  "suppressRowTransform",
  "suppressClipboardPaste",
  "suppressLastEmptyLineOnPaste",
  "enableCharts",
  "enableChartToolPanelsButton",
  "suppressChartToolPanelsButton",
  "suppressMaintainUnsortedOrder",
  "enableCellTextSelection",
  "suppressBrowserResizeObserver",
  "suppressMaxRenderedRowRestriction",
  "excludeChildrenWhenTreeDataFiltering",
  "tooltipMouseTrack",
  "keepDetailRows",
  "paginateChildRows",
  "preventDefaultOnContextMenu",
  "undoRedoCellEditing",
  "allowDragFromColumnsToolPanel",
  "pivotSuppressAutoColumn",
  "suppressExpandablePivotGroups",
  "debounceVerticalScrollbar",
  "detailRowAutoHeight",
  "serverSideFilteringAlwaysResets",
  "serverSideFilterAllLevels",
  "serverSideSortingAlwaysResets",
  "serverSideSortAllLevels",
  "serverSideOnlyRefreshFilteredGroups",
  "serverSideSortOnServer",
  "serverSideFilterOnServer",
  "suppressAggFilteredOnly",
  "showOpenedGroup",
  "suppressClipboardApi",
  "suppressModelUpdateAfterUpdateTransaction",
  "stopEditingWhenCellsLoseFocus",
  "maintainColumnOrder",
  "groupMaintainOrder",
  "columnHoverHighlight",
  "suppressReactUi",
  "readOnlyEdit",
  "suppressRowVirtualisation",
  "enableCellEditingOnBackspace",
  "resetRowDataOnUpdate",
  "removePivotHeaderRowWhenSingleValueColumn",
  "suppressCopySingleCellRanges",
  "suppressGroupRowsSticky",
  "suppressServerSideInfiniteScroll",
  "rowGroupPanelSuppressSort",
  "allowShowChangeAfterFilter",
  "suppressCutToClipboard"
];
vt.FUNCTIONAL_PROPERTIES = [
  "doesExternalFilterPass",
  "processSecondaryColDef",
  "processSecondaryColGroupDef",
  "processPivotResultColDef",
  "processPivotResultColGroupDef",
  "getBusinessKeyForNode",
  "isRowSelectable",
  "rowDragText",
  "groupRowRenderer",
  "fullWidthCellRenderer",
  "loadingCellRenderer",
  "loadingOverlayComponent",
  "noRowsOverlayComponent",
  "detailCellRenderer"
];
vt.CALLBACK_PROPERTIES = [
  "getLocaleText",
  "isExternalFilterPresent",
  "getRowHeight",
  "getRowClass",
  "getRowStyle",
  "getContextMenuItems",
  "getMainMenuItems",
  "processRowPostCreate",
  "processCellForClipboard",
  "getGroupRowAgg",
  "isFullWidthRow",
  "sendToClipboard",
  "navigateToNextHeader",
  "tabToNextHeader",
  "navigateToNextCell",
  "tabToNextCell",
  "processCellFromClipboard",
  "getDocument",
  "postProcessPopup",
  "getChildCount",
  "getDataPath",
  "isRowMaster",
  "postSortRows",
  "processHeaderForClipboard",
  "processGroupHeaderForClipboard",
  "paginationNumberFormatter",
  "processDataFromClipboard",
  "getServerSideGroupKey",
  "isServerSideGroup",
  "createChartContainer",
  "getChartToolbarItems",
  "fillOperation",
  "isApplyServerSideTransaction",
  "getServerSideStoreParams",
  "getServerSideGroupLevelParams",
  "isServerSideGroupOpenByDefault",
  "isGroupOpenByDefault",
  "initialGroupOrderComparator",
  "loadingCellRendererSelector",
  "getRowId",
  "groupAggFiltering"
];
vt.FUNCTION_PROPERTIES = [
  ...vt.FUNCTIONAL_PROPERTIES,
  ...vt.CALLBACK_PROPERTIES
];
vt.ALL_PROPERTIES = [
  ...vt.ARRAY_PROPERTIES,
  ...vt.OBJECT_PROPERTIES,
  ...vt.STRING_PROPERTIES,
  ...vt.NUMBER_PROPERTIES,
  ...vt.FUNCTION_PROPERTIES,
  ...vt.BOOLEAN_PROPERTIES
];
class ke {
  static getCallbackForEvent(e) {
    return !e || e.length < 2 ? e : "on" + e[0].toUpperCase() + e.substr(1);
  }
  static getCoercionLookup() {
    let e = {};
    return [
      ...ke.ARRAY_PROPERTIES,
      ...ke.OBJECT_PROPERTIES,
      ...ke.STRING_PROPERTIES,
      ...ke.FUNCTION_PROPERTIES,
      ...ke.EVENT_CALLBACKS
    ].forEach((t) => e[t] = "none"), ke.BOOLEAN_PROPERTIES.forEach((t) => e[t] = "boolean"), ke.NUMBER_PROPERTIES.forEach((t) => e[t] = "number"), e;
  }
  static getValue(e, t) {
    const i = ke.coercionLookup[e];
    if (i) {
      let r = t;
      switch (i) {
        case "number": {
          r = ke.toNumber(t);
          break;
        }
        case "boolean": {
          r = ke.toBoolean(t);
          break;
        }
        case "none": {
          e === "groupAggFiltering" && typeof t != "function" && (r = ke.toBoolean(t));
          break;
        }
      }
      return r;
    }
  }
  static getGridOptionKeys(e, t) {
    return Object.keys(t ? ke.coercionLookup : e);
  }
  static copyAttributesToGridOptions(e, t, i = !1) {
    typeof e != "object" && (e = {});
    const r = e;
    return ke.getGridOptionKeys(t, i).forEach((s) => {
      const a = t[s];
      if (typeof a != "undefined") {
        const l = ke.getValue(s, a);
        l !== void 0 && (r[s] = l);
      }
    }), e;
  }
  static processOnChange(e, t) {
    if (!e || Object.keys(e).length === 0)
      return;
    const i = Object.assign({}, e);
    i.columnTypes && (t.setColumnTypes(i.columnTypes.currentValue, "gridOptionsChanged"), delete i.columnTypes), i.autoGroupColumnDef && (t.setAutoGroupColumnDef(i.autoGroupColumnDef.currentValue, "gridOptionsChanged"), delete i.autoGroupColumnDef), i.defaultColDef && (t.setDefaultColDef(i.defaultColDef.currentValue, "gridOptionsChanged"), delete i.defaultColDef), i.columnDefs && (t.setColumnDefs(i.columnDefs.currentValue, "gridOptionsChanged"), delete i.columnDefs), Object.keys(i).forEach((n) => {
      const s = n, a = ke.getValue(s, i[s].currentValue);
      t.__setProperty(s, a);
    });
    const r = {
      type: w.EVENT_COMPONENT_STATE_CHANGED
    };
    Ct(e, (n, s) => {
      r[n] = s;
    }), t.dispatchEvent(r);
  }
  static toBoolean(e) {
    return typeof e == "boolean" ? e : typeof e == "string" ? e.toUpperCase() === "TRUE" || e == "" : !1;
  }
  static toNumber(e) {
    if (typeof e == "number")
      return e;
    if (typeof e == "string")
      return Number(e);
  }
}
ke.EVENTS = Dl(w);
ke.EXCLUDED_INTERNAL_EVENTS = [
  w.EVENT_SCROLLBAR_WIDTH_CHANGED,
  w.EVENT_CHECKBOX_CHANGED,
  w.EVENT_HEIGHT_SCALE_CHANGED,
  w.EVENT_BODY_HEIGHT_CHANGED,
  w.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,
  w.EVENT_SCROLL_VISIBILITY_CHANGED,
  w.EVENT_COLUMN_HOVER_CHANGED,
  w.EVENT_FLASH_CELLS,
  w.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED,
  w.EVENT_DISPLAYED_ROWS_CHANGED,
  w.EVENT_LEFT_PINNED_WIDTH_CHANGED,
  w.EVENT_RIGHT_PINNED_WIDTH_CHANGED,
  w.EVENT_ROW_CONTAINER_HEIGHT_CHANGED,
  w.EVENT_POPUP_TO_FRONT,
  w.EVENT_KEYBOARD_FOCUS,
  w.EVENT_MOUSE_FOCUS,
  w.EVENT_STORE_UPDATED,
  w.EVENT_COLUMN_PANEL_ITEM_DRAG_START,
  w.EVENT_COLUMN_PANEL_ITEM_DRAG_END,
  w.EVENT_FILL_START,
  w.EVENT_FILL_END,
  w.EVENT_KEY_SHORTCUT_CHANGED_CELL_START,
  w.EVENT_KEY_SHORTCUT_CHANGED_CELL_END,
  w.EVENT_FULL_WIDTH_ROW_FOCUSED,
  w.EVENT_HEADER_HEIGHT_CHANGED,
  w.EVENT_COLUMN_HEADER_HEIGHT_CHANGED,
  w.EVENT_CELL_FOCUS_CLEARED,
  w.EVENT_GRID_STYLES_CHANGED,
  w.EVENT_FILTER_DESTROYED,
  w.EVENT_ROW_DATA_UPDATE_STARTED
];
ke.PUBLIC_EVENTS = ke.EVENTS.filter((o) => !ln(ke.EXCLUDED_INTERNAL_EVENTS, o));
ke.EVENT_CALLBACKS = ke.EVENTS.map((o) => ke.getCallbackForEvent(o));
ke.STRING_PROPERTIES = vt.STRING_PROPERTIES;
ke.OBJECT_PROPERTIES = vt.OBJECT_PROPERTIES;
ke.ARRAY_PROPERTIES = vt.ARRAY_PROPERTIES;
ke.NUMBER_PROPERTIES = vt.NUMBER_PROPERTIES;
ke.BOOLEAN_PROPERTIES = vt.BOOLEAN_PROPERTIES;
ke.FUNCTION_PROPERTIES = vt.FUNCTION_PROPERTIES;
ke.ALL_PROPERTIES = vt.ALL_PROPERTIES;
ke.ALL_PROPERTIES_SET = new Set(vt.ALL_PROPERTIES);
ke.coercionLookup = ke.getCoercionLookup();
function nT(o, e, t) {
  const i = {}, r = o.filter((n) => !e.some((s) => s === n));
  return r.length > 0 && r.forEach((n) => i[n] = wS(n, t)), i;
}
function wS(o, e, t, i) {
  let r = e.map((n) => ({
    value: n,
    relevance: iF(o.toLowerCase(), n.toLocaleLowerCase())
  }));
  if (r.sort((n, s) => s.relevance - n.relevance), t && (r = r.filter((n) => n.relevance !== 0)), i && i > 0) {
    const s = r[0].relevance * i;
    r = r.filter((a) => s - a.relevance < 0);
  }
  return r.map((n) => n.value);
}
function iF(o, e) {
  const t = o.replace(/\s/g, ""), i = e.replace(/\s/g, "");
  let r = 0, n = -1;
  for (let s = 0; s < t.length; s++) {
    const a = i.indexOf(t[s], n + 1);
    a !== -1 && (n = a, r += 100 - n * 100 / 1e4 * 100);
  }
  return r;
}
var rF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fuzzyCheckStrings: nT,
  fuzzySuggestions: wS
}), Fv = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
function rn(o, e, t, i) {
  const r = t ? `Please use '${t}' instead. ` : "";
  tt(() => console.warn(`AG Grid: since v${o}, '${e}' is deprecated. ${r}${i != null ? i : ""}`), `Deprecated_${e}`);
}
const Kw = ["__ob__", "__v_skip", "__metadata__"];
let Md = class {
  constructor() {
    this.deprecatedProperties = {
      rememberGroupStateWhenNewData: { version: "24", message: "Now that transaction updates are possible and they keep group state, this feature is no longer needed." },
      serverSideFilteringAlwaysResets: { version: "28.0", newProp: "serverSideOnlyRefreshFilteredGroups", copyToNewProp: !0 },
      serverSideSortingAlwaysResets: { version: "28.0", newProp: "serverSideSortAllLevels", copyToNewProp: !0 },
      suppressReactUi: { version: "28", message: "The legacy React rendering engine is deprecated and will be removed in the next major version of the grid." },
      processSecondaryColDef: { version: "28", newProp: "processPivotResultColDef", copyToNewProp: !0 },
      processSecondaryColGroupDef: { version: "28", newProp: "processPivotResultColGroupDef", copyToNewProp: !0 },
      getServerSideStoreParams: { version: "28", newProp: "getServerSideGroupLevelParams", copyToNewProp: !0 },
      serverSideInfiniteScroll: { version: "29", message: "Infinite Scrolling is now the default behaviour. This can be suppressed with `suppressServerSideInfiniteScroll`." },
      enableChartToolPanelsButton: { version: "29", message: "The Chart Tool Panels button is now enabled by default. To hide the Chart Tool Panels button and display the hamburger button instead, set suppressChartToolPanelsButton=true." },
      functionsPassive: { version: "29.2" },
      onColumnRowGroupChangeRequest: { version: "29.2" },
      onColumnPivotChangeRequest: { version: "29.2" },
      onColumnValueChangeRequest: { version: "29.2" },
      onColumnAggFuncChangeRequest: { version: "29.2" },
      serverSideFilterAllLevels: { version: "30", message: "All server-side group levels are now filtered by default. This can be toggled using `serverSideOnlyRefreshFilteredGroups`." },
      suppressAggAtRootLevel: { version: "30", message: "The root level aggregation is now suppressed by default. This can be toggled using  `alwaysAggregateAtRootLevel`." },
      excludeHiddenColumnsFromQuickFilter: { version: "30", message: "Hidden columns are now excluded from the Quick Filter by default. This can be toggled using `includeHiddenColumnsInQuickFilter`." },
      enterMovesDown: { version: "30", newProp: "enterNavigatesVertically", copyToNewProp: !0 },
      enterMovesDownAfterEdit: { version: "30", newProp: "enterNavigatesVerticallyAfterEdit", copyToNewProp: !0 }
    };
  }
  pickOneWarning(e, t) {
    console.warn(`AG Grid: ${e} and ${t} do not work with each other, you need to pick one.`);
  }
  init() {
    if (this.checkForDeprecated(), this.checkForViolations(), this.gridOptions.suppressPropertyNamesCheck !== !0 && (this.checkGridOptionsProperties(), this.checkColumnDefProperties()), this.checkColumnDefViolations(), this.gridOptionsService.is("groupSelectsChildren") && this.gridOptionsService.is("suppressParentsInRowNodes") && console.warn("AG Grid: 'groupSelectsChildren' does not work with 'suppressParentsInRowNodes', this selection method needs the part in rowNode to work"), this.gridOptionsService.is("groupSelectsChildren") && this.gridOptionsService.get("rowSelection") !== "multiple" && console.warn("AG Grid: rowSelection must be 'multiple' for groupSelectsChildren to make sense"), this.gridOptionsService.is("groupRemoveSingleChildren") && this.gridOptionsService.is("groupHideOpenParents") && this.pickOneWarning("groupRemoveSingleChildren", "groupHideOpenParents"), this.gridOptionsService.isRowModelType("serverSide")) {
      const t = (i, r) => `AG Grid: '${i}' is not supported on the Server-Side Row Model.` + (r ? ` Please use ${r} instead.` : "");
      this.gridOptionsService.exists("groupDefaultExpanded") && console.warn(t("groupDefaultExpanded", "isServerSideGroupOpenByDefault callback")), this.gridOptionsService.exists("groupIncludeFooter") && this.gridOptionsService.is("suppressServerSideInfiniteScroll") && console.warn(t("groupIncludeFooter")), this.gridOptionsService.exists("groupIncludeTotalFooter") && console.warn(t("groupIncludeTotalFooter"));
    }
    this.gridOptionsService.is("enableRangeSelection") ? Z.__assertRegistered(Q.RangeSelectionModule, "enableRangeSelection", this.gridOptionsService.getGridId()) : (this.gridOptionsService.is("enableRangeHandle") || this.gridOptionsService.is("enableFillHandle")) && console.warn("AG Grid: 'enableRangeHandle' or 'enableFillHandle' will not work unless 'enableRangeSelection' is set to true");
    const e = (t, i) => this.gridOptionsService.exists(t) && Z.__assertRegistered(i, t, this.gridOptionsService.getGridId());
    e("sideBar", Q.SideBarModule), e("statusBar", Q.StatusBarModule), e("enableCharts", Q.GridChartsModule), e("getMainMenuItems", Q.MenuModule), e("getContextMenuItems", Q.MenuModule), e("allowContextMenuWithControlKey", Q.MenuModule);
  }
  checkColumnDefProperties() {
    if (this.gridOptions.columnDefs == null)
      return;
    const e = Pg.ALL_PROPERTIES, t = (i, r) => {
      const n = Object.getOwnPropertyNames(i);
      this.checkProperties(n, [...e, ...Kw], e, r, "https://www.ag-grid.com/javascript-data-grid/column-properties/"), i.children && i.children.forEach((s) => t(s, "columnDefs.children"));
    };
    this.gridOptions.columnDefs.forEach((i) => t(i, "columnDefs")), this.gridOptions.defaultColDef && t(this.gridOptions.defaultColDef, "defaultColDef");
  }
  checkColumnDefViolations() {
    var e;
    const t = (e = this.gridOptionsService.get("rowModelType")) !== null && e !== void 0 ? e : "clientSide", r = {
      infinite: ["headerCheckboxSelection", "headerCheckboxSelectionFilteredOnly", "headerCheckboxSelectionCurrentPageOnly"],
      viewport: ["headerCheckboxSelection", "headerCheckboxSelectionFilteredOnly", "headerCheckboxSelectionCurrentPageOnly"],
      serverSide: ["headerCheckboxSelectionFilteredOnly", "headerCheckboxSelectionCurrentPageOnly"],
      clientSide: []
    }[t];
    if (!(r != null && r.length))
      return;
    const n = (s) => {
      r.forEach((a) => {
        a in s && s[a] && console.warn(`AG Grid: Column property ${a} is not supported with the row model type ${t}.`);
      });
    };
    this.gridOptions.columnDefs != null && this.gridOptions.columnDefs.forEach((s) => n(s)), this.gridOptions.autoGroupColumnDef != null && n(this.gridOptions.autoGroupColumnDef), this.gridOptions.defaultColDef != null && n(this.gridOptions.defaultColDef);
  }
  checkGridOptionsProperties() {
    const e = Object.getOwnPropertyNames(this.gridOptions), t = [
      ...vt.ALL_PROPERTIES,
      ...ke.EVENT_CALLBACKS
    ], i = [...t, "api", "columnApi", ...Kw, ...Object.keys(this.deprecatedProperties)];
    this.checkProperties(e, i, t, "gridOptions", "https://www.ag-grid.com/javascript-data-grid/grid-options/");
  }
  checkProperties(e, t, i, r, n) {
    const s = nT(e, t, i);
    Ct(s, (a, l) => {
      tt(() => console.warn(`AG Grid: invalid ${r} property '${a}' did you mean any of these: ${l.slice(0, 8).join(", ")}`), "invalidProperty" + r + a);
    }), Object.keys(s).length > 0 && tt(() => console.warn(`AG Grid: to see all the valid ${r} properties please check: ${n}`), "invalidProperties" + r + n);
  }
  checkForDeprecated() {
    const e = this.gridOptions;
    Object.entries(this.deprecatedProperties).forEach(([t, i]) => {
      var r;
      const n = e[t];
      n && (rn(i.version, t, i.newProp, i.message), i.copyToNewProp && i.newProp && e[i.newProp] == null && (e[i.newProp] = (r = i.newPropValue) !== null && r !== void 0 ? r : n));
    }), e.serverSideStoreType && (console.warn("AG Grid: since v29.0, `serverSideStoreType` has been replaced by `suppressServerSideInfiniteScroll`. Set to false to use Partial Store, and true to use Full Store."), e.suppressServerSideInfiniteScroll = e.serverSideStoreType !== "partial");
  }
  checkForViolations() {
    this.gridOptionsService.is("treeData") && this.treeDataViolations();
  }
  treeDataViolations() {
    this.gridOptionsService.isRowModelType("clientSide") && (this.gridOptionsService.exists("getDataPath") || console.warn("AG Grid: property usingTreeData=true with rowModel=clientSide, but you did not provide getDataPath function, please provide getDataPath function if using tree data.")), this.gridOptionsService.isRowModelType("serverSide") && (this.gridOptionsService.exists("isServerSideGroup") || console.warn("AG Grid: property usingTreeData=true with rowModel=serverSide, but you did not provide isServerSideGroup function, please provide isServerSideGroup function if using tree data."), this.gridOptionsService.exists("getServerSideGroupKey") || console.warn("AG Grid: property usingTreeData=true with rowModel=serverSide, but you did not provide getServerSideGroupKey function, please provide getServerSideGroupKey function if using tree data."));
  }
};
Fv([
  S("gridOptions")
], Md.prototype, "gridOptions", void 0);
Fv([
  S("gridOptionsService")
], Md.prototype, "gridOptionsService", void 0);
Fv([
  B
], Md.prototype, "init", null);
Md = Fv([
  q("gridOptionsValidator")
], Md);
function yC(o, e) {
  const t = ["groupRows", "multipleColumns", "custom", "singleColumn"];
  return t.indexOf(e) < 0 ? (console.warn(`AG Grid: '${e}' is not a valid groupDisplayType value - possible values are: '${t.join("', '")}'`), !1) : e === o;
}
function nF(o, e) {
  const t = ["auto", "custom"];
  return t.indexOf(e) < 0 ? (console.warn(`AG Grid: '${e}' is not a valid treeDataDisplayType value - possible values are: '${t.join("', '")}'`), !1) : e === o;
}
var Di = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, oF = function(o, e) {
  return function(t, i) {
    e(t, i, o);
  };
}, sF = function(o, e) {
  var t = {};
  for (var i in o)
    Object.prototype.hasOwnProperty.call(o, i) && e.indexOf(i) < 0 && (t[i] = o[i]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(o); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(o, i[r]) && (t[i[r]] = o[i[r]]);
  return t;
};
let ti = class extends H {
  constructor() {
    super(...arguments), this.primaryHeaderRowCount = 0, this.secondaryHeaderRowCount = 0, this.gridHeaderRowCount = 0, this.displayedColumnsLeft = [], this.displayedColumnsRight = [], this.displayedColumnsCenter = [], this.displayedColumns = [], this.displayedColumnsAndGroupsMap = {}, this.viewportColumns = [], this.viewportColumnsHash = "", this.headerViewportColumns = [], this.viewportColumnsCenter = [], this.headerViewportColumnsCenter = [], this.autoHeightActiveAtLeastOnce = !1, this.rowGroupColumns = [], this.valueColumns = [], this.pivotColumns = [], this.ready = !1, this.autoGroupsNeedBuilding = !1, this.forceRecreateAutoGroups = !1, this.pivotMode = !1, this.bodyWidth = 0, this.leftWidth = 0, this.rightWidth = 0, this.bodyWidthDirty = !0, this.shouldQueueResizeOperations = !1, this.resizeOperationQueue = [];
  }
  init() {
    this.suppressColumnVirtualisation = this.gridOptionsService.is("suppressColumnVirtualisation");
    const e = this.gridOptionsService.is("pivotMode");
    this.isPivotSettingAllowed(e) && (this.pivotMode = e), this.usingTreeData = this.gridOptionsService.isTreeData(), this.addManagedPropertyListener("groupDisplayType", () => this.onAutoGroupColumnDefChanged()), this.addManagedPropertyListener("autoGroupColumnDef", () => this.onAutoGroupColumnDefChanged()), this.addManagedPropertyListener("defaultColDef", (t) => this.onSharedColDefChanged(t.source)), this.addManagedPropertyListener("columnTypes", (t) => this.onSharedColDefChanged(t.source));
  }
  onAutoGroupColumnDefChanged() {
    this.columnDefs && (this.autoGroupsNeedBuilding = !0, this.forceRecreateAutoGroups = !0, this.updateGridColumns(), this.updateDisplayedColumns("gridOptionsChanged"));
  }
  onSharedColDefChanged(e = "api") {
    this.forceRecreateAutoGroups = !0, this.createColumnsFromColumnDefs(!0, e);
  }
  setColumnDefs(e, t = "api") {
    const i = !!this.columnDefs;
    this.columnDefs = e, this.createColumnsFromColumnDefs(i, t);
  }
  recreateColumnDefs(e = "api") {
    this.onSharedColDefChanged(e);
  }
  destroyOldColumns(e, t) {
    const i = {};
    if (!e)
      return;
    this.columnUtils.depthFirstOriginalTreeSearch(null, e, (n) => {
      i[n.getInstanceId()] = n;
    }), t && this.columnUtils.depthFirstOriginalTreeSearch(null, t, (n) => {
      i[n.getInstanceId()] = null;
    });
    const r = Object.values(i).filter((n) => n != null);
    this.destroyBeans(r);
  }
  destroyColumns() {
    this.destroyOldColumns(this.primaryColumnTree), this.destroyOldColumns(this.secondaryBalancedTree), this.destroyOldColumns(this.groupAutoColsBalancedTree);
  }
  createColumnsFromColumnDefs(e, t = "api") {
    const i = e ? this.compareColumnStatesAndDispatchEvents(t) : void 0;
    this.valueCache.expire(), this.autoGroupsNeedBuilding = !0;
    const r = this.primaryColumns, n = this.primaryColumnTree, s = this.columnFactory.createColumnTree(this.columnDefs, !0, n);
    this.destroyOldColumns(this.primaryColumnTree, s.columnTree), this.primaryColumnTree = s.columnTree, this.primaryHeaderRowCount = s.treeDept + 1, this.primaryColumns = this.getColumnsFromTree(this.primaryColumnTree), this.primaryColumnsMap = {}, this.primaryColumns.forEach((c) => this.primaryColumnsMap[c.getId()] = c), this.extractRowGroupColumns(t, r), this.extractPivotColumns(t, r), this.extractValueColumns(t, r), this.ready = !0;
    const a = this.gridColsArePrimary === void 0;
    (this.gridColsArePrimary || a) && (this.updateGridColumns(), e && !this.gridOptionsService.is("maintainColumnOrder") && this.orderGridColumnsLikePrimary(), this.updateDisplayedColumns(t), this.checkViewportColumns()), this.dispatchEverythingChanged(t), i && i(), this.dispatchNewColumnsLoaded();
  }
  dispatchNewColumnsLoaded() {
    const e = {
      type: w.EVENT_NEW_COLUMNS_LOADED
    };
    this.eventService.dispatchEvent(e);
  }
  // this event is legacy, no grid code listens to it. instead the grid listens to New Columns Loaded
  dispatchEverythingChanged(e = "api") {
    const t = {
      type: w.EVENT_COLUMN_EVERYTHING_CHANGED,
      source: e
    };
    this.eventService.dispatchEvent(t);
  }
  orderGridColumnsLikePrimary() {
    const e = this.primaryColumns;
    e && (this.gridColumns.sort((t, i) => {
      const r = e.indexOf(t), n = e.indexOf(i), s = r >= 0, a = n >= 0;
      if (s && a)
        return r - n;
      if (s)
        return 1;
      if (a)
        return -1;
      const l = this.gridColumns.indexOf(t), c = this.gridColumns.indexOf(i);
      return l - c;
    }), this.gridColumns = this.placeLockedColumns(this.gridColumns));
  }
  getAllDisplayedAutoHeightCols() {
    return this.displayedAutoHeightCols;
  }
  setViewport() {
    this.gridOptionsService.is("enableRtl") ? (this.viewportLeft = this.bodyWidth - this.scrollPosition - this.scrollWidth, this.viewportRight = this.bodyWidth - this.scrollPosition) : (this.viewportLeft = this.scrollPosition, this.viewportRight = this.scrollWidth + this.scrollPosition);
  }
  // used by clipboard service, to know what columns to paste into
  getDisplayedColumnsStartingAt(e) {
    let t = e;
    const i = [];
    for (; t != null; )
      i.push(t), t = this.getDisplayedColAfter(t);
    return i;
  }
  // checks what columns are currently displayed due to column virtualisation. dispatches an event
  // if the list of columns has changed.
  // + setColumnWidth(), setViewportPosition(), setColumnDefs(), sizeColumnsToFit()
  checkViewportColumns() {
    if (this.displayedColumnsCenter == null || !this.extractViewport())
      return;
    const t = {
      type: w.EVENT_VIRTUAL_COLUMNS_CHANGED
    };
    this.eventService.dispatchEvent(t);
  }
  setViewportPosition(e, t) {
    (e !== this.scrollWidth || t !== this.scrollPosition || this.bodyWidthDirty) && (this.scrollWidth = e, this.scrollPosition = t, this.bodyWidthDirty = !0, this.setViewport(), this.ready && this.checkViewportColumns());
  }
  isPivotMode() {
    return this.pivotMode;
  }
  isPivotSettingAllowed(e) {
    return e && this.gridOptionsService.isTreeData() ? (console.warn("AG Grid: Pivot mode not available in conjunction Tree Data i.e. 'gridOptions.treeData: true'"), !1) : !0;
  }
  setPivotMode(e, t = "api") {
    if (e === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode))
      return;
    this.pivotMode = e, this.autoGroupsNeedBuilding = !0, this.updateGridColumns(), this.updateDisplayedColumns(t);
    const i = {
      type: w.EVENT_COLUMN_PIVOT_MODE_CHANGED
    };
    this.eventService.dispatchEvent(i);
  }
  getSecondaryPivotColumn(e, t) {
    if (Se(this.secondaryColumns))
      return null;
    const i = this.getPrimaryColumn(t);
    let r = null;
    return this.secondaryColumns.forEach((n) => {
      const s = n.getColDef().pivotKeys, a = n.getColDef().pivotValueColumn;
      ia(s, e) && a === i && (r = n);
    }), r;
  }
  setBeans(e) {
    this.logger = e.create("columnModel");
  }
  setFirstRightAndLastLeftPinned(e) {
    let t, i;
    this.gridOptionsService.is("enableRtl") ? (t = this.displayedColumnsLeft ? this.displayedColumnsLeft[0] : null, i = this.displayedColumnsRight ? at(this.displayedColumnsRight) : null) : (t = this.displayedColumnsLeft ? at(this.displayedColumnsLeft) : null, i = this.displayedColumnsRight ? this.displayedColumnsRight[0] : null), this.gridColumns.forEach((r) => {
      r.setLastLeftPinned(r === t, e), r.setFirstRightPinned(r === i, e);
    });
  }
  autoSizeColumns(e) {
    if (this.shouldQueueResizeOperations) {
      this.resizeOperationQueue.push(() => this.autoSizeColumns(e));
      return;
    }
    const { columns: t, skipHeader: i, skipHeaderGroups: r, stopAtGroup: n, source: s = "api" } = e;
    this.animationFrameService.flushAllFrames();
    const a = [];
    let l = -1;
    const c = i != null ? i : this.gridOptionsService.is("skipHeaderOnAutoSize"), d = r != null ? r : c;
    for (; l !== 0; )
      l = 0, this.actionOnGridColumns(t, (u) => {
        if (a.indexOf(u) >= 0)
          return !1;
        const h = this.autoWidthCalculator.getPreferredWidthForColumn(u, c);
        if (h > 0) {
          const p = this.normaliseColumnWidth(u, h);
          u.setActualWidth(p, s), a.push(u), l++;
        }
        return !0;
      }, s);
    d || this.autoSizeColumnGroupsByColumns(t, s, n), this.dispatchColumnResizedEvent(a, !0, "autosizeColumns");
  }
  dispatchColumnResizedEvent(e, t, i, r = null) {
    if (e && e.length) {
      const n = {
        type: w.EVENT_COLUMN_RESIZED,
        columns: e,
        column: e.length === 1 ? e[0] : null,
        flexColumns: r,
        finished: t,
        source: i
      };
      this.eventService.dispatchEvent(n);
    }
  }
  dispatchColumnChangedEvent(e, t, i) {
    const r = {
      type: e,
      columns: t,
      column: t && t.length == 1 ? t[0] : null,
      source: i
    };
    this.eventService.dispatchEvent(r);
  }
  dispatchColumnMovedEvent(e) {
    const { movedColumns: t, source: i, toIndex: r, finished: n } = e, s = {
      type: w.EVENT_COLUMN_MOVED,
      columns: t,
      column: t && t.length === 1 ? t[0] : null,
      toIndex: r,
      finished: n,
      source: i
    };
    this.eventService.dispatchEvent(s);
  }
  dispatchColumnPinnedEvent(e, t) {
    if (!e.length)
      return;
    const i = e.length === 1 ? e[0] : null, r = this.getCommonValue(e, (s) => s.getPinned()), n = {
      type: w.EVENT_COLUMN_PINNED,
      // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'
      pinned: r != null ? r : null,
      columns: e,
      column: i,
      source: t
    };
    this.eventService.dispatchEvent(n);
  }
  dispatchColumnVisibleEvent(e, t) {
    if (!e.length)
      return;
    const i = e.length === 1 ? e[0] : null, r = this.getCommonValue(e, (s) => s.isVisible()), n = {
      type: w.EVENT_COLUMN_VISIBLE,
      visible: r,
      columns: e,
      column: i,
      source: t
    };
    this.eventService.dispatchEvent(n);
  }
  autoSizeColumn(e, t, i = "api") {
    e && this.autoSizeColumns({ columns: [e], skipHeader: t, skipHeaderGroups: !0, source: i });
  }
  autoSizeColumnGroupsByColumns(e, t, i) {
    const r = /* @__PURE__ */ new Set();
    this.getGridColumns(e).forEach((l) => {
      let c = l.getParent();
      for (; c && c != i; )
        c.isPadding() || r.add(c), c = c.getParent();
    });
    let s;
    const a = [];
    for (const l of r) {
      for (const c of this.ctrlsService.getHeaderRowContainerCtrls())
        if (s = c.getHeaderCtrlForColumn(l), s)
          break;
      s && s.resizeLeafColumnsToFit(t);
    }
    return a;
  }
  autoSizeAllColumns(e, t = "api") {
    if (this.shouldQueueResizeOperations) {
      this.resizeOperationQueue.push(() => this.autoSizeAllColumns(e, t));
      return;
    }
    const i = this.getAllDisplayedColumns();
    this.autoSizeColumns({ columns: i, skipHeader: e, source: t });
  }
  // Possible candidate for reuse (alot of recursive traversal duplication)
  getColumnsFromTree(e) {
    const t = [], i = (r) => {
      for (let n = 0; n < r.length; n++) {
        const s = r[n];
        s instanceof me ? t.push(s) : s instanceof Be && i(s.getChildren());
      }
    };
    return i(e), t;
  }
  getAllDisplayedTrees() {
    return this.displayedTreeLeft && this.displayedTreeRight && this.displayedTreeCentre ? this.displayedTreeLeft.concat(this.displayedTreeCentre).concat(this.displayedTreeRight) : null;
  }
  // + columnSelectPanel
  getPrimaryColumnTree() {
    return this.primaryColumnTree;
  }
  // + gridPanel -> for resizing the body and setting top margin
  getHeaderRowCount() {
    return this.gridHeaderRowCount;
  }
  // + headerRenderer -> setting pinned body width
  getDisplayedTreeLeft() {
    return this.displayedTreeLeft;
  }
  // + headerRenderer -> setting pinned body width
  getDisplayedTreeRight() {
    return this.displayedTreeRight;
  }
  // + headerRenderer -> setting pinned body width
  getDisplayedTreeCentre() {
    return this.displayedTreeCentre;
  }
  // gridPanel -> ensureColumnVisible
  isColumnDisplayed(e) {
    return this.getAllDisplayedColumns().indexOf(e) >= 0;
  }
  // + csvCreator
  getAllDisplayedColumns() {
    return this.displayedColumns;
  }
  getViewportColumns() {
    return this.viewportColumns;
  }
  getDisplayedLeftColumnsForRow(e) {
    return this.colSpanActive ? this.getDisplayedColumnsForRow(e, this.displayedColumnsLeft) : this.displayedColumnsLeft;
  }
  getDisplayedRightColumnsForRow(e) {
    return this.colSpanActive ? this.getDisplayedColumnsForRow(e, this.displayedColumnsRight) : this.displayedColumnsRight;
  }
  isColSpanActive() {
    return this.colSpanActive;
  }
  getDisplayedColumnsForRow(e, t, i, r) {
    const n = [];
    let s = null;
    for (let a = 0; a < t.length; a++) {
      const l = t[a], c = t.length - a, d = Math.min(l.getColSpan(e), c), u = [l];
      if (d > 1) {
        const p = d - 1;
        for (let f = 1; f <= p; f++)
          u.push(t[a + f]);
        a += p;
      }
      let h;
      i ? (h = !1, u.forEach((p) => {
        i(p) && (h = !0);
      })) : h = !0, h && (n.length === 0 && s && (r && r(l)) && n.push(s), n.push(l)), s = l;
    }
    return n;
  }
  // + rowRenderer
  // if we are not column spanning, this just returns back the virtual centre columns,
  // however if we are column spanning, then different rows can have different virtual
  // columns, so we have to work out the list for each individual row.
  getViewportCenterColumnsForRow(e) {
    if (!this.colSpanActive)
      return this.viewportColumnsCenter;
    const t = (r) => {
      const n = r.getLeft();
      return z(n) && n > this.viewportLeft;
    }, i = this.suppressColumnVirtualisation ? null : this.isColumnInRowViewport.bind(this);
    return this.getDisplayedColumnsForRow(e, this.displayedColumnsCenter, i, t);
  }
  getAriaColumnIndex(e) {
    return this.getAllGridColumns().indexOf(e) + 1;
  }
  isColumnInHeaderViewport(e) {
    return e.isAutoHeaderHeight() ? !0 : this.isColumnInRowViewport(e);
  }
  isColumnInRowViewport(e) {
    if (e.isAutoHeight())
      return !0;
    const t = e.getLeft() || 0, i = t + e.getActualWidth(), r = this.viewportLeft - 200, n = this.viewportRight + 200, s = t < r && i < r, a = t > n && i > n;
    return !s && !a;
  }
  // used by:
  // + angularGrid -> setting pinned body width
  // note: this should be cached
  getDisplayedColumnsLeftWidth() {
    return this.getWidthOfColsInList(this.displayedColumnsLeft);
  }
  // note: this should be cached
  getDisplayedColumnsRightWidth() {
    return this.getWidthOfColsInList(this.displayedColumnsRight);
  }
  updatePrimaryColumnList(e, t, i, r, n, s = "api") {
    if (!e || br(e))
      return;
    let a = !1;
    if (e.forEach((c) => {
      const d = this.getPrimaryColumn(c);
      if (d) {
        if (i) {
          if (t.indexOf(d) >= 0)
            return;
          t.push(d);
        } else {
          if (t.indexOf(d) < 0)
            return;
          Ni(t, d);
        }
        r(d), a = !0;
      }
    }), !a)
      return;
    this.autoGroupsNeedBuilding && this.updateGridColumns(), this.updateDisplayedColumns(s);
    const l = {
      type: n,
      columns: t,
      column: t.length === 1 ? t[0] : null,
      source: s
    };
    this.eventService.dispatchEvent(l);
  }
  setRowGroupColumns(e, t = "api") {
    this.autoGroupsNeedBuilding = !0, this.setPrimaryColumnList(e, this.rowGroupColumns, w.EVENT_COLUMN_ROW_GROUP_CHANGED, this.setRowGroupActive.bind(this), t);
  }
  setRowGroupActive(e, t, i) {
    e !== t.isRowGroupActive() && (t.setRowGroupActive(e, i), e && !this.gridOptionsService.is("suppressRowGroupHidesColumns") && this.setColumnVisible(t, !1, i), !e && !this.gridOptionsService.is("suppressMakeColumnVisibleAfterUnGroup") && this.setColumnVisible(t, !0, i));
  }
  addRowGroupColumn(e, t = "api") {
    e && this.addRowGroupColumns([e], t);
  }
  addRowGroupColumns(e, t = "api") {
    this.autoGroupsNeedBuilding = !0, this.updatePrimaryColumnList(e, this.rowGroupColumns, !0, this.setRowGroupActive.bind(this, !0), w.EVENT_COLUMN_ROW_GROUP_CHANGED, t);
  }
  removeRowGroupColumns(e, t = "api") {
    this.autoGroupsNeedBuilding = !0, this.updatePrimaryColumnList(e, this.rowGroupColumns, !1, this.setRowGroupActive.bind(this, !1), w.EVENT_COLUMN_ROW_GROUP_CHANGED, t);
  }
  removeRowGroupColumn(e, t = "api") {
    e && this.removeRowGroupColumns([e], t);
  }
  addPivotColumns(e, t = "api") {
    this.updatePrimaryColumnList(e, this.pivotColumns, !0, (i) => i.setPivotActive(!0, t), w.EVENT_COLUMN_PIVOT_CHANGED, t);
  }
  setPivotColumns(e, t = "api") {
    this.setPrimaryColumnList(e, this.pivotColumns, w.EVENT_COLUMN_PIVOT_CHANGED, (i, r) => {
      r.setPivotActive(i, t);
    }, t);
  }
  addPivotColumn(e, t = "api") {
    this.addPivotColumns([e], t);
  }
  removePivotColumns(e, t = "api") {
    this.updatePrimaryColumnList(e, this.pivotColumns, !1, (i) => i.setPivotActive(!1, t), w.EVENT_COLUMN_PIVOT_CHANGED, t);
  }
  removePivotColumn(e, t = "api") {
    this.removePivotColumns([e], t);
  }
  setPrimaryColumnList(e, t, i, r, n) {
    t.length = 0, z(e) && e.forEach((s) => {
      const a = this.getPrimaryColumn(s);
      a && t.push(a);
    }), (this.primaryColumns || []).forEach((s) => {
      const a = t.indexOf(s) >= 0;
      r(a, s);
    }), this.autoGroupsNeedBuilding && this.updateGridColumns(), this.updateDisplayedColumns(n), this.dispatchColumnChangedEvent(i, t, n);
  }
  setValueColumns(e, t = "api") {
    this.setPrimaryColumnList(e, this.valueColumns, w.EVENT_COLUMN_VALUE_CHANGED, this.setValueActive.bind(this), t);
  }
  setValueActive(e, t, i) {
    if (e !== t.isValueActive() && (t.setValueActive(e, i), e && !t.getAggFunc())) {
      const r = this.aggFuncService.getDefaultAggFunc(t);
      t.setAggFunc(r);
    }
  }
  addValueColumns(e, t = "api") {
    this.updatePrimaryColumnList(e, this.valueColumns, !0, this.setValueActive.bind(this, !0), w.EVENT_COLUMN_VALUE_CHANGED, t);
  }
  addValueColumn(e, t = "api") {
    e && this.addValueColumns([e], t);
  }
  removeValueColumn(e, t = "api") {
    this.removeValueColumns([e], t);
  }
  removeValueColumns(e, t = "api") {
    this.updatePrimaryColumnList(e, this.valueColumns, !1, this.setValueActive.bind(this, !1), w.EVENT_COLUMN_VALUE_CHANGED, t);
  }
  // returns the width we can set to this col, taking into consideration min and max widths
  normaliseColumnWidth(e, t) {
    const i = e.getMinWidth();
    z(i) && t < i && (t = i);
    const r = e.getMaxWidth();
    return z(r) && e.isGreaterThanMax(t) && (t = r), t;
  }
  getPrimaryOrGridColumn(e) {
    return this.getPrimaryColumn(e) || this.getGridColumn(e);
  }
  setColumnWidths(e, t, i, r = "api") {
    const n = [];
    e.forEach((s) => {
      const a = this.getPrimaryOrGridColumn(s.key);
      if (!a)
        return;
      if (n.push({
        width: s.newWidth,
        ratios: [1],
        columns: [a]
      }), this.gridOptionsService.get("colResizeDefault") === "shift" && (t = !t), t) {
        const c = this.getDisplayedColAfter(a);
        if (!c)
          return;
        const d = a.getActualWidth() - s.newWidth, u = c.getActualWidth() + d;
        n.push({
          width: u,
          ratios: [1],
          columns: [c]
        });
      }
    }), n.length !== 0 && this.resizeColumnSets({
      resizeSets: n,
      finished: i,
      source: r
    });
  }
  checkMinAndMaxWidthsForSet(e) {
    const { columns: t, width: i } = e;
    let r = 0, n = 0, s = !0;
    t.forEach((c) => {
      const d = c.getMinWidth();
      r += d || 0;
      const u = c.getMaxWidth();
      z(u) && u > 0 ? n += u : s = !1;
    });
    const a = i >= r, l = !s || i <= n;
    return a && l;
  }
  // method takes sets of columns and resizes them. either all sets will be resized, or nothing
  // be resized. this is used for example when user tries to resize a group and holds shift key,
  // then both the current group (grows), and the adjacent group (shrinks), will get resized,
  // so that's two sets for this method.
  resizeColumnSets(e) {
    const { resizeSets: t, finished: i, source: r } = e;
    if (!(!t || t.every((u) => this.checkMinAndMaxWidthsForSet(u)))) {
      if (i) {
        const u = t && t.length > 0 ? t[0].columns : null;
        this.dispatchColumnResizedEvent(u, i, r);
      }
      return;
    }
    const s = [], a = [];
    t.forEach((u) => {
      const { width: h, columns: p, ratios: f } = u, g = {}, v = {};
      p.forEach((C) => a.push(C));
      let y = !0, m = 0;
      for (; y; ) {
        if (m++, m > 1e3) {
          console.error("AG Grid: infinite loop in resizeColumnSets");
          break;
        }
        y = !1;
        const C = [];
        let R = 0, E = h;
        p.forEach((T, D) => {
          if (v[T.getId()])
            E -= g[T.getId()];
          else {
            C.push(T);
            const O = f[D];
            R += O;
          }
        });
        const b = 1 / R;
        C.forEach((T, D) => {
          const P = D === C.length - 1;
          let O;
          P ? O = E : (O = Math.round(f[D] * h * b), E -= O);
          const M = T.getMinWidth(), _ = T.getMaxWidth();
          z(M) && O < M ? (O = M, v[T.getId()] = !0, y = !0) : z(_) && _ > 0 && O > _ && (O = _, v[T.getId()] = !0, y = !0), g[T.getId()] = O;
        });
      }
      p.forEach((C) => {
        const R = g[C.getId()];
        C.getActualWidth() !== R && (C.setActualWidth(R, r), s.push(C));
      });
    });
    const l = s.length > 0;
    let c = [];
    l && (c = this.refreshFlexedColumns({ resizingCols: a, skipSetLeft: !0 }), this.setLeftValues(r), this.updateBodyWidths(), this.checkViewportColumns());
    const d = a.concat(c);
    (l || i) && this.dispatchColumnResizedEvent(d, i, r, c);
  }
  setColumnAggFunc(e, t, i = "api") {
    if (!e)
      return;
    const r = this.getPrimaryColumn(e);
    r && (r.setAggFunc(t), this.dispatchColumnChangedEvent(w.EVENT_COLUMN_VALUE_CHANGED, [r], i));
  }
  moveRowGroupColumn(e, t, i = "api") {
    const r = this.rowGroupColumns[e];
    this.rowGroupColumns.splice(e, 1), this.rowGroupColumns.splice(t, 0, r);
    const n = {
      type: w.EVENT_COLUMN_ROW_GROUP_CHANGED,
      columns: this.rowGroupColumns,
      column: this.rowGroupColumns.length === 1 ? this.rowGroupColumns[0] : null,
      source: i
    };
    this.eventService.dispatchEvent(n);
  }
  moveColumns(e, t, i = "api", r = !0) {
    if (this.columnAnimationService.start(), t > this.gridColumns.length - e.length) {
      console.warn("AG Grid: tried to insert columns in invalid location, toIndex = " + t), console.warn("AG Grid: remember that you should not count the moving columns when calculating the new index");
      return;
    }
    const n = this.getGridColumns(e);
    this.doesMovePassRules(n, t) && (vC(this.gridColumns, n, t), this.updateDisplayedColumns(i), this.dispatchColumnMovedEvent({ movedColumns: n, source: i, toIndex: t, finished: r }), this.columnAnimationService.finish());
  }
  doesMovePassRules(e, t) {
    const i = this.getProposedColumnOrder(e, t);
    return this.doesOrderPassRules(i);
  }
  doesOrderPassRules(e) {
    return !(!this.doesMovePassMarryChildren(e) || !this.doesMovePassLockedPositions(e));
  }
  getProposedColumnOrder(e, t) {
    const i = this.gridColumns.slice();
    return vC(i, e, t), i;
  }
  // returns the provided cols sorted in same order as they appear in grid columns. eg if grid columns
  // contains [a,b,c,d,e] and col passed is [e,a] then the passed cols are sorted into [a,e]
  sortColumnsLikeGridColumns(e) {
    !e || e.length <= 1 || e.filter((i) => this.gridColumns.indexOf(i) < 0).length > 0 || e.sort((i, r) => {
      const n = this.gridColumns.indexOf(i), s = this.gridColumns.indexOf(r);
      return n - s;
    });
  }
  doesMovePassLockedPositions(e) {
    let t = 0, i = !0;
    const r = (n) => n ? n === !0 || n === "left" ? 0 : 2 : 1;
    return e.forEach((n) => {
      const s = r(n.getColDef().lockPosition);
      s < t && (i = !1), t = s;
    }), i;
  }
  doesMovePassMarryChildren(e) {
    let t = !0;
    return this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, (i) => {
      if (!(i instanceof Be))
        return;
      const r = i, n = r.getColGroupDef();
      if (!(n && n.marryChildren))
        return;
      const a = [];
      r.getLeafColumns().forEach((h) => {
        const p = e.indexOf(h);
        a.push(p);
      });
      const l = Math.max.apply(Math, a), c = Math.min.apply(Math, a), d = l - c, u = r.getLeafColumns().length - 1;
      d > u && (t = !1);
    }), t;
  }
  moveColumn(e, t, i = "api") {
    this.moveColumns([e], t, i);
  }
  moveColumnByIndex(e, t, i = "api") {
    const r = this.gridColumns[e];
    this.moveColumn(r, t, i);
  }
  getColumnDefs() {
    if (!this.primaryColumns)
      return;
    const e = this.primaryColumns.slice();
    return this.gridColsArePrimary ? e.sort((t, i) => this.gridColumns.indexOf(t) - this.gridColumns.indexOf(i)) : this.lastPrimaryOrder && e.sort((t, i) => this.lastPrimaryOrder.indexOf(t) - this.lastPrimaryOrder.indexOf(i)), this.columnDefFactory.buildColumnDefs(e, this.rowGroupColumns, this.pivotColumns);
  }
  // used by:
  // + angularGrid -> for setting body width
  // + rowController -> setting main row widths (when inserting and resizing)
  // need to cache this
  getBodyContainerWidth() {
    return this.bodyWidth;
  }
  getContainerWidth(e) {
    switch (e) {
      case "left":
        return this.leftWidth;
      case "right":
        return this.rightWidth;
      default:
        return this.bodyWidth;
    }
  }
  // after setColumnWidth or updateGroupsAndDisplayedColumns
  updateBodyWidths() {
    const e = this.getWidthOfColsInList(this.displayedColumnsCenter), t = this.getWidthOfColsInList(this.displayedColumnsLeft), i = this.getWidthOfColsInList(this.displayedColumnsRight);
    if (this.bodyWidthDirty = this.bodyWidth !== e, this.bodyWidth !== e || this.leftWidth !== t || this.rightWidth !== i) {
      this.bodyWidth = e, this.leftWidth = t, this.rightWidth = i;
      const n = {
        type: w.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED
      };
      this.eventService.dispatchEvent(n);
    }
  }
  // + rowController
  getValueColumns() {
    return this.valueColumns ? this.valueColumns : [];
  }
  // + rowController
  getPivotColumns() {
    return this.pivotColumns ? this.pivotColumns : [];
  }
  // + clientSideRowModel
  isPivotActive() {
    return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;
  }
  // + toolPanel
  getRowGroupColumns() {
    return this.rowGroupColumns ? this.rowGroupColumns : [];
  }
  // + rowController -> while inserting rows
  getDisplayedCenterColumns() {
    return this.displayedColumnsCenter;
  }
  // + rowController -> while inserting rows
  getDisplayedLeftColumns() {
    return this.displayedColumnsLeft;
  }
  getDisplayedRightColumns() {
    return this.displayedColumnsRight;
  }
  getDisplayedColumns(e) {
    switch (e) {
      case "left":
        return this.getDisplayedLeftColumns();
      case "right":
        return this.getDisplayedRightColumns();
      default:
        return this.getDisplayedCenterColumns();
    }
  }
  // used by:
  // + clientSideRowController -> sorting, building quick filter text
  // + headerRenderer -> sorting (clearing icon)
  getAllPrimaryColumns() {
    return this.primaryColumns ? this.primaryColumns.slice() : null;
  }
  getSecondaryColumns() {
    return this.secondaryColumns ? this.secondaryColumns.slice() : null;
  }
  getAllColumnsForQuickFilter() {
    return this.columnsForQuickFilter;
  }
  // + moveColumnController
  getAllGridColumns() {
    return this.gridColumns;
  }
  isEmpty() {
    return br(this.gridColumns);
  }
  isRowGroupEmpty() {
    return br(this.rowGroupColumns);
  }
  setColumnVisible(e, t, i = "api") {
    this.setColumnsVisible([e], t, i);
  }
  setColumnsVisible(e, t = !1, i = "api") {
    this.applyColumnState({
      state: e.map((r) => ({
        colId: typeof r == "string" ? r : r.getColId(),
        hide: !t
      }))
    }, i);
  }
  setColumnPinned(e, t, i = "api") {
    e && this.setColumnsPinned([e], t, i);
  }
  setColumnsPinned(e, t, i = "api") {
    if (this.gridOptionsService.isDomLayout("print")) {
      console.warn("AG Grid: Changing the column pinning status is not allowed with domLayout='print'");
      return;
    }
    this.columnAnimationService.start();
    let r;
    t === !0 || t === "left" ? r = "left" : t === "right" ? r = "right" : r = null, this.actionOnGridColumns(e, (n) => n.getPinned() !== r ? (n.setPinned(r), !0) : !1, i, () => ({
      type: w.EVENT_COLUMN_PINNED,
      pinned: r,
      column: null,
      columns: null,
      source: i
    })), this.columnAnimationService.finish();
  }
  // does an action on a set of columns. provides common functionality for looking up the
  // columns based on key, getting a list of effected columns, and then updated the event
  // with either one column (if it was just one col) or a list of columns
  // used by: autoResize, setVisible, setPinned
  actionOnGridColumns(e, t, i, r) {
    if (br(e))
      return;
    const n = [];
    if (e.forEach((s) => {
      const a = this.getGridColumn(s);
      if (!a)
        return;
      t(a) !== !1 && n.push(a);
    }), !!n.length && (this.updateDisplayedColumns(i), z(r) && r)) {
      const s = r();
      s.columns = n, s.column = n.length === 1 ? n[0] : null, this.eventService.dispatchEvent(s);
    }
  }
  getDisplayedColBefore(e) {
    const t = this.getAllDisplayedColumns(), i = t.indexOf(e);
    return i > 0 ? t[i - 1] : null;
  }
  // used by:
  // + rowRenderer -> for navigation
  getDisplayedColAfter(e) {
    const t = this.getAllDisplayedColumns(), i = t.indexOf(e);
    return i < t.length - 1 ? t[i + 1] : null;
  }
  getDisplayedGroupAfter(e) {
    return this.getDisplayedGroupAtDirection(e, "After");
  }
  getDisplayedGroupBefore(e) {
    return this.getDisplayedGroupAtDirection(e, "Before");
  }
  getDisplayedGroupAtDirection(e, t) {
    const i = e.getProvidedColumnGroup().getLevel() + e.getPaddingLevel(), r = e.getDisplayedLeafColumns(), n = t === "After" ? at(r) : r[0], s = `getDisplayedCol${t}`;
    for (; ; ) {
      const a = this[s](n);
      if (!a)
        return null;
      const l = this.getColumnGroupAtLevel(a, i);
      if (l !== e)
        return l;
    }
  }
  getColumnGroupAtLevel(e, t) {
    let i = e.getParent(), r, n;
    for (; r = i.getProvidedColumnGroup().getLevel(), n = i.getPaddingLevel(), !(r + n <= t); )
      i = i.getParent();
    return i;
  }
  isPinningLeft() {
    return this.displayedColumnsLeft.length > 0;
  }
  isPinningRight() {
    return this.displayedColumnsRight.length > 0;
  }
  getPrimaryAndSecondaryAndAutoColumns() {
    return [].concat(this.primaryColumns || [], this.groupAutoColumns || [], this.secondaryColumns || []);
  }
  createStateItemFromColumn(e) {
    const t = e.isRowGroupActive() ? this.rowGroupColumns.indexOf(e) : null, i = e.isPivotActive() ? this.pivotColumns.indexOf(e) : null, r = e.isValueActive() ? e.getAggFunc() : null, n = e.getSort() != null ? e.getSort() : null, s = e.getSortIndex() != null ? e.getSortIndex() : null, a = e.getFlex() != null && e.getFlex() > 0 ? e.getFlex() : null;
    return {
      colId: e.getColId(),
      width: e.getActualWidth(),
      hide: !e.isVisible(),
      pinned: e.getPinned(),
      sort: n,
      sortIndex: s,
      aggFunc: r,
      rowGroup: e.isRowGroupActive(),
      rowGroupIndex: t,
      pivot: e.isPivotActive(),
      pivotIndex: i,
      flex: a
    };
  }
  getColumnState() {
    if (Se(this.primaryColumns) || !this.isAlive())
      return [];
    const t = this.getPrimaryAndSecondaryAndAutoColumns().map(this.createStateItemFromColumn.bind(this));
    return this.orderColumnStateList(t), t;
  }
  orderColumnStateList(e) {
    const t = us(this.gridColumns.map((i, r) => [i.getColId(), r]));
    e.sort((i, r) => {
      const n = t.has(i.colId) ? t.get(i.colId) : -1, s = t.has(r.colId) ? t.get(r.colId) : -1;
      return n - s;
    });
  }
  resetColumnState(e = "api") {
    const t = this.getColumnsFromTree(this.primaryColumnTree), i = [];
    let r = 1e3, n = 1e3, s = [];
    this.groupAutoColumns && (s = s.concat(this.groupAutoColumns)), t && (s = s.concat(t)), s.forEach((a) => {
      const l = this.getColumnStateFromColDef(a);
      Se(l.rowGroupIndex) && l.rowGroup && (l.rowGroupIndex = r++), Se(l.pivotIndex) && l.pivot && (l.pivotIndex = n++), i.push(l);
    }), this.applyColumnState({ state: i, applyOrder: !0 }, e);
  }
  getColumnStateFromColDef(e) {
    const t = (g, v) => g != null ? g : v != null ? v : null, i = e.getColDef(), r = t(i.sort, i.initialSort), n = t(i.sortIndex, i.initialSortIndex), s = t(i.hide, i.initialHide), a = t(i.pinned, i.initialPinned), l = t(i.width, i.initialWidth), c = t(i.flex, i.initialFlex);
    let d = t(i.rowGroupIndex, i.initialRowGroupIndex), u = t(i.rowGroup, i.initialRowGroup);
    d == null && (u == null || u == !1) && (d = null, u = null);
    let h = t(i.pivotIndex, i.initialPivotIndex), p = t(i.pivot, i.initialPivot);
    h == null && (p == null || p == !1) && (h = null, p = null);
    const f = t(i.aggFunc, i.initialAggFunc);
    return {
      colId: e.getColId(),
      sort: r,
      sortIndex: n,
      hide: s,
      pinned: a,
      width: l,
      flex: c,
      rowGroup: u,
      rowGroupIndex: d,
      pivot: p,
      pivotIndex: h,
      aggFunc: f
    };
  }
  applyColumnState(e, t) {
    if (br(this.primaryColumns))
      return !1;
    if (e && e.state && !e.state.forEach)
      return console.warn("AG Grid: applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state."), !1;
    const i = (s, a, l) => {
      const c = this.compareColumnStatesAndDispatchEvents(t);
      this.autoGroupsNeedBuilding = !0;
      const d = a.slice(), u = {}, h = {}, p = [], f = [];
      let g = 0;
      const v = this.rowGroupColumns.slice(), y = this.pivotColumns.slice();
      s.forEach((E) => {
        const b = E.colId || "";
        if (b.startsWith(bs)) {
          p.push(E), f.push(E);
          return;
        }
        const D = l(b);
        D ? (this.syncColumnWithStateItem(D, E, e.defaultState, u, h, !1, t), Ni(d, D)) : (f.push(E), g += 1);
      });
      const m = (E) => this.syncColumnWithStateItem(E, null, e.defaultState, u, h, !1, t);
      d.forEach(m);
      const C = (E, b, T, D) => {
        const P = E[T.getId()], O = E[D.getId()], M = P != null, _ = O != null;
        if (M && _)
          return P - O;
        if (M)
          return -1;
        if (_)
          return 1;
        const F = b.indexOf(T), I = b.indexOf(D), G = F >= 0, k = I >= 0;
        return G && k ? F - I : G ? -1 : 1;
      };
      this.rowGroupColumns.sort(C.bind(this, u, v)), this.pivotColumns.sort(C.bind(this, h, y)), this.updateGridColumns();
      const R = this.groupAutoColumns ? this.groupAutoColumns.slice() : [];
      return p.forEach((E) => {
        const b = this.getAutoColumn(E.colId);
        Ni(R, b), this.syncColumnWithStateItem(b, E, e.defaultState, null, null, !0, t);
      }), R.forEach(m), this.applyOrderAfterApplyState(e), this.updateDisplayedColumns(t), this.dispatchEverythingChanged(t), c(), { unmatchedAndAutoStates: f, unmatchedCount: g };
    };
    this.columnAnimationService.start();
    let { unmatchedAndAutoStates: r, unmatchedCount: n } = i(e.state || [], this.primaryColumns || [], (s) => this.getPrimaryColumn(s));
    return (r.length > 0 || z(e.defaultState)) && (n = i(r, this.secondaryColumns || [], (s) => this.getSecondaryColumn(s)).unmatchedCount), this.columnAnimationService.finish(), n === 0;
  }
  applyOrderAfterApplyState(e) {
    if (!e.applyOrder || !e.state)
      return;
    let t = [];
    const i = {};
    e.state.forEach((n) => {
      if (!n.colId || i[n.colId])
        return;
      const s = this.gridColumnsMap[n.colId];
      s && (t.push(s), i[n.colId] = !0);
    });
    let r = 0;
    if (this.gridColumns.forEach((n) => {
      const s = n.getColId();
      if (i[s] != null)
        return;
      s.startsWith(bs) ? Nh(t, n, r++) : t.push(n);
    }), t = this.placeLockedColumns(t), !this.doesMovePassMarryChildren(t)) {
      console.warn("AG Grid: Applying column order broke a group where columns should be married together. Applying new order has been discarded.");
      return;
    }
    this.gridColumns = t;
  }
  compareColumnStatesAndDispatchEvents(e) {
    const t = {
      rowGroupColumns: this.rowGroupColumns.slice(),
      pivotColumns: this.pivotColumns.slice(),
      valueColumns: this.valueColumns.slice()
    }, i = this.getColumnState(), r = {};
    return i.forEach((n) => {
      r[n.colId] = n;
    }), () => {
      const n = this.getPrimaryAndSecondaryAndAutoColumns(), s = (g, v, y, m) => {
        const C = v.map(m), R = y.map(m);
        if (ia(C, R))
          return;
        const b = {
          type: g,
          columns: y,
          column: y.length === 1 ? y[0] : null,
          source: e
        };
        this.eventService.dispatchEvent(b);
      }, a = (g) => {
        const v = [];
        return n.forEach((y) => {
          const m = r[y.getColId()];
          m && g(m, y) && v.push(y);
        }), v;
      }, l = (g) => g.getColId();
      s(w.EVENT_COLUMN_ROW_GROUP_CHANGED, t.rowGroupColumns, this.rowGroupColumns, l), s(w.EVENT_COLUMN_PIVOT_CHANGED, t.pivotColumns, this.pivotColumns, l), a((g, v) => {
        const y = g.aggFunc != null, m = y != v.isValueActive(), C = y && g.aggFunc != v.getAggFunc();
        return m || C;
      }).length > 0 && this.dispatchColumnChangedEvent(w.EVENT_COLUMN_VALUE_CHANGED, this.valueColumns, e);
      const u = (g, v) => g.width != v.getActualWidth();
      this.dispatchColumnResizedEvent(a(u), !0, e);
      const h = (g, v) => g.pinned != v.getPinned();
      this.dispatchColumnPinnedEvent(a(h), e);
      const p = (g, v) => g.hide == v.isVisible();
      this.dispatchColumnVisibleEvent(a(p), e), a((g, v) => g.sort != v.getSort() || g.sortIndex != v.getSortIndex()).length > 0 && this.sortController.dispatchSortChangedEvents(e), this.normaliseColumnMovedEventForColumnState(i, e);
    };
  }
  getCommonValue(e, t) {
    if (!e || e.length == 0)
      return;
    const i = t(e[0]);
    for (let r = 1; r < e.length; r++)
      if (i !== t(e[r]))
        return;
    return i;
  }
  normaliseColumnMovedEventForColumnState(e, t) {
    const i = this.getColumnState(), r = {};
    i.forEach((c) => r[c.colId] = c);
    const n = {};
    e.forEach((c) => {
      r[c.colId] && (n[c.colId] = !0);
    });
    const s = e.filter((c) => n[c.colId]), a = i.filter((c) => n[c.colId]), l = [];
    a.forEach((c, d) => {
      const u = s && s[d];
      if (u && u.colId !== c.colId) {
        const h = this.getGridColumn(u.colId);
        h && l.push(h);
      }
    }), l.length && this.dispatchColumnMovedEvent({ movedColumns: l, source: t, finished: !0 });
  }
  syncColumnWithStateItem(e, t, i, r, n, s, a) {
    if (!e)
      return;
    const l = (E, b) => {
      const T = { value1: void 0, value2: void 0 };
      let D = !1;
      return t && (t[E] !== void 0 && (T.value1 = t[E], D = !0), z(b) && t[b] !== void 0 && (T.value2 = t[b], D = !0)), !D && i && (i[E] !== void 0 && (T.value1 = i[E]), z(b) && i[b] !== void 0 && (T.value2 = i[b])), T;
    }, c = l("hide").value1;
    c !== void 0 && e.setVisible(!c, a);
    const d = l("pinned").value1;
    d !== void 0 && e.setPinned(d);
    const u = this.columnUtils.calculateColMinWidth(e.getColDef()), h = l("flex").value1;
    if (h !== void 0 && e.setFlex(h), e.getFlex() <= 0) {
      const E = l("width").value1;
      E != null && u != null && E >= u && e.setActualWidth(E, a);
    }
    const f = l("sort").value1;
    f !== void 0 && (f === "desc" || f === "asc" ? e.setSort(f, a) : e.setSort(void 0, a));
    const g = l("sortIndex").value1;
    if (g !== void 0 && e.setSortIndex(g), s || !e.isPrimary())
      return;
    const v = l("aggFunc").value1;
    v !== void 0 && (typeof v == "string" ? (e.setAggFunc(v), e.isValueActive() || (e.setValueActive(!0, a), this.valueColumns.push(e))) : (z(v) && console.warn("AG Grid: stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON."), e.isValueActive() && (e.setValueActive(!1, a), Ni(this.valueColumns, e))));
    const { value1: y, value2: m } = l("rowGroup", "rowGroupIndex");
    (y !== void 0 || m !== void 0) && (typeof m == "number" || y ? (e.isRowGroupActive() || (e.setRowGroupActive(!0, a), this.rowGroupColumns.push(e)), r && typeof m == "number" && (r[e.getId()] = m)) : e.isRowGroupActive() && (e.setRowGroupActive(!1, a), Ni(this.rowGroupColumns, e)));
    const { value1: C, value2: R } = l("pivot", "pivotIndex");
    (C !== void 0 || R !== void 0) && (typeof R == "number" || C ? (e.isPivotActive() || (e.setPivotActive(!0, a), this.pivotColumns.push(e)), n && typeof R == "number" && (n[e.getId()] = R)) : e.isPivotActive() && (e.setPivotActive(!1, a), Ni(this.pivotColumns, e)));
  }
  getGridColumns(e) {
    return this.getColumns(e, this.getGridColumn.bind(this));
  }
  getColumns(e, t) {
    const i = [];
    return e && e.forEach((r) => {
      const n = t(r);
      n && i.push(n);
    }), i;
  }
  // used by growGroupPanel
  getColumnWithValidation(e) {
    if (e == null)
      return null;
    const t = this.getGridColumn(e);
    return t || console.warn("AG Grid: could not find column " + e), t;
  }
  getPrimaryColumn(e) {
    return this.primaryColumns ? this.getColumn(e, this.primaryColumns, this.primaryColumnsMap) : null;
  }
  getGridColumn(e) {
    return this.getColumn(e, this.gridColumns, this.gridColumnsMap);
  }
  getSecondaryColumn(e) {
    return this.secondaryColumns ? this.getColumn(e, this.secondaryColumns, this.secondaryColumnsMap) : null;
  }
  getColumn(e, t, i) {
    if (!e)
      return null;
    if (typeof e == "string" && i[e])
      return i[e];
    for (let r = 0; r < t.length; r++)
      if (this.columnsMatch(t[r], e))
        return t[r];
    return this.getAutoColumn(e);
  }
  getSourceColumnsForGroupColumn(e) {
    const t = e.getColDef().showRowGroup;
    if (!t)
      return null;
    if (t === !0)
      return this.rowGroupColumns.slice(0);
    const i = this.getPrimaryColumn(t);
    return i ? [i] : null;
  }
  getAutoColumn(e) {
    return !this.groupAutoColumns || !z(this.groupAutoColumns) || Se(this.groupAutoColumns) ? null : this.groupAutoColumns.find((t) => this.columnsMatch(t, e)) || null;
  }
  columnsMatch(e, t) {
    const i = e === t, r = e.getColDef() === t, n = e.getColId() == t;
    return i || r || n;
  }
  getDisplayNameForColumn(e, t, i = !1) {
    if (!e)
      return null;
    const r = this.getHeaderName(e.getColDef(), e, null, null, t);
    return i ? this.wrapHeaderNameWithAggFunc(e, r) : r;
  }
  getDisplayNameForProvidedColumnGroup(e, t, i) {
    const r = t ? t.getColGroupDef() : null;
    return r ? this.getHeaderName(r, null, e, t, i) : null;
  }
  getDisplayNameForColumnGroup(e, t) {
    return this.getDisplayNameForProvidedColumnGroup(e, e.getProvidedColumnGroup(), t);
  }
  // location is where the column is going to appear, ie who is calling us
  getHeaderName(e, t, i, r, n) {
    const s = e.headerValueGetter;
    if (s) {
      const a = {
        colDef: e,
        column: t,
        columnGroup: i,
        providedColumnGroup: r,
        location: n,
        api: this.gridOptionsService.api,
        columnApi: this.gridOptionsService.columnApi,
        context: this.gridOptionsService.context
      };
      return typeof s == "function" ? s(a) : typeof s == "string" ? this.expressionService.evaluate(s, a) : (console.warn("AG Grid: headerValueGetter must be a function or a string"), "");
    } else {
      if (e.headerName != null)
        return e.headerName;
      if (e.field)
        return iT(e.field);
    }
    return "";
  }
  wrapHeaderNameWithAggFunc(e, t) {
    if (this.gridOptionsService.is("suppressAggFuncInHeader"))
      return t;
    const i = e.getColDef().pivotValueColumn, r = z(i);
    let n = null, s;
    if (r) {
      const a = this.gridOptionsService.is("removePivotHeaderRowWhenSingleValueColumn") && this.valueColumns.length === 1, l = e.getColDef().pivotTotalColumnIds !== void 0;
      if (a && !l)
        return t;
      n = i ? i.getAggFunc() : null, s = !0;
    } else {
      const a = e.isValueActive(), l = this.pivotMode || !this.isRowGroupEmpty();
      a && l ? (n = e.getAggFunc(), s = !0) : s = !1;
    }
    if (s) {
      const a = typeof n == "string" ? n : "func";
      return `${this.localeService.getLocaleTextFunc()(a, a)}(${t})`;
    }
    return t;
  }
  // returns the group with matching colId and instanceId. If instanceId is missing,
  // matches only on the colId.
  getColumnGroup(e, t) {
    if (!e)
      return null;
    if (e instanceof pt)
      return e;
    const i = this.getAllDisplayedTrees(), r = typeof t == "number";
    let n = null;
    return this.columnUtils.depthFirstAllColumnTreeSearch(i, (s) => {
      if (s instanceof pt) {
        const a = s;
        let l;
        r ? l = e === a.getGroupId() && t === a.getPartId() : l = e === a.getGroupId(), l && (n = a);
      }
    }), n;
  }
  isReady() {
    return this.ready;
  }
  extractValueColumns(e, t) {
    this.valueColumns = this.extractColumns(
      t,
      this.valueColumns,
      (i, r) => i.setValueActive(r, e),
      // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null
      () => {
      },
      () => {
      },
      // aggFunc is a string, so return it's existence
      (i) => {
        const r = i.aggFunc;
        if (r === null || r === "")
          return null;
        if (r !== void 0)
          return !!r;
      },
      (i) => i.initialAggFunc != null && i.initialAggFunc != ""
    ), this.valueColumns.forEach((i) => {
      const r = i.getColDef();
      r.aggFunc != null && r.aggFunc != "" ? i.setAggFunc(r.aggFunc) : i.getAggFunc() || i.setAggFunc(r.initialAggFunc);
    });
  }
  extractRowGroupColumns(e, t) {
    this.rowGroupColumns = this.extractColumns(t, this.rowGroupColumns, (i, r) => i.setRowGroupActive(r, e), (i) => i.rowGroupIndex, (i) => i.initialRowGroupIndex, (i) => i.rowGroup, (i) => i.initialRowGroup);
  }
  extractColumns(e = [], t = [], i, r, n, s, a) {
    const l = [], c = [];
    (this.primaryColumns || []).forEach((h) => {
      const p = e.indexOf(h) < 0, f = h.getColDef(), g = po(s(f)), v = po(a(f)), y = sn(r(f)), m = sn(n(f));
      let C;
      g !== void 0 ? C = g : y !== void 0 ? y === null ? C = !1 : C = y >= 0 : p ? v !== void 0 ? C = v : m !== void 0 ? C = m != null && m >= 0 : C = !1 : C = t.indexOf(h) >= 0, C && ((p ? y != null || m != null : y != null) ? l.push(h) : c.push(h));
    });
    const d = (h) => {
      const p = r(h.getColDef()), f = n(h.getColDef());
      return p != null ? p : f;
    };
    l.sort((h, p) => {
      const f = d(h), g = d(p);
      return f === g ? 0 : f < g ? -1 : 1;
    });
    const u = [].concat(l);
    return t.forEach((h) => {
      c.indexOf(h) >= 0 && u.push(h);
    }), c.forEach((h) => {
      u.indexOf(h) < 0 && u.push(h);
    }), t.forEach((h) => {
      u.indexOf(h) < 0 && i(h, !1);
    }), u.forEach((h) => {
      t.indexOf(h) < 0 && i(h, !0);
    }), u;
  }
  extractPivotColumns(e, t) {
    this.pivotColumns = this.extractColumns(t, this.pivotColumns, (i, r) => i.setPivotActive(r, e), (i) => i.pivotIndex, (i) => i.initialPivotIndex, (i) => i.pivot, (i) => i.initialPivot);
  }
  resetColumnGroupState(e = "api") {
    const t = [];
    this.columnUtils.depthFirstOriginalTreeSearch(null, this.primaryColumnTree, (i) => {
      if (i instanceof Be) {
        const r = i.getColGroupDef(), n = {
          groupId: i.getGroupId(),
          open: r ? r.openByDefault : void 0
        };
        t.push(n);
      }
    }), this.setColumnGroupState(t, e);
  }
  getColumnGroupState() {
    const e = [];
    return this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, (t) => {
      t instanceof Be && e.push({
        groupId: t.getGroupId(),
        open: t.isExpanded()
      });
    }), e;
  }
  setColumnGroupState(e, t = "api") {
    this.columnAnimationService.start();
    const i = [];
    e.forEach((r) => {
      const n = r.groupId, s = r.open, a = this.getProvidedColumnGroup(n);
      a && a.isExpanded() !== s && (this.logger.log("columnGroupOpened(" + a.getGroupId() + "," + s + ")"), a.setExpanded(s), i.push(a));
    }), this.updateGroupsAndDisplayedColumns(t), this.setFirstRightAndLastLeftPinned(t), i.forEach((r) => {
      const n = {
        type: w.EVENT_COLUMN_GROUP_OPENED,
        columnGroup: r
      };
      this.eventService.dispatchEvent(n);
    }), this.columnAnimationService.finish();
  }
  // called by headerRenderer - when a header is opened or closed
  setColumnGroupOpened(e, t, i = "api") {
    let r;
    e instanceof Be ? r = e.getId() : r = e || "", this.setColumnGroupState([{ groupId: r, open: t }], i);
  }
  getProvidedColumnGroup(e) {
    typeof e != "string" && console.error("AG Grid: group key must be a string");
    let t = null;
    return this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, (i) => {
      i instanceof Be && i.getId() === e && (t = i);
    }), t;
  }
  calculateColumnsForDisplay() {
    let e;
    return this.pivotMode && Se(this.secondaryColumns) ? e = this.gridColumns.filter((t) => {
      const i = this.groupAutoColumns && ln(this.groupAutoColumns, t), r = this.valueColumns && ln(this.valueColumns, t);
      return i || r;
    }) : e = this.gridColumns.filter((t) => this.groupAutoColumns && ln(this.groupAutoColumns, t) || t.isVisible()), e;
  }
  checkColSpanActiveInCols(e) {
    let t = !1;
    return e.forEach((i) => {
      z(i.getColDef().colSpan) && (t = !0);
    }), t;
  }
  calculateColumnsForGroupDisplay() {
    this.groupDisplayColumns = [], this.groupDisplayColumnsMap = {};
    const e = (t) => {
      const i = t.getColDef(), r = i.showRowGroup;
      i && z(r) && (this.groupDisplayColumns.push(t), typeof r == "string" ? this.groupDisplayColumnsMap[r] = t : r === !0 && this.getRowGroupColumns().forEach((n) => {
        this.groupDisplayColumnsMap[n.getId()] = t;
      }));
    };
    this.gridColumns.forEach(e);
  }
  getGroupDisplayColumns() {
    return this.groupDisplayColumns;
  }
  getGroupDisplayColumnForGroup(e) {
    return this.groupDisplayColumnsMap[e];
  }
  updateDisplayedColumns(e) {
    const t = this.calculateColumnsForDisplay();
    this.buildDisplayedTrees(t), this.updateGroupsAndDisplayedColumns(e), this.setFirstRightAndLastLeftPinned(e);
  }
  isSecondaryColumnsPresent() {
    return z(this.secondaryColumns);
  }
  setSecondaryColumns(e, t = "api") {
    const i = e && e.length > 0;
    if (!(!i && Se(this.secondaryColumns))) {
      if (i) {
        this.processSecondaryColumnDefinitions(e);
        const r = this.columnFactory.createColumnTree(e, !1, this.secondaryBalancedTree || this.previousSecondaryColumns || void 0);
        this.destroyOldColumns(this.secondaryBalancedTree, r.columnTree), this.secondaryBalancedTree = r.columnTree, this.secondaryHeaderRowCount = r.treeDept + 1, this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree), this.secondaryColumnsMap = {}, this.secondaryColumns.forEach((n) => this.secondaryColumnsMap[n.getId()] = n), this.previousSecondaryColumns = null;
      } else
        this.previousSecondaryColumns = this.secondaryBalancedTree, this.secondaryBalancedTree = null, this.secondaryHeaderRowCount = -1, this.secondaryColumns = null, this.secondaryColumnsMap = {};
      this.updateGridColumns(), this.updateDisplayedColumns(t);
    }
  }
  processSecondaryColumnDefinitions(e) {
    const t = this.gridOptionsService.get("processPivotResultColDef") || this.gridOptionsService.get("processSecondaryColDef"), i = this.gridOptionsService.get("processPivotResultColGroupDef") || this.gridOptionsService.get("processSecondaryColGroupDef");
    if (!t && !i)
      return;
    const r = (n) => {
      n.forEach((s) => {
        if (z(s.children)) {
          const l = s;
          i && i(l), r(l.children);
        } else
          t && t(s);
      });
    };
    e && r(e);
  }
  // called from: applyColumnState, setColumnDefs, setSecondaryColumns
  updateGridColumns() {
    const e = this.gridBalancedTree;
    this.gridColsArePrimary ? this.lastPrimaryOrder = this.gridColumns : this.lastSecondaryOrder = this.gridColumns;
    let t;
    if (this.secondaryColumns && this.secondaryBalancedTree) {
      const r = this.secondaryColumns.every((n) => this.gridColumnsMap[n.getColId()] !== void 0);
      this.gridBalancedTree = this.secondaryBalancedTree.slice(), this.gridHeaderRowCount = this.secondaryHeaderRowCount, this.gridColumns = this.secondaryColumns.slice(), this.gridColsArePrimary = !1, r && (t = this.lastSecondaryOrder);
    } else
      this.primaryColumns && (this.gridBalancedTree = this.primaryColumnTree.slice(), this.gridHeaderRowCount = this.primaryHeaderRowCount, this.gridColumns = this.primaryColumns.slice(), this.gridColsArePrimary = !0, t = this.lastPrimaryOrder);
    if (this.createGroupAutoColumnsIfNeeded() && t) {
      const r = us(this.groupAutoColumns.map((n) => [n, !0]));
      t = t.filter((n) => !r.has(n)), t = [...this.groupAutoColumns, ...t];
    }
    if (this.addAutoGroupToGridColumns(), this.orderGridColsLike(t), this.gridColumns = this.placeLockedColumns(this.gridColumns), this.calculateColumnsForGroupDisplay(), this.refreshQuickFilterColumns(), this.clearDisplayedAndViewportColumns(), this.colSpanActive = this.checkColSpanActiveInCols(this.gridColumns), this.gridColumnsMap = {}, this.gridColumns.forEach((r) => this.gridColumnsMap[r.getId()] = r), this.setAutoHeightActive(), !ia(e, this.gridBalancedTree)) {
      const r = {
        type: w.EVENT_GRID_COLUMNS_CHANGED
      };
      this.eventService.dispatchEvent(r);
    }
  }
  setAutoHeightActive() {
    if (this.autoHeightActive = this.gridColumns.filter((e) => e.isAutoHeight()).length > 0, this.autoHeightActive && (this.autoHeightActiveAtLeastOnce = !0, !(this.gridOptionsService.isRowModelType("clientSide") || this.gridOptionsService.isRowModelType("serverSide")))) {
      const t = "AG Grid - autoHeight columns only work with Client Side Row Model and Server Side Row Model.";
      tt(() => console.warn(t), "autoHeightActive.wrongRowModel");
    }
  }
  orderGridColsLike(e) {
    if (Se(e))
      return;
    const t = us(e.map((c, d) => [c, d]));
    let i = !0;
    if (this.gridColumns.forEach((c) => {
      t.has(c) && (i = !1);
    }), i)
      return;
    const r = us(this.gridColumns.map((c) => [c, !0])), n = e.filter((c) => r.has(c)), s = us(n.map((c) => [c, !0])), a = this.gridColumns.filter((c) => !s.has(c)), l = n.slice();
    a.forEach((c) => {
      let d = c.getOriginalParent();
      if (!d) {
        l.push(c);
        return;
      }
      const u = [];
      for (; !u.length && d; )
        d.getLeafColumns().forEach((g) => {
          const v = l.indexOf(g) >= 0, y = u.indexOf(g) < 0;
          v && y && u.push(g);
        }), d = d.getOriginalParent();
      if (!u.length) {
        l.push(c);
        return;
      }
      const h = u.map((f) => l.indexOf(f)), p = Math.max(...h);
      Nh(l, c, p + 1);
    }), this.gridColumns = l;
  }
  isPrimaryColumnGroupsPresent() {
    return this.primaryHeaderRowCount > 1;
  }
  // if we are using autoGroupCols, then they should be included for quick filter. this covers the
  // following scenarios:
  // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on
  // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this
  //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)
  refreshQuickFilterColumns() {
    var e;
    let t = (e = this.isPivotMode() ? this.secondaryColumns : this.primaryColumns) !== null && e !== void 0 ? e : [];
    this.groupAutoColumns && (t = t.concat(this.groupAutoColumns)), this.columnsForQuickFilter = this.gridOptionsService.is("includeHiddenColumnsInQuickFilter") ? t : t.filter((i) => i.isVisible() || i.isRowGroupActive());
  }
  placeLockedColumns(e) {
    const t = [], i = [], r = [];
    return e.forEach((n) => {
      const s = n.getColDef().lockPosition;
      s === "right" ? r.push(n) : s === "left" || s === !0 ? t.push(n) : i.push(n);
    }), [...t, ...i, ...r];
  }
  addAutoGroupToGridColumns() {
    if (Se(this.groupAutoColumns)) {
      this.destroyOldColumns(this.groupAutoColsBalancedTree), this.groupAutoColsBalancedTree = null;
      return;
    }
    this.gridColumns = this.groupAutoColumns ? this.groupAutoColumns.concat(this.gridColumns) : this.gridColumns;
    const e = this.columnFactory.createForAutoGroups(this.groupAutoColumns, this.gridBalancedTree);
    this.destroyOldColumns(this.groupAutoColsBalancedTree, e), this.groupAutoColsBalancedTree = e, this.gridBalancedTree = e.concat(this.gridBalancedTree);
  }
  // gets called after we copy down grid columns, to make sure any part of the gui
  // that tries to draw, eg the header, it will get empty lists of columns rather
  // than stale columns. for example, the header will received gridColumnsChanged
  // event, so will try and draw, but it will draw successfully when it acts on the
  // virtualColumnsChanged event
  clearDisplayedAndViewportColumns() {
    this.viewportRowLeft = {}, this.viewportRowRight = {}, this.viewportRowCenter = {}, this.displayedColumnsLeft = [], this.displayedColumnsRight = [], this.displayedColumnsCenter = [], this.displayedColumns = [], this.viewportColumns = [], this.headerViewportColumns = [], this.viewportColumnsHash = "";
  }
  updateGroupsAndDisplayedColumns(e) {
    this.updateOpenClosedVisibilityInColumnGroups(), this.deriveDisplayedColumns(e), this.refreshFlexedColumns(), this.extractViewport(), this.updateBodyWidths();
    const t = {
      type: w.EVENT_DISPLAYED_COLUMNS_CHANGED
    };
    this.eventService.dispatchEvent(t);
  }
  deriveDisplayedColumns(e) {
    this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeLeft, this.displayedColumnsLeft), this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeCentre, this.displayedColumnsCenter), this.derivedDisplayedColumnsFromDisplayedTree(this.displayedTreeRight, this.displayedColumnsRight), this.joinDisplayedColumns(), this.setLeftValues(e), this.displayedAutoHeightCols = this.displayedColumns.filter((t) => t.isAutoHeight());
  }
  isAutoRowHeightActive() {
    return this.autoHeightActive;
  }
  wasAutoRowHeightEverActive() {
    return this.autoHeightActiveAtLeastOnce;
  }
  joinDisplayedColumns() {
    this.gridOptionsService.is("enableRtl") ? this.displayedColumns = this.displayedColumnsRight.concat(this.displayedColumnsCenter).concat(this.displayedColumnsLeft) : this.displayedColumns = this.displayedColumnsLeft.concat(this.displayedColumnsCenter).concat(this.displayedColumnsRight);
  }
  // sets the left pixel position of each column
  setLeftValues(e) {
    this.setLeftValuesOfColumns(e), this.setLeftValuesOfGroups();
  }
  setLeftValuesOfColumns(e) {
    if (!this.primaryColumns)
      return;
    const t = this.primaryColumns.slice(0), i = this.gridOptionsService.is("enableRtl");
    [
      this.displayedColumnsLeft,
      this.displayedColumnsRight,
      this.displayedColumnsCenter
    ].forEach((r) => {
      if (i) {
        let n = this.getWidthOfColsInList(r);
        r.forEach((s) => {
          n -= s.getActualWidth(), s.setLeft(n, e);
        });
      } else {
        let n = 0;
        r.forEach((s) => {
          s.setLeft(n, e), n += s.getActualWidth();
        });
      }
      CS(t, r);
    }), t.forEach((r) => {
      r.setLeft(null, e);
    });
  }
  setLeftValuesOfGroups() {
    [
      this.displayedTreeLeft,
      this.displayedTreeRight,
      this.displayedTreeCentre
    ].forEach((e) => {
      e.forEach((t) => {
        t instanceof pt && t.checkLeft();
      });
    });
  }
  derivedDisplayedColumnsFromDisplayedTree(e, t) {
    t.length = 0, this.columnUtils.depthFirstDisplayedColumnTreeSearch(e, (i) => {
      i instanceof me && t.push(i);
    });
  }
  extractViewportColumns() {
    this.suppressColumnVirtualisation ? (this.viewportColumnsCenter = this.displayedColumnsCenter, this.headerViewportColumnsCenter = this.displayedColumnsCenter) : (this.viewportColumnsCenter = this.displayedColumnsCenter.filter(this.isColumnInRowViewport.bind(this)), this.headerViewportColumnsCenter = this.displayedColumnsCenter.filter(this.isColumnInHeaderViewport.bind(this))), this.viewportColumns = this.viewportColumnsCenter.concat(this.displayedColumnsLeft).concat(this.displayedColumnsRight), this.headerViewportColumns = this.headerViewportColumnsCenter.concat(this.displayedColumnsLeft).concat(this.displayedColumnsRight);
  }
  getVirtualHeaderGroupRow(e, t) {
    let i;
    switch (e) {
      case "left":
        i = this.viewportRowLeft[t];
        break;
      case "right":
        i = this.viewportRowRight[t];
        break;
      default:
        i = this.viewportRowCenter[t];
        break;
    }
    return Se(i) && (i = []), i;
  }
  calculateHeaderRows() {
    this.viewportRowLeft = {}, this.viewportRowRight = {}, this.viewportRowCenter = {};
    const e = {};
    this.headerViewportColumns.forEach((i) => e[i.getId()] = !0);
    const t = (i, r, n) => {
      let s = !1;
      for (let a = 0; a < i.length; a++) {
        const l = i[a];
        let c = !1;
        if (l instanceof me)
          c = e[l.getId()] === !0;
        else {
          const u = l.getDisplayedChildren();
          u && (c = t(u, r, n + 1));
        }
        c && (s = !0, r[n] || (r[n] = []), r[n].push(l));
      }
      return s;
    };
    t(this.displayedTreeLeft, this.viewportRowLeft, 0), t(this.displayedTreeRight, this.viewportRowRight, 0), t(this.displayedTreeCentre, this.viewportRowCenter, 0);
  }
  extractViewport() {
    const e = (r) => `${r.getId()}-${r.getPinned() || "normal"}`;
    this.extractViewportColumns();
    const t = this.viewportColumns.map(e).join("#"), i = this.viewportColumnsHash !== t;
    return i && (this.viewportColumnsHash = t, this.calculateHeaderRows()), i;
  }
  refreshFlexedColumns(e = {}) {
    const t = e.source ? e.source : "flex";
    if (e.viewportWidth != null && (this.flexViewportWidth = e.viewportWidth), !this.flexViewportWidth)
      return [];
    let i = -1;
    e.resizingCols && e.resizingCols.forEach((u) => {
      const h = this.displayedColumnsCenter.indexOf(u);
      i < h && (i = h);
    });
    const r = (u) => {
      const h = this.displayedColumnsCenter.indexOf(u) > i;
      return u.getFlex() && h;
    }, n = this.displayedColumnsCenter.filter((u) => !r(u)), s = this.displayedColumnsCenter.filter((u) => r(u)), a = [];
    if (!s.length)
      return [];
    const l = [];
    let c;
    e:
      for (; ; ) {
        const u = s.reduce((h, p) => h + p.getFlex(), 0);
        c = this.flexViewportWidth - this.getWidthOfColsInList(n);
        for (let h = 0; h < s.length; h++) {
          const p = s[h], f = c * p.getFlex() / u;
          let g = 0;
          const v = p.getMinWidth(), y = p.getMaxWidth();
          if (z(v) && f < v ? g = v : z(y) && f > y && (g = y), g) {
            p.setActualWidth(g, t), Ni(s, p), a.push(p), n.push(p);
            continue e;
          }
          l[h] = Math.round(f);
        }
        break;
      }
    let d = c;
    return s.forEach((u, h) => {
      u.setActualWidth(Math.min(l[h], d), t), a.push(u), d -= l[h];
    }), e.skipSetLeft || this.setLeftValues(t), e.updateBodyWidths && this.updateBodyWidths(), e.fireResizedEvent && this.dispatchColumnResizedEvent(a, !0, t, s), s;
  }
  // called from api
  sizeColumnsToFit(e, t = "sizeColumnsToFit", i, r) {
    var n, s, a, l, c;
    if (this.shouldQueueResizeOperations) {
      this.resizeOperationQueue.push(() => this.sizeColumnsToFit(e, t, i, r));
      return;
    }
    const d = {};
    r && ((n = r == null ? void 0 : r.columnLimits) === null || n === void 0 || n.forEach((m) => {
      var { key: C } = m, R = sF(m, ["key"]);
      d[typeof C == "string" ? C : C.getColId()] = R;
    }));
    const u = this.getAllDisplayedColumns(), h = e === this.getWidthOfColsInList(u);
    if (e <= 0 || !u.length || h)
      return;
    const p = [], f = [];
    u.forEach((m) => {
      m.getColDef().suppressSizeToFit === !0 ? f.push(m) : p.push(m);
    });
    const g = p.slice(0);
    let v = !1;
    const y = (m) => {
      Ni(p, m), f.push(m);
    };
    for (p.forEach((m) => m.resetActualWidth(t)); !v; ) {
      v = !0;
      const m = e - this.getWidthOfColsInList(f);
      if (m <= 0)
        p.forEach((C) => {
          var R, E;
          const b = (E = (R = d == null ? void 0 : d[C.getId()]) === null || R === void 0 ? void 0 : R.minWidth) !== null && E !== void 0 ? E : r == null ? void 0 : r.defaultMinWidth;
          if (typeof b == "number") {
            C.setActualWidth(b);
            return;
          }
          C.setMinimum(t);
        });
      else {
        const C = m / this.getWidthOfColsInList(p);
        let R = m;
        for (let E = p.length - 1; E >= 0; E--) {
          const b = p[E], T = d == null ? void 0 : d[b.getId()], D = (s = T == null ? void 0 : T.minWidth) !== null && s !== void 0 ? s : r == null ? void 0 : r.defaultMinWidth, P = (a = T == null ? void 0 : T.maxWidth) !== null && a !== void 0 ? a : r == null ? void 0 : r.defaultMaxWidth, O = (l = b.getMinWidth()) !== null && l !== void 0 ? l : 0, M = (c = b.getMaxWidth()) !== null && c !== void 0 ? c : Number.MAX_VALUE, _ = typeof D == "number" && D > O ? D : b.getMinWidth(), F = typeof P == "number" && P < M ? P : b.getMaxWidth();
          let I = Math.round(b.getActualWidth() * C);
          z(_) && I < _ ? (I = _, y(b), v = !1) : z(F) && I > F ? (I = F, y(b), v = !1) : E === 0 && (I = R), b.setActualWidth(I, t, !0), R -= I;
        }
      }
    }
    g.forEach((m) => {
      m.fireColumnWidthChangedEvent(t);
    }), this.setLeftValues(t), this.updateBodyWidths(), !i && this.dispatchColumnResizedEvent(g, !0, t);
  }
  buildDisplayedTrees(e) {
    const t = [], i = [], r = [];
    e.forEach((s) => {
      switch (s.getPinned()) {
        case "left":
          t.push(s);
          break;
        case "right":
          i.push(s);
          break;
        default:
          r.push(s);
          break;
      }
    });
    const n = new eT();
    this.displayedTreeLeft = this.displayedGroupCreator.createDisplayedGroups(t, this.gridBalancedTree, n, "left", this.displayedTreeLeft), this.displayedTreeRight = this.displayedGroupCreator.createDisplayedGroups(i, this.gridBalancedTree, n, "right", this.displayedTreeRight), this.displayedTreeCentre = this.displayedGroupCreator.createDisplayedGroups(r, this.gridBalancedTree, n, null, this.displayedTreeCentre), this.updateDisplayedMap();
  }
  updateDisplayedMap() {
    this.displayedColumnsAndGroupsMap = {};
    const e = (t) => {
      this.displayedColumnsAndGroupsMap[t.getUniqueId()] = t;
    };
    this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeCentre, e), this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeLeft, e), this.columnUtils.depthFirstAllColumnTreeSearch(this.displayedTreeRight, e);
  }
  isDisplayed(e) {
    return this.displayedColumnsAndGroupsMap[e.getUniqueId()] === e;
  }
  updateOpenClosedVisibilityInColumnGroups() {
    const e = this.getAllDisplayedTrees();
    this.columnUtils.depthFirstAllColumnTreeSearch(e, (t) => {
      t instanceof pt && t.calculateDisplayedColumns();
    });
  }
  getGroupAutoColumns() {
    return this.groupAutoColumns;
  }
  /**
   * Creates new auto group columns if required
   * @returns whether auto cols have changed
   */
  createGroupAutoColumnsIfNeeded() {
    const e = this.forceRecreateAutoGroups;
    if (this.forceRecreateAutoGroups = !1, !this.autoGroupsNeedBuilding)
      return !1;
    this.autoGroupsNeedBuilding = !1;
    const t = this.gridOptionsService.isGroupUseEntireRow(this.pivotMode), i = this.pivotMode ? this.gridOptionsService.is("pivotSuppressAutoColumn") : this.isGroupSuppressAutoColumn();
    if ((this.rowGroupColumns.length > 0 || this.usingTreeData) && !i && !t) {
      const s = this.groupAutoColumns || [], a = this.autoGroupColService.createAutoGroupColumns(s, this.rowGroupColumns);
      if (!this.autoColsEqual(a, this.groupAutoColumns) || e)
        return this.groupAutoColumns = a, !0;
    } else
      this.groupAutoColumns = null;
    return !1;
  }
  isGroupSuppressAutoColumn() {
    const e = this.gridOptionsService.get("groupDisplayType");
    if (e ? yC("custom", e) : !1)
      return !0;
    const i = this.gridOptionsService.get("treeDataDisplayType");
    return i ? nF("custom", i) : !1;
  }
  autoColsEqual(e, t) {
    return ia(e, t, (i, r) => i.getColId() === r.getColId());
  }
  getWidthOfColsInList(e) {
    return e.reduce((t, i) => t + i.getActualWidth(), 0);
  }
  getGridBalancedTree() {
    return this.gridBalancedTree;
  }
  hasFloatingFilters() {
    return this.gridColumns ? this.gridColumns.some((t) => t.getColDef().floatingFilter) : !1;
  }
  getFirstDisplayedColumn() {
    const e = this.gridOptionsService.is("enableRtl"), t = [
      "getDisplayedLeftColumns",
      "getDisplayedCenterColumns",
      "getDisplayedRightColumns"
    ];
    e && t.reverse();
    for (let i = 0; i < t.length; i++) {
      const r = this[t[i]]();
      if (r.length)
        return e ? at(r) : r[0];
    }
    return null;
  }
  setColumnHeaderHeight(e, t) {
    if (e.setAutoHeaderHeight(t)) {
      const r = {
        type: w.EVENT_COLUMN_HEADER_HEIGHT_CHANGED,
        column: e,
        columns: [e],
        source: "autosizeColumnHeaderHeight"
      };
      this.eventService.dispatchEvent(r);
    }
  }
  getColumnGroupHeaderRowHeight() {
    return this.isPivotMode() ? this.getPivotGroupHeaderHeight() : this.getGroupHeaderHeight();
  }
  getColumnHeaderRowHeight() {
    const e = this.isPivotMode() ? this.getPivotHeaderHeight() : this.getHeaderHeight(), t = this.getAllDisplayedColumns().filter((i) => i.isAutoHeaderHeight()).map((i) => i.getAutoHeaderHeight() || 0);
    return Math.max(e, ...t);
  }
  getHeaderHeight() {
    var e;
    return (e = this.gridOptionsService.getNum("headerHeight")) !== null && e !== void 0 ? e : this.environment.getFromTheme(25, "headerHeight");
  }
  getFloatingFiltersHeight() {
    var e;
    return (e = this.gridOptionsService.getNum("floatingFiltersHeight")) !== null && e !== void 0 ? e : this.getHeaderHeight();
  }
  getGroupHeaderHeight() {
    var e;
    return (e = this.gridOptionsService.getNum("groupHeaderHeight")) !== null && e !== void 0 ? e : this.getHeaderHeight();
  }
  getPivotHeaderHeight() {
    var e;
    return (e = this.gridOptionsService.getNum("pivotHeaderHeight")) !== null && e !== void 0 ? e : this.getHeaderHeight();
  }
  getPivotGroupHeaderHeight() {
    var e;
    return (e = this.gridOptionsService.getNum("pivotGroupHeaderHeight")) !== null && e !== void 0 ? e : this.getGroupHeaderHeight();
  }
  queueResizeOperations() {
    this.shouldQueueResizeOperations = !0;
  }
  processResizeOperations() {
    this.shouldQueueResizeOperations = !1, this.resizeOperationQueue.forEach((e) => e()), this.resizeOperationQueue = [];
  }
  resetColumnDefIntoColumn(e) {
    const t = e.getUserProvidedColDef();
    if (!t)
      return !1;
    const i = this.columnFactory.mergeColDefs(t, e.getColId());
    return e.setColDef(i, t), !0;
  }
  generateColumnStateForRowGroupAndPivotIndexes(e, t) {
    let i = {};
    const r = (n, s, a, l, c, d) => {
      if (!s.length || !this.primaryColumns)
        return [];
      const u = Object.keys(n), h = new Set(u), p = new Set(u), f = new Set(s.map((b) => {
        const T = b.getColId();
        return p.delete(T), T;
      }).concat(u)), g = [], v = {};
      let y = 0;
      for (let b = 0; b < this.primaryColumns.length; b++) {
        const T = this.primaryColumns[b].getColId();
        f.has(T) && (g.push(T), v[T] = y++);
      }
      let m = 1e3, C = !1, R = 0;
      const E = (b) => {
        const T = v[b];
        for (let D = R; D < T; D++) {
          const P = g[D];
          p.has(P) && (n[P][c] = m++, p.delete(P));
        }
        R = T;
      };
      s.forEach((b) => {
        const T = b.getColId();
        if (h.has(T))
          E(T), n[T][c] = m++;
        else {
          const D = b.getColDef();
          (D[c] === null || D[c] === void 0 && D[d] == null) && (C || (D[a] || D[a] === void 0 && D[l] ? E(T) : (p.forEach((M) => {
            n[M][c] = m + v[M];
          }), m += g.length, C = !0)), i[T] || (i[T] = { colId: T }), i[T][c] = m++);
        }
      });
    };
    return r(e, this.rowGroupColumns, "rowGroup", "initialRowGroup", "rowGroupIndex", "initialRowGroupIndex"), r(t, this.pivotColumns, "pivot", "initialPivot", "pivotIndex", "initialPivotIndex"), Object.values(i);
  }
};
Di([
  S("expressionService")
], ti.prototype, "expressionService", void 0);
Di([
  S("columnFactory")
], ti.prototype, "columnFactory", void 0);
Di([
  S("displayedGroupCreator")
], ti.prototype, "displayedGroupCreator", void 0);
Di([
  S("ctrlsService")
], ti.prototype, "ctrlsService", void 0);
Di([
  S("autoWidthCalculator")
], ti.prototype, "autoWidthCalculator", void 0);
Di([
  S("columnUtils")
], ti.prototype, "columnUtils", void 0);
Di([
  S("columnAnimationService")
], ti.prototype, "columnAnimationService", void 0);
Di([
  S("autoGroupColService")
], ti.prototype, "autoGroupColService", void 0);
Di([
  Ve("aggFuncService")
], ti.prototype, "aggFuncService", void 0);
Di([
  Ve("valueCache")
], ti.prototype, "valueCache", void 0);
Di([
  Ve("animationFrameService")
], ti.prototype, "animationFrameService", void 0);
Di([
  S("sortController")
], ti.prototype, "sortController", void 0);
Di([
  S("columnDefFactory")
], ti.prototype, "columnDefFactory", void 0);
Di([
  B
], ti.prototype, "init", null);
Di([
  dt
], ti.prototype, "destroyColumns", null);
Di([
  oF(0, qi("loggerFactory"))
], ti.prototype, "setBeans", null);
ti = Di([
  q("columnModel")
], ti);
var aF = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let CC = class extends H {
  calculateColMinWidth(e) {
    return e.minWidth != null ? e.minWidth : this.environment.getMinColWidth();
  }
  calculateColMaxWidth(e) {
    return e.maxWidth != null ? e.maxWidth : Number.MAX_SAFE_INTEGER;
  }
  calculateColInitialWidth(e) {
    const t = this.calculateColMinWidth(e), i = this.calculateColMaxWidth(e);
    let r;
    const n = sn(e.width), s = sn(e.initialWidth);
    return n != null ? r = n : s != null ? r = s : r = 200, Math.max(Math.min(r, i), t);
  }
  getOriginalPathForColumn(e, t) {
    const i = [];
    let r = !1;
    const n = (s, a) => {
      for (let l = 0; l < s.length; l++) {
        if (r)
          return;
        const c = s[l];
        c instanceof Be ? (n(c.getChildren(), a + 1), i[a] = c) : c === e && (r = !0);
      }
    };
    return n(t, 0), r ? i : null;
  }
  depthFirstOriginalTreeSearch(e, t, i) {
    t && t.forEach((r) => {
      r instanceof Be && this.depthFirstOriginalTreeSearch(r, r.getChildren(), i), i(r, e);
    });
  }
  depthFirstAllColumnTreeSearch(e, t) {
    e && e.forEach((i) => {
      i instanceof pt && this.depthFirstAllColumnTreeSearch(i.getChildren(), t), t(i);
    });
  }
  depthFirstDisplayedColumnTreeSearch(e, t) {
    e && e.forEach((i) => {
      i instanceof pt && this.depthFirstDisplayedColumnTreeSearch(i.getDisplayedChildren(), t), t(i);
    });
  }
};
CC = aF([
  q("columnUtils")
], CC);
var lF = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let SC = class extends H {
  createDisplayedGroups(e, t, i, r, n) {
    const s = [];
    let a, l;
    const c = this.mapOldGroupsById(n);
    return e.forEach((d) => {
      const u = this.getOriginalPathForColumn(t, d), h = [], p = !l;
      for (let g = 0; g < u.length; g++)
        if (p || u[g] !== l[g]) {
          const v = this.createColumnGroup(u[g], i, c, r);
          h[g] = v, g == 0 ? s.push(v) : h[g - 1].addChild(v);
        } else
          h[g] = a[g];
      h.length === 0 ? s.push(d) : at(h).addChild(d), a = h, l = u;
    }), this.setupParentsIntoColumns(s, null), s;
  }
  createColumnGroup(e, t, i, r) {
    const n = e.getGroupId(), s = t.getInstanceIdForKey(n), a = pt.createUniqueId(n, s);
    let l = i[a];
    return l && l.getProvidedColumnGroup() !== e && (l = null), z(l) ? l.reset() : (l = new pt(e, n, s, r), this.context.createBean(l)), l;
  }
  // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup
  mapOldGroupsById(e) {
    const t = {}, i = (r) => {
      r.forEach((n) => {
        if (n instanceof pt) {
          const s = n;
          t[n.getUniqueId()] = s, i(s.getChildren());
        }
      });
    };
    return e && i(e), t;
  }
  setupParentsIntoColumns(e, t) {
    e.forEach((i) => {
      if (i.setParent(t), i instanceof pt) {
        const r = i;
        this.setupParentsIntoColumns(r.getChildren(), r);
      }
    });
  }
  getOriginalPathForColumn(e, t) {
    const i = [];
    let r = !1;
    const n = (s, a) => {
      for (let l = 0; l < s.length; l++) {
        if (r)
          return;
        const c = s[l];
        c instanceof Be ? (n(c.getChildren(), a + 1), i[a] = c) : c === t && (r = !0);
      }
    };
    return n(e, 0), r ? i : (console.warn("AG Grid: could not get path"), null);
  }
};
SC = lF([
  q("displayedGroupCreator")
], SC);
var cF = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let bC = class extends H {
  constructor() {
    super(...arguments), this.componentsMappedByName = {};
  }
  setupComponents(e) {
    e && e.forEach((t) => this.addComponent(t));
  }
  addComponent(e) {
    const i = e.componentName.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase().toUpperCase();
    this.componentsMappedByName[i] = e.componentClass;
  }
  getComponentClass(e) {
    return this.componentsMappedByName[e];
  }
};
bC = cF([
  q("agStackComponentsRegistry")
], bC);
function No(o, e, t) {
  t == null || t == "" ? ES(o, e) : Cn(o, e, t);
}
function Cn(o, e, t) {
  o.setAttribute(oT(e), t.toString());
}
function ES(o, e) {
  o.removeAttribute(oT(e));
}
function oT(o) {
  return `aria-${o}`;
}
function ci(o, e) {
  e ? o.setAttribute("role", e) : o.removeAttribute("role");
}
function sT(o) {
  let e;
  return o === "asc" ? e = "ascending" : o === "desc" ? e = "descending" : o === "mixed" ? e = "other" : e = "none", e;
}
function aT(o) {
  return parseInt(o.getAttribute("aria-level"), 10);
}
function lT(o) {
  return parseInt(o.getAttribute("aria-posinset"), 10);
}
function dF(o) {
  return o.getAttribute("aria-describedby") || "";
}
function Ia(o, e) {
  No(o, "label", e);
}
function Lv(o, e) {
  No(o, "labelledby", e);
}
function cT(o, e) {
  No(o, "description", e);
}
function dT(o, e) {
  No(o, "describedby", e);
}
function uT(o, e) {
  No(o, "live", e);
}
function hT(o, e) {
  No(o, "level", e);
}
function RS(o, e) {
  No(o, "disabled", e);
}
function Nv(o, e) {
  No(o, "hidden", e);
}
function Ln(o, e) {
  Cn(o, "expanded", e);
}
function pT(o) {
  ES(o, "expanded");
}
function TS(o, e) {
  Cn(o, "setsize", e);
}
function xS(o, e) {
  Cn(o, "posinset", e);
}
function fT(o, e) {
  Cn(o, "multiselectable", e);
}
function gT(o, e) {
  Cn(o, "rowcount", e);
}
function DS(o, e) {
  Cn(o, "rowindex", e);
}
function vT(o, e) {
  Cn(o, "colcount", e);
}
function OS(o, e) {
  Cn(o, "colindex", e);
}
function mT(o, e) {
  Cn(o, "colspan", e);
}
function yT(o, e) {
  Cn(o, "sort", e);
}
function CT(o) {
  ES(o, "sort");
}
function _d(o, e) {
  No(o, "selected", e);
}
function ST(o, e) {
  Cn(o, "checked", e === void 0 ? "mixed" : e);
}
function uF(o, e) {
  No(o, "controls", e.id), Lv(e, o.id);
}
function Gv(o, e) {
  return e === void 0 ? o("ariaIndeterminate", "indeterminate") : e === !0 ? o("ariaChecked", "checked") : o("ariaUnchecked", "unchecked");
}
var hF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  setAriaRole: ci,
  getAriaSortState: sT,
  getAriaLevel: aT,
  getAriaPosInSet: lT,
  getAriaDescribedBy: dF,
  setAriaLabel: Ia,
  setAriaLabelledBy: Lv,
  setAriaDescription: cT,
  setAriaDescribedBy: dT,
  setAriaLive: uT,
  setAriaLevel: hT,
  setAriaDisabled: RS,
  setAriaHidden: Nv,
  setAriaExpanded: Ln,
  removeAriaExpanded: pT,
  setAriaSetSize: TS,
  setAriaPosInSet: xS,
  setAriaMultiSelectable: fT,
  setAriaRowCount: gT,
  setAriaRowIndex: DS,
  setAriaColCount: vT,
  setAriaColIndex: OS,
  setAriaColSpan: mT,
  setAriaSort: yT,
  removeAriaSort: CT,
  setAriaSelected: _d,
  setAriaChecked: ST,
  setAriaControls: uF,
  getAriaCheckboxStateName: Gv
});
let yy, Hf, Cy, Sy, by, wy, wC, EC;
function fn() {
  return yy === void 0 && (yy = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)), yy;
}
function PS() {
  if (Hf === void 0)
    if (fn()) {
      const o = navigator.userAgent.match(/version\/(\d+)/i);
      o && (Hf = o[1] != null ? parseFloat(o[1]) : 0);
    } else
      Hf = 0;
  return Hf;
}
function kv() {
  if (Cy === void 0) {
    const o = window;
    Cy = !!o.chrome && (!!o.chrome.webstore || !!o.chrome.runtime) || /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
  }
  return Cy;
}
function AS() {
  return Sy === void 0 && (Sy = /(firefox)/i.test(navigator.userAgent)), Sy;
}
function MS() {
  return by === void 0 && (by = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)), by;
}
function Fa() {
  return wy === void 0 && (wy = /iPad|iPhone|iPod/.test(navigator.platform) || // eslint-disable-next-line
  navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1), wy;
}
function Vv() {
  return !fn() || PS() >= 15;
}
function Ag(o) {
  if (!o)
    return null;
  const e = o.tabIndex, t = o.getAttribute("tabIndex");
  return e === -1 && (t === null || t === "" && !AS()) ? null : e.toString();
}
function bT() {
  if (!document.body)
    return -1;
  let o = 1e6;
  const e = navigator.userAgent.toLowerCase().match(/firefox/) ? 6e6 : 1e9, t = document.createElement("div");
  for (document.body.appendChild(t); ; ) {
    const i = o * 2;
    if (t.style.height = i + "px", i > e || t.clientHeight !== i)
      break;
    o = i;
  }
  return document.body.removeChild(t), o;
}
function wT() {
  var o, e, t;
  return (e = (o = document.body) === null || o === void 0 ? void 0 : o.clientWidth) !== null && e !== void 0 ? e : window.innerHeight || ((t = document.documentElement) === null || t === void 0 ? void 0 : t.clientWidth) || -1;
}
function ET() {
  var o, e, t;
  return (e = (o = document.body) === null || o === void 0 ? void 0 : o.clientHeight) !== null && e !== void 0 ? e : window.innerHeight || ((t = document.documentElement) === null || t === void 0 ? void 0 : t.clientHeight) || -1;
}
function RT() {
  return EC == null && TT(), EC;
}
function TT() {
  const o = document.body, e = document.createElement("div");
  e.style.width = e.style.height = "100px", e.style.opacity = "0", e.style.overflow = "scroll", e.style.msOverflowStyle = "scrollbar", e.style.position = "absolute", o.appendChild(e);
  let t = e.offsetWidth - e.clientWidth;
  t === 0 && e.clientWidth === 0 && (t = null), e.parentNode && e.parentNode.removeChild(e), t != null && (EC = t, wC = t === 0);
}
function wd() {
  return wC == null && TT(), wC;
}
var pF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isBrowserSafari: fn,
  getSafariVersion: PS,
  isBrowserChrome: kv,
  isBrowserFirefox: AS,
  isMacOsUserAgent: MS,
  isIOSUserAgent: Fa,
  browserSupportsPreventScroll: Vv,
  getTabIndex: Ag,
  getMaxDivHeight: bT,
  getBodyWidth: wT,
  getBodyHeight: ET,
  getScrollbarWidth: RT,
  isInvisibleScrollbar: wd
});
function Ed(o, e) {
  return o.toString().padStart(e, "0");
}
function xT(o, e) {
  const t = [];
  for (let i = o; i <= e; i++)
    t.push(i);
  return t;
}
function fF(o) {
  return typeof o == "string" && (o = parseInt(o, 10)), typeof o == "number" ? Math.floor(o) : null;
}
function gF(o, e) {
  let t = "";
  for (let i = 0; i < e; i++)
    t += String.fromCharCode(o & 255), o >>>= 8;
  return t;
}
function vF(o, e, t) {
  return typeof o != "number" ? "" : _S(Math.round(o * 100) / 100, e, t);
}
function _S(o, e, t) {
  return typeof o != "number" ? "" : o.toString().replace(".", t).replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${e}`);
}
function mF(o) {
  return o == null ? null : o.reduce((e, t) => e + t, 0);
}
function yF(o, e) {
  return o >= 0 ? o : e;
}
function CF(o, e) {
  const t = parseInt(o, 10);
  return !isNaN(t) && isFinite(t) && t > 0 ? t : e;
}
var SF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  padStartWidthZeros: Ed,
  createArrayOfNumbers: xT,
  cleanNumber: fF,
  decToHex: gF,
  formatNumberTwoDecimalPlacesAndCommas: vF,
  formatNumberCommas: _S,
  sum: mF,
  zeroOrGreater: yF,
  oneOrGreater: CF
});
function cn(o, e = !0, t = "-") {
  if (!o)
    return null;
  let i = [o.getFullYear(), o.getMonth() + 1, o.getDate()].map((r) => Ed(r, 2)).join(t);
  return e && (i += " " + [o.getHours(), o.getMinutes(), o.getSeconds()].map((r) => Ed(r, 2)).join(":")), i;
}
const Ey = (o) => {
  if (o > 3 && o < 21)
    return "th";
  switch (o % 10) {
    case 1:
      return "st";
    case 2:
      return "nd";
    case 3:
      return "rd";
  }
  return "th";
};
function ug(o, e = "YYYY-MM-DD") {
  const t = Ed(o.getFullYear(), 4), i = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ], r = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ], n = {
    YYYY: () => t.slice(t.length - 4, t.length),
    YY: () => t.slice(t.length - 2, t.length),
    Y: () => `${o.getFullYear()}`,
    MMMM: () => i[o.getMonth()],
    MMM: () => i[o.getMonth()].slice(0, 3),
    MM: () => Ed(o.getMonth() + 1, 2),
    Mo: () => `${o.getMonth() + 1}${Ey(o.getMonth() + 1)}`,
    M: () => `${o.getMonth() + 1}`,
    Do: () => `${o.getDate()}${Ey(o.getDate())}`,
    DD: () => Ed(o.getDate(), 2),
    D: () => `${o.getDate()}`,
    dddd: () => r[o.getDay()],
    ddd: () => r[o.getDay()].slice(0, 3),
    dd: () => r[o.getDay()].slice(0, 2),
    do: () => `${o.getDay()}${Ey(o.getDay())}`,
    d: () => `${o.getDay()}`
  }, s = new RegExp(Object.keys(n).join("|"), "g");
  return e.replace(s, (a) => a in n ? n[a]() : a);
}
function Vn(o) {
  if (!o)
    return null;
  const [e, t] = o.split(" ");
  if (!e)
    return null;
  const i = e.split("-").map((u) => parseInt(u, 10));
  if (i.filter((u) => !isNaN(u)).length !== 3)
    return null;
  const [r, n, s] = i, a = new Date(r, n - 1, s);
  if (a.getFullYear() !== r || a.getMonth() !== n - 1 || a.getDate() !== s)
    return null;
  if (!t || t === "00:00:00")
    return a;
  const [l, c, d] = t.split(":").map((u) => parseInt(u, 10));
  return l >= 0 && l < 24 && a.setHours(l), c >= 0 && c < 60 && a.setMinutes(c), d >= 0 && d < 60 && a.setSeconds(d), a;
}
var bF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  serialiseDate: cn,
  dateToFormattedString: ug,
  parseDateTimeFromString: Vn
});
let Wf;
function wF(o, e, t) {
  const i = o.parentElement;
  let r = i && i.firstChild;
  for (; r; )
    e && r.classList.toggle(e, r === o), t && r.classList.toggle(t, r !== o), r = r.nextSibling;
}
const DT = "[tabindex], input, select, button, textarea, [href]", IS = ".ag-hidden, .ag-hidden *, [disabled], .ag-disabled:not(.ag-button), .ag-disabled *.mjs";
function FS(o) {
  const e = Element.prototype.matches || Element.prototype.msMatchesSelector, t = "input, select, button, textarea", i = e.call(o, t), r = e.call(o, IS), n = Ms(o);
  return i && !r && n;
}
function Ke(o, e, t = {}) {
  const { skipAriaHidden: i } = t;
  o.classList.toggle("ag-hidden", !e), i || Nv(o, !e);
}
function OT(o, e, t = {}) {
  const { skipAriaHidden: i } = t;
  o.classList.toggle("ag-invisible", !e), i || Nv(o, !e);
}
function Id(o, e) {
  const t = "disabled", i = e ? (r) => r.setAttribute(t, "") : (r) => r.removeAttribute(t);
  i(o), HS(o.querySelectorAll("input"), (r) => i(r));
}
function Ol(o, e, t) {
  let i = 0;
  for (; o; ) {
    if (o.classList.contains(e))
      return !0;
    if (o = o.parentElement, typeof t == "number") {
      if (++i > t)
        break;
    } else if (o === t)
      break;
  }
  return !1;
}
function La(o) {
  const { height: e, width: t, borderTopWidth: i, borderRightWidth: r, borderBottomWidth: n, borderLeftWidth: s, paddingTop: a, paddingRight: l, paddingBottom: c, paddingLeft: d, marginTop: u, marginRight: h, marginBottom: p, marginLeft: f, boxSizing: g } = window.getComputedStyle(o);
  return {
    height: parseFloat(e),
    width: parseFloat(t),
    borderTopWidth: parseFloat(i),
    borderRightWidth: parseFloat(r),
    borderBottomWidth: parseFloat(n),
    borderLeftWidth: parseFloat(s),
    paddingTop: parseFloat(a),
    paddingRight: parseFloat(l),
    paddingBottom: parseFloat(c),
    paddingLeft: parseFloat(d),
    marginTop: parseFloat(u),
    marginRight: parseFloat(h),
    marginBottom: parseFloat(p),
    marginLeft: parseFloat(f),
    boxSizing: g
  };
}
function Tp(o) {
  const e = La(o);
  return e.boxSizing === "border-box" ? e.height - e.paddingTop - e.paddingBottom : e.height;
}
function Bv(o) {
  const e = La(o);
  return e.boxSizing === "border-box" ? e.width - e.paddingLeft - e.paddingRight : e.width;
}
function LS(o) {
  const e = La(o), t = e.marginBottom + e.marginTop;
  return Math.ceil(o.offsetHeight + t);
}
function Hv(o) {
  const e = La(o), t = e.marginLeft + e.marginRight;
  return Math.ceil(o.offsetWidth + t);
}
function NS(o) {
  const e = o.getBoundingClientRect(), { borderTopWidth: t, borderLeftWidth: i, borderRightWidth: r, borderBottomWidth: n } = La(o);
  return {
    top: e.top + (t || 0),
    left: e.left + (i || 0),
    right: e.right + (r || 0),
    bottom: e.bottom + (n || 0)
  };
}
function kh() {
  if (typeof Wf == "boolean")
    return Wf;
  const o = document.createElement("div");
  return o.style.direction = "rtl", o.style.width = "1px", o.style.height = "1px", o.style.position = "fixed", o.style.top = "0px", o.style.overflow = "hidden", o.dir = "rtl", o.innerHTML = /* html */
  `<div style="width: 2px">
            <span style="display: inline-block; width: 1px"></span>
            <span style="display: inline-block; width: 1px"></span>
        </div>`, document.body.appendChild(o), o.scrollLeft = 1, Wf = Math.floor(o.scrollLeft) === 0, document.body.removeChild(o), Wf;
}
function Vh(o, e) {
  let t = o.scrollLeft;
  return e && (t = Math.abs(t), kv() && !kh() && (t = o.scrollWidth - o.clientWidth - t)), t;
}
function Bh(o, e, t) {
  t && (kh() ? e *= -1 : (fn() || kv()) && (e = o.scrollWidth - o.clientWidth - e)), o.scrollLeft = e;
}
function Or(o) {
  for (; o && o.firstChild; )
    o.removeChild(o.firstChild);
}
function EF(o, e) {
  fs(o.querySelector(e));
}
function fs(o) {
  o && o.parentNode && o.parentNode.removeChild(o);
}
function Ms(o) {
  return o.offsetParent !== null;
}
function Si(o) {
  const e = document.createElement("div");
  return e.innerHTML = (o || "").trim(), e.firstChild;
}
function RF(o, e) {
  o.lastChild ? o.insertAdjacentHTML("afterbegin", e) : o.innerHTML = e;
}
function TF(o, e) {
  return o.attributes && o.attributes[e] ? o.attributes[e].value : null;
}
function RC(o) {
  return o && o.clientHeight ? o.clientHeight : 0;
}
function TC(o) {
  return o && o.clientWidth ? o.clientWidth : 0;
}
function GS(o, e, t) {
  if (t && t.nextSibling === e)
    return;
  const i = document.activeElement, r = e.contains(i);
  t ? t.nextSibling ? o.insertBefore(e, t.nextSibling) : o.appendChild(e) : o.firstChild && o.firstChild !== e && o.insertAdjacentElement("afterbegin", e), r && i && Vv() && i.focus({ preventScroll: !0 });
}
function kS(o, e) {
  for (let t = 0; t < e.length; t++) {
    const i = e[t], r = o.children[t];
    r !== i && o.insertBefore(i, r);
  }
}
function PT(o, e, t) {
  t ? t.insertAdjacentElement("afterend", e) : o.firstChild ? o.insertAdjacentElement("afterbegin", e) : o.appendChild(e);
}
function xF(o, e) {
  z(o.firstChild) ? o.insertBefore(e, o.firstChild) : o.appendChild(e);
}
function VS(o, e) {
  if (e)
    for (const [t, i] of Object.entries(e)) {
      if (!t || !t.length || i == null)
        continue;
      const r = rT(t), n = i.toString(), s = n.replace(/\s*!important/g, ""), a = s.length != n.length ? "important" : void 0;
      o.style.setProperty(r, s, a);
    }
}
function AT(o) {
  return o.clientWidth < o.scrollWidth;
}
function MT(o) {
  return o.clientHeight < o.scrollHeight;
}
function xp(o, e) {
  e === "flex" ? (o.style.removeProperty("width"), o.style.removeProperty("minWidth"), o.style.removeProperty("maxWidth"), o.style.flex = "1 1 auto") : dn(o, e);
}
function dn(o, e) {
  e = BS(e), o.style.width = e.toString(), o.style.maxWidth = e.toString(), o.style.minWidth = e.toString();
}
function DF(o, e) {
  e === "flex" ? (o.style.removeProperty("height"), o.style.removeProperty("minHeight"), o.style.removeProperty("maxHeight"), o.style.flex = "1 1 auto") : Pl(o, e);
}
function Pl(o, e) {
  e = BS(e), o.style.height = e.toString(), o.style.maxHeight = e.toString(), o.style.minHeight = e.toString();
}
function BS(o) {
  return typeof o == "number" ? `${o}px` : o;
}
function Dp(o) {
  return o instanceof Node || o instanceof HTMLElement;
}
function _T(o) {
  if (o == null)
    return [];
  const e = [];
  return HS(o, (t) => e.push(t)), e;
}
function IT(o, e) {
  if (o)
    for (let t = 0; t < o.length; t++) {
      const i = o[t];
      e(i.name, i.value);
    }
}
function da(o, e, t) {
  t == null ? o.removeAttribute(e) : o.setAttribute(e, t.toString());
}
function HS(o, e) {
  if (o != null)
    for (let t = 0; t < o.length; t++)
      e(o[t]);
}
var OF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  radioCssClass: wF,
  FOCUSABLE_SELECTOR: DT,
  FOCUSABLE_EXCLUDE: IS,
  isFocusableFormField: FS,
  setDisplayed: Ke,
  setVisible: OT,
  setDisabled: Id,
  isElementChildOfClass: Ol,
  getElementSize: La,
  getInnerHeight: Tp,
  getInnerWidth: Bv,
  getAbsoluteHeight: LS,
  getAbsoluteWidth: Hv,
  getElementRectWithOffset: NS,
  isRtlNegativeScroll: kh,
  getScrollLeft: Vh,
  setScrollLeft: Bh,
  clearElement: Or,
  removeElement: EF,
  removeFromParent: fs,
  isVisible: Ms,
  loadTemplate: Si,
  appendHtml: RF,
  getElementAttribute: TF,
  offsetHeight: RC,
  offsetWidth: TC,
  ensureDomOrder: GS,
  setDomChildOrder: kS,
  insertWithDomOrder: PT,
  prependDC: xF,
  addStylesToElement: VS,
  isHorizontalScrollShowing: AT,
  isVerticalScrollShowing: MT,
  setElementWidth: xp,
  setFixedWidth: dn,
  setElementHeight: DF,
  setFixedHeight: Pl,
  formatSize: BS,
  isNodeOrElement: Dp,
  copyNodeList: _T,
  iterateNamedNodeMap: IT,
  addOrRemoveAttribute: da,
  nodeListForEach: HS
});
const FT = {
  // header column group shown when expanded (click to contract)
  columnGroupOpened: "expanded",
  // header column group shown when contracted (click to expand)
  columnGroupClosed: "contracted",
  // tool panel column group contracted (click to expand)
  columnSelectClosed: "tree-closed",
  // tool panel column group expanded (click to contract)
  columnSelectOpen: "tree-open",
  // column tool panel header expand/collapse all button, shown when some children are expanded and
  //     others are collapsed
  columnSelectIndeterminate: "tree-indeterminate",
  // shown on ghost icon while dragging column to the side of the grid to pin
  columnMovePin: "pin",
  // shown on ghost icon while dragging over part of the page that is not a drop zone
  columnMoveHide: "eye-slash",
  // shown on ghost icon while dragging columns to reorder
  columnMoveMove: "arrows",
  // animating icon shown when dragging a column to the right of the grid causes horizontal scrolling
  columnMoveLeft: "left",
  // animating icon shown when dragging a column to the left of the grid causes horizontal scrolling
  columnMoveRight: "right",
  // shown on ghost icon while dragging over Row Groups drop zone
  columnMoveGroup: "group",
  // shown on ghost icon while dragging over Values drop zone
  columnMoveValue: "aggregation",
  // shown on ghost icon while dragging over pivot drop zone
  columnMovePivot: "pivot",
  // shown on ghost icon while dragging over drop zone that doesn't support it, e.g.
  //     string column over aggregation drop zone
  dropNotAllowed: "not-allowed",
  // shown on row group when contracted (click to expand)
  groupContracted: "tree-closed",
  // shown on row group when expanded (click to contract)
  groupExpanded: "tree-open",
  // set filter tree list group contracted (click to expand)
  setFilterGroupClosed: "tree-closed",
  // set filter tree list group expanded (click to contract)
  setFilterGroupOpen: "tree-open",
  // set filter tree list expand/collapse all button, shown when some children are expanded and
  //     others are collapsed
  setFilterGroupIndeterminate: "tree-indeterminate",
  // context menu chart item
  chart: "chart",
  // chart window title bar
  close: "cross",
  // X (remove) on column 'pill' after adding it to a drop zone list
  cancel: "cancel",
  // indicates the currently active pin state in the "Pin column" sub-menu of the column menu
  check: "tick",
  // "go to first" button in pagination controls
  first: "first",
  // "go to previous" button in pagination controls
  previous: "previous",
  // "go to next" button in pagination controls
  next: "next",
  // "go to last" button in pagination controls
  last: "last",
  // shown on top right of chart when chart is linked to range data (click to unlink)
  linked: "linked",
  // shown on top right of chart when chart is not linked to range data (click to link)
  unlinked: "unlinked",
  // "Choose colour" button on chart settings tab
  colorPicker: "color-picker",
  // rotating spinner shown by the loading cell renderer
  groupLoading: "loading",
  // button to launch enterprise column menu
  menu: "menu",
  // filter tool panel tab
  filter: "filter",
  // column tool panel tab
  columns: "columns",
  // button in chart regular size window title bar (click to maximise)
  maximize: "maximize",
  // button in chart maximised window title bar (click to make regular size)
  minimize: "minimize",
  // "Pin column" item in column header menu
  menuPin: "pin",
  // "Value aggregation" column menu item (shown on numeric columns when grouping is active)"
  menuValue: "aggregation",
  // "Group by {column-name}" item in column header menu
  menuAddRowGroup: "group",
  // "Un-Group by {column-name}" item in column header menu
  menuRemoveRowGroup: "group",
  // context menu copy item
  clipboardCopy: "copy",
  // context menu cut item
  clipboardCut: "cut",
  // context menu paste item
  clipboardPaste: "paste",
  // identifies the pivot drop zone
  pivotPanel: "pivot",
  // "Row groups" drop zone in column tool panel
  rowGroupPanel: "group",
  // columns tool panel Values drop zone
  valuePanel: "aggregation",
  // drag handle used to pick up draggable columns
  columnDrag: "grip",
  // drag handle used to pick up draggable rows
  rowDrag: "grip",
  // context menu export item
  save: "save",
  // csv export
  csvExport: "csv",
  // excel export,
  excelExport: "excel",
  // icon on dropdown editors
  smallDown: "small-down",
  // version of small-right used in RTL mode
  smallLeft: "small-left",
  // separater between column 'pills' when you add multiple columns to the header drop zone
  smallRight: "small-right",
  smallUp: "small-up",
  // show on column header when column is sorted ascending
  sortAscending: "asc",
  // show on column header when column is sorted descending
  sortDescending: "desc",
  // show on column header when column has no sort, only when enabled with gridOptions.unSortIcon=true
  sortUnSort: "none"
};
function tn(o, e, t) {
  const i = Vt(o, e, t);
  if (i) {
    const { className: n } = i;
    if (typeof n == "string" && n.indexOf("ag-icon") > -1 || typeof n == "object" && n["ag-icon"])
      return i;
  }
  const r = document.createElement("span");
  return r.appendChild(i), r;
}
function Vt(o, e, t, i) {
  let r = null;
  const n = t && t.getColDef().icons;
  if (n && (r = n[o]), e && !r) {
    const s = e.get("icons");
    s && (r = s[o]);
  }
  if (r) {
    let s;
    if (typeof r == "function")
      s = r();
    else if (typeof r == "string")
      s = r;
    else
      throw new Error("icon from grid options needs to be a string or a function");
    if (typeof s == "string")
      return Si(s);
    if (Dp(s))
      return s;
    console.warn("AG Grid: iconRenderer should return back a string or a dom object");
  } else {
    const s = document.createElement("span");
    let a = FT[o];
    return a || (i ? a = o : (console.warn(`AG Grid: Did not find icon ${o}`), a = "")), s.setAttribute("class", `ag-icon ag-icon-${a}`), s.setAttribute("unselectable", "on"), ci(s, "presentation"), s;
  }
}
var PF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  iconNameClassMap: FT,
  createIcon: tn,
  createIconNoSpan: Vt
});
class V {
}
V.BACKSPACE = "Backspace";
V.TAB = "Tab";
V.ENTER = "Enter";
V.ESCAPE = "Escape";
V.SPACE = " ";
V.LEFT = "ArrowLeft";
V.UP = "ArrowUp";
V.RIGHT = "ArrowRight";
V.DOWN = "ArrowDown";
V.DELETE = "Delete";
V.F2 = "F2";
V.PAGE_UP = "PageUp";
V.PAGE_DOWN = "PageDown";
V.PAGE_HOME = "Home";
V.PAGE_END = "End";
V.A = "KeyA";
V.C = "KeyC";
V.D = "KeyD";
V.V = "KeyV";
V.X = "KeyX";
V.Y = "KeyY";
V.Z = "KeyZ";
const AF = 65, MF = 67, _F = 86, IF = 68, FF = 90, LF = 89;
function WS(o) {
  return o.altKey || o.ctrlKey || o.metaKey ? !1 : o.key.length === 1;
}
function Mg(o, e, t, i, r) {
  const n = i ? i.getColDef().suppressKeyboardEvent : void 0;
  if (!n)
    return !1;
  const s = {
    event: e,
    editing: r,
    column: i,
    api: o.api,
    node: t,
    data: t.data,
    colDef: i.getColDef(),
    context: o.context,
    columnApi: o.columnApi
  };
  return !!(n && n(s));
}
function LT(o, e, t, i) {
  const r = i.getDefinition(), n = r && r.suppressHeaderKeyboardEvent;
  if (!z(n))
    return !1;
  const s = {
    api: o.api,
    columnApi: o.columnApi,
    context: o.context,
    colDef: r,
    column: i,
    headerRowIndex: t,
    event: e
  };
  return !!n(s);
}
function NT(o) {
  const { keyCode: e } = o;
  let t;
  switch (e) {
    case AF:
      t = V.A;
      break;
    case MF:
      t = V.C;
      break;
    case _F:
      t = V.V;
      break;
    case IF:
      t = V.D;
      break;
    case FF:
      t = V.Z;
      break;
    case LF:
      t = V.Y;
      break;
    default:
      t = o.code;
  }
  return t;
}
function GT(o, e = !1) {
  return o === V.DELETE ? !0 : !e && o === V.BACKSPACE ? MS() : !1;
}
var NF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isEventFromPrintableCharacter: WS,
  isUserSuppressingKeyboardEvent: Mg,
  isUserSuppressingHeaderKeyboardEvent: LT,
  normaliseQwertyAzerty: NT,
  isDeleteKey: GT
});
function jS(o, e, t) {
  if (t === 0)
    return !1;
  const i = Math.abs(o.clientX - e.clientX), r = Math.abs(o.clientY - e.clientY);
  return Math.max(i, r) <= t;
}
var GF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  areEventsNear: jS
});
function kF(o, e) {
  if (!o)
    return !1;
  const t = (s, a) => {
    const l = e[s.id], c = e[a.id], d = l !== void 0, u = c !== void 0, h = d && u, p = !d && !u;
    return h ? l - c : p ? s.__objectId - a.__objectId : d ? 1 : -1;
  };
  let i, r, n = !1;
  for (let s = 0; s < o.length - 1; s++)
    if (i = o[s], r = o[s + 1], t(i, r) > 0) {
      n = !0;
      break;
    }
  return n ? (o.sort(t), !0) : !1;
}
function VF(o, e) {
  const t = [];
  i(o);
  function i(r) {
    r && r.forEach((n) => {
      if (n.group || n.hasChildren()) {
        t.push(n.key);
        const s = t.join("|");
        e(n, s), i(n.childrenAfterGroup), t.pop();
      }
    });
  }
}
var BF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  sortRowNodesByOrder: kF,
  traverseNodesWithKey: VF
});
function US(o) {
  const e = /* @__PURE__ */ new Set();
  return o.forEach((t) => e.add(t)), e;
}
var HF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  convertToSet: US
});
const WF = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, hF), UI), pF), bF), OF), zI), II), rF), EI), PF), NF), tF), GF), SF), AI), BF), HF), QI), x = WF;
class Ei {
  constructor(e = 0, t = 1) {
    this.nextValue = e, this.step = t;
  }
  next() {
    const e = this.nextValue;
    return this.nextValue += this.step, e;
  }
  peek() {
    return this.nextValue;
  }
  skip(e) {
    this.nextValue += e;
  }
}
var cd;
(function(o) {
  o[o.IN_PROGRESS = 0] = "IN_PROGRESS", o[o.RESOLVED = 1] = "RESOLVED";
})(cd || (cd = {}));
class Qe {
  constructor(e) {
    this.status = cd.IN_PROGRESS, this.resolution = null, this.waiters = [], e((t) => this.onDone(t), (t) => this.onReject(t));
  }
  static all(e) {
    return new Qe((t) => {
      let i = e.length;
      const r = new Array(i);
      e.forEach((n, s) => {
        n.then((a) => {
          r[s] = a, i--, i === 0 && t(r);
        });
      });
    });
  }
  static resolve(e = null) {
    return new Qe((t) => t(e));
  }
  then(e) {
    return new Qe((t) => {
      this.status === cd.RESOLVED ? t(e(this.resolution)) : this.waiters.push((i) => t(e(i)));
    });
  }
  resolveNow(e, t) {
    return this.status === cd.RESOLVED ? t(this.resolution) : e;
  }
  onDone(e) {
    this.status = cd.RESOLVED, this.resolution = e, this.waiters.forEach((t) => t(e));
  }
  onReject(e) {
    console.warn("TBI");
  }
}
var $S = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, Mn;
(function(o) {
  o[o.NOTHING = 0] = "NOTHING", o[o.WAITING_TO_SHOW = 1] = "WAITING_TO_SHOW", o[o.SHOWING = 2] = "SHOWING";
})(Mn || (Mn = {}));
class ws extends H {
  constructor(e) {
    super(), this.DEFAULT_SHOW_TOOLTIP_DELAY = 2e3, this.DEFAULT_HIDE_TOOLTIP_DELAY = 1e4, this.SHOW_QUICK_TOOLTIP_DIFF = 1e3, this.FADE_OUT_TOOLTIP_TIMEOUT = 1e3, this.state = Mn.NOTHING, this.tooltipInstanceCount = 0, this.tooltipMouseTrack = !1, this.parentComp = e;
  }
  postConstruct() {
    this.tooltipShowDelay = this.getTooltipDelay("show") || this.DEFAULT_SHOW_TOOLTIP_DELAY, this.tooltipHideDelay = this.getTooltipDelay("hide") || this.DEFAULT_HIDE_TOOLTIP_DELAY, this.tooltipMouseTrack = this.gridOptionsService.is("tooltipMouseTrack");
    const e = this.parentComp.getGui();
    this.addManagedListener(e, "mouseenter", this.onMouseEnter.bind(this)), this.addManagedListener(e, "mouseleave", this.onMouseLeave.bind(this)), this.addManagedListener(e, "mousemove", this.onMouseMove.bind(this)), this.addManagedListener(e, "mousedown", this.onMouseDown.bind(this)), this.addManagedListener(e, "keydown", this.onKeyDown.bind(this));
  }
  destroy() {
    this.setToDoNothing(), super.destroy();
  }
  onMouseEnter(e) {
    if (Fa() || this.state != Mn.NOTHING)
      return;
    const t = this.isLastTooltipHiddenRecently() ? 200 : this.tooltipShowDelay;
    this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), t), this.lastMouseEvent = e, this.state = Mn.WAITING_TO_SHOW;
  }
  onMouseLeave() {
    this.setToDoNothing();
  }
  onKeyDown() {
    this.setToDoNothing();
  }
  setToDoNothing() {
    this.state === Mn.SHOWING && this.hideTooltip(), this.clearTimeouts(), this.state = Mn.NOTHING;
  }
  onMouseMove(e) {
    this.lastMouseEvent = e, this.tooltipMouseTrack && this.state === Mn.SHOWING && this.tooltipComp && this.positionTooltipUnderLastMouseEvent();
  }
  onMouseDown() {
    this.setToDoNothing();
  }
  getTooltipDelay(e) {
    const t = this.gridOptionsService.getNum("tooltipShowDelay"), i = this.gridOptionsService.getNum("tooltipHideDelay"), r = e === "show" ? t : i, n = tT(e);
    return z(r) ? (r < 0 && tt(() => console.warn(`AG Grid: tooltip${n}Delay should not be lower than 0`), `tooltip${n}DelayWarn`), Math.max(200, r)) : null;
  }
  hideTooltip() {
    this.tooltipComp && (this.destroyTooltipComp(), ws.lastTooltipHideTime = (/* @__PURE__ */ new Date()).getTime()), this.state = Mn.NOTHING;
  }
  destroyTooltipComp() {
    this.tooltipComp.getGui().classList.add("ag-tooltip-hiding");
    const e = this.tooltipPopupDestroyFunc, t = this.tooltipComp;
    window.setTimeout(() => {
      e(), this.getContext().destroyBean(t);
    }, this.FADE_OUT_TOOLTIP_TIMEOUT), this.tooltipPopupDestroyFunc = void 0, this.tooltipComp = void 0;
  }
  isLastTooltipHiddenRecently() {
    const e = (/* @__PURE__ */ new Date()).getTime(), t = ws.lastTooltipHideTime;
    return e - t < this.SHOW_QUICK_TOOLTIP_DIFF;
  }
  showTooltip() {
    const e = Object.assign({}, this.parentComp.getTooltipParams());
    if (!z(e.value)) {
      this.setToDoNothing();
      return;
    }
    this.state = Mn.SHOWING, this.tooltipInstanceCount++;
    const t = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount);
    this.userComponentFactory.getTooltipCompDetails(e).newAgStackInstance().then(t);
  }
  newTooltipComponentCallback(e, t) {
    if (this.state !== Mn.SHOWING || this.tooltipInstanceCount !== e) {
      this.getContext().destroyBean(t);
      return;
    }
    const r = t.getGui();
    this.tooltipComp = t, r.classList.contains("ag-tooltip") || r.classList.add("ag-tooltip-custom");
    const n = this.localeService.getLocaleTextFunc(), s = this.popupService.addPopup({
      eChild: r,
      ariaLabel: n("ariaLabelTooltip", "Tooltip")
    });
    s && (this.tooltipPopupDestroyFunc = s.hideFunc), this.positionTooltipUnderLastMouseEvent(), this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.tooltipHideDelay);
  }
  positionTooltipUnderLastMouseEvent() {
    this.popupService.positionPopupUnderMouseEvent({
      type: "tooltip",
      mouseEvent: this.lastMouseEvent,
      ePopup: this.tooltipComp.getGui(),
      nudgeY: 18,
      skipObserver: this.tooltipMouseTrack
    });
  }
  clearTimeouts() {
    this.showTooltipTimeoutId && (window.clearTimeout(this.showTooltipTimeoutId), this.showTooltipTimeoutId = void 0), this.hideTooltipTimeoutId && (window.clearTimeout(this.hideTooltipTimeoutId), this.hideTooltipTimeoutId = void 0);
  }
}
$S([
  S("popupService")
], ws.prototype, "popupService", void 0);
$S([
  S("userComponentFactory")
], ws.prototype, "userComponentFactory", void 0);
$S([
  B
], ws.prototype, "postConstruct", null);
class jF {
  constructor(e) {
    this.cssClassStates = {}, this.getGui = e;
  }
  addCssClass(e) {
    const t = (e || "").split(" ");
    if (t.length > 1) {
      t.forEach((r) => this.addCssClass(r));
      return;
    }
    if (this.cssClassStates[e] !== !0 && e.length) {
      const r = this.getGui();
      r && r.classList.add(e), this.cssClassStates[e] = !0;
    }
  }
  removeCssClass(e) {
    const t = (e || "").split(" ");
    if (t.length > 1) {
      t.forEach((r) => this.removeCssClass(r));
      return;
    }
    if (this.cssClassStates[e] !== !1 && e.length) {
      const r = this.getGui();
      r && r.classList.remove(e), this.cssClassStates[e] = !1;
    }
  }
  containsCssClass(e) {
    const t = this.getGui();
    return t ? t.classList.contains(e) : !1;
  }
  addOrRemoveCssClass(e, t) {
    if (!e)
      return;
    if (e.indexOf(" ") >= 0) {
      const r = (e || "").split(" ");
      if (r.length > 1) {
        r.forEach((n) => this.addOrRemoveCssClass(n, t));
        return;
      }
    }
    if (this.cssClassStates[e] !== t && e.length) {
      const r = this.getGui();
      r && r.classList.toggle(e, t), this.cssClassStates[e] = t;
    }
  }
}
var zS = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const UF = new Ei();
class X extends H {
  constructor(e) {
    super(), this.displayed = !0, this.visible = !0, this.compId = UF.next(), this.cssClassManager = new jF(() => this.eGui), e && this.setTemplate(e);
  }
  preConstructOnComponent() {
    this.usingBrowserTooltips = this.gridOptionsService.is("enableBrowserTooltips");
  }
  getCompId() {
    return this.compId;
  }
  getTooltipParams() {
    return {
      value: this.tooltipText,
      location: "UNKNOWN"
    };
  }
  setTooltip(e) {
    const t = () => {
      this.usingBrowserTooltips ? this.getGui().removeAttribute("title") : this.tooltipFeature = this.destroyBean(this.tooltipFeature);
    }, i = () => {
      this.usingBrowserTooltips ? this.getGui().setAttribute("title", this.tooltipText) : this.tooltipFeature = this.createBean(new ws(this));
    };
    this.tooltipText != e && (this.tooltipText && t(), e != null && (this.tooltipText = e, this.tooltipText && i()));
  }
  // for registered components only, eg creates AgCheckbox instance from ag-checkbox HTML tag
  createChildComponentsFromTags(e, t) {
    _T(e.childNodes).forEach((r) => {
      if (!(r instanceof HTMLElement))
        return;
      const n = this.createComponentFromElement(r, (s) => {
        s.getGui() && this.copyAttributesFromNode(r, s.getGui());
      }, t);
      if (n) {
        if (n.addItems && r.children.length) {
          this.createChildComponentsFromTags(r, t);
          const s = Array.prototype.slice.call(r.children);
          n.addItems(s);
        }
        this.swapComponentForNode(n, e, r);
      } else
        r.childNodes && this.createChildComponentsFromTags(r, t);
    });
  }
  createComponentFromElement(e, t, i) {
    const r = e.nodeName, n = i ? i[e.getAttribute("ref")] : void 0, s = this.agStackComponentsRegistry.getComponentClass(r);
    if (s) {
      X.elementGettingCreated = e;
      const a = new s(n);
      return a.setParentComponent(this), this.createBean(a, null, t), a;
    }
    return null;
  }
  copyAttributesFromNode(e, t) {
    IT(e.attributes, (i, r) => t.setAttribute(i, r));
  }
  swapComponentForNode(e, t, i) {
    const r = e.getGui();
    t.replaceChild(r, i), t.insertBefore(document.createComment(i.nodeName), r), this.addDestroyFunc(this.destroyBean.bind(this, e)), this.swapInComponentForQuerySelectors(e, i);
  }
  swapInComponentForQuerySelectors(e, t) {
    const i = this;
    this.iterateOverQuerySelectors((r) => {
      i[r.attributeName] === t && (i[r.attributeName] = e);
    });
  }
  iterateOverQuerySelectors(e) {
    let t = Object.getPrototypeOf(this);
    for (; t != null; ) {
      const i = t.__agComponentMetaData, r = Av(t.constructor);
      i && i[r] && i[r].querySelectors && i[r].querySelectors.forEach((n) => e(n)), t = Object.getPrototypeOf(t);
    }
  }
  activateTabIndex(e) {
    const t = this.gridOptionsService.getNum("tabIndex") || 0;
    e || (e = []), e.length || e.push(this.getGui()), e.forEach((i) => i.setAttribute("tabindex", t.toString()));
  }
  setTemplate(e, t) {
    const i = Si(e);
    this.setTemplateFromElement(i, t);
  }
  setTemplateFromElement(e, t) {
    this.eGui = e, this.eGui.__agComponent = this, this.wireQuerySelectors(), this.getContext() && this.createChildComponentsFromTags(this.getGui(), t);
  }
  createChildComponentsPreConstruct() {
    this.getGui() && this.createChildComponentsFromTags(this.getGui());
  }
  wireQuerySelectors() {
    if (!this.eGui)
      return;
    const e = this;
    this.iterateOverQuerySelectors((t) => {
      const i = (n) => e[t.attributeName] = n;
      if (t.refSelector && this.getAttribute("ref") === t.refSelector)
        i(this.eGui);
      else {
        const n = this.eGui.querySelector(t.querySelector);
        n && i(n.__agComponent || n);
      }
    });
  }
  getGui() {
    return this.eGui;
  }
  getFocusableElement() {
    return this.eGui;
  }
  setParentComponent(e) {
    this.parentComponent = e;
  }
  getParentComponent() {
    return this.parentComponent;
  }
  // this method is for older code, that wants to provide the gui element,
  // it is not intended for this to be in ag-Stack
  setGui(e) {
    this.eGui = e;
  }
  queryForHtmlElement(e) {
    return this.eGui.querySelector(e);
  }
  queryForHtmlInputElement(e) {
    return this.eGui.querySelector(e);
  }
  appendChild(e, t) {
    if (e != null)
      if (t || (t = this.eGui), Dp(e))
        t.appendChild(e);
      else {
        const i = e;
        t.appendChild(i.getGui());
      }
  }
  isDisplayed() {
    return this.displayed;
  }
  setVisible(e, t = {}) {
    if (e !== this.visible) {
      this.visible = e;
      const { skipAriaHidden: i } = t;
      OT(this.eGui, e, { skipAriaHidden: i });
    }
  }
  setDisplayed(e, t = {}) {
    if (e !== this.displayed) {
      this.displayed = e;
      const { skipAriaHidden: i } = t;
      Ke(this.eGui, e, { skipAriaHidden: i });
      const r = {
        type: X.EVENT_DISPLAYED_CHANGED,
        visible: this.displayed
      };
      this.dispatchEvent(r);
    }
  }
  destroy() {
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), this.parentComponent && (this.parentComponent = void 0);
    const e = this.eGui;
    e && e.__agComponent && (e.__agComponent = void 0), super.destroy();
  }
  addGuiEventListener(e, t, i) {
    this.eGui.addEventListener(e, t, i), this.addDestroyFunc(() => this.eGui.removeEventListener(e, t));
  }
  addCssClass(e) {
    this.cssClassManager.addCssClass(e);
  }
  removeCssClass(e) {
    this.cssClassManager.removeCssClass(e);
  }
  containsCssClass(e) {
    return this.cssClassManager.containsCssClass(e);
  }
  addOrRemoveCssClass(e, t) {
    this.cssClassManager.addOrRemoveCssClass(e, t);
  }
  getAttribute(e) {
    const { eGui: t } = this;
    return t ? t.getAttribute(e) : null;
  }
  getRefElement(e) {
    return this.queryForHtmlElement(`[ref="${e}"]`);
  }
}
X.EVENT_DISPLAYED_CHANGED = "displayedChanged";
zS([
  S("agStackComponentsRegistry")
], X.prototype, "agStackComponentsRegistry", void 0);
zS([
  su
], X.prototype, "preConstructOnComponent", null);
zS([
  su
], X.prototype, "createChildComponentsPreConstruct", null);
function L(o) {
  return $F.bind(this, `[ref=${o}]`, o);
}
function $F(o, e, t, i, r) {
  if (o === null) {
    console.error("AG Grid: QuerySelector selector should not be null");
    return;
  }
  if (typeof r == "number") {
    console.error("AG Grid: QuerySelector should be on an attribute");
    return;
  }
  zF(t, "querySelectors", {
    attributeName: i,
    querySelector: o,
    refSelector: e
  });
}
function zF(o, e, t) {
  const i = KF(o, Av(o.constructor));
  i[e] || (i[e] = []), i[e].push(t);
}
function KF(o, e) {
  return o.__agComponentMetaData || (o.__agComponentMetaData = {}), o.__agComponentMetaData[e] || (o.__agComponentMetaData[e] = {}), o.__agComponentMetaData[e];
}
var kT = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class KS extends X {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field ref="eFloatingFilterText"></ag-input-text-field>
            </div>`
    );
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    this.params = e;
    const t = this.columnModel.getDisplayNameForColumn(e.column, "header", !0), i = this.localeService.getLocaleTextFunc();
    this.eFloatingFilterText.setDisabled(!0).setInputAriaLabel(`${t} ${i("ariaFilterInput", "Filter Input")}`);
  }
  onParentModelChanged(e) {
    if (!e) {
      this.eFloatingFilterText.setValue("");
      return;
    }
    this.params.parentFilterInstance((t) => {
      if (t.getModelAsString) {
        const i = t.getModelAsString(e);
        this.eFloatingFilterText.setValue(i);
      }
    });
  }
}
kT([
  L("eFloatingFilterText")
], KS.prototype, "eFloatingFilterText", void 0);
kT([
  S("columnModel")
], KS.prototype, "columnModel", void 0);
class VT {
  constructor(e, t, i, r) {
    this.alive = !0, this.context = e, this.eParent = r, t.getDateCompDetails(i).newAgStackInstance().then((a) => {
      if (!this.alive) {
        e.destroyBean(a);
        return;
      }
      this.dateComp = a, a && (r.appendChild(a.getGui()), a.afterGuiAttached && a.afterGuiAttached(), this.tempValue && a.setDate(this.tempValue), this.disabled != null && this.setDateCompDisabled(this.disabled));
    });
  }
  destroy() {
    this.alive = !1, this.dateComp = this.context.destroyBean(this.dateComp);
  }
  getDate() {
    return this.dateComp ? this.dateComp.getDate() : this.tempValue;
  }
  setDate(e) {
    this.dateComp ? this.dateComp.setDate(e) : this.tempValue = e;
  }
  setDisabled(e) {
    this.dateComp ? this.setDateCompDisabled(e) : this.disabled = e;
  }
  setDisplayed(e) {
    Ke(this.eParent, e);
  }
  setInputPlaceholder(e) {
    this.dateComp && this.dateComp.setInputPlaceholder && this.dateComp.setInputPlaceholder(e);
  }
  setInputAriaLabel(e) {
    this.dateComp && this.dateComp.setInputAriaLabel && this.dateComp.setInputAriaLabel(e);
  }
  afterGuiAttached(e) {
    this.dateComp && typeof this.dateComp.afterGuiAttached == "function" && this.dateComp.afterGuiAttached(e);
  }
  setDateCompDisabled(e) {
    this.dateComp != null && this.dateComp.setDisabled != null && this.dateComp.setDisabled(e);
  }
}
class BT {
  constructor() {
    this.customFilterOptions = {};
  }
  init(e, t) {
    this.filterOptions = e.filterOptions || t, this.mapCustomOptions(), this.selectDefaultItem(e);
  }
  getFilterOptions() {
    return this.filterOptions;
  }
  mapCustomOptions() {
    this.filterOptions && this.filterOptions.forEach((e) => {
      if (typeof e == "string")
        return;
      const t = [["displayKey"], ["displayName"], ["predicate", "test"]], i = (r) => r.some((n) => e[n] != null) ? !0 : (console.warn(`AG Grid: ignoring FilterOptionDef as it doesn't contain one of '${r}'`), !1);
      if (!t.every(i)) {
        this.filterOptions = this.filterOptions.filter((r) => r === e) || [];
        return;
      }
      this.customFilterOptions[e.displayKey] = e;
    });
  }
  selectDefaultItem(e) {
    if (e.defaultOption)
      this.defaultOption = e.defaultOption;
    else if (this.filterOptions.length >= 1) {
      const t = this.filterOptions[0];
      typeof t == "string" ? this.defaultOption = t : t.displayKey ? this.defaultOption = t.displayKey : console.warn("AG Grid: invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'");
    } else
      console.warn("AG Grid: no filter options for filter");
  }
  getDefaultOption() {
    return this.defaultOption;
  }
  getCustomOption(e) {
    return this.customFilterOptions[e];
  }
}
const HT = {
  applyFilter: "Apply",
  clearFilter: "Clear",
  resetFilter: "Reset",
  cancelFilter: "Cancel",
  textFilter: "Text Filter",
  numberFilter: "Number Filter",
  dateFilter: "Date Filter",
  setFilter: "Set Filter",
  filterOoo: "Filter...",
  empty: "Choose One",
  equals: "Equals",
  notEqual: "Not equal",
  lessThan: "Less than",
  greaterThan: "Greater than",
  inRange: "In range",
  inRangeStart: "From",
  inRangeEnd: "To",
  lessThanOrEqual: "Less than or equals",
  greaterThanOrEqual: "Greater than or equals",
  contains: "Contains",
  notContains: "Not contains",
  startsWith: "Starts with",
  endsWith: "Ends with",
  blank: "Blank",
  notBlank: "Not blank",
  andCondition: "AND",
  orCondition: "OR",
  dateFormatOoo: "yyyy-mm-dd"
};
var WT = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Ji extends H {
  constructor(e, t = {}) {
    super(), this.eFocusableElement = e, this.callbacks = t, this.callbacks = Object.assign({ shouldStopEventPropagation: () => !1, onTabKeyDown: (i) => {
      if (i.defaultPrevented)
        return;
      const r = this.focusService.findNextFocusableElement(this.eFocusableElement, !1, i.shiftKey);
      r && (r.focus(), i.preventDefault());
    } }, t);
  }
  postConstruct() {
    this.eFocusableElement.classList.add(Ji.FOCUS_MANAGED_CLASS), this.addKeyDownListeners(this.eFocusableElement), this.callbacks.onFocusIn && this.addManagedListener(this.eFocusableElement, "focusin", this.callbacks.onFocusIn), this.callbacks.onFocusOut && this.addManagedListener(this.eFocusableElement, "focusout", this.callbacks.onFocusOut);
  }
  addKeyDownListeners(e) {
    this.addManagedListener(e, "keydown", (t) => {
      if (!(t.defaultPrevented || Eo(t))) {
        if (this.callbacks.shouldStopEventPropagation(t)) {
          Ss(t);
          return;
        }
        t.key === V.TAB ? this.callbacks.onTabKeyDown(t) : this.callbacks.handleKeyDown && this.callbacks.handleKeyDown(t);
      }
    });
  }
}
Ji.FOCUS_MANAGED_CLASS = "ag-focus-managed";
WT([
  S("focusService")
], Ji.prototype, "focusService", void 0);
WT([
  B
], Ji.prototype, "postConstruct", null);
var YS = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const jT = "ag-resizer-wrapper", YF = (
  /* html */
  `<div class="${jT}">
        <div ref="eTopLeftResizer" class="ag-resizer ag-resizer-topLeft"></div>
        <div ref="eTopResizer" class="ag-resizer ag-resizer-top"></div>
        <div ref="eTopRightResizer" class="ag-resizer ag-resizer-topRight"></div>
        <div ref="eRightResizer" class="ag-resizer ag-resizer-right"></div>
        <div ref="eBottomRightResizer" class="ag-resizer ag-resizer-bottomRight"></div>
        <div ref="eBottomResizer" class="ag-resizer ag-resizer-bottom"></div>
        <div ref="eBottomLeftResizer" class="ag-resizer ag-resizer-bottomLeft"></div>
        <div ref="eLeftResizer" class="ag-resizer ag-resizer-left"></div>
    </div>`
);
class ec extends H {
  constructor(e, t) {
    super(), this.element = e, this.dragStartPosition = {
      x: 0,
      y: 0
    }, this.position = {
      x: 0,
      y: 0
    }, this.lastSize = {
      width: -1,
      height: -1
    }, this.positioned = !1, this.resizersAdded = !1, this.resizeListeners = [], this.boundaryEl = null, this.isResizing = !1, this.isMoving = !1, this.resizable = {}, this.movable = !1, this.currentResizer = null, this.config = Object.assign({}, { popup: !1 }, t);
  }
  center() {
    const { clientHeight: e, clientWidth: t } = this.offsetParent, i = t / 2 - this.getWidth() / 2, r = e / 2 - this.getHeight() / 2;
    this.offsetElement(i, r);
  }
  initialisePosition() {
    if (this.positioned)
      return;
    const { centered: e, forcePopupParentAsOffsetParent: t, minWidth: i, width: r, minHeight: n, height: s, x: a, y: l } = this.config;
    this.offsetParent || this.setOffsetParent();
    let c = 0, d = 0;
    const u = !!this.element.offsetParent;
    if (u) {
      const h = this.findBoundaryElement(), p = window.getComputedStyle(h);
      if (p.minWidth != null) {
        const f = h.offsetWidth - this.element.offsetWidth;
        d = parseInt(p.minWidth, 10) - f;
      }
      if (p.minHeight != null) {
        const f = h.offsetHeight - this.element.offsetHeight;
        c = parseInt(p.minHeight, 10) - f;
      }
    }
    if (this.minHeight = n || c, this.minWidth = i || d, r && this.setWidth(r), s && this.setHeight(s), (!r || !s) && this.refreshSize(), e)
      this.center();
    else if (a || l)
      this.offsetElement(a, l);
    else if (u && t) {
      let h = this.boundaryEl, p = !0;
      if (h || (h = this.findBoundaryElement(), p = !1), h) {
        const f = parseFloat(h.style.top), g = parseFloat(h.style.left);
        p ? this.offsetElement(isNaN(g) ? 0 : g, isNaN(f) ? 0 : f) : this.setPosition(g, f);
      }
    }
    this.positioned = !!this.offsetParent;
  }
  isPositioned() {
    return this.positioned;
  }
  getPosition() {
    return this.position;
  }
  setMovable(e, t) {
    if (!this.config.popup || e === this.movable)
      return;
    this.movable = e;
    const i = this.moveElementDragListener || {
      eElement: t,
      onDragStart: this.onMoveStart.bind(this),
      onDragging: this.onMove.bind(this),
      onDragStop: this.onMoveEnd.bind(this)
    };
    e ? (this.dragService.addDragSource(i), this.moveElementDragListener = i) : (this.dragService.removeDragSource(i), this.moveElementDragListener = void 0);
  }
  setResizable(e) {
    if (this.clearResizeListeners(), e ? this.addResizers() : this.removeResizers(), typeof e == "boolean") {
      if (e === !1)
        return;
      e = {
        topLeft: e,
        top: e,
        topRight: e,
        right: e,
        bottomRight: e,
        bottom: e,
        bottomLeft: e,
        left: e
      };
    }
    Object.keys(e).forEach((t) => {
      const r = !!e[t], n = this.getResizerElement(t), s = {
        dragStartPixels: 0,
        eElement: n,
        onDragStart: (a) => this.onResizeStart(a, t),
        onDragging: this.onResize.bind(this),
        onDragStop: (a) => this.onResizeEnd(a, t)
      };
      (r || !this.isAlive() && !r) && (r ? (this.dragService.addDragSource(s), this.resizeListeners.push(s), n.style.pointerEvents = "all") : n.style.pointerEvents = "none", this.resizable[t] = r);
    });
  }
  removeSizeFromEl() {
    this.element.style.removeProperty("height"), this.element.style.removeProperty("width"), this.element.style.removeProperty("flex");
  }
  restoreLastSize() {
    this.element.style.flex = "0 0 auto";
    const { height: e, width: t } = this.lastSize;
    t !== -1 && (this.element.style.width = `${t}px`), e !== -1 && (this.element.style.height = `${e}px`);
  }
  getHeight() {
    return this.element.offsetHeight;
  }
  setHeight(e) {
    const { popup: t } = this.config, i = this.element;
    let r = !1;
    if (typeof e == "string" && e.indexOf("%") !== -1)
      Pl(i, e), e = LS(i), r = !0;
    else if (e = Math.max(this.minHeight, e), this.positioned) {
      const n = this.getAvailableHeight();
      n && e > n && (e = n);
    }
    this.getHeight() !== e && (r ? (i.style.maxHeight = "unset", i.style.minHeight = "unset") : t ? Pl(i, e) : (i.style.height = `${e}px`, i.style.flex = "0 0 auto", this.lastSize.height = typeof e == "number" ? e : parseFloat(e)));
  }
  getAvailableHeight() {
    const { popup: e, forcePopupParentAsOffsetParent: t } = this.config;
    this.positioned || this.initialisePosition();
    const { clientHeight: i } = this.offsetParent;
    if (!i)
      return null;
    const r = this.element.getBoundingClientRect(), n = this.offsetParent.getBoundingClientRect(), s = e ? this.position.y : r.top, a = e ? 0 : n.top;
    let l = 0;
    if (t) {
      const d = this.element.parentElement;
      if (d) {
        const { bottom: u } = d.getBoundingClientRect();
        l = u - r.bottom;
      }
    }
    return i + a - s - l;
  }
  getWidth() {
    return this.element.offsetWidth;
  }
  setWidth(e) {
    const t = this.element, { popup: i } = this.config;
    let r = !1;
    if (typeof e == "string" && e.indexOf("%") !== -1)
      dn(t, e), e = Hv(t), r = !0;
    else if (this.positioned) {
      e = Math.max(this.minWidth, e);
      const { clientWidth: n } = this.offsetParent, s = i ? this.position.x : this.element.getBoundingClientRect().left;
      n && e + s > n && (e = n - s);
    }
    this.getWidth() !== e && (r ? (t.style.maxWidth = "unset", t.style.minWidth = "unset") : this.config.popup ? dn(t, e) : (t.style.width = `${e}px`, t.style.flex = " unset", this.lastSize.width = typeof e == "number" ? e : parseFloat(e)));
  }
  offsetElement(e = 0, t = 0) {
    const { forcePopupParentAsOffsetParent: i } = this.config, r = i ? this.boundaryEl : this.element;
    r && (this.popupService.positionPopup({
      ePopup: r,
      keepWithinBounds: !0,
      skipObserver: this.movable || this.isResizable(),
      updatePosition: () => ({ x: e, y: t })
    }), this.setPosition(parseFloat(r.style.left), parseFloat(r.style.top)));
  }
  constrainSizeToAvailableHeight(e) {
    if (!this.config.forcePopupParentAsOffsetParent)
      return;
    const t = () => {
      const i = this.getAvailableHeight();
      this.element.style.setProperty("max-height", `${i}px`);
    };
    e ? this.resizeObserverSubscriber = this.resizeObserverService.observeResize(this.popupService.getPopupParent(), t) : (this.element.style.removeProperty("max-height"), this.resizeObserverSubscriber && (this.resizeObserverSubscriber(), this.resizeObserverSubscriber = void 0));
  }
  setPosition(e, t) {
    this.position.x = e, this.position.y = t;
  }
  updateDragStartPosition(e, t) {
    this.dragStartPosition = { x: e, y: t };
  }
  calculateMouseMovement(e) {
    const { e: t, isLeft: i, isTop: r, anywhereWithin: n, topBuffer: s } = e, a = t.clientX - this.dragStartPosition.x, l = t.clientY - this.dragStartPosition.y, c = this.shouldSkipX(t, !!i, !!n, a) ? 0 : a, d = this.shouldSkipY(t, !!r, s, l) ? 0 : l;
    return { movementX: c, movementY: d };
  }
  shouldSkipX(e, t, i, r) {
    const n = this.element.getBoundingClientRect(), s = this.offsetParent.getBoundingClientRect(), a = this.boundaryEl.getBoundingClientRect(), l = this.config.popup ? this.position.x : n.left;
    let c = l <= 0 && s.left >= e.clientX || s.right <= e.clientX && s.right <= a.right;
    return c ? !0 : (t ? c = // skip if we are moving to the left and the cursor
    // is positioned to the right of the left side anchor
    r < 0 && e.clientX > l + s.left || // skip if we are moving to the right and the cursor
    // is positioned to the left of the dialog
    r > 0 && e.clientX < l + s.left : i ? c = r < 0 && e.clientX > a.right || r > 0 && e.clientX < l + s.left : c = // if the movement is bound to the right side of the dialog
    // we skip if we are moving to the left and the cursor
    // is to the right of the dialog
    r < 0 && e.clientX > a.right || // or skip if we are moving to the right and the cursor
    // is to the left of the right side anchor
    r > 0 && e.clientX < a.right, c);
  }
  shouldSkipY(e, t, i = 0, r) {
    const n = this.element.getBoundingClientRect(), s = this.offsetParent.getBoundingClientRect(), a = this.boundaryEl.getBoundingClientRect(), l = this.config.popup ? this.position.y : n.top;
    let c = l <= 0 && s.top >= e.clientY || s.bottom <= e.clientY && s.bottom <= a.bottom;
    return c ? !0 : (t ? c = // skip if we are moving to towards top and the cursor is
    // below the top anchor + topBuffer
    // note: topBuffer is used when moving the dialog using the title bar
    r < 0 && e.clientY > l + s.top + i || // skip if we are moving to the bottom and the cursor is
    // above the top anchor
    r > 0 && e.clientY < l + s.top : c = // skip if we are moving towards the top and the cursor
    // is below the bottom anchor
    r < 0 && e.clientY > a.bottom || // skip if we are moving towards the bottom and the cursor
    // is above the bottom anchor
    r > 0 && e.clientY < a.bottom, c);
  }
  createResizeMap() {
    const e = this.element;
    this.resizerMap = {
      topLeft: { element: e.querySelector("[ref=eTopLeftResizer]") },
      top: { element: e.querySelector("[ref=eTopResizer]") },
      topRight: { element: e.querySelector("[ref=eTopRightResizer]") },
      right: { element: e.querySelector("[ref=eRightResizer]") },
      bottomRight: { element: e.querySelector("[ref=eBottomRightResizer]") },
      bottom: { element: e.querySelector("[ref=eBottomResizer]") },
      bottomLeft: { element: e.querySelector("[ref=eBottomLeftResizer]") },
      left: { element: e.querySelector("[ref=eLeftResizer]") }
    };
  }
  addResizers() {
    if (this.resizersAdded)
      return;
    const e = this.element;
    if (!e)
      return;
    const i = new DOMParser().parseFromString(YF, "text/html").body;
    e.appendChild(i.firstChild), this.createResizeMap(), this.resizersAdded = !0;
  }
  removeResizers() {
    this.resizerMap = void 0;
    const e = this.element.querySelector(`.${jT}`);
    e && this.element.removeChild(e), this.resizersAdded = !1;
  }
  getResizerElement(e) {
    return this.resizerMap[e].element;
  }
  onResizeStart(e, t) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.currentResizer = {
      isTop: !!t.match(/top/i),
      isRight: !!t.match(/right/i),
      isBottom: !!t.match(/bottom/i),
      isLeft: !!t.match(/left/i)
    }, this.element.classList.add("ag-resizing"), this.resizerMap[t].element.classList.add("ag-active");
    const { popup: i, forcePopupParentAsOffsetParent: r } = this.config;
    !i && !r && this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop), this.isResizing = !0, this.updateDragStartPosition(e.clientX, e.clientY);
  }
  getSiblings() {
    const t = this.element.parentElement;
    return t ? Array.prototype.slice.call(t.children).filter((i) => !i.classList.contains("ag-hidden")) : null;
  }
  getMinSizeOfSiblings() {
    const e = this.getSiblings() || [];
    let t = 0, i = 0;
    for (let r = 0; r < e.length; r++) {
      const n = e[r], s = !!n.style.flex && n.style.flex !== "0 0 auto";
      if (n === this.element)
        continue;
      let a = this.minHeight || 0, l = this.minWidth || 0;
      if (s) {
        const c = window.getComputedStyle(n);
        c.minHeight && (a = parseInt(c.minHeight, 10)), c.minWidth && (l = parseInt(c.minWidth, 10));
      } else
        a = n.offsetHeight, l = n.offsetWidth;
      t += a, i += l;
    }
    return { height: t, width: i };
  }
  applySizeToSiblings(e) {
    let t = null;
    const i = this.getSiblings();
    if (i) {
      for (let r = 0; r < i.length; r++) {
        const n = i[r];
        n !== t && (e ? n.style.height = `${n.offsetHeight}px` : n.style.width = `${n.offsetWidth}px`, n.style.flex = "0 0 auto", n === this.element && (t = i[r + 1]));
      }
      t && (t.style.removeProperty("height"), t.style.removeProperty("min-height"), t.style.removeProperty("max-height"), t.style.flex = "1 1 auto");
    }
  }
  isResizable() {
    return Object.values(this.resizable).some((e) => e);
  }
  onResize(e) {
    if (!this.isResizing || !this.currentResizer)
      return;
    const { popup: t, forcePopupParentAsOffsetParent: i } = this.config, { isTop: r, isRight: n, isBottom: s, isLeft: a } = this.currentResizer, l = n || a, c = s || r, { movementX: d, movementY: u } = this.calculateMouseMovement({ e, isLeft: a, isTop: r }), h = this.position.x, p = this.position.y;
    let f = 0, g = 0;
    if (l && d) {
      const v = a ? -1 : 1, y = this.getWidth(), m = y + d * v;
      let C = !1;
      a && (f = y - m, (h + f <= 0 || m <= this.minWidth) && (C = !0, f = 0)), C || this.setWidth(m);
    }
    if (c && u) {
      const v = r ? -1 : 1, y = this.getHeight(), m = y + u * v;
      let C = !1;
      r ? (g = y - m, (p + g <= 0 || m <= this.minHeight) && (C = !0, g = 0)) : !this.config.popup && !this.config.forcePopupParentAsOffsetParent && y < m && this.getMinSizeOfSiblings().height + m > this.element.parentElement.offsetHeight && (C = !0), C || this.setHeight(m);
    }
    this.updateDragStartPosition(e.clientX, e.clientY), ((t || i) && f || g) && this.offsetElement(h + f, p + g);
  }
  onResizeEnd(e, t) {
    this.isResizing = !1, this.currentResizer = null, this.boundaryEl = null;
    const i = {
      type: "resize",
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi
    };
    this.element.classList.remove("ag-resizing"), this.resizerMap[t].element.classList.remove("ag-active"), this.dispatchEvent(i);
  }
  refreshSize() {
    const e = this.element;
    this.config.popup && (this.config.width || this.setWidth(e.offsetWidth), this.config.height || this.setHeight(e.offsetHeight));
  }
  onMoveStart(e) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.isMoving = !0, this.element.classList.add("ag-moving"), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMove(e) {
    if (!this.isMoving)
      return;
    const { x: t, y: i } = this.position;
    let r;
    this.config.calculateTopBuffer && (r = this.config.calculateTopBuffer());
    const { movementX: n, movementY: s } = this.calculateMouseMovement({
      e,
      isTop: !0,
      anywhereWithin: !0,
      topBuffer: r
    });
    this.offsetElement(t + n, i + s), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMoveEnd() {
    this.isMoving = !1, this.boundaryEl = null, this.element.classList.remove("ag-moving");
  }
  setOffsetParent() {
    this.config.forcePopupParentAsOffsetParent ? this.offsetParent = this.popupService.getPopupParent() : this.offsetParent = this.element.offsetParent;
  }
  findBoundaryElement() {
    let e = this.element;
    for (; e; ) {
      if (window.getComputedStyle(e).position !== "static")
        return e;
      e = e.parentElement;
    }
    return this.element;
  }
  clearResizeListeners() {
    for (; this.resizeListeners.length; ) {
      const e = this.resizeListeners.pop();
      this.dragService.removeDragSource(e);
    }
  }
  destroy() {
    super.destroy(), this.moveElementDragListener && this.dragService.removeDragSource(this.moveElementDragListener), this.constrainSizeToAvailableHeight(!1), this.clearResizeListeners(), this.removeResizers();
  }
}
YS([
  S("popupService")
], ec.prototype, "popupService", void 0);
YS([
  S("resizeObserverService")
], ec.prototype, "resizeObserverService", void 0);
YS([
  S("dragService")
], ec.prototype, "dragService", void 0);
var XS = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Pr extends X {
  constructor(e) {
    super(), this.filterNameKey = e, this.applyActive = !1, this.hidePopup = null, this.debouncePending = !1, this.appliedModel = null;
  }
  postConstruct() {
    this.resetTemplate(), this.createManagedBean(new Ji(this.getFocusableElement(), {
      handleKeyDown: this.handleKeyDown.bind(this)
    })), this.positionableFeature = new ec(this.getPositionableElement(), {
      forcePopupParentAsOffsetParent: !0
    }), this.createBean(this.positionableFeature);
  }
  // override
  handleKeyDown(e) {
  }
  getFilterTitle() {
    return this.translate(this.filterNameKey);
  }
  isFilterActive() {
    return !!this.appliedModel;
  }
  resetTemplate(e) {
    let t = this.getGui();
    t && t.removeEventListener("submit", this.onFormSubmit);
    const i = (
      /* html */
      `
            <form class="ag-filter-wrapper">
                <div class="ag-filter-body-wrapper ag-${this.getCssIdentifier()}-body-wrapper" ref="eFilterBody">
                    ${this.createBodyTemplate()}
                </div>
            </form>`
    );
    this.setTemplate(i, e), t = this.getGui(), t && t.addEventListener("submit", this.onFormSubmit);
  }
  isReadOnly() {
    return !!this.providedFilterParams.readOnly;
  }
  init(e) {
    this.setParams(e), this.resetUiToDefaults(!0).then(() => {
      this.updateUiVisibility(), this.setupOnBtApplyDebounce();
    });
  }
  setParams(e) {
    this.providedFilterParams = e, this.applyActive = Pr.isUseApplyButton(e), this.createButtonPanel();
  }
  createButtonPanel() {
    const { buttons: e } = this.providedFilterParams;
    if (!e || e.length < 1 || this.isReadOnly())
      return;
    const t = document.createElement("div");
    t.classList.add("ag-filter-apply-panel");
    const i = (r) => {
      let n, s;
      switch (r) {
        case "apply":
          n = this.translate("applyFilter"), s = (c) => this.onBtApply(!1, !1, c);
          break;
        case "clear":
          n = this.translate("clearFilter"), s = () => this.onBtClear();
          break;
        case "reset":
          n = this.translate("resetFilter"), s = () => this.onBtReset();
          break;
        case "cancel":
          n = this.translate("cancelFilter"), s = (c) => {
            this.onBtCancel(c);
          };
          break;
        default:
          console.warn("AG Grid: Unknown button type specified");
          return;
      }
      const l = Si(
        /* html */
        `<button
                    type="${r === "apply" ? "submit" : "button"}"
                    ref="${r}FilterButton"
                    class="ag-button ag-standard-button ag-filter-apply-panel-button"
                >${n}
                </button>`
      );
      t.appendChild(l), this.addManagedListener(l, "click", s);
    };
    US(e).forEach((r) => i(r)), this.getGui().appendChild(t);
  }
  // subclasses can override this to provide alternative debounce defaults
  getDefaultDebounceMs() {
    return 0;
  }
  setupOnBtApplyDebounce() {
    const e = Pr.getDebounceMs(this.providedFilterParams, this.getDefaultDebounceMs()), t = Co(this.checkApplyDebounce.bind(this), e);
    this.onBtApplyDebounce = () => {
      this.debouncePending = !0, t();
    };
  }
  checkApplyDebounce() {
    this.debouncePending && (this.debouncePending = !1, this.onBtApply());
  }
  getModel() {
    return this.appliedModel ? this.appliedModel : null;
  }
  setModel(e) {
    return (e != null ? this.setModelIntoUi(e) : this.resetUiToDefaults()).then(() => {
      this.updateUiVisibility(), this.applyModel("api");
    });
  }
  onBtCancel(e) {
    this.resetUiToActiveModel(this.getModel(), () => {
      this.handleCancelEnd(e);
    });
  }
  handleCancelEnd(e) {
    this.providedFilterParams.closeOnApply && this.close(e);
  }
  resetUiToActiveModel(e, t) {
    const i = () => {
      this.onUiChanged(!1, "prevent"), t == null || t();
    };
    e != null ? this.setModelIntoUi(e).then(i) : this.resetUiToDefaults().then(i);
  }
  onBtClear() {
    this.resetUiToDefaults().then(() => this.onUiChanged());
  }
  onBtReset() {
    this.onBtClear(), this.onBtApply();
  }
  /**
   * Applies changes made in the UI to the filter, and returns true if the model has changed.
   */
  applyModel(e = "api") {
    const t = this.getModelFromUi();
    if (!this.isModelValid(t))
      return !1;
    const i = this.appliedModel;
    return this.appliedModel = t, !this.areModelsEqual(i, t);
  }
  isModelValid(e) {
    return !0;
  }
  onFormSubmit(e) {
    e.preventDefault();
  }
  onBtApply(e = !1, t = !1, i) {
    i && i.preventDefault(), this.applyModel(t ? "rowDataUpdated" : "ui") && this.providedFilterParams.filterChangedCallback({ afterFloatingFilter: e, afterDataChange: t });
    const { closeOnApply: r } = this.providedFilterParams;
    r && this.applyActive && !e && !t && this.close(i);
  }
  onNewRowsLoaded() {
  }
  close(e) {
    if (!this.hidePopup)
      return;
    const t = e, i = t && t.key;
    let r;
    (i === "Enter" || i === "Space") && (r = { keyboardEvent: t }), this.hidePopup(r), this.hidePopup = null;
  }
  /**
   * By default, if the change came from a floating filter it will be applied immediately, otherwise if there is no
   * apply button it will be applied after a debounce, otherwise it will not be applied at all. This behaviour can
   * be adjusted by using the apply parameter.
   */
  onUiChanged(e = !1, t) {
    if (this.updateUiVisibility(), this.providedFilterParams.filterModifiedCallback(), this.applyActive && !this.isReadOnly()) {
      const i = this.isModelValid(this.getModelFromUi());
      Id(this.getRefElement("applyFilterButton"), !i);
    }
    e && !t || t === "immediately" ? this.onBtApply(e) : (!this.applyActive && !t || t === "debounce") && this.onBtApplyDebounce();
  }
  afterGuiAttached(e) {
    e && (this.hidePopup = e.hidePopup), this.refreshFilterResizer(e == null ? void 0 : e.container);
  }
  refreshFilterResizer(e) {
    if (!this.positionableFeature || e === "toolPanel")
      return;
    const t = e === "floatingFilter", { positionableFeature: i, gridOptionsService: r } = this;
    t ? (i.restoreLastSize(), i.setResizable(r.is("enableRtl") ? { bottom: !0, bottomLeft: !0, left: !0 } : { bottom: !0, bottomRight: !0, right: !0 })) : (this.positionableFeature.removeSizeFromEl(), this.positionableFeature.setResizable(!1)), this.positionableFeature.constrainSizeToAvailableHeight(!0);
  }
  afterGuiDetached() {
    this.checkApplyDebounce(), this.positionableFeature && this.positionableFeature.constrainSizeToAvailableHeight(!1);
  }
  // static, as used by floating filter also
  static getDebounceMs(e, t) {
    return Pr.isUseApplyButton(e) ? (e.debounceMs != null && console.warn("AG Grid: debounceMs is ignored when apply button is present"), 0) : e.debounceMs != null ? e.debounceMs : t;
  }
  // static, as used by floating filter also
  static isUseApplyButton(e) {
    return !!e.buttons && e.buttons.indexOf("apply") >= 0;
  }
  destroy() {
    const e = this.getGui();
    e && e.removeEventListener("submit", this.onFormSubmit), this.hidePopup = null, this.positionableFeature && (this.positionableFeature = this.destroyBean(this.positionableFeature)), super.destroy();
  }
  translate(e) {
    return this.localeService.getLocaleTextFunc()(e, HT[e]);
  }
  getCellValue(e) {
    const { api: t, colDef: i, column: r, columnApi: n, context: s } = this.providedFilterParams;
    return this.providedFilterParams.valueGetter({
      api: t,
      colDef: i,
      column: r,
      columnApi: n,
      context: s,
      data: e.data,
      getValue: (a) => e.data[a],
      node: e
    });
  }
  // override to control positionable feature
  getPositionableElement() {
    return this.eFilterBody;
  }
}
XS([
  S("rowModel")
], Pr.prototype, "rowModel", void 0);
XS([
  L("eFilterBody")
], Pr.prototype, "eFilterBody", void 0);
XS([
  B
], Pr.prototype, "postConstruct", null);
var XF = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Wv extends X {
  constructor(e, t) {
    super(t), this.labelSeparator = "", this.labelAlignment = "left", this.disabled = !1, this.label = "", this.config = e || {};
  }
  postConstruct() {
    this.addCssClass("ag-labeled"), this.eLabel.classList.add("ag-label");
    const { labelSeparator: e, label: t, labelWidth: i, labelAlignment: r } = this.config;
    e != null && this.setLabelSeparator(e), t != null && this.setLabel(t), i != null && this.setLabelWidth(i), this.setLabelAlignment(r || this.labelAlignment), this.refreshLabel();
  }
  refreshLabel() {
    Or(this.eLabel), typeof this.label == "string" ? this.eLabel.innerText = this.label + this.labelSeparator : this.label && this.eLabel.appendChild(this.label), this.label === "" ? (Ke(this.eLabel, !1), ci(this.eLabel, "presentation")) : (Ke(this.eLabel, !0), ci(this.eLabel, null));
  }
  setLabelSeparator(e) {
    return this.labelSeparator === e ? this : (this.labelSeparator = e, this.label != null && this.refreshLabel(), this);
  }
  getLabelId() {
    return this.eLabel.id = this.eLabel.id || `ag-${this.getCompId()}-label`, this.eLabel.id;
  }
  getLabel() {
    return this.label;
  }
  setLabel(e) {
    return this.label === e ? this : (this.label = e, this.refreshLabel(), this);
  }
  setLabelAlignment(e) {
    const i = this.getGui().classList;
    return i.toggle("ag-label-align-left", e === "left"), i.toggle("ag-label-align-right", e === "right"), i.toggle("ag-label-align-top", e === "top"), this;
  }
  setLabelEllipsis(e) {
    return this.eLabel.classList.toggle("ag-label-ellipsis", e), this;
  }
  setLabelWidth(e) {
    return this.label == null ? this : (xp(this.eLabel, e), this);
  }
  setDisabled(e) {
    e = !!e;
    const t = this.getGui();
    return Id(t, e), t.classList.toggle("ag-disabled", e), this.disabled = e, this;
  }
  isDisabled() {
    return !!this.disabled;
  }
}
XF([
  B
], Wv.prototype, "postConstruct", null);
class ir extends Wv {
  constructor(e, t, i) {
    super(e, t), this.className = i;
  }
  postConstruct() {
    super.postConstruct(), this.className && this.addCssClass(this.className);
  }
  onValueChange(e) {
    return this.addManagedListener(this, ir.EVENT_CHANGED, () => e(this.getValue())), this;
  }
  getWidth() {
    return this.getGui().clientWidth;
  }
  setWidth(e) {
    return dn(this.getGui(), e), this;
  }
  getPreviousValue() {
    return this.previousValue;
  }
  getValue() {
    return this.value;
  }
  setValue(e, t) {
    return this.value === e ? this : (this.previousValue = this.value, this.value = e, t || this.dispatchEvent({ type: ir.EVENT_CHANGED }), this);
  }
}
ir.EVENT_CHANGED = "valueChange";
var jv = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class au extends ir {
  constructor(e, t, i, r) {
    super(
      e,
      /* html */
      `<div class="ag-picker-field" role="presentation">
                <div ref="eLabel"></div>
                <div ref="eWrapper"
                    class="ag-wrapper ag-picker-field-wrapper"
                    tabIndex="-1"
                    aria-expanded="false"
                    ${r ? `role="${r}"` : ""}
                >
                    <div ref="eDisplayField" class="ag-picker-field-display"></div>
                    <div ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                </div>
            </div>`,
      t
    ), this.pickerIcon = i, this.isPickerDisplayed = !1, this.isDestroyingPicker = !1, this.skipClick = !1;
  }
  postConstruct() {
    super.postConstruct();
    const e = `ag-${this.getCompId()}-display`;
    this.eDisplayField.setAttribute("id", e), dT(this.eWrapper, e);
    const t = () => {
      if (this.skipClick) {
        this.skipClick = !1;
        return;
      }
      this.isDisabled() || (this.pickerComponent = this.showPicker());
    }, i = this.getGui();
    if (this.addManagedListener(i, "mousedown", (r) => {
      !this.skipClick && this.pickerComponent && this.pickerComponent.isAlive() && Ms(this.pickerComponent.getGui()) && i.contains(r.target) && (this.skipClick = !0);
    }), this.addManagedListener(i, "keydown", (r) => {
      switch (r.key) {
        case V.UP:
        case V.DOWN:
        case V.ENTER:
        case V.SPACE:
          t();
        case V.ESCAPE:
          this.isPickerDisplayed && r.preventDefault();
          break;
      }
    }), this.addManagedListener(this.eWrapper, "click", t), this.addManagedListener(this.eLabel, "click", t), this.pickerIcon) {
      const r = Vt(this.pickerIcon, this.gridOptionsService);
      r && this.eIcon.appendChild(r);
    }
  }
  refreshLabel() {
    z(this.getLabel()) ? Lv(this.eWrapper, this.getLabelId()) : this.eWrapper.removeAttribute("aria-labelledby"), super.refreshLabel();
  }
  setAriaLabel(e) {
    return Ia(this.eWrapper, e), this;
  }
  setInputWidth(e) {
    return xp(this.eWrapper, e), this;
  }
  getFocusableElement() {
    return this.eWrapper;
  }
}
jv([
  L("eLabel")
], au.prototype, "eLabel", void 0);
jv([
  L("eWrapper")
], au.prototype, "eWrapper", void 0);
jv([
  L("eDisplayField")
], au.prototype, "eDisplayField", void 0);
jv([
  L("eIcon")
], au.prototype, "eIcon", void 0);
var qF = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class vs extends X {
  constructor(e = "default") {
    super(
      /* html */
      `<div class="ag-list ag-${e}-list" role="listbox"></div>`
    ), this.cssIdentifier = e, this.options = [], this.itemEls = [];
  }
  init() {
    this.addManagedListener(this.getGui(), "keydown", this.handleKeyDown.bind(this));
  }
  handleKeyDown(e) {
    const t = e.key;
    switch (t) {
      case V.ENTER:
        if (!this.highlightedEl)
          this.setValue(this.getValue());
        else {
          const n = this.itemEls.indexOf(this.highlightedEl);
          this.setValueByIndex(n);
        }
        break;
      case V.DOWN:
      case V.UP:
        const i = t === V.DOWN;
        let r;
        if (e.preventDefault(), !this.highlightedEl)
          r = this.itemEls[i ? 0 : this.itemEls.length - 1];
        else {
          let s = this.itemEls.indexOf(this.highlightedEl) + (i ? 1 : -1);
          s = Math.min(Math.max(s, 0), this.itemEls.length - 1), r = this.itemEls[s];
        }
        this.highlightItem(r);
        break;
    }
  }
  addOptions(e) {
    return e.forEach((t) => this.addOption(t)), this;
  }
  addOption(e) {
    const { value: t, text: i } = e, r = xo(i || t);
    return this.options.push({ value: t, text: r }), this.renderOption(t, r), this.updateIndices(), this;
  }
  updateIndices() {
    const e = this.getGui().querySelectorAll(".ag-list-item");
    e.forEach((t, i) => {
      xS(t, i + 1), TS(t, e.length);
    });
  }
  renderOption(e, t) {
    const i = document.createElement("div");
    ci(i, "option"), i.classList.add("ag-list-item", `ag-${this.cssIdentifier}-list-item`), i.innerHTML = `<span>${t}</span>`, i.tabIndex = -1, this.itemEls.push(i), this.addManagedListener(i, "mouseover", () => this.highlightItem(i)), this.addManagedListener(i, "mouseleave", () => this.clearHighlighted()), this.addManagedListener(i, "click", () => this.setValue(e)), this.getGui().appendChild(i);
  }
  setValue(e, t) {
    if (this.value === e)
      return this.fireItemSelected(), this;
    if (e == null)
      return this.reset(), this;
    const i = this.options.findIndex((r) => r.value === e);
    if (i !== -1) {
      const r = this.options[i];
      this.value = r.value, this.displayValue = r.text != null ? r.text : r.value, this.highlightItem(this.itemEls[i]), t || this.fireChangeEvent();
    }
    return this;
  }
  setValueByIndex(e) {
    return this.setValue(this.options[e].value);
  }
  getValue() {
    return this.value;
  }
  getDisplayValue() {
    return this.displayValue;
  }
  refreshHighlighted() {
    this.clearHighlighted();
    const e = this.options.findIndex((t) => t.value === this.value);
    e !== -1 && this.highlightItem(this.itemEls[e]);
  }
  reset() {
    this.value = null, this.displayValue = null, this.clearHighlighted(), this.fireChangeEvent();
  }
  highlightItem(e) {
    e.offsetParent && (this.clearHighlighted(), this.highlightedEl = e, this.highlightedEl.classList.add(vs.ACTIVE_CLASS), _d(this.highlightedEl, !0), this.highlightedEl.focus());
  }
  clearHighlighted() {
    !this.highlightedEl || !this.highlightedEl.offsetParent || (this.highlightedEl.classList.remove(vs.ACTIVE_CLASS), _d(this.highlightedEl, !1), this.highlightedEl = null);
  }
  fireChangeEvent() {
    this.dispatchEvent({ type: ir.EVENT_CHANGED }), this.fireItemSelected();
  }
  fireItemSelected() {
    this.dispatchEvent({ type: vs.EVENT_ITEM_SELECTED });
  }
}
vs.EVENT_ITEM_SELECTED = "selectedItem";
vs.ACTIVE_CLASS = "ag-active-item";
qF([
  B
], vs.prototype, "init", null);
var UT = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class zn extends au {
  constructor(e) {
    super(e, "ag-select", "smallDown", "listbox");
  }
  init() {
    this.listComponent = this.createBean(new vs("select")), this.listComponent.setParentComponent(this), this.eWrapper.tabIndex = 0, this.listComponent.addManagedListener(this.listComponent, vs.EVENT_ITEM_SELECTED, () => {
      this.hideList && this.hideList(), this.dispatchEvent({ type: zn.EVENT_ITEM_SELECTED });
    }), this.listComponent.addManagedListener(this.listComponent, ir.EVENT_CHANGED, () => {
      this.setValue(this.listComponent.getValue(), !1, !0), this.hideList && this.hideList();
    });
  }
  showPicker() {
    const e = this.listComponent.getGui(), t = this.gridOptionsService.getDocument(), i = this.addManagedListener(t.body, "wheel", (a) => {
      !e.contains(a.target) && this.hideList && this.hideList();
    }), r = this.addManagedListener(e, "focusout", (a) => {
      !e.contains(a.relatedTarget) && this.hideList && this.hideList();
    }), n = this.localeService.getLocaleTextFunc(), s = this.popupService.addPopup({
      modal: !0,
      eChild: e,
      closeOnEsc: !0,
      closedCallback: () => {
        this.hideList = null, this.isPickerDisplayed = !1, r(), i(), this.isAlive() && (Ln(this.eWrapper, !1), this.getFocusableElement().focus());
      },
      ariaLabel: n("ariaLabelSelectField", "Select Field")
    });
    return s && (this.hideList = s.hideFunc), this.isPickerDisplayed = !0, xp(e, Hv(this.eWrapper)), Ln(this.eWrapper, !0), e.style.maxHeight = Tp(this.popupService.getPopupParent()) + "px", e.style.position = "absolute", this.popupService.positionPopupByComponent({
      type: "ag-list",
      eventSource: this.eWrapper,
      ePopup: e,
      position: "under",
      keepWithinBounds: !0
    }), this.listComponent.refreshHighlighted(), this.listComponent;
  }
  addOptions(e) {
    return e.forEach((t) => this.addOption(t)), this;
  }
  addOption(e) {
    return this.listComponent.addOption(e), this;
  }
  setValue(e, t, i) {
    return this.value === e ? this : (i || this.listComponent.setValue(e, !0), this.listComponent.getValue() === this.getValue() ? this : (this.eDisplayField.innerHTML = this.listComponent.getDisplayValue(), super.setValue(e, t)));
  }
  destroy() {
    this.hideList && this.hideList(), this.destroyBean(this.listComponent), super.destroy();
  }
}
zn.EVENT_ITEM_SELECTED = "selectedItem";
UT([
  S("popupService")
], zn.prototype, "popupService", void 0);
UT([
  B
], zn.prototype, "init", null);
var qS = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Nn extends ir {
  constructor(e, t, i = "text", r = "input") {
    super(
      e,
      /* html */
      `
            <div role="presentation">
                <div ref="eLabel" class="ag-input-field-label"></div>
                <div ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">
                    <${r} ref="eInput" class="ag-input-field-input"></${r}>
                </div>
            </div>`,
      t
    ), this.inputType = i, this.displayFieldTag = r;
  }
  postConstruct() {
    super.postConstruct(), this.setInputType(), this.eLabel.classList.add(`${this.className}-label`), this.eWrapper.classList.add(`${this.className}-input-wrapper`), this.eInput.classList.add(`${this.className}-input`), this.addCssClass("ag-input-field"), this.eInput.id = this.eInput.id || `ag-${this.getCompId()}-input`;
    const { width: e, value: t } = this.config;
    e != null && this.setWidth(e), t != null && this.setValue(t), this.addInputListeners(), this.activateTabIndex([this.eInput]);
  }
  refreshLabel() {
    z(this.getLabel()) ? Lv(this.eInput, this.getLabelId()) : this.eInput.removeAttribute("aria-labelledby"), super.refreshLabel();
  }
  addInputListeners() {
    this.addManagedListener(this.eInput, "input", (e) => this.setValue(e.target.value));
  }
  setInputType() {
    this.displayFieldTag === "input" && this.eInput.setAttribute("type", this.inputType);
  }
  getInputElement() {
    return this.eInput;
  }
  setInputWidth(e) {
    return xp(this.eWrapper, e), this;
  }
  setInputName(e) {
    return this.getInputElement().setAttribute("name", e), this;
  }
  getFocusableElement() {
    return this.eInput;
  }
  setMaxLength(e) {
    const t = this.eInput;
    return t.maxLength = e, this;
  }
  setInputPlaceholder(e) {
    return da(this.eInput, "placeholder", e), this;
  }
  setInputAriaLabel(e) {
    return Ia(this.eInput, e), this;
  }
  setDisabled(e) {
    return Id(this.eInput, e), super.setDisabled(e);
  }
}
qS([
  L("eLabel")
], Nn.prototype, "eLabel", void 0);
qS([
  L("eWrapper")
], Nn.prototype, "eWrapper", void 0);
qS([
  L("eInput")
], Nn.prototype, "eInput", void 0);
class rr extends Nn {
  constructor(e, t = "ag-checkbox", i = "checkbox") {
    super(e, t, i), this.labelAlignment = "right", this.selected = !1, this.readOnly = !1, this.passive = !1;
  }
  addInputListeners() {
    this.addManagedListener(this.eInput, "click", this.onCheckboxClick.bind(this)), this.addManagedListener(this.eLabel, "click", this.toggle.bind(this));
  }
  getNextValue() {
    return this.selected === void 0 ? !0 : !this.selected;
  }
  setPassive(e) {
    this.passive = e;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setReadOnly(e) {
    this.eWrapper.classList.toggle("ag-disabled", e), this.eInput.disabled = e, this.readOnly = e;
  }
  setDisabled(e) {
    return this.eWrapper.classList.toggle("ag-disabled", e), super.setDisabled(e);
  }
  toggle() {
    if (this.eInput.disabled)
      return;
    const e = this.isSelected(), t = this.getNextValue();
    this.passive ? this.dispatchChange(t, e) : this.setValue(t);
  }
  getValue() {
    return this.isSelected();
  }
  setValue(e, t) {
    return this.refreshSelectedClass(e), this.setSelected(e, t), this;
  }
  setName(e) {
    const t = this.getInputElement();
    return t.name = e, this;
  }
  isSelected() {
    return this.selected;
  }
  setSelected(e, t) {
    this.isSelected() !== e && (this.previousValue = this.isSelected(), e = this.selected = typeof e == "boolean" ? e : void 0, this.eInput.checked = e, this.eInput.indeterminate = e === void 0, t || this.dispatchChange(this.selected, this.previousValue));
  }
  dispatchChange(e, t, i) {
    this.dispatchEvent({ type: rr.EVENT_CHANGED, selected: e, previousValue: t, event: i });
    const r = this.getInputElement(), n = {
      type: w.EVENT_CHECKBOX_CHANGED,
      id: r.id,
      name: r.name,
      selected: e,
      previousValue: t
    };
    this.eventService.dispatchEvent(n);
  }
  onCheckboxClick(e) {
    if (this.passive || this.eInput.disabled)
      return;
    const t = this.isSelected(), i = this.selected = e.target.checked;
    this.refreshSelectedClass(i), this.dispatchChange(i, t, e);
  }
  refreshSelectedClass(e) {
    this.eWrapper.classList.toggle("ag-checked", e === !0), this.eWrapper.classList.toggle("ag-indeterminate", e == null);
  }
}
class ZS extends rr {
  constructor(e) {
    super(e, "ag-radio-button", "radio");
  }
  isSelected() {
    return this.eInput.checked;
  }
  toggle() {
    this.eInput.disabled || this.isSelected() || this.setValue(!0);
  }
  addInputListeners() {
    super.addInputListeners(), this.addManagedListener(this.eventService, w.EVENT_CHECKBOX_CHANGED, this.onChange.bind(this));
  }
  /**
   * This ensures that if another radio button in the same named group is selected, we deselect this radio button.
   * By default the browser does this for you, but we are managing classes ourselves in order to ensure input
   * elements are styled correctly in IE11, and the DOM 'changed' event is only fired when a button is selected,
   * not deselected, so we need to use our own event.
   */
  onChange(e) {
    e.selected && e.name && this.eInput.name && this.eInput.name === e.name && e.id && this.eInput.id !== e.id && this.setValue(!1, !0);
  }
}
class QS {
  constructor(e, t) {
    this.localeService = e, this.optionsFactory = t;
  }
  // used by:
  // 1) NumberFloatingFilter & TextFloatingFilter: Always, for both when editable and read only.
  // 2) DateFloatingFilter: Only when read only (as we show text rather than a date picker when read only)
  getModelAsString(e) {
    if (!e)
      return null;
    const t = e.operator != null, i = this.localeService.getLocaleTextFunc();
    if (t) {
      const r = e;
      let { conditions: n } = r;
      if (!n) {
        const { condition1: l, condition2: c } = r;
        n = [l, c];
      }
      const s = n.map((l) => this.getModelAsString(l)), a = r.operator === "AND" ? "andCondition" : "orCondition";
      return s.join(` ${i(a, HT[a])} `);
    } else {
      if (e.type === Le.BLANK || e.type === Le.NOT_BLANK)
        return i(e.type, e.type);
      {
        const r = e, n = this.optionsFactory.getCustomOption(r.type), { displayKey: s, displayName: a, numberOfInputs: l } = n || {};
        return s && a && l === 0 ? (i(s, a), a) : this.conditionToString(r, n);
      }
    }
  }
}
class Le extends Pr {
  constructor() {
    super(...arguments), this.eTypes = [], this.eJoinOperatorPanels = [], this.eJoinOperatorsAnd = [], this.eJoinOperatorsOr = [], this.eConditionBodies = [], this.listener = () => this.onUiChanged(), this.lastUiCompletePosition = null, this.joinOperatorId = 0;
  }
  getNumberOfInputs(e) {
    const t = this.optionsFactory.getCustomOption(e);
    if (t) {
      const { numberOfInputs: r } = t;
      return r != null ? r : 1;
    }
    const i = [
      Le.EMPTY,
      Le.NOT_BLANK,
      Le.BLANK
    ];
    return e && i.indexOf(e) >= 0 ? 0 : e === Le.IN_RANGE ? 2 : 1;
  }
  // floating filter calls this when user applies filter from floating filter
  onFloatingFilterChanged(e, t) {
    this.setTypeFromFloatingFilter(e), this.setValueFromFloatingFilter(t), this.onUiChanged(!0);
  }
  setTypeFromFloatingFilter(e) {
    this.eTypes.forEach((t, i) => {
      i === 0 ? t.setValue(e, !0) : t.setValue(this.optionsFactory.getDefaultOption(), !0);
    });
  }
  getModelFromUi() {
    const e = this.getUiCompleteConditions();
    return e.length === 0 ? null : this.maxNumConditions > 1 && e.length > 1 ? {
      filterType: this.getFilterType(),
      operator: this.getJoinOperator(),
      condition1: e[0],
      condition2: e[1],
      conditions: e
    } : e[0];
  }
  getConditionTypes() {
    return this.eTypes.map((e) => e.getValue());
  }
  getConditionType(e) {
    return this.eTypes[e].getValue();
  }
  getJoinOperator() {
    return this.eJoinOperatorsOr.length === 0 ? this.defaultJoinOperator : this.eJoinOperatorsOr[0].getValue() === !0 ? "OR" : "AND";
  }
  areModelsEqual(e, t) {
    if (!e && !t)
      return !0;
    if (!e && t || e && !t)
      return !1;
    const i = !e.operator, r = !t.operator;
    if (!i && r || i && !r)
      return !1;
    let s;
    if (i) {
      const a = e, l = t;
      s = this.areSimpleModelsEqual(a, l);
    } else {
      const a = e, l = t;
      s = a.operator === l.operator && ia(a.conditions, l.conditions, (c, d) => this.areSimpleModelsEqual(c, d));
    }
    return s;
  }
  setModelIntoUi(e) {
    if (e.operator) {
      let i = e;
      i.conditions || (i.conditions = [
        i.condition1,
        i.condition2
      ]);
      const r = this.validateAndUpdateConditions(i.conditions), n = this.getNumConditions();
      if (r < n)
        this.removeConditionsAndOperators(r);
      else if (r > n)
        for (let a = n; a < r; a++)
          this.createJoinOperatorPanel(), this.createOption();
      const s = i.operator === "OR";
      this.eJoinOperatorsAnd.forEach((a) => a.setValue(!s, !0)), this.eJoinOperatorsOr.forEach((a) => a.setValue(s, !0)), i.conditions.forEach((a, l) => {
        this.eTypes[l].setValue(a.type, !0), this.setConditionIntoUi(a, l);
      });
    } else {
      const i = e;
      this.getNumConditions() > 1 && this.removeConditionsAndOperators(1), this.eTypes[0].setValue(i.type, !0), this.setConditionIntoUi(i, 0);
    }
    return this.lastUiCompletePosition = this.getNumConditions() - 1, this.createMissingConditionsAndOperators(), this.onUiChanged(), Qe.resolve();
  }
  validateAndUpdateConditions(e) {
    let t = e.length;
    return t > this.maxNumConditions && (e.splice(this.maxNumConditions), tt(() => console.warn('AG Grid: Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.'), "simpleFilterSetModelMaxNumConditions"), t = this.maxNumConditions), t;
  }
  doesFilterPass(e) {
    var t;
    const i = this.getModel();
    if (i == null)
      return !0;
    const { operator: r } = i, n = [];
    if (r) {
      const a = i;
      n.push(...(t = a.conditions) !== null && t !== void 0 ? t : []);
    } else
      n.push(i);
    return n[r && r === "OR" ? "some" : "every"]((a) => this.individualConditionPasses(e, a));
  }
  setParams(e) {
    super.setParams(e), this.setNumConditions(e), this.defaultJoinOperator = this.getDefaultJoinOperator(e.defaultJoinOperator), this.filterPlaceholder = e.filterPlaceholder, this.optionsFactory = new BT(), this.optionsFactory.init(e, this.getDefaultFilterOptions()), this.createFilterListOptions(), this.createOption(), this.createMissingConditionsAndOperators();
  }
  setNumConditions(e) {
    var t, i;
    e.suppressAndOrCondition != null && tt(() => console.warn('AG Grid: Since v29.2 "filterParams.suppressAndOrCondition" is deprecated. Use "filterParams.maxNumConditions = 1" instead.'), "simpleFilterSuppressAndOrCondition"), e.alwaysShowBothConditions != null && tt(() => console.warn('AG Grid: Since v29.2 "filterParams.alwaysShowBothConditions" is deprecated. Use "filterParams.numAlwaysVisibleConditions = 2" instead.'), "simpleFilterAlwaysShowBothConditions"), this.maxNumConditions = (t = e.maxNumConditions) !== null && t !== void 0 ? t : e.suppressAndOrCondition ? 1 : 2, this.maxNumConditions < 1 && (tt(() => console.warn('AG Grid: "filterParams.maxNumConditions" must be greater than or equal to zero.'), "simpleFilterMaxNumConditions"), this.maxNumConditions = 1), this.numAlwaysVisibleConditions = (i = e.numAlwaysVisibleConditions) !== null && i !== void 0 ? i : e.alwaysShowBothConditions ? 2 : 1, this.numAlwaysVisibleConditions < 1 && (tt(() => console.warn('AG Grid: "filterParams.numAlwaysVisibleConditions" must be greater than or equal to zero.'), "simpleFilterNumAlwaysVisibleConditions"), this.numAlwaysVisibleConditions = 1), this.numAlwaysVisibleConditions > this.maxNumConditions && (tt(() => console.warn('AG Grid: "filterParams.numAlwaysVisibleConditions" cannot be greater than "filterParams.maxNumConditions".'), "simpleFilterNumAlwaysVisibleGreaterThanMaxNumConditions"), this.numAlwaysVisibleConditions = this.maxNumConditions);
  }
  createOption() {
    const e = this.createManagedBean(new zn());
    this.eTypes.push(e), e.addCssClass("ag-filter-select"), this.eFilterBody.appendChild(e.getGui());
    const t = this.createValueElement();
    this.eConditionBodies.push(t), this.eFilterBody.appendChild(t), this.putOptionsIntoDropdown(e), this.resetType(e);
    const i = this.getNumConditions() - 1;
    this.forEachPositionInput(i, (r) => this.resetInput(r)), this.addChangedListeners(e, i);
  }
  createJoinOperatorPanel() {
    const e = document.createElement("div");
    this.eJoinOperatorPanels.push(e), e.classList.add("ag-filter-condition");
    const t = this.createJoinOperator(this.eJoinOperatorsAnd, e, "and"), i = this.createJoinOperator(this.eJoinOperatorsOr, e, "or");
    this.eFilterBody.appendChild(e);
    const r = this.eJoinOperatorPanels.length - 1, n = this.joinOperatorId++;
    this.resetJoinOperatorAnd(t, r, n), this.resetJoinOperatorOr(i, r, n), this.isReadOnly() || (t.onValueChange(this.listener), i.onValueChange(this.listener));
  }
  createJoinOperator(e, t, i) {
    const r = this.createManagedBean(new ZS());
    return e.push(r), r.addCssClass("ag-filter-condition-operator"), r.addCssClass(`ag-filter-condition-operator-${i}`), t.appendChild(r.getGui()), r;
  }
  getDefaultJoinOperator(e) {
    return e === "AND" || e === "OR" ? e : "AND";
  }
  createFilterListOptions() {
    const e = this.optionsFactory.getFilterOptions();
    this.filterListOptions = e.map((t) => typeof t == "string" ? this.createBoilerplateListOption(t) : this.createCustomListOption(t));
  }
  putOptionsIntoDropdown(e) {
    this.filterListOptions.forEach((t) => {
      e.addOption(t);
    }), e.setDisabled(this.filterListOptions.length <= 1);
  }
  createBoilerplateListOption(e) {
    return { value: e, text: this.translate(e) };
  }
  createCustomListOption(e) {
    const { displayKey: t } = e, i = this.optionsFactory.getCustomOption(e.displayKey);
    return {
      value: t,
      text: i ? this.localeService.getLocaleTextFunc()(i.displayKey, i.displayName) : this.translate(t)
    };
  }
  /**
   * @deprecated As of v29.2 filters can have more than two conditions. Check `colDef.filterParams.maxNumConditions` instead.
   */
  isAllowTwoConditions() {
    return this.maxNumConditions >= 2;
  }
  createBodyTemplate() {
    return "";
  }
  getCssIdentifier() {
    return "simple-filter";
  }
  updateUiVisibility() {
    const e = this.getJoinOperator();
    this.updateNumConditions(), this.updateConditionStatusesAndValues(this.lastUiCompletePosition, e);
  }
  updateNumConditions() {
    var e;
    let t = -1, i = !0;
    for (let r = 0; r < this.getNumConditions(); r++)
      this.isConditionUiComplete(r) ? t = r : i = !1;
    if (this.shouldAddNewConditionAtEnd(i))
      this.createJoinOperatorPanel(), this.createOption();
    else {
      const r = (e = this.lastUiCompletePosition) !== null && e !== void 0 ? e : this.getNumConditions() - 2;
      if (t < r) {
        this.removeConditionsAndOperators(r + 1);
        const n = t + 1, s = r - n;
        s > 0 && this.removeConditionsAndOperators(n, s), this.createMissingConditionsAndOperators();
      }
    }
    this.lastUiCompletePosition = t;
  }
  updateConditionStatusesAndValues(e, t) {
    this.eTypes.forEach((r, n) => {
      const s = this.isConditionDisabled(n, e);
      r.setDisabled(s || this.filterListOptions.length <= 1), n === 1 && (Id(this.eJoinOperatorPanels[0], s), this.eJoinOperatorsAnd[0].setDisabled(s), this.eJoinOperatorsOr[0].setDisabled(s));
    }), this.eConditionBodies.forEach((r, n) => {
      Ke(r, this.isConditionBodyVisible(n));
    });
    const i = (t != null ? t : this.getJoinOperator()) === "OR";
    this.eJoinOperatorsAnd.forEach((r, n) => {
      r.setValue(!i, !0);
    }), this.eJoinOperatorsOr.forEach((r, n) => {
      r.setValue(i, !0);
    }), this.forEachInput((r, n, s, a) => {
      this.setElementDisplayed(r, n < a), this.setElementDisabled(r, this.isConditionDisabled(s, e));
    }), this.resetPlaceholder();
  }
  shouldAddNewConditionAtEnd(e) {
    return e && this.getNumConditions() < this.maxNumConditions && !this.isReadOnly();
  }
  removeConditionsAndOperators(e, t) {
    if (e >= this.getNumConditions())
      return;
    this.removeComponents(this.eTypes, e, t), this.removeElements(this.eConditionBodies, e, t), this.removeValueElements(e, t);
    const i = Math.max(e - 1, 0);
    this.removeElements(this.eJoinOperatorPanels, i, t), this.removeComponents(this.eJoinOperatorsAnd, i, t), this.removeComponents(this.eJoinOperatorsOr, i, t);
  }
  removeElements(e, t, i) {
    this.removeItems(e, t, i).forEach((n) => fs(n));
  }
  removeComponents(e, t, i) {
    this.removeItems(e, t, i).forEach((n) => {
      fs(n.getGui()), this.destroyBean(n);
    });
  }
  removeItems(e, t, i) {
    return i == null ? e.splice(t) : e.splice(t, i);
  }
  afterGuiAttached(e) {
    if (super.afterGuiAttached(e), this.resetPlaceholder(), !e || !e.suppressFocus && !this.isReadOnly()) {
      const t = this.getInputs(0)[0];
      if (!t)
        return;
      t instanceof Nn && t.getInputElement().focus();
    }
  }
  afterGuiDetached() {
    super.afterGuiDetached();
    const e = this.getModel();
    (!this.areModelsEqual(e, this.getModelFromUi()) || this.hasInvalidInputs()) && this.resetUiToActiveModel(e);
    let t = -1, i = -1, r = !1;
    const n = this.getJoinOperator();
    for (let a = this.getNumConditions() - 1; a >= 0; a--)
      if (this.isConditionUiComplete(a))
        t === -1 && (t = a, i = a);
      else {
        const l = a >= this.numAlwaysVisibleConditions && !this.isConditionUiComplete(a - 1), c = a < t;
        (l || c) && (this.removeConditionsAndOperators(a, 1), r = !0, c && i--);
      }
    let s = !1;
    this.getNumConditions() < this.numAlwaysVisibleConditions && (this.createMissingConditionsAndOperators(), s = !0), this.shouldAddNewConditionAtEnd(i === this.getNumConditions() - 1) && (this.createJoinOperatorPanel(), this.createOption(), s = !0), s && this.updateConditionStatusesAndValues(i, n), r && this.updateJoinOperatorsDisabled(), this.lastUiCompletePosition = i;
  }
  getPlaceholderText(e, t) {
    let i = this.translate(e);
    if (Mv(this.filterPlaceholder)) {
      const r = this.filterPlaceholder, n = this.eTypes[t].getValue(), s = this.translate(n);
      i = r({
        filterOptionKey: n,
        filterOption: s,
        placeholder: i
      });
    } else
      typeof this.filterPlaceholder == "string" && (i = this.filterPlaceholder);
    return i;
  }
  // allow sub-classes to reset HTML placeholders after UI update.
  resetPlaceholder() {
    const e = this.localeService.getLocaleTextFunc();
    this.forEachInput((t, i, r, n) => {
      if (!(t instanceof Nn))
        return;
      const s = i === 0 && n > 1 ? "inRangeStart" : i === 0 ? "filterOoo" : "inRangeEnd", a = i === 0 && n > 1 ? e("ariaFilterFromValue", "Filter from value") : i === 0 ? e("ariaFilterValue", "Filter Value") : e("ariaFilterToValue", "Filter to Value");
      t.setInputPlaceholder(this.getPlaceholderText(s, r)), t.setInputAriaLabel(a);
    });
  }
  setElementValue(e, t) {
    e instanceof Nn && e.setValue(t != null ? String(t) : null, !0);
  }
  setElementDisplayed(e, t) {
    e instanceof X && Ke(e.getGui(), t);
  }
  setElementDisabled(e, t) {
    e instanceof X && Id(e.getGui(), t);
  }
  attachElementOnChange(e, t) {
    e instanceof Nn && e.onValueChange(t);
  }
  forEachInput(e) {
    this.getConditionTypes().forEach((t, i) => {
      this.forEachPositionTypeInput(i, t, e);
    });
  }
  forEachPositionInput(e, t) {
    const i = this.getConditionType(e);
    this.forEachPositionTypeInput(e, i, t);
  }
  forEachPositionTypeInput(e, t, i) {
    const r = this.getNumberOfInputs(t), n = this.getInputs(e);
    for (let s = 0; s < n.length; s++) {
      const a = n[s];
      a != null && i(a, s, e, r);
    }
  }
  isConditionDisabled(e, t) {
    return this.isReadOnly() ? !0 : e === 0 ? !1 : e > t + 1;
  }
  isConditionBodyVisible(e) {
    const t = this.getConditionType(e);
    return this.getNumberOfInputs(t) > 0;
  }
  // returns true if the UI represents a working filter, eg all parts are filled out.
  // eg if text filter and textfield blank then returns false.
  isConditionUiComplete(e) {
    return !(e >= this.getNumConditions() || this.getConditionType(e) === Le.EMPTY || this.getValues(e).some((i) => i == null));
  }
  getNumConditions() {
    return this.eTypes.length;
  }
  getUiCompleteConditions() {
    const e = [];
    for (let t = 0; t < this.getNumConditions(); t++)
      this.isConditionUiComplete(t) && e.push(this.createCondition(t));
    return e;
  }
  createMissingConditionsAndOperators() {
    if (!this.isReadOnly())
      for (let e = this.getNumConditions(); e < this.numAlwaysVisibleConditions; e++)
        this.createJoinOperatorPanel(), this.createOption();
  }
  resetUiToDefaults(e) {
    return this.removeConditionsAndOperators(this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions), this.eTypes.forEach((t) => this.resetType(t)), this.eJoinOperatorsAnd.forEach((t, i) => this.resetJoinOperatorAnd(t, i, this.joinOperatorId + i)), this.eJoinOperatorsOr.forEach((t, i) => this.resetJoinOperatorOr(t, i, this.joinOperatorId + i)), this.joinOperatorId++, this.forEachInput((t) => this.resetInput(t)), this.resetPlaceholder(), this.createMissingConditionsAndOperators(), this.lastUiCompletePosition = null, e || this.onUiChanged(), Qe.resolve();
  }
  resetType(e) {
    const i = this.localeService.getLocaleTextFunc()("ariaFilteringOperator", "Filtering operator");
    e.setValue(this.optionsFactory.getDefaultOption(), !0).setAriaLabel(i).setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1);
  }
  resetJoinOperatorAnd(e, t, i) {
    this.resetJoinOperator(e, t, this.isDefaultOperator("AND"), this.translate("andCondition"), i);
  }
  resetJoinOperatorOr(e, t, i) {
    this.resetJoinOperator(e, t, this.isDefaultOperator("OR"), this.translate("orCondition"), i);
  }
  resetJoinOperator(e, t, i, r, n) {
    this.updateJoinOperatorDisabled(e.setValue(i, !0).setName(`ag-simple-filter-and-or-${this.getCompId()}-${n}`).setLabel(r), t);
  }
  updateJoinOperatorsDisabled() {
    this.eJoinOperatorsAnd.forEach((e, t) => this.updateJoinOperatorDisabled(e, t)), this.eJoinOperatorsOr.forEach((e, t) => this.updateJoinOperatorDisabled(e, t));
  }
  updateJoinOperatorDisabled(e, t) {
    e.setDisabled(this.isReadOnly() || t > 0);
  }
  resetInput(e) {
    this.setElementValue(e, null), this.setElementDisabled(e, this.isReadOnly());
  }
  // puts model values into the UI
  setConditionIntoUi(e, t) {
    const i = this.mapValuesFromModel(e);
    this.forEachInput((r, n, s, a) => {
      s === t && this.setElementValue(r, i[n] != null ? i[n] : null);
    });
  }
  // after floating filter changes, this sets the 'value' section. this is implemented by the base class
  // (as that's where value is controlled), the 'type' part from the floating filter is dealt with in this class.
  setValueFromFloatingFilter(e) {
    this.forEachInput((t, i, r, n) => {
      this.setElementValue(t, i === 0 && r === 0 ? e : null);
    });
  }
  isDefaultOperator(e) {
    return e === this.defaultJoinOperator;
  }
  addChangedListeners(e, t) {
    this.isReadOnly() || (e.onValueChange(this.listener), this.forEachPositionInput(t, (i) => {
      this.attachElementOnChange(i, this.listener);
    }));
  }
  /** returns true if the row passes the said condition */
  individualConditionPasses(e, t) {
    const i = this.getCellValue(e.node), r = this.mapValuesFromModel(t), n = this.optionsFactory.getCustomOption(t.type), s = this.evaluateCustomFilter(n, r, i);
    return s != null ? s : i == null ? this.evaluateNullValue(t.type) : this.evaluateNonNullValue(r, i, t, e);
  }
  evaluateCustomFilter(e, t, i) {
    if (e == null)
      return;
    const { predicate: r } = e;
    if (r != null && !t.some((n) => n == null))
      return r(t, i);
  }
  isBlank(e) {
    return e == null || typeof e == "string" && e.trim().length === 0;
  }
  hasInvalidInputs() {
    return !1;
  }
}
Le.EMPTY = "empty";
Le.BLANK = "blank";
Le.NOT_BLANK = "notBlank";
Le.EQUALS = "equals";
Le.NOT_EQUAL = "notEqual";
Le.LESS_THAN = "lessThan";
Le.LESS_THAN_OR_EQUAL = "lessThanOrEqual";
Le.GREATER_THAN = "greaterThan";
Le.GREATER_THAN_OR_EQUAL = "greaterThanOrEqual";
Le.IN_RANGE = "inRange";
Le.CONTAINS = "contains";
Le.NOT_CONTAINS = "notContains";
Le.STARTS_WITH = "startsWith";
Le.ENDS_WITH = "endsWith";
class ze extends Le {
  setParams(e) {
    super.setParams(e), this.scalarFilterParams = e;
  }
  evaluateNullValue(e) {
    switch (e) {
      case ze.EQUALS:
      case ze.NOT_EQUAL:
        if (this.scalarFilterParams.includeBlanksInEquals)
          return !0;
        break;
      case ze.GREATER_THAN:
      case ze.GREATER_THAN_OR_EQUAL:
        if (this.scalarFilterParams.includeBlanksInGreaterThan)
          return !0;
        break;
      case ze.LESS_THAN:
      case ze.LESS_THAN_OR_EQUAL:
        if (this.scalarFilterParams.includeBlanksInLessThan)
          return !0;
        break;
      case ze.IN_RANGE:
        if (this.scalarFilterParams.includeBlanksInRange)
          return !0;
        break;
      case ze.BLANK:
        return !0;
      case ze.NOT_BLANK:
        return !1;
    }
    return !1;
  }
  evaluateNonNullValue(e, t, i) {
    const r = this.comparator(), n = e[0] != null ? r(e[0], t) : 0;
    switch (i.type) {
      case ze.EQUALS:
        return n === 0;
      case ze.NOT_EQUAL:
        return n !== 0;
      case ze.GREATER_THAN:
        return n > 0;
      case ze.GREATER_THAN_OR_EQUAL:
        return n >= 0;
      case ze.LESS_THAN:
        return n < 0;
      case ze.LESS_THAN_OR_EQUAL:
        return n <= 0;
      case ze.IN_RANGE: {
        const s = r(e[1], t);
        return this.scalarFilterParams.inRangeInclusive ? n >= 0 && s <= 0 : n > 0 && s < 0;
      }
      case ze.BLANK:
        return this.isBlank(t);
      case ze.NOT_BLANK:
        return !this.isBlank(t);
      default:
        return console.warn('AG Grid: Unexpected type of filter "' + i.type + '", it looks like the filter was configured with incorrect Filter Options'), !0;
    }
  }
}
var ZF = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const Yw = 1e3, Xw = 1 / 0;
class $T extends QS {
  constructor(e, t, i) {
    super(t, i), this.dateFilterParams = e;
  }
  conditionToString(e, t) {
    const { type: i } = e, { numberOfInputs: r } = t || {}, n = i == Le.IN_RANGE || r === 2, s = Vn(e.dateFrom), a = Vn(e.dateTo), l = this.dateFilterParams.inRangeFloatingFilterDateFormat;
    if (n) {
      const c = s !== null ? ug(s, l) : "null", d = a !== null ? ug(a, l) : "null";
      return `${c}-${d}`;
    }
    return s != null ? ug(s, l) : `${i}`;
  }
}
class lu extends ze {
  constructor() {
    super("dateFilter"), this.eConditionPanelsFrom = [], this.eConditionPanelsTo = [], this.dateConditionFromComps = [], this.dateConditionToComps = [], this.minValidYear = Yw, this.maxValidYear = Xw;
  }
  afterGuiAttached(e) {
    super.afterGuiAttached(e), this.dateConditionFromComps[0].afterGuiAttached(e);
  }
  mapValuesFromModel(e) {
    const { dateFrom: t, dateTo: i, type: r } = e || {};
    return [
      t && Vn(t) || null,
      i && Vn(i) || null
    ].slice(0, this.getNumberOfInputs(r));
  }
  comparator() {
    return this.dateFilterParams.comparator ? this.dateFilterParams.comparator : this.defaultComparator.bind(this);
  }
  defaultComparator(e, t) {
    const i = t;
    return t == null || i < e ? -1 : i > e ? 1 : 0;
  }
  setParams(e) {
    this.dateFilterParams = e, super.setParams(e);
    const t = (i, r) => {
      if (e[i] != null)
        if (isNaN(e[i]))
          console.warn(`AG Grid: DateFilter ${i} is not a number`);
        else
          return e[i] == null ? r : Number(e[i]);
      return r;
    };
    this.minValidYear = t("minValidYear", Yw), this.maxValidYear = t("maxValidYear", Xw), this.minValidYear > this.maxValidYear && console.warn("AG Grid: DateFilter minValidYear should be <= maxValidYear"), this.filterModelFormatter = new $T(this.dateFilterParams, this.localeService, this.optionsFactory);
  }
  createDateCompWrapper(e) {
    const t = new VT(this.getContext(), this.userComponentFactory, {
      onDateChanged: () => this.onUiChanged(),
      filterParams: this.dateFilterParams
    }, e);
    return this.addDestroyFunc(() => t.destroy()), t;
  }
  setElementValue(e, t) {
    e.setDate(t);
  }
  setElementDisplayed(e, t) {
    e.setDisplayed(t);
  }
  setElementDisabled(e, t) {
    e.setDisabled(t);
  }
  getDefaultFilterOptions() {
    return lu.DEFAULT_FILTER_OPTIONS;
  }
  createValueElement() {
    const e = document.createElement("div");
    return e.classList.add("ag-filter-body"), this.createFromToElement(e, this.eConditionPanelsFrom, this.dateConditionFromComps, "from"), this.createFromToElement(e, this.eConditionPanelsTo, this.dateConditionToComps, "to"), e;
  }
  createFromToElement(e, t, i, r) {
    const n = document.createElement("div");
    n.classList.add(`ag-filter-${r}`), n.classList.add(`ag-filter-date-${r}`), t.push(n), e.appendChild(n), i.push(this.createDateCompWrapper(n));
  }
  removeValueElements(e, t) {
    this.removeDateComps(this.dateConditionFromComps, e, t), this.removeDateComps(this.dateConditionToComps, e, t), this.removeItems(this.eConditionPanelsFrom, e, t), this.removeItems(this.eConditionPanelsTo, e, t);
  }
  removeDateComps(e, t, i) {
    this.removeItems(e, t, i).forEach((n) => n.destroy());
  }
  isConditionUiComplete(e) {
    if (!super.isConditionUiComplete(e))
      return !1;
    const t = (r) => r != null && r.getUTCFullYear() >= this.minValidYear && r.getUTCFullYear() <= this.maxValidYear;
    let i = !0;
    return this.forEachInput((r, n, s, a) => {
      s !== e || !i || n >= a || (i = i && t(r.getDate()));
    }), i;
  }
  areSimpleModelsEqual(e, t) {
    return e.dateFrom === t.dateFrom && e.dateTo === t.dateTo && e.type === t.type;
  }
  getFilterType() {
    return "date";
  }
  createCondition(e) {
    const t = this.getConditionType(e), i = {}, r = this.getValues(e);
    return r.length > 0 && (i.dateFrom = cn(r[0])), r.length > 1 && (i.dateTo = cn(r[1])), Object.assign({ dateFrom: null, dateTo: null, filterType: this.getFilterType(), type: t }, i);
  }
  resetPlaceholder() {
    const e = this.localeService.getLocaleTextFunc(), t = this.translate("dateFormatOoo"), i = e("ariaFilterValue", "Filter Value");
    this.forEachInput((r) => {
      r.setInputPlaceholder(t), r.setInputAriaLabel(i);
    });
  }
  getInputs(e) {
    return e >= this.dateConditionFromComps.length ? [null, null] : [this.dateConditionFromComps[e], this.dateConditionToComps[e]];
  }
  getValues(e) {
    const t = [];
    return this.forEachPositionInput(e, (i, r, n, s) => {
      r < s && t.push(i.getDate());
    }), t;
  }
  getModelAsString(e) {
    var t;
    return (t = this.filterModelFormatter.getModelAsString(e)) !== null && t !== void 0 ? t : "";
  }
}
lu.DEFAULT_FILTER_OPTIONS = [
  ze.EQUALS,
  ze.GREATER_THAN,
  ze.LESS_THAN,
  ze.NOT_EQUAL,
  ze.IN_RANGE,
  ze.BLANK,
  ze.NOT_BLANK
];
ZF([
  S("userComponentFactory")
], lu.prototype, "userComponentFactory", void 0);
class zT extends X {
  getDefaultDebounceMs() {
    return 0;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  isEventFromFloatingFilter(e) {
    return e && e.afterFloatingFilter;
  }
  isEventFromDataChange(e) {
    return e == null ? void 0 : e.afterDataChange;
  }
  getLastType() {
    return this.lastType;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setLastTypeFromModel(e) {
    if (!e) {
      this.lastType = this.optionsFactory.getDefaultOption();
      return;
    }
    const t = e.operator;
    let i;
    t ? i = e.conditions[0] : i = e, this.lastType = i.type;
  }
  canWeEditAfterModelFromParentFilter(e) {
    if (!e)
      return this.isTypeEditable(this.lastType);
    if (e.operator)
      return !1;
    const i = e;
    return this.isTypeEditable(i.type);
  }
  init(e) {
    this.optionsFactory = new BT(), this.optionsFactory.init(e.filterParams, this.getDefaultFilterOptions()), this.lastType = this.optionsFactory.getDefaultOption(), this.readOnly = !!e.filterParams.readOnly;
    const t = this.isTypeEditable(this.lastType);
    this.setEditable(t);
  }
  doesFilterHaveSingleInput(e) {
    const t = this.optionsFactory.getCustomOption(e), { numberOfInputs: i } = t || {};
    return i == null || i == 1;
  }
  isTypeEditable(e) {
    const t = [
      Le.IN_RANGE,
      Le.EMPTY,
      Le.BLANK,
      Le.NOT_BLANK
    ];
    return !!e && !this.isReadOnly() && this.doesFilterHaveSingleInput(e) && t.indexOf(e) < 0;
  }
}
var JS = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Uv extends zT {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field ref="eReadOnlyText"></ag-input-text-field>
                <div ref="eDateWrapper" style="display: flex;"></div>
            </div>`
    );
  }
  getDefaultFilterOptions() {
    return lu.DEFAULT_FILTER_OPTIONS;
  }
  init(e) {
    super.init(e), this.params = e, this.filterParams = e.filterParams, this.createDateComponent();
    const t = this.localeService.getLocaleTextFunc();
    this.eReadOnlyText.setDisabled(!0).setInputAriaLabel(t("ariaDateFilterInput", "Date Filter Input")), this.filterModelFormatter = new $T(this.filterParams, this.localeService, this.optionsFactory);
  }
  setEditable(e) {
    Ke(this.eDateWrapper, e), Ke(this.eReadOnlyText.getGui(), !e);
  }
  onParentModelChanged(e, t) {
    if (this.isEventFromFloatingFilter(t) || this.isEventFromDataChange(t))
      return;
    super.setLastTypeFromModel(e);
    const i = !this.isReadOnly() && this.canWeEditAfterModelFromParentFilter(e);
    if (this.setEditable(i), i) {
      if (e) {
        const r = e;
        this.dateComp.setDate(Vn(r.dateFrom));
      } else
        this.dateComp.setDate(null);
      this.eReadOnlyText.setValue("");
    } else
      this.eReadOnlyText.setValue(this.filterModelFormatter.getModelAsString(e)), this.dateComp.setDate(null);
  }
  onDateChanged() {
    const e = this.dateComp.getDate(), t = cn(e);
    this.params.parentFilterInstance((i) => {
      if (i) {
        const r = Vn(t);
        i.onFloatingFilterChanged(this.getLastType() || null, r);
      }
    });
  }
  createDateComponent() {
    const e = Pr.getDebounceMs(this.params.filterParams, this.getDefaultDebounceMs()), t = {
      onDateChanged: Co(this.onDateChanged.bind(this), e),
      filterParams: this.params.column.getColDef().filterParams
    };
    this.dateComp = new VT(this.getContext(), this.userComponentFactory, t, this.eDateWrapper), this.addDestroyFunc(() => this.dateComp.destroy());
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
}
JS([
  S("userComponentFactory")
], Uv.prototype, "userComponentFactory", void 0);
JS([
  L("eReadOnlyText")
], Uv.prototype, "eReadOnlyText", void 0);
JS([
  L("eDateWrapper")
], Uv.prototype, "eDateWrapper", void 0);
var QF = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class KT extends X {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-filter-filter">
                <ag-input-text-field class="ag-date-filter" ref="eDateInput"></ag-input-text-field>
            </div>`
    );
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    const t = this.gridOptionsService.getDocument(), i = this.eDateInput.getInputElement(), r = this.shouldUseBrowserDatePicker(e);
    r && (i.type = "date");
    const n = r && fn();
    this.addManagedListener(i, "mousedown", () => {
      this.eDateInput.isDisabled() || n || i.focus();
    }), this.addManagedListener(i, "input", (l) => {
      l.target === t.activeElement && (this.eDateInput.isDisabled() || e.onDateChanged());
    });
    const { minValidYear: s, maxValidYear: a } = e.filterParams || {};
    s && (i.min = `${s}-01-01`), a && (i.max = `${a}-12-31`);
  }
  getDate() {
    return Vn(this.eDateInput.getValue());
  }
  setDate(e) {
    this.eDateInput.setValue(cn(e, !1));
  }
  setInputPlaceholder(e) {
    this.eDateInput.setInputPlaceholder(e);
  }
  setDisabled(e) {
    this.eDateInput.setDisabled(e);
  }
  afterGuiAttached(e) {
    (!e || !e.suppressFocus) && this.eDateInput.getInputElement().focus();
  }
  shouldUseBrowserDatePicker(e) {
    return e.filterParams && e.filterParams.browserDatePicker != null ? e.filterParams.browserDatePicker : kv() || AS() || fn() && PS() >= 14.1;
  }
}
QF([
  L("eDateInput")
], KT.prototype, "eDateInput", void 0);
class Na extends Nn {
  constructor(e, t = "ag-text-field", i = "text") {
    super(e, t, i);
  }
  postConstruct() {
    super.postConstruct(), this.config.allowedCharPattern && this.preventDisallowedCharacters();
  }
  setValue(e, t) {
    const i = super.setValue(e, t);
    return this.eInput.value !== e && (this.eInput.value = z(e) ? e : ""), i;
  }
  /** Used to set an initial value into the input without necessarily setting `this.value` or triggering events (e.g. to set an invalid value) */
  setStartValue(e) {
    this.setValue(e, !0);
  }
  preventDisallowedCharacters() {
    const e = new RegExp(`[${this.config.allowedCharPattern}]`), t = (i) => {
      WS(i) && i.key && !e.test(i.key) && i.preventDefault();
    };
    this.addManagedListener(this.eInput, "keydown", t), this.addManagedListener(this.eInput, "paste", (i) => {
      var r;
      const n = (r = i.clipboardData) === null || r === void 0 ? void 0 : r.getData("text");
      n && n.split("").some((s) => !e.test(s)) && i.preventDefault();
    });
  }
}
class eb extends Na {
  constructor(e) {
    super(e, "ag-number-field", "number");
  }
  postConstruct() {
    super.postConstruct(), this.addManagedListener(this.eInput, "blur", () => {
      const e = parseFloat(this.eInput.value), t = isNaN(e) ? "" : this.normalizeValue(e.toString());
      this.value !== t && this.setValue(t);
    }), this.addManagedListener(this.eInput, "wheel", this.onWheel.bind(this)), this.eInput.step = "any";
  }
  onWheel(e) {
    document.activeElement === this.eInput && e.preventDefault();
  }
  normalizeValue(e) {
    if (e === "")
      return "";
    this.precision != null && (e = this.adjustPrecision(e));
    const t = parseFloat(e);
    return this.min != null && t < this.min ? e = this.min.toString() : this.max != null && t > this.max && (e = this.max.toString()), e;
  }
  adjustPrecision(e, t) {
    if (this.precision == null)
      return e;
    if (t) {
      const r = parseFloat(e).toFixed(this.precision);
      return parseFloat(r).toString();
    }
    const i = String(e).split(".");
    if (i.length > 1) {
      if (i[1].length <= this.precision)
        return e;
      if (this.precision > 0)
        return `${i[0]}.${i[1].slice(0, this.precision)}`;
    }
    return i[0];
  }
  setMin(e) {
    return this.min === e ? this : (this.min = e, da(this.eInput, "min", e), this);
  }
  setMax(e) {
    return this.max === e ? this : (this.max = e, da(this.eInput, "max", e), this);
  }
  setPrecision(e) {
    return this.precision = e, this;
  }
  setStep(e) {
    return this.step === e ? this : (this.step = e, da(this.eInput, "step", e), this);
  }
  setValue(e, t) {
    return this.setValueOrInputValue((i) => super.setValue(i, t), () => this, e);
  }
  setStartValue(e) {
    return this.setValueOrInputValue((t) => super.setValue(t, !0), (t) => {
      this.eInput.value = t;
    }, e);
  }
  setValueOrInputValue(e, t, i) {
    if (z(i)) {
      let r = this.isScientificNotation(i);
      if (r && this.eInput.validity.valid)
        return e(i);
      if (!r) {
        i = this.adjustPrecision(i);
        const n = this.normalizeValue(i);
        r = i != n;
      }
      if (r)
        return t(i);
    }
    return e(i);
  }
  getValue() {
    if (!this.eInput.validity.valid)
      return;
    const e = this.eInput.value;
    return this.isScientificNotation(e) ? this.adjustPrecision(e, !0) : super.getValue();
  }
  isScientificNotation(e) {
    return typeof e == "string" && e.includes("e");
  }
}
class YT extends QS {
  conditionToString(e, t) {
    const { numberOfInputs: i } = t || {};
    return e.type == Le.IN_RANGE || i === 2 ? `${e.filter}-${e.filterTo}` : e.filter != null ? `${e.filter}` : `${e.type}`;
  }
}
function XT(o) {
  const { allowedCharPattern: e } = o != null ? o : {};
  return e != null ? e : null;
}
class Op extends ze {
  constructor() {
    super("numberFilter"), this.eValuesFrom = [], this.eValuesTo = [];
  }
  mapValuesFromModel(e) {
    const { filter: t, filterTo: i, type: r } = e || {};
    return [
      this.processValue(t),
      this.processValue(i)
    ].slice(0, this.getNumberOfInputs(r));
  }
  getDefaultDebounceMs() {
    return 500;
  }
  comparator() {
    return (e, t) => e === t ? 0 : e < t ? 1 : -1;
  }
  setParams(e) {
    this.numberFilterParams = e, super.setParams(e), this.filterModelFormatter = new YT(this.localeService, this.optionsFactory);
  }
  getDefaultFilterOptions() {
    return Op.DEFAULT_FILTER_OPTIONS;
  }
  createValueElement() {
    const e = XT(this.numberFilterParams), t = document.createElement("div");
    return t.classList.add("ag-filter-body"), ci(t, "presentation"), this.createFromToElement(t, this.eValuesFrom, "from", e), this.createFromToElement(t, this.eValuesTo, "to", e), t;
  }
  createFromToElement(e, t, i, r) {
    const n = this.createManagedBean(r ? new Na({ allowedCharPattern: r }) : new eb());
    n.addCssClass(`ag-filter-${i}`), n.addCssClass("ag-filter-filter"), t.push(n), e.appendChild(n.getGui());
  }
  removeValueElements(e, t) {
    this.removeComponents(this.eValuesFrom, e, t), this.removeComponents(this.eValuesTo, e, t);
  }
  getValues(e) {
    const t = [];
    return this.forEachPositionInput(e, (i, r, n, s) => {
      r < s && t.push(this.processValue(this.stringToFloat(i.getValue())));
    }), t;
  }
  areSimpleModelsEqual(e, t) {
    return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type;
  }
  getFilterType() {
    return "number";
  }
  processValue(e) {
    return e == null || isNaN(e) ? null : e;
  }
  stringToFloat(e) {
    if (typeof e == "number")
      return e;
    let t = ca(e);
    return t != null && t.trim() === "" && (t = null), this.numberFilterParams.numberParser ? this.numberFilterParams.numberParser(t) : t == null || t.trim() === "-" ? null : parseFloat(t);
  }
  createCondition(e) {
    const t = this.getConditionType(e), i = {
      filterType: this.getFilterType(),
      type: t
    }, r = this.getValues(e);
    return r.length > 0 && (i.filter = r[0]), r.length > 1 && (i.filterTo = r[1]), i;
  }
  getInputs(e) {
    return e >= this.eValuesFrom.length ? [null, null] : [this.eValuesFrom[e], this.eValuesTo[e]];
  }
  getModelAsString(e) {
    var t;
    return (t = this.filterModelFormatter.getModelAsString(e)) !== null && t !== void 0 ? t : "";
  }
  hasInvalidInputs() {
    let e = !1;
    return this.forEachInput((t) => {
      if (!t.getInputElement().validity.valid) {
        e = !0;
        return;
      }
    }), e;
  }
}
Op.DEFAULT_FILTER_OPTIONS = [
  ze.EQUALS,
  ze.NOT_EQUAL,
  ze.LESS_THAN,
  ze.LESS_THAN_OR_EQUAL,
  ze.GREATER_THAN,
  ze.GREATER_THAN_OR_EQUAL,
  ze.IN_RANGE,
  ze.BLANK,
  ze.NOT_BLANK
];
class qT extends QS {
  conditionToString(e, t) {
    const { numberOfInputs: i } = t || {};
    return e.type == Le.IN_RANGE || i === 2 ? `${e.filter}-${e.filterTo}` : e.filter != null ? `${e.filter}` : `${e.type}`;
  }
}
class $t extends Le {
  constructor() {
    super("textFilter"), this.eValuesFrom = [], this.eValuesTo = [];
  }
  static trimInput(e) {
    const t = e && e.trim();
    return t === "" ? e : t;
  }
  getDefaultDebounceMs() {
    return 500;
  }
  setParams(e) {
    this.textFilterParams = e, super.setParams(e), this.matcher = this.getTextMatcher(), this.formatter = this.textFilterParams.textFormatter || (this.textFilterParams.caseSensitive ? $t.DEFAULT_FORMATTER : $t.DEFAULT_LOWERCASE_FORMATTER), this.filterModelFormatter = new qT(this.localeService, this.optionsFactory);
  }
  getTextMatcher() {
    const e = this.textFilterParams.textCustomComparator;
    return e ? (x.doOnce(() => console.warn("AG Grid - textCustomComparator is deprecated, use textMatcher instead."), "textCustomComparator.deprecated"), ({ filterOption: t, value: i, filterText: r }) => e(t, i, r)) : this.textFilterParams.textMatcher || $t.DEFAULT_MATCHER;
  }
  createCondition(e) {
    const t = this.getConditionType(e), i = {
      filterType: this.getFilterType(),
      type: t
    }, r = this.getValues(e);
    return r.length > 0 && (i.filter = r[0]), r.length > 1 && (i.filterTo = r[1]), i;
  }
  getFilterType() {
    return "text";
  }
  areSimpleModelsEqual(e, t) {
    return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type;
  }
  getInputs(e) {
    return e >= this.eValuesFrom.length ? [null, null] : [this.eValuesFrom[e], this.eValuesTo[e]];
  }
  getValues(e) {
    const t = [];
    return this.forEachPositionInput(e, (i, r, n, s) => {
      if (r < s) {
        const a = ca(i.getValue()), l = (this.textFilterParams.trimInput ? $t.trimInput(a) : a) || null;
        t.push(l), i.setValue(l, !0);
      }
    }), t;
  }
  getDefaultFilterOptions() {
    return $t.DEFAULT_FILTER_OPTIONS;
  }
  createValueElement() {
    const e = document.createElement("div");
    return e.classList.add("ag-filter-body"), ci(e, "presentation"), this.createFromToElement(e, this.eValuesFrom, "from"), this.createFromToElement(e, this.eValuesTo, "to"), e;
  }
  createFromToElement(e, t, i) {
    const r = this.createManagedBean(new Na());
    r.addCssClass(`ag-filter-${i}`), r.addCssClass("ag-filter-filter"), t.push(r), e.appendChild(r.getGui());
  }
  removeValueElements(e, t) {
    this.removeComponents(this.eValuesFrom, e, t), this.removeComponents(this.eValuesTo, e, t);
  }
  mapValuesFromModel(e) {
    const { filter: t, filterTo: i, type: r } = e || {};
    return [
      t || null,
      i || null
    ].slice(0, this.getNumberOfInputs(r));
  }
  evaluateNullValue(e) {
    const t = [
      Le.NOT_EQUAL,
      Le.NOT_CONTAINS,
      Le.BLANK
    ];
    return e ? t.indexOf(e) >= 0 : !1;
  }
  evaluateNonNullValue(e, t, i, r) {
    const n = e.map((f) => this.formatter(f)) || [], s = this.formatter(t), { api: a, colDef: l, column: c, columnApi: d, context: u, textFormatter: h } = this.textFilterParams;
    if (i.type === Le.BLANK)
      return this.isBlank(t);
    if (i.type === Le.NOT_BLANK)
      return !this.isBlank(t);
    const p = {
      api: a,
      colDef: l,
      column: c,
      columnApi: d,
      context: u,
      node: r.node,
      data: r.data,
      filterOption: i.type,
      value: s,
      textFormatter: h
    };
    return n.some((f) => this.matcher(Object.assign(Object.assign({}, p), { filterText: f })));
  }
  getModelAsString(e) {
    var t;
    return (t = this.filterModelFormatter.getModelAsString(e)) !== null && t !== void 0 ? t : "";
  }
}
$t.DEFAULT_FILTER_OPTIONS = [
  Le.CONTAINS,
  Le.NOT_CONTAINS,
  Le.EQUALS,
  Le.NOT_EQUAL,
  Le.STARTS_WITH,
  Le.ENDS_WITH,
  Le.BLANK,
  Le.NOT_BLANK
];
$t.DEFAULT_FORMATTER = (o) => o;
$t.DEFAULT_LOWERCASE_FORMATTER = (o) => o == null ? null : o.toString().toLowerCase();
$t.DEFAULT_MATCHER = ({ filterOption: o, value: e, filterText: t }) => {
  if (t == null)
    return !1;
  switch (o) {
    case $t.CONTAINS:
      return e.indexOf(t) >= 0;
    case $t.NOT_CONTAINS:
      return e.indexOf(t) < 0;
    case $t.EQUALS:
      return e === t;
    case $t.NOT_EQUAL:
      return e != t;
    case $t.STARTS_WITH:
      return e.indexOf(t) === 0;
    case $t.ENDS_WITH:
      const i = e.lastIndexOf(t);
      return i >= 0 && i === e.length - t.length;
    default:
      return !1;
  }
};
var tb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class ZT extends H {
  constructor(e) {
    super(), this.params = e;
  }
  setupGui(e) {
    this.eFloatingFilterTextInput = this.createManagedBean(new Na(this.params.config)), this.eFloatingFilterTextInput.setInputAriaLabel(this.params.ariaLabel), e.appendChild(this.eFloatingFilterTextInput.getGui());
  }
  setEditable(e) {
    this.eFloatingFilterTextInput.setDisabled(!e);
  }
  getValue() {
    return this.eFloatingFilterTextInput.getValue();
  }
  setValue(e, t) {
    this.eFloatingFilterTextInput.setValue(e, t);
  }
  addValueChangedListener(e) {
    const t = this.eFloatingFilterTextInput.getGui();
    this.addManagedListener(t, "input", e), this.addManagedListener(t, "keydown", e);
  }
}
class Pp extends zT {
  postConstruct() {
    this.setTemplate(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation" ref="eFloatingFilterInputContainer"></div>
        `
    );
  }
  getDefaultDebounceMs() {
    return 500;
  }
  onParentModelChanged(e, t) {
    this.isEventFromFloatingFilter(t) || this.isEventFromDataChange(t) || (this.setLastTypeFromModel(e), this.setEditable(this.canWeEditAfterModelFromParentFilter(e)), this.floatingFilterInputService.setValue(this.getFilterModelFormatter().getModelAsString(e)));
  }
  init(e) {
    this.params = e;
    const t = this.columnModel.getDisplayNameForColumn(e.column, "header", !0), i = this.localeService.getLocaleTextFunc(), r = `${t} ${i("ariaFilterInput", "Filter Input")}`;
    if (this.floatingFilterInputService = this.createFloatingFilterInputService(r), this.floatingFilterInputService.setupGui(this.eFloatingFilterInputContainer), super.init(e), this.applyActive = Pr.isUseApplyButton(this.params.filterParams), !this.isReadOnly()) {
      const n = Pr.getDebounceMs(this.params.filterParams, this.getDefaultDebounceMs()), s = Co(this.syncUpWithParentFilter.bind(this), n);
      this.floatingFilterInputService.addValueChangedListener(s);
    }
  }
  syncUpWithParentFilter(e) {
    const t = e.key === V.ENTER;
    if (this.applyActive && !t)
      return;
    let i = this.floatingFilterInputService.getValue();
    this.params.filterParams.trimInput && (i = $t.trimInput(i), this.floatingFilterInputService.setValue(i, !0)), this.params.parentFilterInstance((r) => {
      r && r.onFloatingFilterChanged(this.getLastType() || null, i || null);
    });
  }
  setEditable(e) {
    this.floatingFilterInputService.setEditable(e);
  }
}
tb([
  S("columnModel")
], Pp.prototype, "columnModel", void 0);
tb([
  L("eFloatingFilterInputContainer")
], Pp.prototype, "eFloatingFilterInputContainer", void 0);
tb([
  B
], Pp.prototype, "postConstruct", null);
class JF extends H {
  constructor(e) {
    super(), this.params = e, this.numberInputActive = !0;
  }
  setupGui(e) {
    this.eFloatingFilterNumberInput = this.createManagedBean(new eb()), this.eFloatingFilterTextInput = this.createManagedBean(new Na()), this.eFloatingFilterTextInput.setDisabled(!0), this.eFloatingFilterNumberInput.setInputAriaLabel(this.params.ariaLabel), this.eFloatingFilterTextInput.setInputAriaLabel(this.params.ariaLabel), e.appendChild(this.eFloatingFilterNumberInput.getGui()), e.appendChild(this.eFloatingFilterTextInput.getGui());
  }
  setEditable(e) {
    this.numberInputActive = e, this.eFloatingFilterNumberInput.setDisplayed(this.numberInputActive), this.eFloatingFilterTextInput.setDisplayed(!this.numberInputActive);
  }
  getValue() {
    return this.getActiveInputElement().getValue();
  }
  setValue(e, t) {
    this.getActiveInputElement().setValue(e, t);
  }
  getActiveInputElement() {
    return this.numberInputActive ? this.eFloatingFilterNumberInput : this.eFloatingFilterTextInput;
  }
  addValueChangedListener(e) {
    this.setupListeners(this.eFloatingFilterNumberInput.getGui(), e), this.setupListeners(this.eFloatingFilterTextInput.getGui(), e);
  }
  setupListeners(e, t) {
    this.addManagedListener(e, "input", t), this.addManagedListener(e, "keydown", t);
  }
}
class eL extends Pp {
  init(e) {
    super.init(e), this.filterModelFormatter = new YT(this.localeService, this.optionsFactory);
  }
  getDefaultFilterOptions() {
    return Op.DEFAULT_FILTER_OPTIONS;
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
  createFloatingFilterInputService(e) {
    const t = XT(this.params.filterParams);
    return t ? this.createManagedBean(new ZT({
      config: { allowedCharPattern: t },
      ariaLabel: e
    })) : this.createManagedBean(new JF({ ariaLabel: e }));
  }
}
class tL extends Pp {
  init(e) {
    super.init(e), this.filterModelFormatter = new qT(this.localeService, this.optionsFactory);
  }
  getDefaultFilterOptions() {
    return $t.DEFAULT_FILTER_OPTIONS;
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
  createFloatingFilterInputService(e) {
    return this.createManagedBean(new ZT({
      ariaLabel: e
    }));
  }
}
class mt {
  constructor(e, t = !1) {
    this.destroyFuncs = [], this.touching = !1, this.eventService = new _r(), this.eElement = e, this.preventMouseClick = t;
    const i = this.onTouchStart.bind(this), r = this.onTouchMove.bind(this), n = this.onTouchEnd.bind(this);
    this.eElement.addEventListener("touchstart", i, { passive: !0 }), this.eElement.addEventListener("touchmove", r, { passive: !0 }), this.eElement.addEventListener("touchend", n, { passive: !1 }), this.destroyFuncs.push(() => {
      this.eElement.removeEventListener("touchstart", i, { passive: !0 }), this.eElement.removeEventListener("touchmove", r, { passive: !0 }), this.eElement.removeEventListener("touchend", n, { passive: !1 });
    });
  }
  getActiveTouch(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].identifier === this.touchStart.identifier)
        return e[t];
    return null;
  }
  addEventListener(e, t) {
    this.eventService.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.eventService.removeEventListener(e, t);
  }
  onTouchStart(e) {
    if (this.touching)
      return;
    this.touchStart = e.touches[0], this.touching = !0, this.moved = !1;
    const t = this.touchStart;
    window.setTimeout(() => {
      const i = this.touchStart === t;
      if (this.touching && i && !this.moved) {
        this.moved = !0;
        const r = {
          type: mt.EVENT_LONG_TAP,
          touchStart: this.touchStart,
          touchEvent: e
        };
        this.eventService.dispatchEvent(r);
      }
    }, 500);
  }
  onTouchMove(e) {
    if (!this.touching)
      return;
    const t = this.getActiveTouch(e.touches);
    if (!t)
      return;
    !jS(t, this.touchStart, 4) && (this.moved = !0);
  }
  onTouchEnd(e) {
    if (this.touching) {
      if (!this.moved) {
        const t = {
          type: mt.EVENT_TAP,
          touchStart: this.touchStart
        };
        this.eventService.dispatchEvent(t), this.checkForDoubleTap();
      }
      this.preventMouseClick && e.cancelable && e.preventDefault(), this.touching = !1;
    }
  }
  checkForDoubleTap() {
    const e = (/* @__PURE__ */ new Date()).getTime();
    if (this.lastTapTime && this.lastTapTime > 0)
      if (e - this.lastTapTime > mt.DOUBLE_TAP_MILLIS) {
        const i = {
          type: mt.EVENT_DOUBLE_TAP,
          touchStart: this.touchStart
        };
        this.eventService.dispatchEvent(i), this.lastTapTime = null;
      } else
        this.lastTapTime = e;
    else
      this.lastTapTime = e;
  }
  destroy() {
    this.destroyFuncs.forEach((e) => e());
  }
}
mt.EVENT_TAP = "tap";
mt.EVENT_DOUBLE_TAP = "doubleTap";
mt.EVENT_LONG_TAP = "longTap";
mt.DOUBLE_TAP_MILLIS = 500;
var tc = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Gr extends X {
  constructor(e) {
    super(), e || this.setTemplate(Gr.TEMPLATE);
  }
  attachCustomElements(e, t, i, r, n) {
    this.eSortOrder = e, this.eSortAsc = t, this.eSortDesc = i, this.eSortMixed = r, this.eSortNone = n;
  }
  setupSort(e, t = !1) {
    this.column = e, this.suppressOrder = t, this.setupMultiSortIndicator(), this.column.getColDef().sortable && (this.addInIcon("sortAscending", this.eSortAsc, e), this.addInIcon("sortDescending", this.eSortDesc, e), this.addInIcon("sortUnSort", this.eSortNone, e), this.addManagedListener(this.eventService, w.EVENT_SORT_CHANGED, () => this.onSortChanged()), this.addManagedListener(this.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.onSortChanged()), this.onSortChanged());
  }
  addInIcon(e, t, i) {
    if (t == null)
      return;
    const r = Vt(e, this.gridOptionsService, i);
    r && t.appendChild(r);
  }
  onSortChanged() {
    this.updateIcons(), this.suppressOrder || this.updateSortOrder();
  }
  updateIcons() {
    const e = this.sortController.getDisplaySortForColumn(this.column);
    if (this.eSortAsc) {
      const t = e === "asc";
      Ke(this.eSortAsc, t, { skipAriaHidden: !0 });
    }
    if (this.eSortDesc) {
      const t = e === "desc";
      Ke(this.eSortDesc, t, { skipAriaHidden: !0 });
    }
    if (this.eSortNone) {
      const t = !this.column.getColDef().unSortIcon && !this.gridOptionsService.is("unSortIcon"), i = e == null;
      Ke(this.eSortNone, !t && i, { skipAriaHidden: !0 });
    }
  }
  setupMultiSortIndicator() {
    this.addInIcon("sortUnSort", this.eSortMixed, this.column);
    const e = this.column.getColDef().showRowGroup;
    this.gridOptionsService.isColumnsSortingCoupledToGroup() && e && (this.addManagedListener(this.eventService, w.EVENT_SORT_CHANGED, () => this.updateMultiSortIndicator()), this.addManagedListener(this.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.updateMultiSortIndicator()), this.updateMultiSortIndicator());
  }
  updateMultiSortIndicator() {
    if (this.eSortMixed) {
      const e = this.sortController.getDisplaySortForColumn(this.column) === "mixed";
      Ke(this.eSortMixed, e, { skipAriaHidden: !0 });
    }
  }
  // we listen here for global sort events, NOT column sort events, as we want to do this
  // when sorting has been set on all column (if we listened just for our col (where we
  // set the asc / desc icons) then it's possible other cols are yet to get their sorting state.
  updateSortOrder() {
    var e;
    if (!this.eSortOrder)
      return;
    const t = this.sortController.getColumnsWithSortingOrdered(), i = (e = this.sortController.getDisplaySortIndexForColumn(this.column)) !== null && e !== void 0 ? e : -1, r = t.some((s) => {
      var a;
      return (a = this.sortController.getDisplaySortIndexForColumn(s)) !== null && a !== void 0 ? a : -1 >= 1;
    }), n = i >= 0 && r;
    Ke(this.eSortOrder, n, { skipAriaHidden: !0 }), i >= 0 ? this.eSortOrder.innerHTML = (i + 1).toString() : Or(this.eSortOrder);
  }
}
Gr.TEMPLATE = `<span class="ag-sort-indicator-container">
            <span ref="eSortOrder" class="ag-sort-indicator-icon ag-sort-order ag-hidden" aria-hidden="true"></span>
            <span ref="eSortAsc" class="ag-sort-indicator-icon ag-sort-ascending-icon ag-hidden" aria-hidden="true"></span>
            <span ref="eSortDesc" class="ag-sort-indicator-icon ag-sort-descending-icon ag-hidden" aria-hidden="true"></span>
            <span ref="eSortMixed" class="ag-sort-indicator-icon ag-sort-mixed-icon ag-hidden" aria-hidden="true"></span>
            <span ref="eSortNone" class="ag-sort-indicator-icon ag-sort-none-icon ag-hidden" aria-hidden="true"></span>
        </span>`;
tc([
  L("eSortOrder")
], Gr.prototype, "eSortOrder", void 0);
tc([
  L("eSortAsc")
], Gr.prototype, "eSortAsc", void 0);
tc([
  L("eSortDesc")
], Gr.prototype, "eSortDesc", void 0);
tc([
  L("eSortMixed")
], Gr.prototype, "eSortMixed", void 0);
tc([
  L("eSortNone")
], Gr.prototype, "eSortNone", void 0);
tc([
  S("columnModel")
], Gr.prototype, "columnModel", void 0);
tc([
  S("sortController")
], Gr.prototype, "sortController", void 0);
var kr = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Oi extends X {
  constructor() {
    super(...arguments), this.lastMovingChanged = 0;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  refresh(e) {
    return this.params = e, this.workOutTemplate() != this.currentTemplate || this.workOutShowMenu() != this.currentShowMenu || this.workOutSort() != this.currentSort ? !1 : (this.setDisplayName(e), !0);
  }
  workOutTemplate() {
    let e = KR(this.params.template, Oi.TEMPLATE);
    return e = e && e.trim ? e.trim() : e, e;
  }
  init(e) {
    this.params = e, this.currentTemplate = this.workOutTemplate(), this.setTemplate(this.currentTemplate), this.setupTap(), this.setupIcons(e.column), this.setMenu(), this.setupSort(), this.setupFilterIcon(), this.setDisplayName(e);
  }
  setDisplayName(e) {
    if (this.currentDisplayName != e.displayName) {
      this.currentDisplayName = e.displayName;
      const t = xo(this.currentDisplayName);
      this.eText && (this.eText.innerHTML = t);
    }
  }
  setupIcons(e) {
    this.addInIcon("menu", this.eMenu, e), this.addInIcon("filter", this.eFilter, e);
  }
  addInIcon(e, t, i) {
    if (t == null)
      return;
    const r = Vt(e, this.gridOptionsService, i);
    r && t.appendChild(r);
  }
  setupTap() {
    const { gridOptionsService: e } = this;
    if (e.is("suppressTouch"))
      return;
    const t = new mt(this.getGui(), !0), i = e.is("suppressMenuHide"), r = i && z(this.eMenu), n = r ? new mt(this.eMenu, !0) : t;
    if (this.params.enableMenu) {
      const s = r ? "EVENT_TAP" : "EVENT_LONG_TAP", a = (l) => {
        e.api.showColumnMenuAfterMouseClick(this.params.column, l.touchStart);
      };
      this.addManagedListener(n, mt[s], a);
    }
    if (this.params.enableSorting) {
      const s = (a) => {
        const l = a.touchStart.target;
        i && this.eMenu.contains(l) || this.sortController.progressSort(this.params.column, !1, "uiColumnSorted");
      };
      this.addManagedListener(t, mt.EVENT_TAP, s);
    }
    this.addDestroyFunc(() => t.destroy()), r && this.addDestroyFunc(() => n.destroy());
  }
  workOutShowMenu() {
    const e = !this.gridOptionsService.is("suppressMenuHide"), t = Fa() && e;
    return this.params.enableMenu && !t;
  }
  setMenu() {
    if (!this.eMenu)
      return;
    if (this.currentShowMenu = this.workOutShowMenu(), !this.currentShowMenu) {
      fs(this.eMenu);
      return;
    }
    const e = this.gridOptionsService.is("suppressMenuHide");
    this.addManagedListener(this.eMenu, "click", () => this.showMenu(this.eMenu)), this.eMenu.classList.toggle("ag-header-menu-always-show", e);
  }
  showMenu(e) {
    e || (e = this.eMenu), this.menuFactory.showMenuAfterButtonClick(this.params.column, e, "columnMenu");
  }
  workOutSort() {
    return this.params.enableSorting;
  }
  setupSort() {
    if (this.currentSort = this.params.enableSorting, this.eSortIndicator || (this.eSortIndicator = this.context.createBean(new Gr(!0)), this.eSortIndicator.attachCustomElements(this.eSortOrder, this.eSortAsc, this.eSortDesc, this.eSortMixed, this.eSortNone)), this.eSortIndicator.setupSort(this.params.column), !this.currentSort)
      return;
    const e = this.gridOptionsService.get("multiSortKey") === "ctrl";
    this.addManagedListener(this.params.column, me.EVENT_MOVING_CHANGED, () => {
      this.lastMovingChanged = (/* @__PURE__ */ new Date()).getTime();
    }), this.eLabel && this.addManagedListener(this.eLabel, "click", (i) => {
      const r = this.params.column.isMoving(), s = (/* @__PURE__ */ new Date()).getTime() - this.lastMovingChanged < 50;
      if (!(r || s)) {
        const l = e ? i.ctrlKey || i.metaKey : i.shiftKey;
        this.params.progressSort(l);
      }
    });
    const t = () => {
      if (this.addOrRemoveCssClass("ag-header-cell-sorted-asc", this.params.column.isSortAscending()), this.addOrRemoveCssClass("ag-header-cell-sorted-desc", this.params.column.isSortDescending()), this.addOrRemoveCssClass("ag-header-cell-sorted-none", this.params.column.isSortNone()), this.params.column.getColDef().showRowGroup) {
        const i = this.columnModel.getSourceColumnsForGroupColumn(this.params.column), n = !(i == null ? void 0 : i.every((s) => this.params.column.getSort() == s.getSort()));
        this.addOrRemoveCssClass("ag-header-cell-sorted-mixed", n);
      }
    };
    this.addManagedListener(this.eventService, w.EVENT_SORT_CHANGED, t), this.addManagedListener(this.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, t);
  }
  setupFilterIcon() {
    this.eFilter && (this.addManagedListener(this.params.column, me.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this)), this.onFilterChanged());
  }
  onFilterChanged() {
    const e = this.params.column.isFilterActive();
    Ke(this.eFilter, e, { skipAriaHidden: !0 });
  }
}
Oi.TEMPLATE = `<div class="ag-cell-label-container" role="presentation">
            <span ref="eMenu" class="ag-header-icon ag-header-cell-menu-button" aria-hidden="true"></span>
            <div ref="eLabel" class="ag-header-cell-label" role="presentation">
                <span ref="eText" class="ag-header-cell-text"></span>
                <span ref="eFilter" class="ag-header-icon ag-header-label-icon ag-filter-icon" aria-hidden="true"></span>
                <ag-sort-indicator ref="eSortIndicator"></ag-sort-indicator>
            </div>
        </div>`;
kr([
  S("sortController")
], Oi.prototype, "sortController", void 0);
kr([
  S("menuFactory")
], Oi.prototype, "menuFactory", void 0);
kr([
  S("columnModel")
], Oi.prototype, "columnModel", void 0);
kr([
  L("eFilter")
], Oi.prototype, "eFilter", void 0);
kr([
  L("eSortIndicator")
], Oi.prototype, "eSortIndicator", void 0);
kr([
  L("eMenu")
], Oi.prototype, "eMenu", void 0);
kr([
  L("eLabel")
], Oi.prototype, "eLabel", void 0);
kr([
  L("eText")
], Oi.prototype, "eText", void 0);
kr([
  L("eSortOrder")
], Oi.prototype, "eSortOrder", void 0);
kr([
  L("eSortAsc")
], Oi.prototype, "eSortAsc", void 0);
kr([
  L("eSortDesc")
], Oi.prototype, "eSortDesc", void 0);
kr([
  L("eSortMixed")
], Oi.prototype, "eSortMixed", void 0);
kr([
  L("eSortNone")
], Oi.prototype, "eSortNone", void 0);
var ib = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class ic extends X {
  constructor() {
    super(ic.TEMPLATE);
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    this.params = e, this.checkWarnings(), this.setupLabel(), this.addGroupExpandIcon(), this.setupExpandIcons();
  }
  checkWarnings() {
    if (this.params.template) {
      const t = "AG Grid: A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)";
      tt(() => console.warn(t), "HeaderGroupComp.templateNotSupported");
    }
  }
  setupExpandIcons() {
    this.addInIcon("columnGroupOpened", "agOpened"), this.addInIcon("columnGroupClosed", "agClosed");
    const e = (r) => {
      if (Eo(r))
        return;
      const n = !this.params.columnGroup.isExpanded();
      this.columnModel.setColumnGroupOpened(this.params.columnGroup.getProvidedColumnGroup(), n, "uiColumnExpanded");
    };
    this.addTouchAndClickListeners(this.eCloseIcon, e), this.addTouchAndClickListeners(this.eOpenIcon, e);
    const t = (r) => {
      Ss(r);
    };
    this.addManagedListener(this.eCloseIcon, "dblclick", t), this.addManagedListener(this.eOpenIcon, "dblclick", t), this.addManagedListener(this.getGui(), "dblclick", e), this.updateIconVisibility();
    const i = this.params.columnGroup.getProvidedColumnGroup();
    this.addManagedListener(i, Be.EVENT_EXPANDED_CHANGED, this.updateIconVisibility.bind(this)), this.addManagedListener(i, Be.EVENT_EXPANDABLE_CHANGED, this.updateIconVisibility.bind(this));
  }
  addTouchAndClickListeners(e, t) {
    const i = new mt(e, !0);
    this.addManagedListener(i, mt.EVENT_TAP, t), this.addDestroyFunc(() => i.destroy()), this.addManagedListener(e, "click", t);
  }
  updateIconVisibility() {
    if (this.params.columnGroup.isExpandable()) {
      const t = this.params.columnGroup.isExpanded();
      Ke(this.eOpenIcon, t), Ke(this.eCloseIcon, !t);
    } else
      Ke(this.eOpenIcon, !1), Ke(this.eCloseIcon, !1);
  }
  addInIcon(e, t) {
    const i = Vt(e, this.gridOptionsService, null);
    i && this.getRefElement(t).appendChild(i);
  }
  addGroupExpandIcon() {
    if (!this.params.columnGroup.isExpandable()) {
      Ke(this.eOpenIcon, !1), Ke(this.eCloseIcon, !1);
      return;
    }
  }
  setupLabel() {
    var e;
    const { displayName: t, columnGroup: i } = this.params;
    if (z(t)) {
      const r = xo(t);
      this.getRefElement("agLabel").innerHTML = r;
    }
    this.addOrRemoveCssClass("ag-sticky-label", !(!((e = i.getColGroupDef()) === null || e === void 0) && e.suppressStickyLabel));
  }
}
ic.TEMPLATE = `<div class="ag-header-group-cell-label" ref="agContainer" role="presentation">
            <span ref="agLabel" class="ag-header-group-text" role="presentation"></span>
            <span ref="agOpened" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded"></span>
            <span ref="agClosed" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed"></span>
        </div>`;
ib([
  S("columnModel")
], ic.prototype, "columnModel", void 0);
ib([
  L("agOpened")
], ic.prototype, "eOpenIcon", void 0);
ib([
  L("agClosed")
], ic.prototype, "eCloseIcon", void 0);
class rc extends X {
  isPopup() {
    return !0;
  }
  setParentComponent(e) {
    e.addCssClass("ag-has-popup"), super.setParentComponent(e);
  }
  destroy() {
    const e = this.parentComponent;
    e && e.isAlive() && e.getGui().classList.remove("ag-has-popup"), super.destroy();
  }
}
var iL = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Ap extends rc {
  constructor() {
    super(Ap.TEMPLATE);
  }
  init(e) {
    this.params = e, this.focusAfterAttached = e.cellStartedEdit, this.eTextArea.setMaxLength(e.maxLength || 200).setCols(e.cols || 60).setRows(e.rows || 10), z(e.value, !0) && this.eTextArea.setValue(e.value.toString(), !0), this.addGuiEventListener("keydown", this.onKeyDown.bind(this)), this.activateTabIndex();
  }
  onKeyDown(e) {
    const t = e.key;
    (t === V.LEFT || t === V.UP || t === V.RIGHT || t === V.DOWN || e.shiftKey && t === V.ENTER) && e.stopPropagation();
  }
  afterGuiAttached() {
    const e = this.localeService.getLocaleTextFunc();
    this.eTextArea.setInputAriaLabel(e("ariaInputEditor", "Input Editor")), this.focusAfterAttached && this.eTextArea.getFocusableElement().focus();
  }
  getValue() {
    const e = this.eTextArea.getValue();
    return !z(e) && !z(this.params.value) ? this.params.value : this.params.parseValue(e);
  }
}
Ap.TEMPLATE = `<div class="ag-large-text">
            <ag-input-text-area ref="eTextArea" class="ag-large-text-input"></ag-input-text-area>
        </div>`;
iL([
  L("eTextArea")
], Ap.prototype, "eTextArea", void 0);
var QT = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class rb extends rc {
  constructor() {
    super('<div class="ag-cell-edit-wrapper"><ag-select class="ag-cell-editor" ref="eSelect"></ag-select></div>'), this.startedByEnter = !1;
  }
  init(e) {
    if (this.focusAfterAttached = e.cellStartedEdit, Se(e.values)) {
      console.warn("AG Grid: no values found for select cellEditor");
      return;
    }
    this.startedByEnter = e.eventKey != null ? e.eventKey === V.ENTER : !1;
    let t = !1;
    e.values.forEach((i) => {
      const r = { value: i }, n = this.valueFormatterService.formatValue(e.column, null, i), s = n != null;
      r.text = s ? n : i, this.eSelect.addOption(r), t = t || e.value === i;
    }), t ? this.eSelect.setValue(e.value, !0) : e.values.length && this.eSelect.setValue(e.values[0], !0), this.gridOptionsService.get("editType") !== "fullRow" && this.addManagedListener(this.eSelect, zn.EVENT_ITEM_SELECTED, () => e.stopEditing());
  }
  afterGuiAttached() {
    this.focusAfterAttached && this.eSelect.getFocusableElement().focus(), this.startedByEnter && this.eSelect.showPicker();
  }
  focusIn() {
    this.eSelect.getFocusableElement().focus();
  }
  getValue() {
    return this.eSelect.getValue();
  }
  isPopup() {
    return !1;
  }
}
QT([
  S("valueFormatterService")
], rb.prototype, "valueFormatterService", void 0);
QT([
  L("eSelect")
], rb.prototype, "eSelect", void 0);
var rL = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Mp extends rc {
  constructor(e) {
    super(
      /* html */
      `
            <div class="ag-cell-edit-wrapper">
                ${e.getTemplate()}
            </div>`
    ), this.cellEditorInput = e;
  }
  init(e) {
    this.params = e;
    const t = this.eInput;
    this.cellEditorInput.init(t, e);
    let i;
    if (e.cellStartedEdit) {
      this.focusAfterAttached = !0;
      const r = e.eventKey;
      r === V.BACKSPACE || e.eventKey === V.DELETE ? i = "" : r && r.length === 1 ? i = r : (i = this.cellEditorInput.getStartValue(), r !== V.F2 && (this.highlightAllOnFocus = !0));
    } else
      this.focusAfterAttached = !1, i = this.cellEditorInput.getStartValue();
    i != null && t.setStartValue(i), this.addManagedListener(t.getGui(), "keydown", (r) => {
      const { key: n } = r;
      (n === V.PAGE_UP || n === V.PAGE_DOWN) && r.preventDefault();
    });
  }
  afterGuiAttached() {
    var e, t;
    const i = this.localeService.getLocaleTextFunc(), r = this.eInput;
    if (r.setInputAriaLabel(i("ariaInputEditor", "Input Editor")), !this.focusAfterAttached)
      return;
    fn() || r.getFocusableElement().focus();
    const n = r.getInputElement();
    this.highlightAllOnFocus ? n.select() : (t = (e = this.cellEditorInput).setCaret) === null || t === void 0 || t.call(e);
  }
  // gets called when tabbing through cells and in full row edit mode
  focusIn() {
    const e = this.eInput, t = e.getFocusableElement(), i = e.getInputElement();
    t.focus(), i.select();
  }
  getValue() {
    return this.cellEditorInput.getValue();
  }
  isPopup() {
    return !1;
  }
}
rL([
  L("eInput")
], Mp.prototype, "eInput", void 0);
class nL {
  getTemplate() {
    return (
      /* html */
      '<ag-input-text-field class="ag-cell-editor" ref="eInput"></ag-input-text-field>'
    );
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.maxLength != null && e.setMaxLength(t.maxLength);
  }
  getValue() {
    const e = this.eInput.getValue();
    return !z(e) && !z(this.params.value) ? this.params.value : this.params.parseValue(e);
  }
  getStartValue() {
    return this.params.useFormatter || this.params.column.getColDef().refData ? this.params.formatValue(this.params.value) : this.params.value;
  }
  setCaret() {
    const e = this.eInput.getValue(), t = z(e) && e.length || 0;
    t && this.eInput.getInputElement().setSelectionRange(t, t);
  }
}
class qw extends Mp {
  constructor() {
    super(new nL());
  }
}
var oL = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const sL = "↑", aL = "↓";
class _p extends X {
  constructor() {
    super(_p.TEMPLATE), this.refreshCount = 0;
  }
  init(e) {
    this.eValue = this.queryForHtmlElement(".ag-value-change-value"), this.eDelta = this.queryForHtmlElement(".ag-value-change-delta"), this.refresh(e);
  }
  showDelta(e, t) {
    const i = Math.abs(t), r = e.formatValue(i), n = z(r) ? r : i, s = t >= 0;
    s ? this.eDelta.innerHTML = sL + n : this.eDelta.innerHTML = aL + n, this.eDelta.classList.toggle("ag-value-change-delta-up", s), this.eDelta.classList.toggle("ag-value-change-delta-down", !s);
  }
  setTimerToRemoveDelta() {
    this.refreshCount++;
    const e = this.refreshCount;
    window.setTimeout(() => {
      e === this.refreshCount && this.hideDeltaValue();
    }, 2e3);
  }
  hideDeltaValue() {
    this.eValue.classList.remove("ag-value-change-value-highlight"), Or(this.eDelta);
  }
  refresh(e) {
    const t = e.value;
    if (t === this.lastValue || (z(e.valueFormatted) ? this.eValue.innerHTML = e.valueFormatted : z(e.value) ? this.eValue.innerHTML = t : Or(this.eValue), this.filterManager.isSuppressFlashingCellsBecauseFiltering()))
      return !1;
    if (typeof t == "number" && typeof this.lastValue == "number") {
      const i = t - this.lastValue;
      this.showDelta(e, i);
    }
    return this.lastValue && this.eValue.classList.add("ag-value-change-value-highlight"), this.setTimerToRemoveDelta(), this.lastValue = t, !0;
  }
}
_p.TEMPLATE = '<span><span class="ag-value-change-delta"></span><span class="ag-value-change-value"></span></span>';
oL([
  S("filterManager")
], _p.prototype, "filterManager", void 0);
var lL = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Ip extends X {
  constructor() {
    super(Ip.TEMPLATE), this.refreshCount = 0, this.eCurrent = this.queryForHtmlElement(".ag-value-slide-current");
  }
  init(e) {
    this.refresh(e);
  }
  addSlideAnimation() {
    this.refreshCount++;
    const e = this.refreshCount;
    this.ePrevious && this.getGui().removeChild(this.ePrevious), this.ePrevious = Si('<span class="ag-value-slide-previous ag-value-slide-out"></span>'), this.ePrevious.innerHTML = this.eCurrent.innerHTML, this.getGui().insertBefore(this.ePrevious, this.eCurrent), window.setTimeout(() => {
      e === this.refreshCount && this.ePrevious.classList.add("ag-value-slide-out-end");
    }, 50), window.setTimeout(() => {
      e === this.refreshCount && (this.getGui().removeChild(this.ePrevious), this.ePrevious = null);
    }, 3e3);
  }
  refresh(e) {
    let t = e.value;
    return Se(t) && (t = ""), t === this.lastValue || this.filterManager.isSuppressFlashingCellsBecauseFiltering() ? !1 : (this.addSlideAnimation(), this.lastValue = t, z(e.valueFormatted) ? this.eCurrent.innerHTML = e.valueFormatted : z(e.value) ? this.eCurrent.innerHTML = t : Or(this.eCurrent), !0);
  }
}
Ip.TEMPLATE = `<span>
            <span class="ag-value-slide-current"></span>
        </span>`;
lL([
  S("filterManager")
], Ip.prototype, "filterManager", void 0);
class re {
  constructor(e) {
    this.rowIndex = null, this.key = null, this.childrenMapped = {}, this.displayed = !1, this.rowTop = null, this.oldRowTop = null, this.selectable = !0, this.__objectId = re.OBJECT_ID_SEQUENCE++, this.__autoHeights = {}, this.alreadyRendered = !1, this.highlighted = null, this.hovered = !1, this.selected = !1, this.beans = e;
  }
  /**
   * Replaces the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */
  setData(e) {
    this.setDataCommon(e, !1);
  }
  // similar to setRowData, however it is expected that the data is the same data item. this
  // is intended to be used with Redux type stores, where the whole data can be changed. we are
  // guaranteed that the data is the same entity (so grid doesn't need to worry about the id of the
  // underlying data changing, hence doesn't need to worry about selection). the grid, upon receiving
  // dataChanged event, will refresh the cells rather than rip them all out (so user can show transitions).
  /**
   * Updates the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */
  updateData(e) {
    this.setDataCommon(e, !0);
  }
  setDataCommon(e, t) {
    const i = this.data;
    this.data = e, this.beans.valueCache.onDataChanged(), this.updateDataOnDetailNode(), this.checkRowSelectable(), this.resetQuickFilterAggregateText();
    const r = this.createDataChangedEvent(e, i, t);
    this.dispatchLocalEvent(r);
  }
  // when we are doing master / detail, the detail node is lazy created, but then kept around.
  // so if we show / hide the detail, the same detail rowNode is used. so we need to keep the data
  // in sync, otherwise expand/collapse of the detail would still show the old values.
  updateDataOnDetailNode() {
    this.detailNode && (this.detailNode.data = this.data);
  }
  createDataChangedEvent(e, t, i) {
    return {
      type: re.EVENT_DATA_CHANGED,
      node: this,
      oldData: t,
      newData: e,
      update: i
    };
  }
  createLocalRowEvent(e) {
    return {
      type: e,
      node: this
    };
  }
  getRowIndexString() {
    return this.rowPinned === "top" ? "t-" + this.rowIndex : this.rowPinned === "bottom" ? "b-" + this.rowIndex : this.rowIndex.toString();
  }
  createDaemonNode() {
    const e = new re(this.beans);
    return e.id = this.id, e.data = this.data, e.__daemon = !0, e.selected = this.selected, e.level = this.level, e;
  }
  setDataAndId(e, t) {
    const i = z(this.id) ? this.createDaemonNode() : null, r = this.data;
    this.data = e, this.updateDataOnDetailNode(), this.setId(t), this.beans.selectionService.syncInRowNode(this, i), this.checkRowSelectable();
    const n = this.createDataChangedEvent(e, r, !1);
    this.dispatchLocalEvent(n);
  }
  checkRowSelectable() {
    const e = this.beans.gridOptionsService.get("isRowSelectable");
    this.setRowSelectable(e ? e(this) : !0);
  }
  setRowSelectable(e) {
    if (this.selectable !== e && (this.selectable = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(re.EVENT_SELECTABLE_CHANGED)), this.beans.gridOptionsService.is("groupSelectsChildren"))) {
      const i = this.calculateSelectedFromChildren();
      this.setSelectedParams({
        newValue: i != null ? i : !1,
        source: "selectableChanged"
      });
    }
  }
  setId(e) {
    const t = this.beans.gridOptionsService.getCallback("getRowId");
    if (t)
      if (this.data) {
        const i = this.getGroupKeys(!0);
        this.id = t({
          data: this.data,
          parentKeys: i.length > 0 ? i : void 0,
          level: this.level
        }), this.id !== null && typeof this.id == "string" && this.id.startsWith(re.ID_PREFIX_ROW_GROUP) && console.error(`AG Grid: Row IDs cannot start with ${re.ID_PREFIX_ROW_GROUP}, this is a reserved prefix for AG Grid's row grouping feature.`), this.id !== null && typeof this.id != "string" && (this.id = "" + this.id);
      } else
        this.id = void 0;
    else
      this.id = e;
  }
  getGroupKeys(e = !1) {
    const t = [];
    let i = this;
    for (e && (i = i.parent); i && i.level >= 0; )
      t.push(i.key), i = i.parent;
    return t.reverse(), t;
  }
  isPixelInRange(e) {
    return !z(this.rowTop) || !z(this.rowHeight) ? !1 : e >= this.rowTop && e < this.rowTop + this.rowHeight;
  }
  setFirstChild(e) {
    this.firstChild !== e && (this.firstChild = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(re.EVENT_FIRST_CHILD_CHANGED)));
  }
  setLastChild(e) {
    this.lastChild !== e && (this.lastChild = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(re.EVENT_LAST_CHILD_CHANGED)));
  }
  setChildIndex(e) {
    this.childIndex !== e && (this.childIndex = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(re.EVENT_CHILD_INDEX_CHANGED)));
  }
  setRowTop(e) {
    this.oldRowTop = this.rowTop, this.rowTop !== e && (this.rowTop = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(re.EVENT_TOP_CHANGED)), this.setDisplayed(e !== null));
  }
  clearRowTopAndRowIndex() {
    this.oldRowTop = null, this.setRowTop(null), this.setRowIndex(null);
  }
  setDisplayed(e) {
    this.displayed !== e && (this.displayed = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(re.EVENT_DISPLAYED_CHANGED)));
  }
  setDragging(e) {
    this.dragging !== e && (this.dragging = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(re.EVENT_DRAGGING_CHANGED)));
  }
  setHighlighted(e) {
    e !== this.highlighted && (this.highlighted = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(re.EVENT_HIGHLIGHT_CHANGED)));
  }
  setHovered(e) {
    this.hovered !== e && (this.hovered = e);
  }
  isHovered() {
    return this.hovered;
  }
  setAllChildrenCount(e) {
    this.allChildrenCount !== e && (this.allChildrenCount = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(re.EVENT_ALL_CHILDREN_COUNT_CHANGED)));
  }
  setMaster(e) {
    this.master !== e && (this.master && !e && (this.expanded = !1), this.master = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(re.EVENT_MASTER_CHANGED)));
  }
  setGroup(e) {
    this.group !== e && (this.group && !e && (this.expanded = !1), this.group = e, this.updateHasChildren(), this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(re.EVENT_GROUP_CHANGED)));
  }
  /**
   * Sets the row height.
   * Call if you want to change the height initially assigned to the row.
   * After calling, you must call `api.onRowHeightChanged()` so the grid knows it needs to work out the placement of the rows. */
  setRowHeight(e, t = !1) {
    this.rowHeight = e, this.rowHeightEstimated = t, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(re.EVENT_HEIGHT_CHANGED));
  }
  setRowAutoHeight(e, t) {
    this.__autoHeights || (this.__autoHeights = {}), this.__autoHeights[t.getId()] = e, e != null && (this.checkAutoHeightsDebounced == null && (this.checkAutoHeightsDebounced = Co(this.checkAutoHeights.bind(this), 1)), this.checkAutoHeightsDebounced());
  }
  checkAutoHeights() {
    let e = !1, t = !0, i = 0;
    const r = this.__autoHeights;
    if (r == null || (this.beans.columnModel.getAllDisplayedAutoHeightCols().forEach((a) => {
      let l = r[a.getId()];
      if (l == null)
        if (this.beans.columnModel.isColSpanActive()) {
          let c = [];
          switch (a.getPinned()) {
            case "left":
              c = this.beans.columnModel.getDisplayedLeftColumnsForRow(this);
              break;
            case "right":
              c = this.beans.columnModel.getDisplayedRightColumnsForRow(this);
              break;
            case null:
              c = this.beans.columnModel.getViewportCenterColumnsForRow(this);
              break;
          }
          if (c.includes(a)) {
            e = !0;
            return;
          }
          l = -1;
        } else {
          e = !0;
          return;
        }
      else
        t = !1;
      l > i && (i = l);
    }), e) || ((t || i < 10) && (i = this.beans.gridOptionsService.getRowHeightForNode(this).height), i == this.rowHeight))
      return;
    this.setRowHeight(i);
    const s = this.beans.rowModel;
    s.onRowHeightChangedDebounced && s.onRowHeightChangedDebounced();
  }
  setRowIndex(e) {
    this.rowIndex !== e && (this.rowIndex = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(re.EVENT_ROW_INDEX_CHANGED)));
  }
  setUiLevel(e) {
    this.uiLevel !== e && (this.uiLevel = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(re.EVENT_UI_LEVEL_CHANGED)));
  }
  /**
   * Set the expanded state of this rowNode. Pass `true` to expand and `false` to collapse.
   */
  setExpanded(e, t) {
    if (this.expanded === e)
      return;
    this.expanded = e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(re.EVENT_EXPANDED_CHANGED));
    const i = Object.assign({}, this.createGlobalRowEvent(w.EVENT_ROW_GROUP_OPENED), {
      expanded: e,
      event: t || null
    });
    this.beans.rowNodeEventThrottle.dispatchExpanded(i), this.beans.gridOptionsService.is("groupIncludeFooter") && this.beans.rowRenderer.refreshCells({ rowNodes: [this] });
  }
  createGlobalRowEvent(e) {
    return {
      type: e,
      node: this,
      data: this.data,
      rowIndex: this.rowIndex,
      rowPinned: this.rowPinned,
      context: this.beans.gridOptionsService.context,
      api: this.beans.gridOptionsService.api,
      columnApi: this.beans.gridOptionsService.columnApi
    };
  }
  dispatchLocalEvent(e) {
    this.eventService && this.eventService.dispatchEvent(e);
  }
  /**
   * Replaces the value on the `rowNode` for the specified column. When complete,
   * the grid will refresh the rendered cell on the required row only.
   * **Note**: This method only fires `onCellEditRequest` when the Grid is in **Read Only** mode.
   *
   * @param colKey The column where the value should be updated
   * @param newValue The new value
   * @param eventSource The source of the event
   * @returns `true` if the value was changed, otherwise `false`.
   */
  setDataValue(e, t, i) {
    const n = (() => {
      var l;
      return typeof e != "string" ? e : (l = this.beans.columnModel.getGridColumn(e)) !== null && l !== void 0 ? l : this.beans.columnModel.getPrimaryColumn(e);
    })(), s = this.getValueFromValueService(n);
    if (this.beans.gridOptionsService.is("readOnlyEdit"))
      return this.dispatchEventForSaveValueReadOnly(n, s, t, i), !1;
    const a = this.beans.valueService.setValue(this, n, t, i);
    return this.dispatchCellChangedEvent(n, t, s), this.checkRowSelectable(), a;
  }
  getValueFromValueService(e) {
    const t = this.leafGroup && this.beans.columnModel.isPivotMode(), i = this.group && this.expanded && !this.footer && !t, r = this.beans.gridOptionsService.is("groupIncludeFooter"), n = this.beans.gridOptionsService.is("groupSuppressBlankHeader"), s = i && r && !n;
    return this.beans.valueService.getValue(e, this, !1, s);
  }
  dispatchEventForSaveValueReadOnly(e, t, i, r) {
    const n = {
      type: w.EVENT_CELL_EDIT_REQUEST,
      event: null,
      rowIndex: this.rowIndex,
      rowPinned: this.rowPinned,
      column: e,
      colDef: e.getColDef(),
      context: this.beans.gridOptionsService.context,
      api: this.beans.gridOptionsService.api,
      columnApi: this.beans.gridOptionsService.columnApi,
      data: this.data,
      node: this,
      oldValue: t,
      newValue: i,
      value: i,
      source: r
    };
    this.beans.eventService.dispatchEvent(n);
  }
  setGroupValue(e, t) {
    const i = this.beans.columnModel.getGridColumn(e);
    Se(this.groupData) && (this.groupData = {});
    const r = i.getColId(), n = this.groupData[r];
    n !== t && (this.groupData[r] = t, this.dispatchCellChangedEvent(i, t, n));
  }
  // sets the data for an aggregation
  setAggData(e) {
    const t = VR([this.aggData, e]), i = this.aggData;
    this.aggData = e, this.eventService && t.forEach((r) => {
      const n = this.beans.columnModel.getGridColumn(r), s = this.aggData ? this.aggData[r] : void 0, a = i ? i[r] : void 0;
      this.dispatchCellChangedEvent(n, s, a);
    });
  }
  updateHasChildren() {
    let e = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
    if (this.beans.gridOptionsService.isRowModelType("serverSide")) {
      const i = this.beans.gridOptionsService.isTreeData(), r = this.beans.gridOptionsService.get("isServerSideGroup");
      e = !this.stub && !this.footer && (i ? !!r && r(this.data) : !!this.group);
    }
    e !== this.__hasChildren && (this.__hasChildren = !!e, this.eventService && this.eventService.dispatchEvent(this.createLocalRowEvent(re.EVENT_HAS_CHILDREN_CHANGED)));
  }
  hasChildren() {
    return this.__hasChildren == null && this.updateHasChildren(), this.__hasChildren;
  }
  isEmptyRowGroupNode() {
    return this.group && br(this.childrenAfterGroup);
  }
  dispatchCellChangedEvent(e, t, i) {
    const r = {
      type: re.EVENT_CELL_CHANGED,
      node: this,
      column: e,
      newValue: t,
      oldValue: i
    };
    this.dispatchLocalEvent(r);
  }
  /**
   * The first time `quickFilter` runs, the grid creates a one-off string representation of the row.
   * This string is then used for the quick filter instead of hitting each column separately.
   * When you edit, using grid editing, this string gets cleared down.
   * However if you edit without using grid editing, you will need to clear this string down for the row to be updated with the new values.
   * Otherwise new values will not work with the `quickFilter`. */
  resetQuickFilterAggregateText() {
    this.quickFilterAggregateText = null;
  }
  /** Returns:
  * - `true` if the node can be expanded, i.e it is a group or master row.
  * - `false` if the node cannot be expanded
  */
  isExpandable() {
    return !!(this.hasChildren() && !this.footer || this.master);
  }
  /** Returns:
   * - `true` if node is selected,
   * - `false` if the node isn't selected
   * - `undefined` if it's partially selected (group where not all children are selected). */
  isSelected() {
    return this.footer ? this.sibling.isSelected() : this.selected;
  }
  /** Perform a depth-first search of this node and its children. */
  depthFirstSearch(e) {
    this.childrenAfterGroup && this.childrenAfterGroup.forEach((t) => t.depthFirstSearch(e)), e(this);
  }
  // + selectionController.calculatedSelectedForAllGroupNodes()
  calculateSelectedFromChildren() {
    var e;
    let t = !1, i = !1, r = !1;
    if (!(!((e = this.childrenAfterGroup) === null || e === void 0) && e.length))
      return this.selectable ? this.selected : null;
    for (let n = 0; n < this.childrenAfterGroup.length; n++) {
      const s = this.childrenAfterGroup[n];
      let a = s.isSelected();
      if (!s.selectable) {
        const l = s.calculateSelectedFromChildren();
        if (l === null)
          continue;
        a = l;
      }
      switch (a) {
        case !0:
          t = !0;
          break;
        case !1:
          i = !0;
          break;
        default:
          r = !0;
          break;
      }
    }
    if (!(r || t && i))
      return t ? !0 : i ? !1 : this.selectable ? this.selected : null;
  }
  setSelectedInitialValue(e) {
    this.selected = e;
  }
  selectThisNode(e, t, i = "api") {
    const r = !this.selectable && e, n = this.selected === e;
    if (r || n)
      return !1;
    this.selected = e, this.eventService && this.dispatchLocalEvent(this.createLocalRowEvent(re.EVENT_ROW_SELECTED));
    const s = Object.assign(Object.assign({}, this.createGlobalRowEvent(w.EVENT_ROW_SELECTED)), { event: t || null, source: i });
    return this.beans.eventService.dispatchEvent(s), !0;
  }
  /**
   * Select (or deselect) the node.
   * @param newValue -`true` for selection, `false` for deselection.
   * @param clearSelection - If selecting, then passing `true` will select the node exclusively (i.e. NOT do multi select). If doing deselection, `clearSelection` has no impact.
   * @param source - Source property that will appear in the `selectionChanged` event.
   */
  setSelected(e, t = !1, i = "api") {
    if (typeof i == "boolean") {
      console.warn("AG Grid: since version v30, rowNode.setSelected() property `suppressFinishActions` has been removed, please use `gridApi.setNodesSelected()` for bulk actions, and the event `source` property for ignoring events instead.");
      return;
    }
    this.setSelectedParams({
      newValue: e,
      clearSelection: t,
      rangeSelect: !1,
      source: i
    });
  }
  // this is for internal use only. To make calling code more readable, this is the same method as setSelected except it takes names parameters
  setSelectedParams(e) {
    return this.rowPinned ? (console.warn("AG Grid: cannot select pinned rows"), 0) : this.id === void 0 ? (console.warn("AG Grid: cannot select node until id for node is known"), 0) : this.beans.selectionService.setNodesSelected(Object.assign(Object.assign({}, e), { nodes: [this.footer ? this.sibling : this] }));
  }
  /**
   * Returns:
   * - `true` if node is either pinned to the `top` or `bottom`
   * - `false` if the node isn't pinned
   */
  isRowPinned() {
    return this.rowPinned === "top" || this.rowPinned === "bottom";
  }
  isParentOfNode(e) {
    let t = this.parent;
    for (; t; ) {
      if (t === e)
        return !0;
      t = t.parent;
    }
    return !1;
  }
  /** Add an event listener. */
  addEventListener(e, t) {
    this.eventService || (this.eventService = new _r()), this.eventService.addEventListener(e, t);
  }
  /** Remove event listener. */
  removeEventListener(e, t) {
    this.eventService && (this.eventService.removeEventListener(e, t), this.eventService.noRegisteredListenersExist() && (this.eventService = null));
  }
  onMouseEnter() {
    this.dispatchLocalEvent(this.createLocalRowEvent(re.EVENT_MOUSE_ENTER));
  }
  onMouseLeave() {
    this.dispatchLocalEvent(this.createLocalRowEvent(re.EVENT_MOUSE_LEAVE));
  }
  getFirstChildOfFirstChild(e) {
    let t = this, i = !0, r = !1, n = null;
    for (; i && !r; ) {
      const s = t.parent;
      z(s) && t.firstChild ? s.rowGroupColumn === e && (r = !0, n = s) : i = !1, t = s;
    }
    return r ? n : null;
  }
  /**
   * Returns:
   * - `true` if the node is a full width cell
   * - `false` if the node is not a full width cell
   */
  isFullWidthCell() {
    const e = this.beans.gridOptionsService.getCallback("isFullWidthRow");
    return e ? e({ rowNode: this }) : !1;
  }
  /**
   * Returns the route of the row node. If the Row Node is a group, it returns the route to that Row Node.
   * If the Row Node is not a group, it returns `undefined`.
   */
  getRoute() {
    if (this.key == null)
      return;
    const e = [];
    let t = this;
    for (; t.key != null; )
      e.push(t.key), t = t.parent;
    return e.reverse();
  }
  createFooter() {
    if (this.sibling)
      return;
    const e = new re(this.beans);
    Object.keys(this).forEach((t) => {
      e[t] = this[t];
    }), e.footer = !0, e.setRowTop(null), e.setRowIndex(null), e.oldRowTop = null, e.id = "rowGroupFooter_" + this.id, e.sibling = this, this.sibling = e;
  }
}
re.ID_PREFIX_ROW_GROUP = "row-group-";
re.ID_PREFIX_TOP_PINNED = "t-";
re.ID_PREFIX_BOTTOM_PINNED = "b-";
re.OBJECT_ID_SEQUENCE = 0;
re.EVENT_ROW_SELECTED = "rowSelected";
re.EVENT_DATA_CHANGED = "dataChanged";
re.EVENT_CELL_CHANGED = "cellChanged";
re.EVENT_ALL_CHILDREN_COUNT_CHANGED = "allChildrenCountChanged";
re.EVENT_MASTER_CHANGED = "masterChanged";
re.EVENT_GROUP_CHANGED = "groupChanged";
re.EVENT_MOUSE_ENTER = "mouseEnter";
re.EVENT_MOUSE_LEAVE = "mouseLeave";
re.EVENT_HEIGHT_CHANGED = "heightChanged";
re.EVENT_TOP_CHANGED = "topChanged";
re.EVENT_DISPLAYED_CHANGED = "displayedChanged";
re.EVENT_FIRST_CHILD_CHANGED = "firstChildChanged";
re.EVENT_LAST_CHILD_CHANGED = "lastChildChanged";
re.EVENT_CHILD_INDEX_CHANGED = "childIndexChanged";
re.EVENT_ROW_INDEX_CHANGED = "rowIndexChanged";
re.EVENT_EXPANDED_CHANGED = "expandedChanged";
re.EVENT_HAS_CHILDREN_CHANGED = "hasChildrenChanged";
re.EVENT_SELECTABLE_CHANGED = "selectableChanged";
re.EVENT_UI_LEVEL_CHANGED = "uiLevelChanged";
re.EVENT_HIGHLIGHT_CHANGED = "rowHighlightChanged";
re.EVENT_DRAGGING_CHANGED = "draggingChanged";
var JT = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class $v extends X {
  constructor() {
    super(
      /* html*/
      `
            <div class="ag-selection-checkbox" role="presentation">
                <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>
            </div>`
    );
  }
  postConstruct() {
    this.eCheckbox.setPassive(!0), uT(this.eCheckbox.getInputElement(), "polite");
  }
  getCheckboxId() {
    return this.eCheckbox.getInputElement().id;
  }
  onDataChanged() {
    this.onSelectionChanged();
  }
  onSelectableChanged() {
    this.showOrHideSelect();
  }
  onSelectionChanged() {
    const e = this.localeService.getLocaleTextFunc(), t = this.rowNode.isSelected(), i = Gv(e, t), r = e("ariaRowToggleSelection", "Press Space to toggle row selection");
    this.eCheckbox.setValue(t, !0), this.eCheckbox.setInputAriaLabel(`${r} (${i})`);
  }
  onClicked(e, t, i) {
    return this.rowNode.setSelectedParams({ newValue: e, rangeSelect: i.shiftKey, groupSelectsFiltered: t, event: i, source: "checkboxSelected" });
  }
  init(e) {
    if (this.rowNode = e.rowNode, this.column = e.column, this.overrides = e.overrides, this.onSelectionChanged(), this.addManagedListener(this.eCheckbox.getInputElement(), "dblclick", (r) => {
      Ss(r);
    }), this.addManagedListener(this.eCheckbox.getInputElement(), "click", (r) => {
      Ss(r);
      const n = this.gridOptionsService.is("groupSelectsFiltered"), s = this.eCheckbox.getValue();
      this.shouldHandleIndeterminateState(s, n) ? this.onClicked(!0, n, r || {}) === 0 && this.onClicked(!1, n, r) : s ? this.onClicked(!1, n, r) : this.onClicked(!0, n, r || {});
    }), this.addManagedListener(this.rowNode, re.EVENT_ROW_SELECTED, this.onSelectionChanged.bind(this)), this.addManagedListener(this.rowNode, re.EVENT_DATA_CHANGED, this.onDataChanged.bind(this)), this.addManagedListener(this.rowNode, re.EVENT_SELECTABLE_CHANGED, this.onSelectableChanged.bind(this)), this.gridOptionsService.get("isRowSelectable") || typeof this.getIsVisible() == "function") {
      const r = this.showOrHideSelect.bind(this);
      this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_CHANGED, r), this.addManagedListener(this.rowNode, re.EVENT_DATA_CHANGED, r), this.addManagedListener(this.rowNode, re.EVENT_CELL_CHANGED, r), this.showOrHideSelect();
    }
    this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
  }
  shouldHandleIndeterminateState(e, t) {
    return t && (this.eCheckbox.getPreviousValue() === void 0 || e === void 0) && this.gridOptionsService.isRowModelType("clientSide");
  }
  showOrHideSelect() {
    var e, t, i, r;
    let n = this.rowNode.selectable;
    const s = this.getIsVisible();
    if (n)
      if (typeof s == "function") {
        const l = (e = this.overrides) === null || e === void 0 ? void 0 : e.callbackParams, c = (t = this.column) === null || t === void 0 ? void 0 : t.createColumnFunctionCallbackParams(this.rowNode);
        n = c ? s(Object.assign(Object.assign({}, l), c)) : !1;
      } else
        n = s != null ? s : !1;
    if ((i = this.column) === null || i === void 0 ? void 0 : i.getColDef().showDisabledCheckboxes) {
      this.eCheckbox.setDisabled(!n), this.setVisible(!0), this.setDisplayed(!0);
      return;
    }
    if (!((r = this.overrides) === null || r === void 0) && r.removeHidden) {
      this.setDisplayed(n);
      return;
    }
    this.setVisible(n);
  }
  getIsVisible() {
    var e, t;
    return this.overrides ? this.overrides.isVisible : (t = (e = this.column) === null || e === void 0 ? void 0 : e.getColDef()) === null || t === void 0 ? void 0 : t.checkboxSelection;
  }
}
JT([
  L("eCheckbox")
], $v.prototype, "eCheckbox", void 0);
JT([
  B
], $v.prototype, "postConstruct", null);
var nc = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, vr, Dt;
(function(o) {
  o[o.ToolPanel = 0] = "ToolPanel", o[o.HeaderCell = 1] = "HeaderCell", o[o.RowDrag = 2] = "RowDrag", o[o.ChartPanel = 3] = "ChartPanel";
})(Dt || (Dt = {}));
var Fd;
(function(o) {
  o[o.Up = 0] = "Up", o[o.Down = 1] = "Down";
})(Fd || (Fd = {}));
var fo;
(function(o) {
  o[o.Left = 0] = "Left", o[o.Right = 1] = "Right";
})(fo || (fo = {}));
let Te = vr = class extends H {
  constructor() {
    super(...arguments), this.dragSourceAndParamsList = [], this.dropTargets = [];
  }
  init() {
    this.ePinnedIcon = tn("columnMovePin", this.gridOptionsService, null), this.eHideIcon = tn("columnMoveHide", this.gridOptionsService, null), this.eMoveIcon = tn("columnMoveMove", this.gridOptionsService, null), this.eLeftIcon = tn("columnMoveLeft", this.gridOptionsService, null), this.eRightIcon = tn("columnMoveRight", this.gridOptionsService, null), this.eGroupIcon = tn("columnMoveGroup", this.gridOptionsService, null), this.eAggregateIcon = tn("columnMoveValue", this.gridOptionsService, null), this.ePivotIcon = tn("columnMovePivot", this.gridOptionsService, null), this.eDropNotAllowedIcon = tn("dropNotAllowed", this.gridOptionsService, null);
  }
  addDragSource(e, t = !1) {
    const i = {
      eElement: e.eElement,
      dragStartPixels: e.dragStartPixels,
      onDragStart: this.onDragStart.bind(this, e),
      onDragStop: this.onDragStop.bind(this),
      onDragging: this.onDragging.bind(this),
      includeTouch: t
    };
    this.dragSourceAndParamsList.push({ params: i, dragSource: e }), this.dragService.addDragSource(i);
  }
  removeDragSource(e) {
    const t = this.dragSourceAndParamsList.find((i) => i.dragSource === e);
    t && (this.dragService.removeDragSource(t.params), Ni(this.dragSourceAndParamsList, t));
  }
  clearDragSourceParamsList() {
    this.dragSourceAndParamsList.forEach((e) => this.dragService.removeDragSource(e.params)), this.dragSourceAndParamsList.length = 0, this.dropTargets.length = 0;
  }
  nudge() {
    this.dragging && this.onDragging(this.eventLastTime, !0);
  }
  onDragStart(e, t) {
    this.dragging = !0, this.dragSource = e, this.eventLastTime = t, this.dragItem = this.dragSource.getDragItem(), this.lastDropTarget = this.dragSource.dragSourceDropTarget, this.dragSource.onDragStarted && this.dragSource.onDragStarted(), this.createGhost();
  }
  onDragStop(e) {
    if (this.eventLastTime = null, this.dragging = !1, this.dragSource.onDragStopped && this.dragSource.onDragStopped(), this.lastDropTarget && this.lastDropTarget.onDragStop) {
      const t = this.createDropTargetEvent(this.lastDropTarget, e, null, null, !1);
      this.lastDropTarget.onDragStop(t);
    }
    this.lastDropTarget = null, this.dragItem = null, this.removeGhost();
  }
  onDragging(e, t) {
    var i, r, n, s;
    const a = this.getHorizontalDirection(e), l = this.getVerticalDirection(e);
    this.eventLastTime = e, this.positionGhost(e);
    const c = this.dropTargets.filter((u) => this.isMouseOnDropTarget(e, u)), d = this.findCurrentDropTarget(e, c);
    if (d !== this.lastDropTarget)
      this.leaveLastTargetIfExists(e, a, l, t), this.lastDropTarget !== null && d === null && ((r = (i = this.dragSource).onGridExit) === null || r === void 0 || r.call(i, this.dragItem)), this.lastDropTarget === null && d !== null && ((s = (n = this.dragSource).onGridEnter) === null || s === void 0 || s.call(n, this.dragItem)), this.enterDragTargetIfExists(d, e, a, l, t), this.lastDropTarget = d;
    else if (d && d.onDragging) {
      const u = this.createDropTargetEvent(d, e, a, l, t);
      d.onDragging(u);
    }
  }
  getAllContainersFromDropTarget(e) {
    const t = e.getSecondaryContainers ? e.getSecondaryContainers() : null, i = [[e.getContainer()]];
    return t ? i.concat(t) : i;
  }
  allContainersIntersect(e, t) {
    for (const i of t) {
      const r = i.getBoundingClientRect();
      if (r.width === 0 || r.height === 0)
        return !1;
      const n = e.clientX >= r.left && e.clientX < r.right, s = e.clientY >= r.top && e.clientY < r.bottom;
      if (!n || !s)
        return !1;
    }
    return !0;
  }
  // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
  isMouseOnDropTarget(e, t) {
    const i = this.getAllContainersFromDropTarget(t);
    let r = !1;
    for (const n of i)
      if (this.allContainersIntersect(e, n)) {
        r = !0;
        break;
      }
    return t.targetContainsSource && !t.getContainer().contains(this.dragSource.eElement) ? !1 : r && t.isInterestedIn(this.dragSource.type, this.dragSource.eElement);
  }
  findCurrentDropTarget(e, t) {
    const i = t.length;
    if (i === 0)
      return null;
    if (i === 1)
      return t[0];
    const n = this.gridOptionsService.getRootNode().elementsFromPoint(e.clientX, e.clientY);
    for (const s of n)
      for (const a of t)
        if (XR(this.getAllContainersFromDropTarget(a)).indexOf(s) !== -1)
          return a;
    return null;
  }
  enterDragTargetIfExists(e, t, i, r, n) {
    if (e) {
      if (e.onDragEnter) {
        const s = this.createDropTargetEvent(e, t, i, r, n);
        e.onDragEnter(s);
      }
      this.setGhostIcon(e.getIconName ? e.getIconName() : null);
    }
  }
  leaveLastTargetIfExists(e, t, i, r) {
    if (this.lastDropTarget) {
      if (this.lastDropTarget.onDragLeave) {
        const n = this.createDropTargetEvent(this.lastDropTarget, e, t, i, r);
        this.lastDropTarget.onDragLeave(n);
      }
      this.setGhostIcon(null);
    }
  }
  addDropTarget(e) {
    this.dropTargets.push(e);
  }
  removeDropTarget(e) {
    this.dropTargets = this.dropTargets.filter((t) => t.getContainer() !== e.getContainer());
  }
  hasExternalDropZones() {
    return this.dropTargets.some((e) => e.external);
  }
  findExternalZone(e) {
    return this.dropTargets.filter((i) => i.external).find((i) => i.getContainer() === e.getContainer()) || null;
  }
  getHorizontalDirection(e) {
    const t = this.eventLastTime && this.eventLastTime.clientX, i = e.clientX;
    return t === i ? null : t > i ? fo.Left : fo.Right;
  }
  getVerticalDirection(e) {
    const t = this.eventLastTime && this.eventLastTime.clientY, i = e.clientY;
    return t === i ? null : t > i ? Fd.Up : Fd.Down;
  }
  createDropTargetEvent(e, t, i, r, n) {
    const s = e.getContainer(), a = s.getBoundingClientRect(), { gridApi: l, columnApi: c, dragItem: d, dragSource: u } = this, h = t.clientX - a.left, p = t.clientY - a.top;
    return { event: t, x: h, y: p, vDirection: r, hDirection: i, dragSource: u, fromNudge: n, dragItem: d, api: l, columnApi: c, dropZoneTarget: s };
  }
  positionGhost(e) {
    const t = this.eGhost;
    if (!t)
      return;
    const r = t.getBoundingClientRect().height, n = wT() - 2, s = ET() - 2, a = NS(t.offsetParent), { clientY: l, clientX: c } = e;
    let d = l - a.top - r / 2, u = c - a.left - 10;
    const h = this.gridOptionsService.getDocument(), p = h.defaultView || window, f = p.pageYOffset || h.documentElement.scrollTop, g = p.pageXOffset || h.documentElement.scrollLeft;
    n > 0 && u + t.clientWidth > n + g && (u = n + g - t.clientWidth), u < 0 && (u = 0), s > 0 && d + t.clientHeight > s + f && (d = s + f - t.clientHeight), d < 0 && (d = 0), t.style.left = `${u}px`, t.style.top = `${d}px`;
  }
  removeGhost() {
    this.eGhost && this.eGhostParent && this.eGhostParent.removeChild(this.eGhost), this.eGhost = null;
  }
  createGhost() {
    this.eGhost = Si(vr.GHOST_TEMPLATE), this.mouseEventService.stampTopLevelGridCompWithGridInstance(this.eGhost);
    const { theme: e } = this.environment.getTheme();
    e && this.eGhost.classList.add(e), this.eGhostIcon = this.eGhost.querySelector(".ag-dnd-ghost-icon"), this.setGhostIcon(null);
    const t = this.eGhost.querySelector(".ag-dnd-ghost-label");
    let i = this.dragSource.dragItemName;
    Mv(i) && (i = i()), t.innerHTML = xo(i) || "", this.eGhost.style.height = "25px", this.eGhost.style.top = "20px", this.eGhost.style.left = "20px";
    const r = this.gridOptionsService.getDocument();
    let n = null;
    try {
      n = r.fullscreenElement;
    } catch (s) {
    } finally {
      if (!n) {
        const s = this.gridOptionsService.getRootNode(), a = s.querySelector("body");
        a ? n = a : s instanceof ShadowRoot ? n = s : n = s == null ? void 0 : s.documentElement;
      }
    }
    this.eGhostParent = n, this.eGhostParent ? this.eGhostParent.appendChild(this.eGhost) : console.warn("AG Grid: could not find document body, it is needed for dragging columns");
  }
  setGhostIcon(e, t = !1) {
    Or(this.eGhostIcon);
    let i = null;
    switch (e || (e = this.dragSource.defaultIconName || vr.ICON_NOT_ALLOWED), e) {
      case vr.ICON_PINNED:
        i = this.ePinnedIcon;
        break;
      case vr.ICON_MOVE:
        i = this.eMoveIcon;
        break;
      case vr.ICON_LEFT:
        i = this.eLeftIcon;
        break;
      case vr.ICON_RIGHT:
        i = this.eRightIcon;
        break;
      case vr.ICON_GROUP:
        i = this.eGroupIcon;
        break;
      case vr.ICON_AGGREGATE:
        i = this.eAggregateIcon;
        break;
      case vr.ICON_PIVOT:
        i = this.ePivotIcon;
        break;
      case vr.ICON_NOT_ALLOWED:
        i = this.eDropNotAllowedIcon;
        break;
      case vr.ICON_HIDE:
        i = this.eHideIcon;
        break;
    }
    this.eGhostIcon.classList.toggle("ag-shake-left-to-right", t), !(i === this.eHideIcon && this.gridOptionsService.is("suppressDragLeaveHidesColumns")) && i && this.eGhostIcon.appendChild(i);
  }
};
Te.ICON_PINNED = "pinned";
Te.ICON_MOVE = "move";
Te.ICON_LEFT = "left";
Te.ICON_RIGHT = "right";
Te.ICON_GROUP = "group";
Te.ICON_AGGREGATE = "aggregate";
Te.ICON_PIVOT = "pivot";
Te.ICON_NOT_ALLOWED = "notAllowed";
Te.ICON_HIDE = "hide";
Te.GHOST_TEMPLATE = `<div class="ag-dnd-ghost ag-unselectable">
            <span class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>
            <div class="ag-dnd-ghost-label"></div>
        </div>`;
nc([
  S("dragService")
], Te.prototype, "dragService", void 0);
nc([
  S("mouseEventService")
], Te.prototype, "mouseEventService", void 0);
nc([
  S("columnApi")
], Te.prototype, "columnApi", void 0);
nc([
  S("gridApi")
], Te.prototype, "gridApi", void 0);
nc([
  B
], Te.prototype, "init", null);
nc([
  dt
], Te.prototype, "clearDragSourceParamsList", null);
Te = vr = nc([
  q("dragAndDropService")
], Te);
var Fp = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Il extends X {
  constructor(e, t, i, r, n, s) {
    super(), this.cellValueFn = e, this.rowNode = t, this.column = i, this.customGui = r, this.dragStartPixels = n, this.suppressVisibilityChange = s, this.dragSource = null;
  }
  isCustomGui() {
    return this.customGui != null;
  }
  postConstruct() {
    if (this.customGui ? this.setDragElement(this.customGui, this.dragStartPixels) : (this.setTemplate(
      /* html */
      '<div class="ag-drag-handle ag-row-drag" aria-hidden="true"></div>'
    ), this.getGui().appendChild(Vt("rowDrag", this.gridOptionsService, null)), this.addDragSource()), this.checkCompatibility(), !this.suppressVisibilityChange) {
      const e = this.gridOptionsService.is("rowDragManaged") ? new ix(this, this.beans, this.rowNode, this.column) : new tx(this, this.beans, this.rowNode, this.column);
      this.createManagedBean(e, this.beans.context);
    }
  }
  setDragElement(e, t) {
    this.setTemplateFromElement(e), this.addDragSource(t);
  }
  getSelectedNodes() {
    if (!this.gridOptionsService.is("rowDragMultiRow"))
      return [this.rowNode];
    const t = this.beans.selectionService.getSelectedNodes();
    return t.indexOf(this.rowNode) !== -1 ? t : [this.rowNode];
  }
  // returns true if all compatibility items work out
  checkCompatibility() {
    const e = this.gridOptionsService.is("rowDragManaged");
    this.gridOptionsService.isTreeData() && e && tt(() => console.warn("AG Grid: If using row drag with tree data, you cannot have rowDragManaged=true"), "RowDragComp.managedAndTreeData");
  }
  getDragItem() {
    return {
      rowNode: this.rowNode,
      rowNodes: this.getSelectedNodes(),
      columns: this.column ? [this.column] : void 0,
      defaultTextValue: this.cellValueFn()
    };
  }
  getRowDragText(e) {
    if (e) {
      const t = e.getColDef();
      if (t.rowDragText)
        return t.rowDragText;
    }
    return this.gridOptionsService.get("rowDragText");
  }
  addDragSource(e = 4) {
    this.dragSource && this.removeDragSource();
    const t = this.getRowDragText(this.column), i = this.localeService.getLocaleTextFunc();
    this.dragSource = {
      type: Dt.RowDrag,
      eElement: this.getGui(),
      dragItemName: () => {
        var r;
        const n = this.getDragItem(), s = ((r = n.rowNodes) === null || r === void 0 ? void 0 : r.length) || 1;
        return t ? t(n, s) : s === 1 ? this.cellValueFn() : `${s} ${i("rowDragRows", "rows")}`;
      },
      getDragItem: () => this.getDragItem(),
      dragStartPixels: e,
      dragSourceDomDataKey: this.gridOptionsService.getDomDataKey()
    }, this.beans.dragAndDropService.addDragSource(this.dragSource, !0);
  }
  removeDragSource() {
    this.dragSource && this.beans.dragAndDropService.removeDragSource(this.dragSource), this.dragSource = null;
  }
}
Fp([
  S("beans")
], Il.prototype, "beans", void 0);
Fp([
  B
], Il.prototype, "postConstruct", null);
Fp([
  dt
], Il.prototype, "removeDragSource", null);
class ex extends H {
  constructor(e, t, i) {
    super(), this.parent = e, this.rowNode = t, this.column = i;
  }
  setDisplayedOrVisible(e) {
    const t = { skipAriaHidden: !0 };
    if (e)
      this.parent.setDisplayed(!1, t);
    else {
      let i = !0, r = !1;
      this.column && (i = this.column.isRowDrag(this.rowNode) || this.parent.isCustomGui(), r = Mv(this.column.getColDef().rowDrag)), r ? (this.parent.setDisplayed(!0, t), this.parent.setVisible(i, t)) : (this.parent.setDisplayed(i, t), this.parent.setVisible(!0, t));
    }
  }
}
class tx extends ex {
  constructor(e, t, i, r) {
    super(e, i, r), this.beans = t;
  }
  postConstruct() {
    this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this)), this.addManagedListener(this.rowNode, re.EVENT_DATA_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, re.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, re.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, w.EVENT_NEW_COLUMNS_LOADED, this.workOutVisibility.bind(this)), this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const e = this.gridOptionsService.is("suppressRowDrag");
    this.setDisplayedOrVisible(e);
  }
}
Fp([
  B
], tx.prototype, "postConstruct", null);
class ix extends ex {
  constructor(e, t, i, r) {
    super(e, i, r), this.beans = t;
  }
  postConstruct() {
    this.addManagedListener(this.beans.eventService, w.EVENT_SORT_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, w.EVENT_FILTER_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.beans.eventService, w.EVENT_NEW_COLUMNS_LOADED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, re.EVENT_DATA_CHANGED, this.workOutVisibility.bind(this)), this.addManagedListener(this.rowNode, re.EVENT_CELL_CHANGED, this.workOutVisibility.bind(this)), this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this)), this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const t = this.beans.ctrlsService.getGridBodyCtrl().getRowDragFeature(), i = t && t.shouldPreventRowMove(), r = this.gridOptionsService.is("suppressRowDrag"), n = this.beans.dragAndDropService.hasExternalDropZones(), s = i && !n || r;
    this.setDisplayedOrVisible(s);
  }
}
Fp([
  B
], ix.prototype, "postConstruct", null);
var Lp = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class cu extends H {
  init(e, t, i, r, n, s, a) {
    this.params = a, this.eGui = t, this.eCheckbox = i, this.eExpanded = r, this.eContracted = n, this.comp = e, this.compClass = s;
    const l = this.isTopLevelFooter(), c = this.isEmbeddedRowMismatch(), d = a.value == null && !a.node.master;
    let u = !1;
    if (this.gridOptionsService.is("groupIncludeFooter") && this.gridOptionsService.is("groupHideOpenParents")) {
      const h = a.node;
      if (h.footer) {
        const p = a.colDef && a.colDef.showRowGroup, f = h.rowGroupColumn && h.rowGroupColumn.getColId();
        u = p !== f;
      }
    }
    this.cellIsBlank = l ? !1 : c || d && !a.node.master || u, !this.cellIsBlank && (this.setupShowingValueForOpenedParent(), this.findDisplayedGroupNode(), this.addFullWidthRowDraggerIfNeeded(), this.addExpandAndContract(), this.addCheckboxIfNeeded(), this.addValueElement(), this.setupIndent(), this.refreshAriaExpanded());
  }
  destroy() {
    super.destroy(), this.expandListener = null;
  }
  refreshAriaExpanded() {
    const { node: e, eParentOfValue: t } = this.params;
    if (this.expandListener && (this.expandListener = this.expandListener()), !this.isExpandable()) {
      pT(t);
      return;
    }
    const i = () => {
      Ln(t, !!e.expanded);
    };
    this.expandListener = this.addManagedListener(e, re.EVENT_EXPANDED_CHANGED, i) || null, i();
  }
  isTopLevelFooter() {
    if (!this.gridOptionsService.is("groupIncludeTotalFooter") || this.params.value != null || this.params.node.level != -1)
      return !1;
    const e = this.params.colDef;
    if (e == null || e.showRowGroup === !0)
      return !0;
    const i = this.columnModel.getRowGroupColumns();
    return !i || i.length === 0 ? !0 : i[0].getId() === e.showRowGroup;
  }
  // if we are doing embedded full width rows, we only show the renderer when
  // in the body, or if pinning in the pinned section, or if pinning and RTL,
  // in the right section. otherwise we would have the cell repeated in each section.
  isEmbeddedRowMismatch() {
    if (!this.params.fullWidth || !this.gridOptionsService.is("embedFullWidthRows"))
      return !1;
    const e = this.params.pinned === "left", t = this.params.pinned === "right", i = !e && !t;
    return this.gridOptionsService.is("enableRtl") ? this.columnModel.isPinningLeft() ? !t : !i : this.columnModel.isPinningLeft() ? !e : !i;
  }
  findDisplayedGroupNode() {
    const e = this.params.column, t = this.params.node;
    if (this.showingValueForOpenedParent) {
      let i = t.parent;
      for (; i != null; ) {
        if (i.rowGroupColumn && e.isRowGroupDisplayed(i.rowGroupColumn.getId())) {
          this.displayedGroupNode = i;
          break;
        }
        i = i.parent;
      }
    }
    Se(this.displayedGroupNode) && (this.displayedGroupNode = t);
  }
  setupShowingValueForOpenedParent() {
    const e = this.params.node, t = this.params.column;
    if (!this.gridOptionsService.is("groupHideOpenParents")) {
      this.showingValueForOpenedParent = !1;
      return;
    }
    if (!e.groupData) {
      this.showingValueForOpenedParent = !1;
      return;
    }
    if (e.rowGroupColumn != null) {
      const n = e.rowGroupColumn.getId();
      if (t.isRowGroupDisplayed(n)) {
        this.showingValueForOpenedParent = !1;
        return;
      }
    }
    const r = e.groupData[t.getId()] != null;
    this.showingValueForOpenedParent = r;
  }
  addValueElement() {
    this.displayedGroupNode.footer ? this.addFooterValue() : (this.addGroupValue(), this.addChildCount());
  }
  addGroupValue() {
    const e = this.adjustParamsWithDetailsFromRelatedColumn(), t = this.getInnerCompDetails(e), { valueFormatted: i, value: r } = e;
    let n = i;
    n == null && (r === "" && this.params.node.group ? n = this.localeService.getLocaleTextFunc()("blanks", "(Blanks)") : n = r != null ? r : null), this.comp.setInnerRenderer(t, n);
  }
  adjustParamsWithDetailsFromRelatedColumn() {
    const e = this.displayedGroupNode.rowGroupColumn, t = this.params.column;
    if (!e)
      return this.params;
    if (t != null && !t.isRowGroupDisplayed(e.getId()))
      return this.params;
    const r = this.params, { value: n, node: s } = this.params, a = this.valueFormatterService.formatValue(e, s, n);
    return Object.assign(Object.assign({}, r), { valueFormatted: a });
  }
  addFooterValue() {
    const e = this.params.footerValueGetter;
    let t = "";
    if (e) {
      const r = mS(this.params);
      r.value = this.params.value, typeof e == "function" ? t = e(r) : typeof e == "string" ? t = this.expressionService.evaluate(e, r) : console.warn("AG Grid: footerValueGetter should be either a function or a string (expression)");
    } else
      t = "Total " + (this.params.value != null ? this.params.value : "");
    const i = this.getInnerCompDetails(this.params);
    this.comp.setInnerRenderer(i, t);
  }
  getInnerCompDetails(e) {
    if (e.fullWidth)
      return this.userComponentFactory.getFullWidthGroupRowInnerCellRenderer(this.gridOptionsService.get("groupRowRendererParams"), e);
    const t = this.userComponentFactory.getInnerRendererDetails(e, e), i = (a) => a && a.componentClass == this.compClass;
    if (t && !i(t))
      return t;
    const r = this.displayedGroupNode.rowGroupColumn, n = r ? r.getColDef() : void 0;
    if (!n)
      return;
    const s = this.userComponentFactory.getCellRendererDetails(n, e);
    if (s && !i(s))
      return s;
    if (i(s) && n.cellRendererParams && n.cellRendererParams.innerRenderer)
      return this.userComponentFactory.getInnerRendererDetails(n.cellRendererParams, e);
  }
  addChildCount() {
    this.params.suppressCount || (this.addManagedListener(this.displayedGroupNode, re.EVENT_ALL_CHILDREN_COUNT_CHANGED, this.updateChildCount.bind(this)), this.updateChildCount());
  }
  updateChildCount() {
    const e = this.displayedGroupNode.allChildrenCount, r = this.isShowRowGroupForThisRow() && e != null && e >= 0 ? `(${e})` : "";
    this.comp.setChildCount(r);
  }
  isShowRowGroupForThisRow() {
    if (this.gridOptionsService.isTreeData())
      return !0;
    const e = this.displayedGroupNode.rowGroupColumn;
    if (!e)
      return !1;
    const t = this.params.column;
    return t == null || t.isRowGroupDisplayed(e.getId());
  }
  addExpandAndContract() {
    var e;
    const t = this.params, i = Vt("groupExpanded", this.gridOptionsService, null), r = Vt("groupContracted", this.gridOptionsService, null);
    i && this.eExpanded.appendChild(i), r && this.eContracted.appendChild(r);
    const n = t.eGridCell;
    !(((e = this.params.column) === null || e === void 0 ? void 0 : e.isCellEditable(t.node)) && this.gridOptionsService.is("enableGroupEdit")) && this.isExpandable() && !t.suppressDoubleClickExpand && this.addManagedListener(n, "dblclick", this.onCellDblClicked.bind(this)), this.addManagedListener(this.eExpanded, "click", this.onExpandClicked.bind(this)), this.addManagedListener(this.eContracted, "click", this.onExpandClicked.bind(this)), this.addManagedListener(n, "keydown", this.onKeyDown.bind(this)), this.addManagedListener(t.node, re.EVENT_EXPANDED_CHANGED, this.showExpandAndContractIcons.bind(this)), this.showExpandAndContractIcons();
    const a = this.onRowNodeIsExpandableChanged.bind(this);
    this.addManagedListener(this.displayedGroupNode, re.EVENT_ALL_CHILDREN_COUNT_CHANGED, a), this.addManagedListener(this.displayedGroupNode, re.EVENT_MASTER_CHANGED, a), this.addManagedListener(this.displayedGroupNode, re.EVENT_GROUP_CHANGED, a), this.addManagedListener(this.displayedGroupNode, re.EVENT_HAS_CHILDREN_CHANGED, a);
  }
  onExpandClicked(e) {
    Eo(e) || (Ss(e), this.onExpandOrContract(e));
  }
  onExpandOrContract(e) {
    const t = this.displayedGroupNode, i = !t.expanded;
    !i && t.sticky && this.scrollToStickyNode(t), t.setExpanded(i, e);
  }
  scrollToStickyNode(e) {
    this.ctrlsService.getGridBodyCtrl().getScrollFeature().setVerticalScrollPosition(e.rowTop - e.stickyRowTop);
  }
  isExpandable() {
    if (this.showingValueForOpenedParent)
      return !0;
    const e = this.displayedGroupNode, t = this.columnModel.isPivotMode() && e.leafGroup;
    if (!(e.isExpandable() && !e.footer && !t))
      return !1;
    const r = this.params.column;
    return r != null && typeof r.getColDef().showRowGroup == "string" ? this.isShowRowGroupForThisRow() : !0;
  }
  showExpandAndContractIcons() {
    const { params: e, displayedGroupNode: t, columnModel: i } = this, { node: r } = e, n = this.isExpandable();
    if (n) {
      const d = this.showingValueForOpenedParent ? !0 : r.expanded;
      this.comp.setExpandedDisplayed(d), this.comp.setContractedDisplayed(!d);
    } else
      this.comp.setExpandedDisplayed(!1), this.comp.setContractedDisplayed(!1);
    const s = i.isPivotMode(), a = s && t.leafGroup, l = n && !a, c = r.footer && r.level === -1;
    this.comp.addOrRemoveCssClass("ag-cell-expandable", l), this.comp.addOrRemoveCssClass("ag-row-group", l), s ? this.comp.addOrRemoveCssClass("ag-pivot-leaf-group", a) : c || this.comp.addOrRemoveCssClass("ag-row-group-leaf-indent", !l);
  }
  onRowNodeIsExpandableChanged() {
    this.showExpandAndContractIcons(), this.setIndent(), this.refreshAriaExpanded();
  }
  setupIndent() {
    const e = this.params.node;
    this.params.suppressPadding || (this.addManagedListener(e, re.EVENT_UI_LEVEL_CHANGED, this.setIndent.bind(this)), this.setIndent());
  }
  setIndent() {
    if (this.gridOptionsService.is("groupHideOpenParents"))
      return;
    const e = this.params, t = e.node, i = !!e.colDef, r = this.gridOptionsService.isTreeData(), s = !i || r || e.colDef.showRowGroup === !0 ? t.uiLevel : 0;
    this.indentClass && this.comp.addOrRemoveCssClass(this.indentClass, !1), this.indentClass = "ag-row-group-indent-" + s, this.comp.addOrRemoveCssClass(this.indentClass, !0);
  }
  addFullWidthRowDraggerIfNeeded() {
    if (!this.params.fullWidth || !this.params.rowDrag)
      return;
    const e = new Il(() => this.params.value, this.params.node);
    this.createManagedBean(e, this.context), this.eGui.insertAdjacentElement("afterbegin", e.getGui());
  }
  isUserWantsSelected() {
    const e = this.params.checkbox;
    return typeof e == "function" || e === !0;
  }
  addCheckboxIfNeeded() {
    const e = this.displayedGroupNode, t = this.isUserWantsSelected() && // footers cannot be selected
    !e.footer && // pinned rows cannot be selected
    !e.rowPinned && // details cannot be selected
    !e.detail;
    if (t) {
      const i = new $v();
      this.getContext().createBean(i), i.init({
        rowNode: e,
        column: this.params.column,
        overrides: {
          isVisible: this.params.checkbox,
          callbackParams: this.params,
          removeHidden: !0
        }
      }), this.eCheckbox.appendChild(i.getGui()), this.addDestroyFunc(() => this.getContext().destroyBean(i));
    }
    this.comp.setCheckboxVisible(t);
  }
  onKeyDown(e) {
    !(e.key === V.ENTER) || this.params.suppressEnterExpand || this.params.column && this.params.column.isCellEditable(this.params.node) || this.onExpandOrContract(e);
  }
  onCellDblClicked(e) {
    if (Eo(e))
      return;
    Og(this.eExpanded, e) || Og(this.eContracted, e) || this.onExpandOrContract(e);
  }
}
Lp([
  S("expressionService")
], cu.prototype, "expressionService", void 0);
Lp([
  S("valueFormatterService")
], cu.prototype, "valueFormatterService", void 0);
Lp([
  S("columnModel")
], cu.prototype, "columnModel", void 0);
Lp([
  S("userComponentFactory")
], cu.prototype, "userComponentFactory", void 0);
Lp([
  S("ctrlsService")
], cu.prototype, "ctrlsService", void 0);
var Np = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Do extends X {
  constructor() {
    super(Do.TEMPLATE);
  }
  init(e) {
    const t = {
      setInnerRenderer: (s, a) => this.setRenderDetails(s, a),
      setChildCount: (s) => this.eChildCount.innerHTML = s,
      addOrRemoveCssClass: (s, a) => this.addOrRemoveCssClass(s, a),
      setContractedDisplayed: (s) => Ke(this.eContracted, s),
      setExpandedDisplayed: (s) => Ke(this.eExpanded, s),
      setCheckboxVisible: (s) => this.eCheckbox.classList.toggle("ag-invisible", !s)
    }, i = this.createManagedBean(new cu()), r = !e.colDef, n = this.getGui();
    i.init(t, n, this.eCheckbox, this.eExpanded, this.eContracted, this.constructor, e), r && ci(n, "gridcell");
  }
  setRenderDetails(e, t) {
    if (e) {
      const i = e.newAgStackInstance();
      if (!i)
        return;
      i.then((r) => {
        if (!r)
          return;
        const n = () => this.context.destroyBean(r);
        this.isAlive() ? (this.eValue.appendChild(r.getGui()), this.addDestroyFunc(n)) : n();
      });
    } else
      this.eValue.innerText = t;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to have public here instead of private or protected
  destroy() {
    this.getContext().destroyBean(this.innerCellRenderer), super.destroy();
  }
  refresh() {
    return !1;
  }
}
Do.TEMPLATE = `<span class="ag-cell-wrapper">
            <span class="ag-group-expanded" ref="eExpanded"></span>
            <span class="ag-group-contracted" ref="eContracted"></span>
            <span class="ag-group-checkbox ag-invisible" ref="eCheckbox"></span>
            <span class="ag-group-value" ref="eValue"></span>
            <span class="ag-group-child-count" ref="eChildCount"></span>
        </span>`;
Np([
  L("eExpanded")
], Do.prototype, "eExpanded", void 0);
Np([
  L("eContracted")
], Do.prototype, "eContracted", void 0);
Np([
  L("eCheckbox")
], Do.prototype, "eCheckbox", void 0);
Np([
  L("eValue")
], Do.prototype, "eValue", void 0);
Np([
  L("eChildCount")
], Do.prototype, "eChildCount", void 0);
var rx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class du extends X {
  constructor() {
    super(du.TEMPLATE);
  }
  init(e) {
    e.node.failedLoad ? this.setupFailed() : this.setupLoading();
  }
  setupFailed() {
    const e = this.localeService.getLocaleTextFunc();
    this.eLoadingText.innerText = e("loadingError", "ERR");
  }
  setupLoading() {
    const e = Vt("groupLoading", this.gridOptionsService, null);
    e && this.eLoadingIcon.appendChild(e);
    const t = this.localeService.getLocaleTextFunc();
    this.eLoadingText.innerText = t("loadingOoo", "Loading");
  }
  refresh(e) {
    return !1;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
}
du.TEMPLATE = `<div class="ag-loading">
            <span class="ag-loading-icon" ref="eLoadingIcon"></span>
            <span class="ag-loading-text" ref="eLoadingText"></span>
        </div>`;
rx([
  L("eLoadingIcon")
], du.prototype, "eLoadingIcon", void 0);
rx([
  L("eLoadingText")
], du.prototype, "eLoadingText", void 0);
class zv extends X {
  constructor() {
    super();
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    var t;
    const i = (t = this.gridOptionsService.get("overlayLoadingTemplate")) !== null && t !== void 0 ? t : zv.DEFAULT_LOADING_OVERLAY_TEMPLATE, r = this.localeService.getLocaleTextFunc(), n = i.replace("[LOADING...]", r("loadingOoo", "Loading..."));
    this.setTemplate(n);
  }
}
zv.DEFAULT_LOADING_OVERLAY_TEMPLATE = '<span class="ag-overlay-loading-center">[LOADING...]</span>';
class Kv extends X {
  constructor() {
    super();
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    var t;
    const i = (t = this.gridOptionsService.get("overlayNoRowsTemplate")) !== null && t !== void 0 ? t : Kv.DEFAULT_NO_ROWS_TEMPLATE, r = this.localeService.getLocaleTextFunc(), n = i.replace("[NO_ROWS_TO_SHOW]", r("noRowsToShow", "No Rows To Show"));
    this.setTemplate(n);
  }
}
Kv.DEFAULT_NO_ROWS_TEMPLATE = '<span class="ag-overlay-no-rows-center">[NO_ROWS_TO_SHOW]</span>';
class cL extends rc {
  constructor() {
    super(
      /* html */
      '<div class="ag-tooltip"></div>'
    );
  }
  // will need to type params
  init(e) {
    const { value: t } = e;
    this.getGui().innerHTML = xo(t);
  }
}
class dL {
  getTemplate() {
    return (
      /* html */
      '<ag-input-number-field class="ag-cell-editor" ref="eInput"></ag-input-number-field>'
    );
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.max != null && e.setMax(t.max), t.min != null && e.setMin(t.min), t.precision != null && e.setPrecision(t.precision), t.step != null && e.setStep(t.step), t.showStepperButtons && e.getInputElement().classList.add("ag-number-field-input-stepper");
  }
  getValue() {
    const e = this.eInput.getValue();
    if (!z(e) && !z(this.params.value))
      return this.params.value;
    let t = this.params.parseValue(e);
    if (t == null)
      return t;
    if (typeof t == "string") {
      if (t === "")
        return null;
      t = Number(t);
    }
    return isNaN(t) ? null : t;
  }
  getStartValue() {
    return this.params.value;
  }
}
class uL extends Mp {
  constructor() {
    super(new dL());
  }
}
class hL {
  getTemplate() {
    return (
      /* html */
      '<ag-input-date-field class="ag-cell-editor" ref="eInput"></ag-input-date-field>'
    );
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.min != null && e.setMin(t.min), t.max != null && e.setMax(t.max), t.step != null && e.setStep(t.step);
  }
  getValue() {
    const e = this.eInput.getDate();
    return !z(e) && !z(this.params.value) ? this.params.value : e != null ? e : null;
  }
  getStartValue() {
    const { value: e } = this.params;
    if (e instanceof Date)
      return cn(e, !1);
  }
}
class pL extends Mp {
  constructor() {
    super(new hL());
  }
}
var fL = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class gL {
  constructor(e) {
    this.getDataTypeService = e;
  }
  getTemplate() {
    return (
      /* html */
      '<ag-input-date-field class="ag-cell-editor" ref="eInput"></ag-input-date-field>'
    );
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.min != null && e.setMin(t.min), t.max != null && e.setMax(t.max), t.step != null && e.setStep(t.step);
  }
  getValue() {
    const e = this.formatDate(this.eInput.getDate());
    return !z(e) && !z(this.params.value) ? this.params.value : this.params.parseValue(e != null ? e : "");
  }
  getStartValue() {
    var e, t;
    return cn((t = this.parseDate((e = this.params.value) !== null && e !== void 0 ? e : void 0)) !== null && t !== void 0 ? t : null, !1);
  }
  parseDate(e) {
    return this.getDataTypeService().getDateParserFunction()(e);
  }
  formatDate(e) {
    return this.getDataTypeService().getDateFormatterFunction()(e);
  }
}
class nx extends Mp {
  constructor() {
    super(new gL(() => this.dataTypeService));
  }
}
fL([
  S("dataTypeService")
], nx.prototype, "dataTypeService", void 0);
var vL = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Gp extends X {
  constructor() {
    super(Gp.TEMPLATE);
  }
  init(e) {
    this.params = e, this.updateCheckbox(e), this.eCheckbox.getInputElement().setAttribute("tabindex", "-1"), this.addManagedListener(this.eCheckbox.getInputElement(), "click", (i) => {
      if (Ss(i), this.eCheckbox.isDisabled())
        return;
      const r = this.eCheckbox.getValue();
      this.onCheckboxChanged(r);
    }), this.addManagedListener(this.eCheckbox.getInputElement(), "dblclick", (i) => {
      Ss(i);
    });
    const t = this.gridOptionsService.getDocument();
    this.addManagedListener(this.params.eGridCell, "keydown", (i) => {
      if (i.key === V.SPACE && !this.eCheckbox.isDisabled()) {
        this.params.eGridCell === t.activeElement && this.eCheckbox.toggle();
        const r = this.eCheckbox.getValue();
        this.onCheckboxChanged(r), i.preventDefault();
      }
    });
  }
  refresh(e) {
    return this.params = e, this.updateCheckbox(e), !0;
  }
  updateCheckbox(e) {
    var t, i, r;
    let n, s = !0;
    if (e.node.group && e.column) {
      const u = e.column.getColId();
      u.startsWith(bs) ? n = e.value == null || e.value === "" ? void 0 : e.value === "true" : e.node.aggData && e.node.aggData[u] !== void 0 ? n = (t = e.value) !== null && t !== void 0 ? t : void 0 : s = !1;
    } else
      n = (i = e.value) !== null && i !== void 0 ? i : void 0;
    if (!s) {
      this.eCheckbox.setDisplayed(!1);
      return;
    }
    this.eCheckbox.setValue(n);
    const a = e.disabled != null ? e.disabled : !(!((r = e.column) === null || r === void 0) && r.isCellEditable(e.node));
    this.eCheckbox.setDisabled(a);
    const l = this.localeService.getLocaleTextFunc(), c = Gv(l, n), d = a ? c : `${l("ariaToggleCellValue", "Press SPACE to toggle cell value")} (${c})`;
    this.eCheckbox.setInputAriaLabel(d);
  }
  onCheckboxChanged(e) {
    const { column: t, node: i, rowIndex: r, value: n } = this.params, s = {
      type: w.EVENT_CELL_EDITING_STARTED,
      column: t,
      colDef: t == null ? void 0 : t.getColDef(),
      data: i.data,
      node: i,
      rowIndex: r,
      rowPinned: i.rowPinned,
      value: n
    };
    this.eventService.dispatchEvent(s);
    const a = this.params.node.setDataValue(this.params.column, e, "edit"), l = {
      type: w.EVENT_CELL_EDITING_STOPPED,
      column: t,
      colDef: t == null ? void 0 : t.getColDef(),
      data: i.data,
      node: i,
      rowIndex: r,
      rowPinned: i.rowPinned,
      value: n,
      oldValue: n,
      newValue: e,
      valueChanged: a
    };
    this.eventService.dispatchEvent(l);
  }
}
Gp.TEMPLATE = `
        <div class="ag-cell-wrapper ag-checkbox-cell" role="presentation">
            <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>
        </div>`;
vL([
  L("eCheckbox")
], Gp.prototype, "eCheckbox", void 0);
var mL = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class ox extends rc {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-cell-wrapper ag-cell-edit-wrapper ag-checkbox-edit">
                <ag-checkbox role="presentation" ref="eCheckbox"></ag-checkbox>
            </div>`
    );
  }
  init(e) {
    var t;
    this.params = e;
    const i = (t = e.value) !== null && t !== void 0 ? t : void 0;
    this.eCheckbox.setValue(i), this.eCheckbox.getInputElement().setAttribute("tabindex", "-1"), this.setAriaLabel(i), this.addManagedListener(this.eCheckbox, rr.EVENT_CHANGED, (r) => this.setAriaLabel(r.selected));
  }
  getValue() {
    return this.eCheckbox.getValue();
  }
  focusIn() {
    this.eCheckbox.getFocusableElement().focus();
  }
  afterGuiAttached() {
    this.params.cellStartedEdit && this.focusIn();
  }
  isPopup() {
    return !1;
  }
  setAriaLabel(e) {
    const t = this.localeService.getLocaleTextFunc(), i = Gv(t, e), r = t("ariaToggleCellValue", "Press SPACE to toggle cell value");
    this.eCheckbox.setInputAriaLabel(`${r} (${i})`);
  }
}
mL([
  L("eCheckbox")
], ox.prototype, "eCheckbox", void 0);
var nb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Hh = class extends H {
  constructor() {
    super(...arguments), this.agGridDefaults = {
      //date
      agDateInput: KT,
      //header
      agColumnHeader: Oi,
      agColumnGroupHeader: ic,
      agSortIndicator: Gr,
      //floating filters
      agTextColumnFloatingFilter: tL,
      agNumberColumnFloatingFilter: eL,
      agDateColumnFloatingFilter: Uv,
      agReadOnlyFloatingFilter: KS,
      // renderers
      agAnimateShowChangeCellRenderer: _p,
      agAnimateSlideCellRenderer: Ip,
      agGroupCellRenderer: Do,
      agGroupRowRenderer: Do,
      agLoadingCellRenderer: du,
      agCheckboxCellRenderer: Gp,
      //editors
      agCellEditor: qw,
      agTextCellEditor: qw,
      agNumberCellEditor: uL,
      agDateCellEditor: pL,
      agDateStringCellEditor: nx,
      agSelectCellEditor: rb,
      agLargeTextCellEditor: Ap,
      agCheckboxCellEditor: ox,
      //filter
      agTextColumnFilter: $t,
      agNumberColumnFilter: Op,
      agDateColumnFilter: lu,
      //overlays
      agLoadingOverlay: zv,
      agNoRowsOverlay: Kv,
      // tooltips
      agTooltipComponent: cL
    }, this.enterpriseAgDefaultCompsModule = {
      agSetColumnFilter: Q.SetFilterModule,
      agSetColumnFloatingFilter: Q.SetFilterModule,
      agMultiColumnFilter: Q.MultiFilterModule,
      agMultiColumnFloatingFilter: Q.MultiFilterModule,
      agGroupColumnFilter: Q.RowGroupingModule,
      agGroupColumnFloatingFilter: Q.RowGroupingModule,
      agRichSelect: Q.RichSelectModule,
      agRichSelectCellEditor: Q.RichSelectModule,
      agDetailCellRenderer: Q.MasterDetailModule,
      agSparklineCellRenderer: Q.SparklinesModule
    }, this.jsComps = {};
  }
  init() {
    this.gridOptions.components != null && Ct(this.gridOptions.components, (e, t) => this.registerJsComponent(e, t));
  }
  registerDefaultComponent(e, t) {
    if (this.agGridDefaults[e]) {
      console.error("Trying to overwrite a default component. You should call registerComponent");
      return;
    }
    this.agGridDefaults[e] = t;
  }
  registerJsComponent(e, t) {
    this.jsComps[e] = t;
  }
  retrieve(e, t) {
    const i = (l, c) => ({ componentFromFramework: c, component: l }), r = this.getFrameworkOverrides().frameworkComponent(t, this.gridOptions.components);
    if (r != null)
      return i(r, !0);
    const n = this.jsComps[t];
    if (n) {
      const l = this.getFrameworkOverrides().isFrameworkComponent(n);
      return i(n, l);
    }
    const s = this.agGridDefaults[t];
    if (s)
      return i(s, !1);
    const a = this.enterpriseAgDefaultCompsModule[t];
    return a ? Z.__assertRegistered(a, `AG Grid '${e}' component: ${t}`, this.context.getGridId()) : tt(() => {
      this.warnAboutMissingComponent(e, t);
    }, "MissingComp" + t), null;
  }
  warnAboutMissingComponent(e, t) {
    const i = [
      // Don't include the old names / internals in potential suggestions
      ...Object.keys(this.agGridDefaults).filter((n) => !["agCellEditor", "agGroupRowRenderer", "agSortIndicator"].includes(n)),
      ...Object.keys(this.jsComps)
    ], r = wS(t, i, !0, 0.8);
    console.warn(`AG Grid: Could not find '${t}' component. It was configured as "${e}: '${t}'" but it wasn't found in the list of registered components.`), r.length > 0 && console.warn(`         Did you mean: [${r.slice(0, 3)}]?`), console.warn("If using a custom component check it has been registered as described in: https://ag-grid.com/javascript-data-grid/components/");
  }
};
nb([
  S("gridOptions")
], Hh.prototype, "gridOptions", void 0);
nb([
  B
], Hh.prototype, "init", null);
Hh = nb([
  q("userComponentRegistry")
], Hh);
const yL = {
  propertyName: "dateComponent",
  cellRenderer: !1
}, CL = {
  propertyName: "headerComponent",
  cellRenderer: !1
}, SL = {
  propertyName: "headerGroupComponent",
  cellRenderer: !1
}, Zw = {
  propertyName: "cellRenderer",
  cellRenderer: !0
}, bL = {
  propertyName: "cellEditor",
  cellRenderer: !1
}, Qw = {
  propertyName: "innerRenderer",
  cellRenderer: !0
}, wL = {
  propertyName: "loadingOverlayComponent",
  cellRenderer: !1
}, EL = {
  propertyName: "noRowsOverlayComponent",
  cellRenderer: !1
}, RL = {
  propertyName: "tooltipComponent",
  cellRenderer: !1
}, xC = {
  propertyName: "filter",
  cellRenderer: !1
}, TL = {
  propertyName: "floatingFilterComponent",
  cellRenderer: !1
}, xL = {
  propertyName: "toolPanel",
  cellRenderer: !1
}, DL = {
  propertyName: "statusPanel",
  cellRenderer: !1
}, OL = {
  propertyName: "fullWidthCellRenderer",
  cellRenderer: !0
}, PL = {
  propertyName: "loadingCellRenderer",
  cellRenderer: !0
}, AL = {
  propertyName: "groupRowRenderer",
  cellRenderer: !0
}, ML = {
  propertyName: "detailCellRenderer",
  cellRenderer: !0
};
class sx {
  static getFloatingFilterType(e) {
    return this.filterToFloatingFilterMapping[e];
  }
}
sx.filterToFloatingFilterMapping = {
  set: "agSetColumnFloatingFilter",
  agSetColumnFilter: "agSetColumnFloatingFilter",
  multi: "agMultiColumnFloatingFilter",
  agMultiColumnFilter: "agMultiColumnFloatingFilter",
  group: "agGroupColumnFloatingFilter",
  agGroupColumnFilter: "agGroupColumnFloatingFilter",
  number: "agNumberColumnFloatingFilter",
  agNumberColumnFilter: "agNumberColumnFloatingFilter",
  date: "agDateColumnFloatingFilter",
  agDateColumnFilter: "agDateColumnFloatingFilter",
  text: "agTextColumnFloatingFilter",
  agTextColumnFilter: "agTextColumnFloatingFilter"
};
var uu = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let fa = class extends H {
  getHeaderCompDetails(e, t) {
    return this.getCompDetails(e, CL, "agColumnHeader", t);
  }
  getHeaderGroupCompDetails(e) {
    const t = e.columnGroup.getColGroupDef();
    return this.getCompDetails(t, SL, "agColumnGroupHeader", e);
  }
  // this one is unusual, as it can be LoadingCellRenderer, DetailCellRenderer, FullWidthCellRenderer or GroupRowRenderer.
  // so we have to pass the type in.
  getFullWidthCellRendererDetails(e) {
    return this.getCompDetails(this.gridOptions, OL, null, e, !0);
  }
  getFullWidthLoadingCellRendererDetails(e) {
    return this.getCompDetails(this.gridOptions, PL, "agLoadingCellRenderer", e, !0);
  }
  getFullWidthGroupCellRendererDetails(e) {
    return this.getCompDetails(this.gridOptions, AL, "agGroupRowRenderer", e, !0);
  }
  getFullWidthDetailCellRendererDetails(e) {
    return this.getCompDetails(this.gridOptions, ML, "agDetailCellRenderer", e, !0);
  }
  // CELL RENDERER
  getInnerRendererDetails(e, t) {
    return this.getCompDetails(e, Qw, null, t);
  }
  getFullWidthGroupRowInnerCellRenderer(e, t) {
    return this.getCompDetails(e, Qw, null, t);
  }
  getCellRendererDetails(e, t) {
    return this.getCompDetails(e, Zw, null, t);
  }
  // CELL EDITOR
  getCellEditorDetails(e, t) {
    return this.getCompDetails(e, bL, "agCellEditor", t, !0);
  }
  // FILTER
  getFilterDetails(e, t, i) {
    return this.getCompDetails(e, xC, i, t, !0);
  }
  getDateCompDetails(e) {
    return this.getCompDetails(this.gridOptions, yL, "agDateInput", e, !0);
  }
  getLoadingOverlayCompDetails(e) {
    return this.getCompDetails(this.gridOptions, wL, "agLoadingOverlay", e, !0);
  }
  getNoRowsOverlayCompDetails(e) {
    return this.getCompDetails(this.gridOptions, EL, "agNoRowsOverlay", e, !0);
  }
  getTooltipCompDetails(e) {
    return this.getCompDetails(e.colDef, RL, "agTooltipComponent", e, !0);
  }
  getSetFilterCellRendererDetails(e, t) {
    return this.getCompDetails(e, Zw, null, t);
  }
  getFloatingFilterCompDetails(e, t, i) {
    return this.getCompDetails(e, TL, i, t);
  }
  getToolPanelCompDetails(e, t) {
    return this.getCompDetails(e, xL, null, t, !0);
  }
  getStatusPanelCompDetails(e, t) {
    return this.getCompDetails(e, DL, null, t, !0);
  }
  getCompDetails(e, t, i, r, n = !1) {
    const { propertyName: s, cellRenderer: a } = t;
    let { compName: l, jsComp: c, fwComp: d, paramsFromSelector: u, popupFromSelector: h, popupPositionFromSelector: p } = this.getCompKeys(e, t, r);
    const f = (m) => {
      const C = this.userComponentRegistry.retrieve(s, m);
      C && (c = C.componentFromFramework ? void 0 : C.component, d = C.componentFromFramework ? C.component : void 0);
    };
    if (l != null && f(l), c == null && d == null && i != null && f(i), c && a && !this.agComponentUtils.doesImplementIComponent(c) && (c = this.agComponentUtils.adaptFunction(s, c)), !c && !d) {
      n && console.error(`AG Grid: Could not find component ${l}, did you forget to configure this component?`);
      return;
    }
    const g = this.mergeParamsWithApplicationProvidedParams(e, t, r, u), v = c == null, y = c || d;
    return {
      componentFromFramework: v,
      componentClass: y,
      params: g,
      type: t,
      popupFromSelector: h,
      popupPositionFromSelector: p,
      newAgStackInstance: () => this.newAgStackInstance(y, v, g, t)
    };
  }
  getCompKeys(e, t, i) {
    const { propertyName: r } = t;
    let n, s, a, l, c, d;
    if (e) {
      const u = e, h = u[r + "Selector"], p = h ? h(i) : null, f = (g) => {
        typeof g == "string" ? n = g : g != null && g !== !0 && (this.getFrameworkOverrides().isFrameworkComponent(g) ? a = g : s = g);
      };
      p ? (f(p.component), l = p.params, c = p.popup, d = p.popupPosition) : f(u[r]);
    }
    return { compName: n, jsComp: s, fwComp: a, paramsFromSelector: l, popupFromSelector: c, popupPositionFromSelector: d };
  }
  newAgStackInstance(e, t, i, r) {
    const n = r.propertyName, s = !t;
    let a;
    if (s)
      a = new e();
    else {
      const c = this.componentMetadataProvider.retrieve(n);
      a = this.frameworkComponentWrapper.wrap(e, c.mandatoryMethodList, c.optionalMethodList, r);
    }
    const l = this.initComponent(a, i);
    return l == null ? Qe.resolve(a) : l.then(() => a);
  }
  // used by Floating Filter
  mergeParamsWithApplicationProvidedParams(e, t, i, r = null) {
    const n = {
      context: this.gridOptionsService.context,
      columnApi: this.gridOptionsService.columnApi,
      api: this.gridOptionsService.api
    };
    Tr(n, i);
    const s = e, a = s && s[t.propertyName + "Params"];
    if (typeof a == "function") {
      const l = a(i);
      Tr(n, l);
    } else
      typeof a == "object" && Tr(n, a);
    return Tr(n, r), n;
  }
  initComponent(e, t) {
    if (this.context.createBean(e), e.init != null)
      return e.init(t);
  }
  getDefaultFloatingFilterType(e, t) {
    if (e == null)
      return null;
    let i = null, { compName: r, jsComp: n, fwComp: s } = this.getCompKeys(e, xC);
    return r ? i = sx.getFloatingFilterType(r) : n == null && s == null && e.filter === !0 && (i = t()), i;
  }
};
uu([
  S("gridOptions")
], fa.prototype, "gridOptions", void 0);
uu([
  S("agComponentUtils")
], fa.prototype, "agComponentUtils", void 0);
uu([
  S("componentMetadataProvider")
], fa.prototype, "componentMetadataProvider", void 0);
uu([
  S("userComponentRegistry")
], fa.prototype, "userComponentRegistry", void 0);
uu([
  Ve("frameworkComponentWrapper")
], fa.prototype, "frameworkComponentWrapper", void 0);
fa = uu([
  q("userComponentFactory")
], fa);
var Fl;
(function(o) {
  o[o.SINGLE_SHEET = 0] = "SINGLE_SHEET", o[o.MULTI_SHEET = 1] = "MULTI_SHEET";
})(Fl || (Fl = {}));
var ob = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Wh = class extends H {
  constructor() {
    super(...arguments), this.dragEndFunctions = [], this.dragSources = [];
  }
  removeAllListeners() {
    this.dragSources.forEach(this.removeListener.bind(this)), this.dragSources.length = 0;
  }
  removeListener(e) {
    const t = e.dragSource.eElement, i = e.mouseDownListener;
    if (t.removeEventListener("mousedown", i), e.touchEnabled) {
      const r = e.touchStartListener;
      t.removeEventListener("touchstart", r, { passive: !0 });
    }
  }
  removeDragSource(e) {
    const t = this.dragSources.find((i) => i.dragSource === e);
    t && (this.removeListener(t), Ni(this.dragSources, t));
  }
  isDragging() {
    return this.dragging;
  }
  addDragSource(e) {
    const t = this.onMouseDown.bind(this, e), { eElement: i, includeTouch: r, stopPropagationForTouch: n } = e;
    i.addEventListener("mousedown", t);
    let s = null;
    const a = this.gridOptionsService.is("suppressTouch");
    r && !a && (s = (l) => {
      FS(l.target) || (l.cancelable && (l.preventDefault(), n && l.stopPropagation()), this.onTouchStart(e, l));
    }, i.addEventListener("touchstart", s, { passive: !1 })), this.dragSources.push({
      dragSource: e,
      mouseDownListener: t,
      touchStartListener: s,
      touchEnabled: !!r
    });
  }
  getStartTarget() {
    return this.startTarget;
  }
  // gets called whenever mouse down on any drag source
  onTouchStart(e, t) {
    this.currentDragParams = e, this.dragging = !1;
    const i = t.touches[0];
    this.touchLastTime = i, this.touchStart = i;
    const r = (c) => this.onTouchMove(c, e.eElement), n = (c) => this.onTouchUp(c, e.eElement), s = (c) => {
      c.cancelable && c.preventDefault();
    }, a = t.target, l = [
      // Prevents the page document from moving while we are dragging items around.
      // preventDefault needs to be called in the touchmove listener and never inside the
      // touchstart, because using touchstart causes the click event to be cancelled on touch devices.
      { target: this.gridOptionsService.getRootNode(), type: "touchmove", listener: s, options: { passive: !1 } },
      { target: a, type: "touchmove", listener: r, options: { passive: !0 } },
      { target: a, type: "touchend", listener: n, options: { passive: !0 } },
      { target: a, type: "touchcancel", listener: n, options: { passive: !0 } }
    ];
    this.addTemporaryEvents(l), e.dragStartPixels === 0 && this.onCommonMove(i, this.touchStart, e.eElement);
  }
  // gets called whenever mouse down on any drag source
  onMouseDown(e, t) {
    const i = t;
    if (e.skipMouseEvent && e.skipMouseEvent(t) || i._alreadyProcessedByDragService || (i._alreadyProcessedByDragService = !0, t.button !== 0))
      return;
    this.shouldPreventMouseEvent(t) && t.preventDefault(), this.currentDragParams = e, this.dragging = !1, this.mouseStartEvent = t, this.startTarget = t.target;
    const r = (c) => this.onMouseMove(c, e.eElement), n = (c) => this.onMouseUp(c, e.eElement), s = (c) => c.preventDefault(), a = this.gridOptionsService.getRootNode(), l = [
      { target: a, type: "mousemove", listener: r },
      { target: a, type: "mouseup", listener: n },
      { target: a, type: "contextmenu", listener: s }
    ];
    this.addTemporaryEvents(l), e.dragStartPixels === 0 && this.onMouseMove(t, e.eElement);
  }
  addTemporaryEvents(e) {
    e.forEach((t) => {
      const { target: i, type: r, listener: n, options: s } = t;
      i.addEventListener(r, n, s);
    }), this.dragEndFunctions.push(() => {
      e.forEach((t) => {
        const { target: i, type: r, listener: n, options: s } = t;
        i.removeEventListener(r, n, s);
      });
    });
  }
  // returns true if the event is close to the original event by X pixels either vertically or horizontally.
  // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
  isEventNearStartEvent(e, t) {
    const { dragStartPixels: i } = this.currentDragParams, r = z(i) ? i : 4;
    return jS(e, t, r);
  }
  getFirstActiveTouch(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].identifier === this.touchStart.identifier)
        return e[t];
    return null;
  }
  onCommonMove(e, t, i) {
    if (!this.dragging) {
      if (!this.dragging && this.isEventNearStartEvent(e, t))
        return;
      this.dragging = !0;
      const r = {
        type: w.EVENT_DRAG_STARTED,
        target: i
      };
      this.eventService.dispatchEvent(r), this.currentDragParams.onDragStart(t), this.currentDragParams.onDragging(t);
    }
    this.currentDragParams.onDragging(e);
  }
  onTouchMove(e, t) {
    const i = this.getFirstActiveTouch(e.touches);
    i && this.onCommonMove(i, this.touchStart, t);
  }
  // only gets called after a mouse down - as this is only added after mouseDown
  // and is removed when mouseUp happens
  onMouseMove(e, t) {
    this.shouldPreventMouseEvent(e) && e.preventDefault(), this.onCommonMove(e, this.mouseStartEvent, t);
  }
  shouldPreventMouseEvent(e) {
    const t = this.gridOptionsService.is("enableCellTextSelection"), i = fn(), r = e.type === "mousemove";
    return (
      // when `isEnableCellTextSelect` is `true`, we need to preventDefault on mouseMove
      // to avoid the grid text being selected while dragging components.
      // Note: Safari also has an issue, where `user-select: none` is not being respected, so also
      // prevent it on MouseDown.
      (t && r || i) && e.cancelable && this.mouseEventService.isEventFromThisGrid(e) && !this.isOverFormFieldElement(e)
    );
  }
  isOverFormFieldElement(e) {
    const t = e.target, i = t == null ? void 0 : t.tagName.toLocaleLowerCase();
    return !!(i != null && i.match("^a$|textarea|input|select|button"));
  }
  onTouchUp(e, t) {
    let i = this.getFirstActiveTouch(e.changedTouches);
    i || (i = this.touchLastTime), this.onUpCommon(i, t);
  }
  onMouseUp(e, t) {
    this.onUpCommon(e, t);
  }
  onUpCommon(e, t) {
    if (this.dragging) {
      this.dragging = !1, this.currentDragParams.onDragStop(e);
      const i = {
        type: w.EVENT_DRAG_STOPPED,
        target: t
      };
      this.eventService.dispatchEvent(i);
    }
    this.mouseStartEvent = null, this.startTarget = null, this.touchStart = null, this.touchLastTime = null, this.currentDragParams = null, this.dragEndFunctions.forEach((i) => i()), this.dragEndFunctions.length = 0;
  }
};
ob([
  S("mouseEventService")
], Wh.prototype, "mouseEventService", void 0);
ob([
  dt
], Wh.prototype, "removeAllListeners", null);
Wh = ob([
  q("dragService")
], Wh);
var ms;
(function(o) {
  o[o.Above = 0] = "Above", o[o.Below = 1] = "Below";
})(ms || (ms = {}));
var ot;
(function(o) {
  o.EVERYTHING = "group", o.FILTER = "filter", o.SORT = "sort", o.MAP = "map", o.AGGREGATE = "aggregate", o.FILTER_AGGREGATES = "filter_aggregates", o.PIVOT = "pivot", o.NOTHING = "nothing";
})(ot || (ot = {}));
var it = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
function ml(o) {
  const e = o;
  return e != null && e.getFrameworkComponentInstance != null ? e.getFrameworkComponentInstance() : o;
}
let Ye = class {
  constructor() {
    this.detailGridInfoMap = {}, this.destroyCalled = !1;
  }
  registerOverlayWrapperComp(e) {
    this.overlayWrapperComp = e;
  }
  registerSideBarComp(e) {
    this.sideBarComp = e;
  }
  init() {
    switch (this.rowModel.getType()) {
      case "clientSide":
        this.clientSideRowModel = this.rowModel;
        break;
      case "infinite":
        this.infiniteRowModel = this.rowModel;
        break;
      case "serverSide":
        this.serverSideRowModel = this.rowModel;
        break;
    }
    this.ctrlsService.whenReady(() => {
      this.gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();
    });
  }
  /** Used internally by grid. Not intended to be used by the client. Interface may change between releases. */
  __getAlignedGridService() {
    return this.alignedGridsService;
  }
  /** Used internally by grid. Not intended to be used by the client. Interface may change between releases. */
  __getContext() {
    return this.context;
  }
  getSetterMethod(e) {
    return `set${e.charAt(0).toUpperCase()}${e.substring(1)}`;
  }
  /** Used internally by grid. Not intended to be used by the client. Interface may change between releases. */
  __setProperty(e, t) {
    this.gridOptionsService.set(e, t);
    const i = this.getSetterMethod(e), r = this;
    r[i] && r[i](t);
  }
  /** Returns the `gridId` for the current grid as specified via the gridOptions property `gridId` or the auto assigned grid id if none was provided. */
  getGridId() {
    return this.context.getGridId();
  }
  /** Register a detail grid with the master grid when it is created. */
  addDetailGridInfo(e, t) {
    this.detailGridInfoMap[e] = t;
  }
  /** Unregister a detail grid from the master grid when it is destroyed. */
  removeDetailGridInfo(e) {
    this.detailGridInfoMap[e] = void 0;
  }
  /** Returns the `DetailGridInfo` corresponding to the supplied `detailGridId`. */
  getDetailGridInfo(e) {
    return this.detailGridInfoMap[e];
  }
  /** Iterates through each `DetailGridInfo` in the grid and calls the supplied callback on each. */
  forEachDetailGridInfo(e) {
    let t = 0;
    Ct(this.detailGridInfoMap, (i, r) => {
      z(r) && (e(r, t), t++);
    });
  }
  /** Similar to `exportDataAsCsv`, except returns the result as a string rather than download it. */
  getDataAsCsv(e) {
    if (Z.__assertRegistered(Q.CsvExportModule, "api.getDataAsCsv", this.context.getGridId()))
      return this.csvCreator.getDataAsCsv(e);
  }
  /** Downloads a CSV export of the grid's data. */
  exportDataAsCsv(e) {
    Z.__assertRegistered(Q.CsvExportModule, "api.exportDataAsCSv", this.context.getGridId()) && this.csvCreator.exportDataAsCsv(e);
  }
  getExcelExportMode(e) {
    const t = this.gridOptionsService.get("defaultExcelExportParams");
    return Object.assign({ exportMode: "xlsx" }, t, e).exportMode;
  }
  assertNotExcelMultiSheet(e, t) {
    if (!Z.__assertRegistered(Q.ExcelExportModule, "api." + e, this.context.getGridId()))
      return !1;
    const i = this.getExcelExportMode(t);
    return this.excelCreator.getFactoryMode(i) === Fl.MULTI_SHEET ? (console.warn("AG Grid: The Excel Exporter is currently on Multi Sheet mode. End that operation by calling 'api.getMultipleSheetAsExcel()' or 'api.exportMultipleSheetsAsExcel()'"), !1) : !0;
  }
  /** Similar to `exportDataAsExcel`, except instead of downloading a file, it will return a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob) to be processed by the user. */
  getDataAsExcel(e) {
    if (this.assertNotExcelMultiSheet("getDataAsExcel", e))
      return this.excelCreator.getDataAsExcel(e);
  }
  /** Downloads an Excel export of the grid's data. */
  exportDataAsExcel(e) {
    this.assertNotExcelMultiSheet("exportDataAsExcel", e) && this.excelCreator.exportDataAsExcel(e);
  }
  /** This is method to be used to get the grid's data as a sheet, that will later be exported either by `getMultipleSheetsAsExcel()` or `exportMultipleSheetsAsExcel()`. */
  getSheetDataForExcel(e) {
    if (!Z.__assertRegistered(Q.ExcelExportModule, "api.getSheetDataForExcel", this.context.getGridId()))
      return;
    const t = this.getExcelExportMode(e);
    return this.excelCreator.setFactoryMode(Fl.MULTI_SHEET, t), this.excelCreator.getSheetDataForExcel(e);
  }
  /** Similar to `exportMultipleSheetsAsExcel`, except instead of downloading a file, it will return a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob) to be processed by the user. */
  getMultipleSheetsAsExcel(e) {
    if (Z.__assertRegistered(Q.ExcelExportModule, "api.getMultipleSheetsAsExcel", this.context.getGridId()))
      return this.excelCreator.getMultipleSheetsAsExcel(e);
  }
  /** Downloads an Excel export of multiple sheets in one file. */
  exportMultipleSheetsAsExcel(e) {
    if (Z.__assertRegistered(Q.ExcelExportModule, "api.exportMultipleSheetsAsExcel", this.context.getGridId()))
      return this.excelCreator.exportMultipleSheetsAsExcel(e);
  }
  /**
   * Sets an ARIA property in the grid panel (element with `role=\"grid\"`), and removes an ARIA property when the value is null.
   *
   * Example: `api.setGridAriaProperty('label', 'my grid')` will set `aria-label=\"my grid\"`.
   *
   * `api.setGridAriaProperty('label', null)` will remove the `aria-label` attribute from the grid element.
   */
  setGridAriaProperty(e, t) {
    if (!e)
      return;
    const i = this.ctrlsService.getGridBodyCtrl().getGui(), r = `aria-${e}`;
    t === null ? i.removeAttribute(r) : i.setAttribute(r, t);
  }
  logMissingRowModel(e, ...t) {
    console.error(`AG Grid: api.${e} can only be called when gridOptions.rowModelType is ${t.join(" or ")}`);
  }
  /** Set new datasource for Server-Side Row Model. */
  setServerSideDatasource(e) {
    this.serverSideRowModel ? this.serverSideRowModel.setDatasource(e) : this.logMissingRowModel("setServerSideDatasource", "serverSide");
  }
  /**
   * Updates the `cacheBlockSize` when requesting data from the server if `suppressServerSideInfiniteScroll` is not enabled.
   *
   * Note this purges all the cached data and reloads all the rows of the grid.
   * */
  setCacheBlockSize(e) {
    this.serverSideRowModel ? (this.gridOptionsService.set("cacheBlockSize", e), this.serverSideRowModel.resetRootStore()) : this.logMissingRowModel("setCacheBlockSize", "serverSide");
  }
  /** Set new datasource for Infinite Row Model. */
  setDatasource(e) {
    this.gridOptionsService.isRowModelType("infinite") ? this.rowModel.setDatasource(e) : this.logMissingRowModel("setDatasource", "infinite");
  }
  /** Set new datasource for Viewport Row Model. */
  setViewportDatasource(e) {
    this.gridOptionsService.isRowModelType("viewport") ? this.rowModel.setViewportDatasource(e) : this.logMissingRowModel("setViewportDatasource", "viewport");
  }
  /** Set the row data. */
  setRowData(e) {
    if (this.immutableService == null) {
      this.logMissingRowModel("setRowData", "clientSide");
      return;
    }
    this.immutableService.isActive() ? this.immutableService.setRowData(e) : (this.selectionService.reset(), this.clientSideRowModel.setRowData(e));
  }
  /** Set the top pinned rows. Call with no rows / undefined to clear top pinned rows. */
  setPinnedTopRowData(e) {
    this.pinnedRowModel.setPinnedTopRowData(e);
  }
  /** Set the bottom pinned rows. Call with no rows / undefined to clear bottom pinned rows. */
  setPinnedBottomRowData(e) {
    this.pinnedRowModel.setPinnedBottomRowData(e);
  }
  /** Gets the number of top pinned rows. */
  getPinnedTopRowCount() {
    return this.pinnedRowModel.getPinnedTopRowCount();
  }
  /** Gets the number of bottom pinned rows. */
  getPinnedBottomRowCount() {
    return this.pinnedRowModel.getPinnedBottomRowCount();
  }
  /** Gets the top pinned row with the specified index. */
  getPinnedTopRow(e) {
    return this.pinnedRowModel.getPinnedTopRow(e);
  }
  /** Gets the bottom pinned row with the specified index. */
  getPinnedBottomRow(e) {
    return this.pinnedRowModel.getPinnedBottomRow(e);
  }
  /**
   * Call to set new column definitions. The grid will redraw all the column headers, and then redraw all of the rows.
   */
  setColumnDefs(e, t = "api") {
    this.columnModel.setColumnDefs(e, t), this.gridOptionsService.set("columnDefs", e, !0, { source: t });
  }
  /** Call to set new auto group column definition. The grid will recreate any auto-group columns if present. */
  setAutoGroupColumnDef(e, t = "api") {
    this.gridOptionsService.set("autoGroupColumnDef", e, !0, { source: t });
  }
  /** Call to set new Default Column Definition. */
  setDefaultColDef(e, t = "api") {
    this.gridOptionsService.set("defaultColDef", e, !0, { source: t });
  }
  /** Call to set new Column Types. */
  setColumnTypes(e, t = "api") {
    this.gridOptionsService.set("columnTypes", e, !0, { source: t });
  }
  expireValueCache() {
    this.valueCache.expire();
  }
  /**
   * Returns an object with two properties:
   *  - `top`: The top pixel position of the current scroll in the grid
   *  - `bottom`: The bottom pixel position of the current scroll in the grid
   */
  getVerticalPixelRange() {
    return this.gridBodyCtrl.getScrollFeature().getVScrollPosition();
  }
  /**
   * Returns an object with two properties:
   * - `left`: The left pixel position of the current scroll in the grid
   * - `right`: The right pixel position of the current scroll in the grid
   */
  getHorizontalPixelRange() {
    return this.gridBodyCtrl.getScrollFeature().getHScrollPosition();
  }
  /** If `true`, the horizontal scrollbar will always be present, even if not required. Otherwise, it will only be displayed when necessary. */
  setAlwaysShowHorizontalScroll(e) {
    this.gridOptionsService.set("alwaysShowHorizontalScroll", e);
  }
  /** If `true`, the vertical scrollbar will always be present, even if not required. Otherwise it will only be displayed when necessary. */
  setAlwaysShowVerticalScroll(e) {
    this.gridOptionsService.set("alwaysShowVerticalScroll", e);
  }
  /** Performs change detection on all cells, refreshing cells where required. */
  refreshCells(e = {}) {
    this.rowRenderer.refreshCells(e);
  }
  /** Flash rows, columns or individual cells. */
  flashCells(e = {}) {
    this.rowRenderer.flashCells(e);
  }
  /** Remove row(s) from the DOM and recreate them again from scratch. */
  redrawRows(e = {}) {
    const t = e ? e.rowNodes : void 0;
    this.rowRenderer.redrawRows(t);
  }
  setFunctionsReadOnly(e) {
    this.gridOptionsService.set("functionsReadOnly", e);
  }
  /** Redraws the header. Useful if a column name changes, or something else that changes how the column header is displayed. */
  refreshHeader() {
    this.ctrlsService.getHeaderRowContainerCtrls().forEach((e) => e.refresh());
  }
  /** Returns `true` if any filter is set. This includes quick filter, advanced filter or external filter. */
  isAnyFilterPresent() {
    return this.filterManager.isAnyFilterPresent();
  }
  /** Returns `true` if any column filter is set, otherwise `false`. */
  isColumnFilterPresent() {
    return this.filterManager.isColumnFilterPresent() || this.filterManager.isAggregateFilterPresent();
  }
  /** Returns `true` if the Quick Filter is set, otherwise `false`. */
  isQuickFilterPresent() {
    return this.filterManager.isQuickFilterPresent();
  }
  /**
   * Returns the row model inside the table.
   * From here you can see the original rows, rows after filter has been applied,
   * rows after aggregation has been applied, and the final set of 'to be displayed' rows.
   */
  getModel() {
    return this.rowModel;
  }
  /** Expand or collapse a specific row node, optionally expanding/collapsing all of its parent nodes. */
  setRowNodeExpanded(e, t, i) {
    e && (i && e.parent && e.parent.level !== -1 && this.setRowNodeExpanded(e.parent, t, i), e.setExpanded(t));
  }
  /**
   * Informs the grid that row group expanded state has changed and it needs to rerender the group nodes.
   * Typically called after updating the row node expanded state explicitly, i.e `rowNode.expanded = false`,
   * across multiple groups and you want to update the grid view in a single rerender instead of on every group change.
   */
  onGroupExpandedOrCollapsed() {
    if (Se(this.clientSideRowModel)) {
      this.logMissingRowModel("onGroupExpandedOrCollapsed", "clientSide");
      return;
    }
    this.clientSideRowModel.refreshModel({ step: ot.MAP });
  }
  /**
   * Refresh the Client-Side Row Model, executing the grouping, filtering and sorting again.
   * Optionally provide the step you wish the refresh to apply from. Defaults to `everything`.
   */
  refreshClientSideRowModel(e) {
    if (Se(this.clientSideRowModel)) {
      this.logMissingRowModel("refreshClientSideRowModel", "clientSide");
      return;
    }
    this.clientSideRowModel.refreshModel(e);
  }
  /** Returns `true` when there are no more animation frames left to process. */
  isAnimationFrameQueueEmpty() {
    return this.animationFrameService.isQueueEmpty();
  }
  flushAllAnimationFrames() {
    this.animationFrameService.flushAllFrames();
  }
  /**
   * Returns the row node with the given ID.
   * The row node ID is the one you provide from the callback `getRowId(params)`,
   * otherwise the ID is a number (cast as string) auto-generated by the grid when
   * the row data is set.
   */
  getRowNode(e) {
    return this.rowModel.getRowNode(e);
  }
  /**
   * Gets the sizes that various UI elements will be rendered at with the current theme.
   * If you override the row or header height using `gridOptions`, the override value you provided will be returned.
   */
  getSizesForCurrentTheme() {
    return {
      rowHeight: this.gridOptionsService.getRowHeightAsNumber(),
      headerHeight: this.columnModel.getHeaderHeight()
    };
  }
  /** Expand all groups. */
  expandAll() {
    this.clientSideRowModel ? this.clientSideRowModel.expandOrCollapseAll(!0) : this.serverSideRowModel ? this.serverSideRowModel.expandAll(!0) : this.logMissingRowModel("expandAll", "clientSide", "serverSide");
  }
  /** Collapse all groups. */
  collapseAll() {
    this.clientSideRowModel ? this.clientSideRowModel.expandOrCollapseAll(!1) : this.serverSideRowModel ? this.serverSideRowModel.expandAll(!1) : this.logMissingRowModel("expandAll", "clientSide", "serverSide");
  }
  /**
   * Registers a callback to a virtual row.
   * A virtual row is a row that is visually rendered on the screen (rows that are not visible because of the scroll position are not rendered).
   * Unlike normal events, you do not need to unregister rendered row listeners.
   * When the rendered row is removed from the grid, all associated rendered row listeners will also be removed.
   * listen for this event if your `cellRenderer` needs to do cleanup when the row no longer exists.
   */
  addRenderedRowListener(e, t, i) {
    this.rowRenderer.addRenderedRowListener(e, t, i);
  }
  /** Get the current Quick Filter text from the grid, or `undefined` if none is set. */
  getQuickFilter() {
    return this.gridOptionsService.get("quickFilterText");
  }
  /** Pass a Quick Filter text into the grid for filtering. */
  setQuickFilter(e) {
    this.gridOptionsService.set("quickFilterText", e);
  }
  /**
   * @deprecated As of v30, hidden columns are excluded from the Quick Filter by default. To include hidden columns, use `setIncludeHiddenColumnsInQuickFilter` instead.
   */
  setExcludeHiddenColumnsFromQuickFilter(e) {
    rn("30", "setExcludeHiddenColumnsFromQuickFilter", void 0, "Hidden columns are now excluded from the Quick Filter by default. This can be toggled using `setIncludeHiddenColumnsInQuickFilter`"), this.setIncludeHiddenColumnsInQuickFilter(!e);
  }
  /**
   * Updates the `includeHiddenColumnsInQuickFilter` grid option.
   * By default hidden columns are excluded from the Quick Filter.
   * Set to `true` to include them.
   */
  setIncludeHiddenColumnsInQuickFilter(e) {
    this.gridOptionsService.set("includeHiddenColumnsInQuickFilter", e);
  }
  /**
   * Set all of the provided nodes selection state to the provided value.
   */
  setNodesSelected(e) {
    if (!e.nodes.every((a) => a.rowPinned ? (console.warn("AG Grid: cannot select pinned rows"), !1) : a.id === void 0 ? (console.warn("AG Grid: cannot select node until id for node is known"), !1) : !0))
      return;
    const { nodes: i, source: r, newValue: n } = e, s = i;
    this.selectionService.setNodesSelected({ nodes: s, source: r != null ? r : "api", newValue: n });
  }
  /**
   * Select all rows, regardless of filtering and rows that are not visible due to grouping being enabled and their groups not expanded.
   * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAll'`
   */
  selectAll(e = "apiSelectAll") {
    this.selectionService.selectAllRowNodes({ source: e });
  }
  /**
   * Clear all row selections, regardless of filtering.
   * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAll'`
   */
  deselectAll(e = "apiSelectAll") {
    this.selectionService.deselectAllRowNodes({ source: e });
  }
  /**
   * Select all filtered rows.
   * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAllFiltered'`
   */
  selectAllFiltered(e = "apiSelectAllFiltered") {
    this.selectionService.selectAllRowNodes({ source: e, justFiltered: !0 });
  }
  /**
   * Clear all filtered selections.
   * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAllFiltered'`
   */
  deselectAllFiltered(e = "apiSelectAllFiltered") {
    this.selectionService.deselectAllRowNodes({ source: e, justFiltered: !0 });
  }
  /**
   * Returns an object containing rules matching the selected rows in the SSRM.
   *
   * If `groupSelectsChildren=false` the returned object will be flat, and will conform to IServerSideSelectionState.
   * If `groupSelectsChildren=true` the retuned object will be hierarchical, and will conform to IServerSideGroupSelectionState.
   */
  getServerSideSelectionState() {
    return Se(this.serverSideRowModel) ? (this.logMissingRowModel("getServerSideSelectionState", "serverSide"), null) : this.selectionService.getServerSideSelectionState();
  }
  /**
   * Set the rules matching the selected rows in the SSRM.
   *
   * If `groupSelectsChildren=false` the param will be flat, and should conform to IServerSideSelectionState.
   * If `groupSelectsChildren=true` the param will be hierarchical, and should conform to IServerSideGroupSelectionState.
   */
  setServerSideSelectionState(e) {
    if (Se(this.serverSideRowModel)) {
      this.logMissingRowModel("setServerSideSelectionState", "serverSide");
      return;
    }
    this.selectionService.setServerSideSelectionState(e);
  }
  /**
   * Select all rows on the current page.
   * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAllCurrentPage'`
   */
  selectAllOnCurrentPage(e = "apiSelectAllCurrentPage") {
    this.selectionService.selectAllRowNodes({ source: e, justCurrentPage: !0 });
  }
  /**
   * Clear all filtered on the current page.
   * @param source Source property that will appear in the `selectionChanged` event, defaults to `'apiSelectAllCurrentPage'`
   */
  deselectAllOnCurrentPage(e = "apiSelectAllCurrentPage") {
    this.selectionService.deselectAllRowNodes({ source: e, justCurrentPage: !0 });
  }
  /**
   * Sets columns to adjust in size to fit the grid horizontally. If inferring cell data types with custom column types
   * and row data is provided asynchronously, the column sizing will happen asynchronously when row data is added.
   * To always perform this synchronously, set `cellDataType = false` on the default column definition.
   **/
  sizeColumnsToFit(e) {
    this.gridBodyCtrl.sizeColumnsToFit(e);
  }
  /** Show the 'loading' overlay. */
  showLoadingOverlay() {
    this.overlayWrapperComp.showLoadingOverlay();
  }
  /** Show the 'no rows' overlay. */
  showNoRowsOverlay() {
    this.overlayWrapperComp.showNoRowsOverlay();
  }
  /** Hides the overlay if showing. */
  hideOverlay() {
    this.overlayWrapperComp.hideOverlay();
  }
  /**
   * Returns an unsorted list of selected nodes.
   * Getting the underlying node (rather than the data) is useful when working with tree / aggregated data,
   * as the node can be traversed.
   */
  getSelectedNodes() {
    return this.selectionService.getSelectedNodes();
  }
  /** Returns an unsorted list of selected rows (i.e. row data that you provided). */
  getSelectedRows() {
    return this.selectionService.getSelectedRows();
  }
  /**
   * Returns a list of all selected nodes at 'best cost', a feature to be used with groups / trees.
   * If a group has all its children selected, then the group appears in the result, but not the children.
   * Designed for use with `'children'` as the group selection type, where groups don't actually appear in the selection normally.
   */
  getBestCostNodeSelection() {
    if (Se(this.clientSideRowModel)) {
      this.logMissingRowModel("getBestCostNodeSelection", "clientSide");
      return;
    }
    return this.selectionService.getBestCostNodeSelection();
  }
  /** Retrieve rendered nodes. Due to virtualisation this will contain only the current visible rows and those in the buffer. */
  getRenderedNodes() {
    return this.rowRenderer.getRenderedNodes();
  }
  /**
   *  Ensures the column is visible by scrolling the table if needed.
   *
   * This will have no effect before the firstDataRendered event has fired.
   *
   * @param key - The column to ensure visible
   * @param position - Where the column will be positioned.
   * - `auto` - Scrolls the minimum amount to make sure the column is visible.
   * - `start` - Scrolls the column to the start of the viewport.
   * - `middle` - Scrolls the column to the middle of the viewport.
   * - `end` - Scrolls the column to the end of the viewport.
  */
  ensureColumnVisible(e, t = "auto") {
    this.gridBodyCtrl.getScrollFeature().ensureColumnVisible(e, t);
  }
  /**
   * Vertically scrolls the grid until the provided row index is inside the visible viewport.
   * If a position is provided, the grid will attempt to scroll until the row is at the given position within the viewport.
   * This will have no effect before the firstDataRendered event has fired.
   */
  ensureIndexVisible(e, t) {
    this.gridBodyCtrl.getScrollFeature().ensureIndexVisible(e, t);
  }
  /**
   * Vertically scrolls the grid until the provided row (or a row matching the provided comparator) is inside the visible viewport.
   * If a position is provided, the grid will attempt to scroll until the row is at the given position within the viewport.
   * This will have no effect before the firstDataRendered event has fired.
   */
  ensureNodeVisible(e, t = null) {
    this.gridBodyCtrl.getScrollFeature().ensureNodeVisible(e, t);
  }
  /**
   * Similar to `forEachNode`, except lists all the leaf nodes.
   * This effectively goes through all the data that you provided to the grid before the grid performed any grouping.
   * If using tree data, goes through all the nodes for the data you provided, including nodes that have children,
   * but excluding groups the grid created where gaps were missing in the hierarchy.
   */
  forEachLeafNode(e) {
    if (Se(this.clientSideRowModel)) {
      this.logMissingRowModel("forEachLeafNode", "clientSide");
      return;
    }
    this.clientSideRowModel.forEachLeafNode(e);
  }
  /**
   * Iterates through each node (row) in the grid and calls the callback for each node.
   * This works similar to the `forEach` method on a JavaScript array.
   * This is called for every node, ignoring any filtering or sorting applied within the grid.
   * If using the Infinite Row Model, then this gets called for each page loaded in the page cache.
   */
  forEachNode(e, t) {
    this.rowModel.forEachNode(e, t);
  }
  /** Similar to `forEachNode`, except skips any filtered out data. */
  forEachNodeAfterFilter(e) {
    if (Se(this.clientSideRowModel)) {
      this.logMissingRowModel("forEachNodeAfterFilter", "clientSide");
      return;
    }
    this.clientSideRowModel.forEachNodeAfterFilter(e);
  }
  /** Similar to `forEachNodeAfterFilter`, except the callbacks are called in the order the rows are displayed in the grid. */
  forEachNodeAfterFilterAndSort(e) {
    if (Se(this.clientSideRowModel)) {
      this.logMissingRowModel("forEachNodeAfterFilterAndSort", "clientSide");
      return;
    }
    this.clientSideRowModel.forEachNodeAfterFilterAndSort(e);
  }
  /**
   * Returns the filter component instance for a column.
   * `key` can be a string field name or a ColDef object (matches on object reference, useful if field names are not unique).
   * If your filter is created asynchronously, `getFilterInstance` will return `null` so you will need to use the `callback` to access the filter instance instead.
   */
  getFilterInstance(e, t) {
    const i = this.getFilterInstanceImpl(e, (n) => {
      if (!t)
        return;
      const s = ml(n);
      t(s);
    });
    return ml(i);
  }
  getFilterInstanceImpl(e, t) {
    const i = this.columnModel.getPrimaryColumn(e);
    if (!i)
      return;
    const r = this.filterManager.getFilterComponent(i, "NO_UI"), n = r && r.resolveNow(null, (s) => s);
    return n ? setTimeout(t, 0, n) : r && r.then((s) => {
      t(s);
    }), n;
  }
  /** Destroys a filter. Useful to force a particular filter to be created from scratch again. */
  destroyFilter(e) {
    const t = this.columnModel.getPrimaryColumn(e);
    if (t)
      return this.filterManager.destroyFilter(t, "api");
  }
  /** Gets the status panel instance corresponding to the supplied `id`. */
  getStatusPanel(e) {
    if (!Z.__assertRegistered(Q.StatusBarModule, "api.getStatusPanel", this.context.getGridId()))
      return;
    const t = this.statusBarService.getStatusPanel(e);
    return ml(t);
  }
  getColumnDef(e) {
    const t = this.columnModel.getPrimaryColumn(e);
    return t ? t.getColDef() : null;
  }
  /**
   * Returns the current column definitions.
  */
  getColumnDefs() {
    return this.columnModel.getColumnDefs();
  }
  /** Informs the grid that a filter has changed. This is typically called after a filter change through one of the filter APIs. */
  onFilterChanged() {
    this.filterManager.onFilterChanged();
  }
  /**
   * Gets the grid to act as if the sort was changed.
   * Useful if you update some values and want to get the grid to reorder them according to the new values.
   */
  onSortChanged() {
    this.sortController.onSortChanged("api");
  }
  /** Sets the state of all the advanced filters. Provide it with what you get from `getFilterModel()` to restore filter state. */
  setFilterModel(e) {
    this.filterManager.setFilterModel(e);
  }
  /** Gets the current state of all the advanced filters. Used for saving filter state. */
  getFilterModel() {
    return this.filterManager.getFilterModel();
  }
  /** Returns the focused cell (or the last focused cell if the grid lost focus). */
  getFocusedCell() {
    return this.focusService.getFocusedCell();
  }
  /** Clears the focused cell. */
  clearFocusedCell() {
    return this.focusService.clearFocusedCell();
  }
  /** Sets the focus to the specified cell. `rowPinned` can be either 'top', 'bottom' or null (for not pinned). */
  setFocusedCell(e, t, i) {
    this.focusService.setFocusedCell({ rowIndex: e, column: t, rowPinned: i, forceBrowserFocus: !0 });
  }
  /** Sets the `suppressRowDrag` property. */
  setSuppressRowDrag(e) {
    this.gridOptionsService.set("suppressRowDrag", e);
  }
  /** Sets the `suppressMoveWhenRowDragging` property. */
  setSuppressMoveWhenRowDragging(e) {
    this.gridOptionsService.set("suppressMoveWhenRowDragging", e);
  }
  /** Sets the `suppressRowClickSelection` property. */
  setSuppressRowClickSelection(e) {
    this.gridOptionsService.set("suppressRowClickSelection", e);
  }
  /** Adds a drop zone outside of the grid where rows can be dropped. */
  addRowDropZone(e) {
    this.gridBodyCtrl.getRowDragFeature().addRowDropZone(e);
  }
  /** Removes an external drop zone added by `addRowDropZone`. */
  removeRowDropZone(e) {
    const t = this.dragAndDropService.findExternalZone(e);
    t && this.dragAndDropService.removeDropTarget(t);
  }
  /** Returns the `RowDropZoneParams` to be used by another grid's `addRowDropZone` method. */
  getRowDropZoneParams(e) {
    return this.gridBodyCtrl.getRowDragFeature().getRowDropZone(e);
  }
  /** Sets the height in pixels for the row containing the column label header. */
  setHeaderHeight(e) {
    this.gridOptionsService.set("headerHeight", e);
  }
  /**
   * Switch between layout options: `normal`, `autoHeight`, `print`.
   * Defaults to `normal` if no domLayout provided.
   */
  setDomLayout(e) {
    this.gridOptionsService.set("domLayout", e);
  }
  /** Sets the `enableCellTextSelection` property. */
  setEnableCellTextSelection(e) {
    this.gridBodyCtrl.setCellTextSelection(e);
  }
  /** Sets the preferred direction for the selection fill handle. */
  setFillHandleDirection(e) {
    this.gridOptionsService.set("fillHandleDirection", e);
  }
  /** Sets the height in pixels for the rows containing header column groups. */
  setGroupHeaderHeight(e) {
    this.gridOptionsService.set("groupHeaderHeight", e);
  }
  /** Sets the height in pixels for the row containing the floating filters. */
  setFloatingFiltersHeight(e) {
    this.gridOptionsService.set("floatingFiltersHeight", e);
  }
  /** Sets the height in pixels for the row containing the columns when in pivot mode. */
  setPivotHeaderHeight(e) {
    this.gridOptionsService.set("pivotHeaderHeight", e);
  }
  /** Sets the height in pixels for the row containing header column groups when in pivot mode. */
  setPivotGroupHeaderHeight(e) {
    this.gridOptionsService.set("pivotGroupHeaderHeight", e);
  }
  setPivotMode(e) {
    this.columnModel.setPivotMode(e);
  }
  setAnimateRows(e) {
    this.gridOptionsService.set("animateRows", e);
  }
  setIsExternalFilterPresent(e) {
    this.gridOptionsService.set("isExternalFilterPresent", e);
  }
  setDoesExternalFilterPass(e) {
    this.gridOptionsService.set("doesExternalFilterPass", e);
  }
  setNavigateToNextCell(e) {
    this.gridOptionsService.set("navigateToNextCell", e);
  }
  setTabToNextCell(e) {
    this.gridOptionsService.set("tabToNextCell", e);
  }
  setTabToNextHeader(e) {
    this.gridOptionsService.set("tabToNextHeader", e);
  }
  setNavigateToNextHeader(e) {
    this.gridOptionsService.set("navigateToNextHeader", e);
  }
  setRowGroupPanelShow(e) {
    this.gridOptionsService.set("rowGroupPanelShow", e);
  }
  setGetGroupRowAgg(e) {
    this.gridOptionsService.set("getGroupRowAgg", e);
  }
  setGetBusinessKeyForNode(e) {
    this.gridOptionsService.set("getBusinessKeyForNode", e);
  }
  setGetChildCount(e) {
    this.gridOptionsService.set("getChildCount", e);
  }
  setProcessRowPostCreate(e) {
    this.gridOptionsService.set("processRowPostCreate", e);
  }
  setGetRowId(e) {
    this.gridOptionsService.set("getRowId", e);
  }
  setGetRowClass(e) {
    this.gridOptionsService.set("getRowClass", e);
  }
  setIsFullWidthRow(e) {
    this.gridOptionsService.set("isFullWidthRow", e);
  }
  setIsRowSelectable(e) {
    this.gridOptionsService.set("isRowSelectable", e);
  }
  setIsRowMaster(e) {
    this.gridOptionsService.set("isRowMaster", e);
  }
  setPostSortRows(e) {
    this.gridOptionsService.set("postSortRows", e);
  }
  setGetDocument(e) {
    this.gridOptionsService.set("getDocument", e);
  }
  setGetContextMenuItems(e) {
    this.gridOptionsService.set("getContextMenuItems", e);
  }
  setGetMainMenuItems(e) {
    this.gridOptionsService.set("getMainMenuItems", e);
  }
  setProcessCellForClipboard(e) {
    this.gridOptionsService.set("processCellForClipboard", e);
  }
  setSendToClipboard(e) {
    this.gridOptionsService.set("sendToClipboard", e);
  }
  setProcessCellFromClipboard(e) {
    this.gridOptionsService.set("processCellFromClipboard", e);
  }
  /** @deprecated v28 use `setProcessPivotResultColDef` instead */
  setProcessSecondaryColDef(e) {
    rn("28.0", "setProcessSecondaryColDef", "setProcessPivotResultColDef"), this.setProcessPivotResultColDef(e);
  }
  /** @deprecated v28 use `setProcessPivotResultColGroupDef` instead */
  setProcessSecondaryColGroupDef(e) {
    rn("28.0", "setProcessSecondaryColGroupDef", "setProcessPivotResultColGroupDef"), this.setProcessPivotResultColGroupDef(e);
  }
  setProcessPivotResultColDef(e) {
    this.gridOptionsService.set("processPivotResultColDef", e);
  }
  setProcessPivotResultColGroupDef(e) {
    this.gridOptionsService.set("processPivotResultColGroupDef", e);
  }
  setPostProcessPopup(e) {
    this.gridOptionsService.set("postProcessPopup", e);
  }
  setInitialGroupOrderComparator(e) {
    this.gridOptionsService.set("initialGroupOrderComparator", e);
  }
  setGetChartToolbarItems(e) {
    this.gridOptionsService.set("getChartToolbarItems", e);
  }
  setPaginationNumberFormatter(e) {
    this.gridOptionsService.set("paginationNumberFormatter", e);
  }
  /** @deprecated v28 use setGetServerSideGroupLevelParams instead */
  setGetServerSideStoreParams(e) {
    rn("28.0", "setGetServerSideStoreParams", "setGetServerSideGroupLevelParams"), this.setGetServerSideGroupLevelParams(e);
  }
  setGetServerSideGroupLevelParams(e) {
    this.gridOptionsService.set("getServerSideGroupLevelParams", e);
  }
  setIsServerSideGroupOpenByDefault(e) {
    this.gridOptionsService.set("isServerSideGroupOpenByDefault", e);
  }
  setIsApplyServerSideTransaction(e) {
    this.gridOptionsService.set("isApplyServerSideTransaction", e);
  }
  setIsServerSideGroup(e) {
    this.gridOptionsService.set("isServerSideGroup", e);
  }
  setGetServerSideGroupKey(e) {
    this.gridOptionsService.set("getServerSideGroupKey", e);
  }
  setGetRowStyle(e) {
    this.gridOptionsService.set("getRowStyle", e);
  }
  setGetRowHeight(e) {
    this.gridOptionsService.set("getRowHeight", e);
  }
  assertSideBarLoaded(e) {
    return Z.__assertRegistered(Q.SideBarModule, "api." + e, this.context.getGridId());
  }
  /** Returns `true` if the side bar is visible. */
  isSideBarVisible() {
    return this.assertSideBarLoaded("isSideBarVisible") && this.sideBarComp.isDisplayed();
  }
  /** Show/hide the entire side bar, including any visible panel and the tab buttons. */
  setSideBarVisible(e) {
    this.assertSideBarLoaded("setSideBarVisible") && this.sideBarComp.setDisplayed(e);
  }
  /** Sets the side bar position relative to the grid. Possible values are `'left'` or `'right'`. */
  setSideBarPosition(e) {
    this.assertSideBarLoaded("setSideBarPosition") && this.sideBarComp.setSideBarPosition(e);
  }
  /** Opens a particular tool panel. Provide the ID of the tool panel to open. */
  openToolPanel(e) {
    this.assertSideBarLoaded("openToolPanel") && this.sideBarComp.openToolPanel(e, "api");
  }
  /** Closes the currently open tool panel (if any). */
  closeToolPanel() {
    this.assertSideBarLoaded("closeToolPanel") && this.sideBarComp.close("api");
  }
  /** Returns the ID of the currently shown tool panel if any, otherwise `null`. */
  getOpenedToolPanel() {
    return this.assertSideBarLoaded("getOpenedToolPanel") ? this.sideBarComp.openedItem() : null;
  }
  /** Force refresh all tool panels by calling their `refresh` method. */
  refreshToolPanel() {
    this.assertSideBarLoaded("refreshToolPanel") && this.sideBarComp.refresh();
  }
  /** Returns `true` if the tool panel is showing, otherwise `false`. */
  isToolPanelShowing() {
    return this.assertSideBarLoaded("isToolPanelShowing") && this.sideBarComp.isToolPanelShowing();
  }
  /** Gets the tool panel instance corresponding to the supplied `id`. */
  getToolPanelInstance(e) {
    if (this.assertSideBarLoaded("getToolPanelInstance")) {
      const t = this.sideBarComp.getToolPanelInstance(e);
      return ml(t);
    }
  }
  /** Returns the current side bar configuration. If a shortcut was used, returns the detailed long form. */
  getSideBar() {
    if (this.assertSideBarLoaded("getSideBar"))
      return this.sideBarComp.getDef();
  }
  /** Resets the side bar to the provided configuration. The parameter is the same as the sideBar grid property. The side bar is re-created from scratch with the new config. */
  setSideBar(e) {
    this.gridOptionsService.set("sideBar", e);
  }
  setSuppressClipboardPaste(e) {
    this.gridOptionsService.set("suppressClipboardPaste", e);
  }
  /** Tells the grid to recalculate the row heights. */
  resetRowHeights() {
    if (z(this.clientSideRowModel)) {
      if (this.columnModel.isAutoRowHeightActive()) {
        console.warn("AG Grid: calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.");
        return;
      }
      this.clientSideRowModel.resetRowHeights();
    }
  }
  setGroupRemoveSingleChildren(e) {
    this.gridOptionsService.set("groupRemoveSingleChildren", e);
  }
  setGroupRemoveLowestSingleChildren(e) {
    this.gridOptionsService.set("groupRemoveLowestSingleChildren", e);
  }
  setGroupDisplayType(e) {
    this.gridOptionsService.set("groupDisplayType", e);
  }
  setRowClass(e) {
    this.gridOptionsService.set("rowClass", e);
  }
  /** Sets the `deltaSort` property */
  setDeltaSort(e) {
    this.gridOptionsService.set("deltaSort", e);
  }
  /**
   * Sets the `rowCount` and `maxRowFound` properties.
   * The second parameter, `maxRowFound`, is optional and if left out, only `rowCount` is set.
   * Set `rowCount` to adjust the height of the vertical scroll.
   * Set `maxRowFound` to enable / disable searching for more rows.
   * Use this method if you add or remove rows into the dataset and need to reset the number of rows or instruct the grid that the entire row count is no longer known.
   */
  setRowCount(e, t) {
    if (this.serverSideRowModel) {
      if (this.columnModel.isRowGroupEmpty()) {
        this.serverSideRowModel.setRowCount(e, t);
        return;
      }
      console.error("AG Grid: setRowCount cannot be used while using row grouping.");
      return;
    }
    if (this.infiniteRowModel) {
      this.infiniteRowModel.setRowCount(e, t);
      return;
    }
    this.logMissingRowModel("setRowCount", "infinite", "serverSide");
  }
  /** Tells the grid a row height has changed. To be used after calling `rowNode.setRowHeight(newHeight)`. */
  onRowHeightChanged() {
    this.clientSideRowModel ? this.clientSideRowModel.onRowHeightChanged() : this.serverSideRowModel && this.serverSideRowModel.onRowHeightChanged();
  }
  /**
   * Gets the value for a column for a particular `rowNode` (row).
   * This is useful if you want the raw value of a cell e.g. if implementing your own CSV export.
   */
  getValue(e, t) {
    let i = this.columnModel.getPrimaryColumn(e);
    return Se(i) && (i = this.columnModel.getGridColumn(e)), Se(i) ? null : this.valueService.getValue(i, t);
  }
  /** Add an event listener for the specified `eventType`. Works similar to `addEventListener` for a browser DOM element. */
  addEventListener(e, t) {
    const i = this.gridOptionsService.useAsyncEvents();
    this.eventService.addEventListener(e, t, i);
  }
  /** Add an event listener for all event types coming from the grid. */
  addGlobalListener(e) {
    const t = this.gridOptionsService.useAsyncEvents();
    this.eventService.addGlobalListener(e, t);
  }
  /** Remove an event listener. */
  removeEventListener(e, t) {
    const i = this.gridOptionsService.useAsyncEvents();
    this.eventService.removeEventListener(e, t, i);
  }
  /** Remove a global event listener. */
  removeGlobalListener(e) {
    const t = this.gridOptionsService.useAsyncEvents();
    this.eventService.removeGlobalListener(e, t);
  }
  dispatchEvent(e) {
    this.eventService.dispatchEvent(e);
  }
  /** Will destroy the grid and release resources. If you are using a framework you do not need to call this, as the grid links in with the framework lifecycle. However if you are using Web Components or native JavaScript, you do need to call this, to avoid a memory leak in your application. */
  destroy() {
    if (this.destroyCalled)
      return;
    this.destroyCalled = !0;
    const e = this.ctrlsService.getGridCtrl();
    e && e.destroyGridUi(), this.context.destroy();
  }
  cleanDownReferencesToAvoidMemoryLeakInCaseApplicationIsKeepingReferenceToDestroyedGrid() {
    setTimeout(BR.bind(window, this, "Grid API"), 100);
  }
  warnIfDestroyed(e) {
    return this.destroyCalled && console.warn(`AG Grid: Grid API method ${e} was called on a grid that was destroyed.`), this.destroyCalled;
  }
  /** Reset the Quick Filter cache text on every rowNode. */
  resetQuickFilter() {
    this.warnIfDestroyed("resetQuickFilter") || this.filterManager.resetQuickFilterCache();
  }
  /** Returns the list of selected cell ranges. */
  getCellRanges() {
    return this.rangeService ? this.rangeService.getCellRanges() : (Z.__assertRegistered(Q.RangeSelectionModule, "api.getCellRanges", this.context.getGridId()), null);
  }
  /** Adds the provided cell range to the selected ranges. */
  addCellRange(e) {
    if (this.rangeService) {
      this.rangeService.addCellRange(e);
      return;
    }
    Z.__assertRegistered(Q.RangeSelectionModule, "api.addCellRange", this.context.getGridId());
  }
  /** Clears the selected ranges. */
  clearRangeSelection() {
    this.rangeService && this.rangeService.removeAllCellRanges(), Z.__assertRegistered(Q.RangeSelectionModule, "gridApi.clearRangeSelection", this.context.getGridId());
  }
  /** Reverts the last cell edit. */
  undoCellEditing() {
    this.undoRedoService.undo("api");
  }
  /** Re-applies the most recently undone cell edit. */
  redoCellEditing() {
    this.undoRedoService.redo("api");
  }
  /** Returns current number of available cell edit undo operations. */
  getCurrentUndoSize() {
    return this.undoRedoService.getCurrentUndoStackSize();
  }
  /** Returns current number of available cell edit redo operations. */
  getCurrentRedoSize() {
    return this.undoRedoService.getCurrentRedoStackSize();
  }
  /** Returns a list of models with information about the charts that are currently rendered from the grid. */
  getChartModels() {
    if (Z.__assertRegistered(Q.GridChartsModule, "api.getChartModels", this.context.getGridId()))
      return this.chartService.getChartModels();
  }
  /** Returns the `ChartRef` using the supplied `chartId`. */
  getChartRef(e) {
    if (Z.__assertRegistered(Q.GridChartsModule, "api.getChartRef", this.context.getGridId()))
      return this.chartService.getChartRef(e);
  }
  /** Returns a base64-encoded image data URL for the referenced chartId. */
  getChartImageDataURL(e) {
    if (Z.__assertRegistered(Q.GridChartsModule, "api.getChartImageDataURL", this.context.getGridId()))
      return this.chartService.getChartImageDataURL(e);
  }
  /** Starts a browser-based image download for the referenced chartId. */
  downloadChart(e) {
    if (Z.__assertRegistered(Q.GridChartsModule, "api.downloadChart", this.context.getGridId()))
      return this.chartService.downloadChart(e);
  }
  /** Open the Chart Tool Panel. */
  openChartToolPanel(e) {
    if (Z.__assertRegistered(Q.GridChartsModule, "api.openChartToolPanel", this.context.getGridId()))
      return this.chartService.openChartToolPanel(e);
  }
  /** Close the Chart Tool Panel. */
  closeChartToolPanel(e) {
    if (Z.__assertRegistered(Q.GridChartsModule, "api.closeChartToolPanel", this.context.getGridId()))
      return this.chartService.closeChartToolPanel(e.chartId);
  }
  /** Used to programmatically create charts from a range. */
  createRangeChart(e) {
    if (Z.__assertRegistered(Q.GridChartsModule, "api.createRangeChart", this.context.getGridId()))
      return this.chartService.createRangeChart(e);
  }
  /** Used to programmatically create pivot charts from a grid. */
  createPivotChart(e) {
    if (Z.__assertRegistered(Q.GridChartsModule, "api.createPivotChart", this.context.getGridId()))
      return this.chartService.createPivotChart(e);
  }
  /** Used to programmatically create cross filter charts from a range. */
  createCrossFilterChart(e) {
    if (Z.__assertRegistered(Q.GridChartsModule, "api.createCrossFilterChart", this.context.getGridId()))
      return this.chartService.createCrossFilterChart(e);
  }
  /** Used to programmatically update a chart. */
  updateChart(e) {
    Z.__assertRegistered(Q.GridChartsModule, "api.updateChart", this.context.getGridId()) && this.chartService.updateChart(e);
  }
  /** Restores a chart using the `ChartModel` that was previously obtained from `getChartModels()`. */
  restoreChart(e, t) {
    if (Z.__assertRegistered(Q.GridChartsModule, "api.restoreChart", this.context.getGridId()))
      return this.chartService.restoreChart(e, t);
  }
  /** Copies data to clipboard by following the same rules as pressing Ctrl+C. */
  copyToClipboard(e) {
    Z.__assertRegistered(Q.ClipboardModule, "api.copyToClipboard", this.context.getGridId()) && this.clipboardService.copyToClipboard(e);
  }
  /** Cuts data to clipboard by following the same rules as pressing Ctrl+X. */
  cutToClipboard(e) {
    Z.__assertRegistered(Q.ClipboardModule, "api.cutToClipboard", this.context.getGridId()) && this.clipboardService.cutToClipboard(e, "api");
  }
  /** Copies the selected rows to the clipboard. */
  copySelectedRowsToClipboard(e) {
    Z.__assertRegistered(Q.ClipboardModule, "api.copySelectedRowsToClipboard", this.context.getGridId()) && this.clipboardService.copySelectedRowsToClipboard(e);
  }
  /** Copies the selected ranges to the clipboard. */
  copySelectedRangeToClipboard(e) {
    Z.__assertRegistered(Q.ClipboardModule, "api.copySelectedRangeToClipboard", this.context.getGridId()) && this.clipboardService.copySelectedRangeToClipboard(e);
  }
  /** Copies the selected range down, similar to `Ctrl + D` in Excel. */
  copySelectedRangeDown() {
    Z.__assertRegistered(Q.ClipboardModule, "api.copySelectedRangeDown", this.context.getGridId()) && this.clipboardService.copyRangeDown();
  }
  /** Pastes the data from the Clipboard into the focused cell of the grid. If no grid cell is focused, calling this method has no effect. */
  pasteFromClipboard() {
    Z.__assertRegistered(Q.ClipboardModule, "api.pasteFromClipboard", this.context.getGridId()) && this.clipboardService.pasteFromClipboard();
  }
  /** Shows the column menu after and positions it relative to the provided button element. Use in conjunction with your own header template. */
  showColumnMenuAfterButtonClick(e, t) {
    const i = this.columnModel.getGridColumn(e);
    this.menuFactory.showMenuAfterButtonClick(i, t, "columnMenu");
  }
  /** Shows the column menu after and positions it relative to the mouse event. Use in conjunction with your own header template. */
  showColumnMenuAfterMouseClick(e, t) {
    let i = this.columnModel.getGridColumn(e);
    if (i || (i = this.columnModel.getPrimaryColumn(e)), !i) {
      console.error(`AG Grid: column '${e}' not found`);
      return;
    }
    this.menuFactory.showMenuAfterMouseEvent(i, t);
  }
  /** Hides any visible context menu or column menu. */
  hidePopupMenu() {
    this.contextMenuFactory && this.contextMenuFactory.hideActiveMenu(), this.menuFactory.hideActiveMenu();
  }
  /** DOM element to use as the popup parent for grid popups (context menu, column menu etc). */
  setPopupParent(e) {
    this.gridOptionsService.set("popupParent", e);
  }
  /** Navigates the grid focus to the next cell, as if tabbing. */
  tabToNextCell(e) {
    return this.navigationService.tabToNextCell(!1, e);
  }
  /** Navigates the grid focus to the previous cell, as if shift-tabbing. */
  tabToPreviousCell(e) {
    return this.navigationService.tabToNextCell(!0, e);
  }
  /** Returns the list of active cell renderer instances. */
  getCellRendererInstances(e = {}) {
    return this.rowRenderer.getCellRendererInstances(e).map(ml);
  }
  /** Returns the list of active cell editor instances. Optionally provide parameters to restrict to certain columns / row nodes. */
  getCellEditorInstances(e = {}) {
    return this.rowRenderer.getCellEditorInstances(e).map(ml);
  }
  /** If the grid is editing, returns back details of the editing cell(s). */
  getEditingCells() {
    return this.rowRenderer.getEditingCells();
  }
  /** If a cell is editing, it stops the editing. Pass `true` if you want to cancel the editing (i.e. don't accept changes). */
  stopEditing(e = !1) {
    this.rowRenderer.stopEditing(e);
  }
  /** Start editing the provided cell. If another cell is editing, the editing will be stopped in that other cell. */
  startEditingCell(e) {
    const t = this.columnModel.getGridColumn(e.colKey);
    if (!t) {
      console.warn(`AG Grid: no column found for ${e.colKey}`);
      return;
    }
    const i = {
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned || null,
      column: t
    };
    e.rowPinned == null && this.gridBodyCtrl.getScrollFeature().ensureIndexVisible(e.rowIndex);
    const n = this.navigationService.getCellByPosition(i);
    n && n.startRowOrCellEdit(e.key);
  }
  /** Add an aggregation function with the specified key. */
  addAggFunc(e, t) {
    this.aggFuncService && this.aggFuncService.addAggFunc(e, t);
  }
  /** Add aggregations function with the specified keys. */
  addAggFuncs(e) {
    this.aggFuncService && this.aggFuncService.addAggFuncs(e);
  }
  /** Clears all aggregation functions (including those provided by the grid). */
  clearAggFuncs() {
    this.aggFuncService && this.aggFuncService.clear();
  }
  /** Apply transactions to the server side row model. */
  applyServerSideTransaction(e) {
    if (!this.serverSideTransactionManager) {
      this.logMissingRowModel("applyServerSideTransaction", "serverSide");
      return;
    }
    return this.serverSideTransactionManager.applyTransaction(e);
  }
  /** Batch apply transactions to the server side row model. */
  applyServerSideTransactionAsync(e, t) {
    if (!this.serverSideTransactionManager) {
      this.logMissingRowModel("applyServerSideTransactionAsync", "serverSide");
      return;
    }
    return this.serverSideTransactionManager.applyTransactionAsync(e, t);
  }
  /** Gets all failed server side loads to retry. */
  retryServerSideLoads() {
    if (!this.serverSideRowModel) {
      this.logMissingRowModel("retryServerSideLoads", "serverSide");
      return;
    }
    this.serverSideRowModel.retryLoads();
  }
  flushServerSideAsyncTransactions() {
    if (!this.serverSideTransactionManager) {
      this.logMissingRowModel("flushServerSideAsyncTransactions", "serverSide");
      return;
    }
    return this.serverSideTransactionManager.flushAsyncTransactions();
  }
  /** Update row data. Pass a transaction object with lists for `add`, `remove` and `update`. */
  applyTransaction(e) {
    if (!this.clientSideRowModel) {
      this.logMissingRowModel("applyTransaction", "clientSide");
      return;
    }
    return this.clientSideRowModel.updateRowData(e);
  }
  /** Same as `applyTransaction` except executes asynchronously for efficiency. */
  applyTransactionAsync(e, t) {
    if (!this.clientSideRowModel) {
      this.logMissingRowModel("applyTransactionAsync", "clientSide");
      return;
    }
    this.clientSideRowModel.batchUpdateRowData(e, t);
  }
  /** Executes any remaining asynchronous grid transactions, if any are waiting to be executed. */
  flushAsyncTransactions() {
    if (!this.clientSideRowModel) {
      this.logMissingRowModel("flushAsyncTransactions", "clientSide");
      return;
    }
    this.clientSideRowModel.flushAsyncTransactions();
  }
  setSuppressModelUpdateAfterUpdateTransaction(e) {
    this.gridOptionsService.set("suppressModelUpdateAfterUpdateTransaction", e);
  }
  /**
   * Marks all the currently loaded blocks in the cache for reload.
   * If you have 10 blocks in the cache, all 10 will be marked for reload.
   * The old data will continue to be displayed until the new data is loaded.
   */
  refreshInfiniteCache() {
    this.infiniteRowModel ? this.infiniteRowModel.refreshCache() : this.logMissingRowModel("refreshInfiniteCache", "infinite");
  }
  /**
   * Purges the cache.
   * The grid is then told to refresh. Only the blocks required to display the current data on screen are fetched (typically no more than 2).
   * The grid will display nothing while the new blocks are loaded.
   * Use this to immediately remove the old data from the user.
   */
  purgeInfiniteCache() {
    this.infiniteRowModel ? this.infiniteRowModel.purgeCache() : this.logMissingRowModel("purgeInfiniteCache", "infinite");
  }
  /**
   * Refresh a server-side store level.
   * If you pass no parameters, then the top level store is refreshed.
   * To refresh a child level, pass in the string of keys to get to the desired level.
   * Once the store refresh is complete, the storeRefreshed event is fired.
   */
  refreshServerSide(e) {
    if (!this.serverSideRowModel) {
      this.logMissingRowModel("refreshServerSide", "serverSide");
      return;
    }
    this.serverSideRowModel.refreshStore(e);
  }
  /** @deprecated v28 use `refreshServerSide` instead */
  refreshServerSideStore(e) {
    return rn("28.0", "refreshServerSideStore", "refreshServerSide"), this.refreshServerSide(e);
  }
  /** @deprecated v28 use `getServerSideGroupLevelState` instead */
  getServerSideStoreState() {
    return rn("28.0", "getServerSideStoreState", "getServerSideGroupLevelState"), this.getServerSideGroupLevelState();
  }
  /** Returns info on all server side group levels. */
  getServerSideGroupLevelState() {
    return this.serverSideRowModel ? this.serverSideRowModel.getStoreState() : (this.logMissingRowModel("getServerSideGroupLevelState", "serverSide"), []);
  }
  /** The row count defines how many rows the grid allows scrolling to. */
  getInfiniteRowCount() {
    if (this.infiniteRowModel)
      return this.infiniteRowModel.getRowCount();
    this.logMissingRowModel("getInfiniteRowCount", "infinite");
  }
  /** Returns `true` if grid allows for scrolling past the last row to load more rows, thus providing infinite scroll. */
  isLastRowIndexKnown() {
    if (this.infiniteRowModel)
      return this.infiniteRowModel.isLastRowIndexKnown();
    this.logMissingRowModel("isLastRowIndexKnown", "infinite");
  }
  /**
   * Returns an object representing the state of the cache. This is useful for debugging and understanding how the cache is working.
   */
  getCacheBlockState() {
    return this.rowNodeBlockLoader.getBlockState();
  }
  /** Get the index of the first displayed row due to scrolling (includes invisible rendered rows in the buffer). */
  getFirstDisplayedRow() {
    return this.rowRenderer.getFirstVirtualRenderedRow();
  }
  /** Get the index of the last displayed row due to scrolling (includes invisible rendered rows in the buffer). */
  getLastDisplayedRow() {
    return this.rowRenderer.getLastVirtualRenderedRow();
  }
  /** Returns the displayed `RowNode` at the given `index`. */
  getDisplayedRowAtIndex(e) {
    return this.rowModel.getRow(e);
  }
  /** Returns the total number of displayed rows. */
  getDisplayedRowCount() {
    return this.rowModel.getRowCount();
  }
  /** Resets the data type definitions. This will update the columns in the grid. */
  setDataTypeDefinitions(e) {
    this.gridOptionsService.set("dataTypeDefinitions", e);
  }
  /**
   * Set whether the grid paginates the data or not.
   *  - `true` to enable pagination
   *  - `false` to disable pagination
   */
  setPagination(e) {
    this.gridOptionsService.set("pagination", e);
  }
  /**
   * Returns `true` when the last page is known.
   * This will always be `true` if you are using the Client-Side Row Model for pagination.
   * Returns `false` when the last page is not known; this only happens when using Infinite Row Model.
   */
  paginationIsLastPageFound() {
    return this.paginationProxy.isLastPageFound();
  }
  /** Returns how many rows are being shown per page. */
  paginationGetPageSize() {
    return this.paginationProxy.getPageSize();
  }
  /** Sets the `paginationPageSize`, then re-paginates the grid so the changes are applied immediately. */
  paginationSetPageSize(e) {
    this.gridOptionsService.set("paginationPageSize", e);
  }
  /** Returns the 0-based index of the page which is showing. */
  paginationGetCurrentPage() {
    return this.paginationProxy.getCurrentPage();
  }
  /** Returns the total number of pages. Returns `null` if `paginationIsLastPageFound() === false`. */
  paginationGetTotalPages() {
    return this.paginationProxy.getTotalPages();
  }
  /** The total number of rows. Returns `null` if `paginationIsLastPageFound() === false`. */
  paginationGetRowCount() {
    return this.paginationProxy.getMasterRowCount();
  }
  /** Navigates to the next page. */
  paginationGoToNextPage() {
    this.paginationProxy.goToNextPage();
  }
  /** Navigates to the previous page. */
  paginationGoToPreviousPage() {
    this.paginationProxy.goToPreviousPage();
  }
  /** Navigates to the first page. */
  paginationGoToFirstPage() {
    this.paginationProxy.goToFirstPage();
  }
  /** Navigates to the last page. */
  paginationGoToLastPage() {
    this.paginationProxy.goToLastPage();
  }
  /** Goes to the specified page. If the page requested doesn't exist, it will go to the last page. */
  paginationGoToPage(e) {
    this.paginationProxy.goToPage(e);
  }
};
it([
  Ve("immutableService")
], Ye.prototype, "immutableService", void 0);
it([
  Ve("csvCreator")
], Ye.prototype, "csvCreator", void 0);
it([
  Ve("excelCreator")
], Ye.prototype, "excelCreator", void 0);
it([
  S("rowRenderer")
], Ye.prototype, "rowRenderer", void 0);
it([
  S("navigationService")
], Ye.prototype, "navigationService", void 0);
it([
  S("filterManager")
], Ye.prototype, "filterManager", void 0);
it([
  S("columnModel")
], Ye.prototype, "columnModel", void 0);
it([
  S("selectionService")
], Ye.prototype, "selectionService", void 0);
it([
  S("gridOptionsService")
], Ye.prototype, "gridOptionsService", void 0);
it([
  S("valueService")
], Ye.prototype, "valueService", void 0);
it([
  S("alignedGridsService")
], Ye.prototype, "alignedGridsService", void 0);
it([
  S("eventService")
], Ye.prototype, "eventService", void 0);
it([
  S("pinnedRowModel")
], Ye.prototype, "pinnedRowModel", void 0);
it([
  S("context")
], Ye.prototype, "context", void 0);
it([
  S("rowModel")
], Ye.prototype, "rowModel", void 0);
it([
  S("sortController")
], Ye.prototype, "sortController", void 0);
it([
  S("paginationProxy")
], Ye.prototype, "paginationProxy", void 0);
it([
  S("focusService")
], Ye.prototype, "focusService", void 0);
it([
  S("dragAndDropService")
], Ye.prototype, "dragAndDropService", void 0);
it([
  Ve("rangeService")
], Ye.prototype, "rangeService", void 0);
it([
  Ve("clipboardService")
], Ye.prototype, "clipboardService", void 0);
it([
  Ve("aggFuncService")
], Ye.prototype, "aggFuncService", void 0);
it([
  S("menuFactory")
], Ye.prototype, "menuFactory", void 0);
it([
  Ve("contextMenuFactory")
], Ye.prototype, "contextMenuFactory", void 0);
it([
  S("valueCache")
], Ye.prototype, "valueCache", void 0);
it([
  S("animationFrameService")
], Ye.prototype, "animationFrameService", void 0);
it([
  Ve("statusBarService")
], Ye.prototype, "statusBarService", void 0);
it([
  Ve("chartService")
], Ye.prototype, "chartService", void 0);
it([
  Ve("undoRedoService")
], Ye.prototype, "undoRedoService", void 0);
it([
  Ve("rowNodeBlockLoader")
], Ye.prototype, "rowNodeBlockLoader", void 0);
it([
  Ve("ssrmTransactionManager")
], Ye.prototype, "serverSideTransactionManager", void 0);
it([
  S("ctrlsService")
], Ye.prototype, "ctrlsService", void 0);
it([
  B
], Ye.prototype, "init", null);
it([
  dt
], Ye.prototype, "cleanDownReferencesToAvoidMemoryLeakInCaseApplicationIsKeepingReferenceToDestroyedGrid", null);
Ye = it([
  q("gridApi")
], Ye);
var oc = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, DC;
let Oo = DC = class extends H {
  constructor() {
    super(...arguments), this.allColumnFilters = /* @__PURE__ */ new Map(), this.allColumnListeners = /* @__PURE__ */ new Map(), this.activeAggregateFilters = [], this.activeColumnFilters = [], this.quickFilter = null, this.quickFilterParts = null, this.processingFilterChange = !1;
  }
  init() {
    this.addManagedListener(this.eventService, w.EVENT_GRID_COLUMNS_CHANGED, () => this.onColumnsChanged()), this.addManagedListener(this.eventService, w.EVENT_COLUMN_VALUE_CHANGED, () => this.refreshFiltersForAggregations()), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_CHANGED, () => this.refreshFiltersForAggregations()), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_MODE_CHANGED, () => {
      this.refreshFiltersForAggregations(), this.resetQuickFilterCache();
    }), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, () => this.resetQuickFilterCache()), this.addManagedListener(this.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.resetQuickFilterCache()), this.addManagedListener(this.eventService, w.EVENT_COLUMN_VISIBLE, () => {
      this.gridOptionsService.is("includeHiddenColumnsInQuickFilter") || this.resetQuickFilterCache();
    }), this.addManagedPropertyListener("quickFilterText", (e) => this.setQuickFilter(e.currentValue)), this.addManagedPropertyListener("includeHiddenColumnsInQuickFilter", () => this.onIncludeHiddenColumnsInQuickFilterChanged()), this.quickFilter = this.parseQuickFilter(this.gridOptionsService.get("quickFilterText")), this.setQuickFilterParts(), this.allowShowChangeAfterFilter = this.gridOptionsService.is("allowShowChangeAfterFilter"), this.externalFilterPresent = this.isExternalFilterPresentCallback(), this.updateAggFiltering(), this.addManagedPropertyListener("groupAggFiltering", () => this.updateAggFiltering());
  }
  isExternalFilterPresentCallback() {
    const e = this.gridOptionsService.getCallback("isExternalFilterPresent");
    return typeof e == "function" ? e({}) : !1;
  }
  doesExternalFilterPass(e) {
    const t = this.gridOptionsService.get("doesExternalFilterPass");
    return typeof t == "function" ? t(e) : !1;
  }
  setQuickFilterParts() {
    this.quickFilterParts = this.quickFilter ? this.quickFilter.split(" ") : null;
  }
  setFilterModel(e) {
    const t = [], i = this.getFilterModel();
    if (e) {
      const r = US(Object.keys(e));
      this.allColumnFilters.forEach((n, s) => {
        const a = e[s];
        t.push(this.setModelOnFilterWrapper(n.filterPromise, a)), r.delete(s);
      }), r.forEach((n) => {
        const s = this.columnModel.getPrimaryColumn(n) || this.columnModel.getGridColumn(n);
        if (!s) {
          console.warn("AG Grid: setFilterModel() - no column found for colId: " + n);
          return;
        }
        if (!s.isFilterAllowed()) {
          console.warn("AG Grid: setFilterModel() - unable to fully apply model, filtering disabled for colId: " + n);
          return;
        }
        const a = this.getOrCreateFilterWrapper(s, "NO_UI");
        if (!a) {
          console.warn("AG-Grid: setFilterModel() - unable to fully apply model, unable to create filter for colId: " + n);
          return;
        }
        t.push(this.setModelOnFilterWrapper(a.filterPromise, e[n]));
      });
    } else
      this.allColumnFilters.forEach((r) => {
        t.push(this.setModelOnFilterWrapper(r.filterPromise, null));
      });
    Qe.all(t).then(() => {
      const r = this.getFilterModel(), n = [];
      this.allColumnFilters.forEach((s, a) => {
        const l = i ? i[a] : null, c = r ? r[a] : null;
        x.jsonEquals(l, c) || n.push(s.column);
      }), n.length > 0 && this.onFilterChanged({ columns: n });
    });
  }
  setModelOnFilterWrapper(e, t) {
    return new Qe((i) => {
      e.then((r) => {
        typeof r.setModel != "function" && (console.warn("AG Grid: filter missing setModel method, which is needed for setFilterModel"), i()), (r.setModel(t) || Qe.resolve()).then(() => i());
      });
    });
  }
  getFilterModel() {
    const e = {};
    return this.allColumnFilters.forEach((t, i) => {
      const n = t.filterPromise.resolveNow(null, (a) => a);
      if (n == null)
        return null;
      if (typeof n.getModel != "function") {
        console.warn("AG Grid: filter API missing getModel method, which is needed for getFilterModel");
        return;
      }
      const s = n.getModel();
      z(s) && (e[i] = s);
    }), e;
  }
  isColumnFilterPresent() {
    return this.activeColumnFilters.length > 0;
  }
  isAggregateFilterPresent() {
    return !!this.activeAggregateFilters.length;
  }
  isExternalFilterPresent() {
    return this.externalFilterPresent;
  }
  doAggregateFiltersPass(e, t) {
    return this.doColumnFiltersPass(e, t, !0);
  }
  // called by:
  // 1) onFilterChanged()
  // 2) onNewRowsLoaded()
  updateActiveFilters() {
    this.activeColumnFilters.length = 0, this.activeAggregateFilters.length = 0;
    const e = (r) => r ? r.isFilterActive ? r.isFilterActive() : (console.warn("AG Grid: Filter is missing isFilterActive() method"), !1) : !1, t = !!this.gridOptionsService.getGroupAggFiltering(), i = (r) => {
      if (!r.isPrimary())
        return !0;
      const s = !this.columnModel.isPivotActive();
      return !r.isValueActive() || !s ? !1 : this.columnModel.isPivotMode() ? !0 : t;
    };
    this.allColumnFilters.forEach((r) => {
      if (r.filterPromise.resolveNow(!1, e)) {
        const n = r.filterPromise.resolveNow(null, (s) => s);
        i(r.column) ? this.activeAggregateFilters.push(n) : this.activeColumnFilters.push(n);
      }
    });
  }
  updateFilterFlagInColumns(e, t) {
    this.allColumnFilters.forEach((i) => {
      const r = i.filterPromise.resolveNow(!1, (n) => n.isFilterActive());
      i.column.setFilterActive(r, e, t);
    });
  }
  isAnyFilterPresent() {
    return this.isQuickFilterPresent() || this.isColumnFilterPresent() || this.isAggregateFilterPresent() || this.isExternalFilterPresent();
  }
  doColumnFiltersPass(e, t, i) {
    const { data: r, aggData: n } = e, s = i ? this.activeAggregateFilters : this.activeColumnFilters, a = i ? n : r;
    for (let l = 0; l < s.length; l++) {
      const c = s[l];
      if (!(c == null || c === t)) {
        if (typeof c.doesFilterPass != "function")
          throw new Error("Filter is missing method doesFilterPass");
        if (!c.doesFilterPass({ node: e, data: a }))
          return !1;
      }
    }
    return !0;
  }
  parseQuickFilter(e) {
    return z(e) ? this.gridOptionsService.isRowModelType("clientSide") ? e.toUpperCase() : (console.warn("AG Grid - Quick filtering only works with the Client-Side Row Model"), null) : null;
  }
  setQuickFilter(e) {
    if (e != null && typeof e != "string") {
      console.warn(`AG Grid - setQuickFilter() only supports string inputs, received: ${typeof e}`);
      return;
    }
    const t = this.parseQuickFilter(e);
    this.quickFilter !== t && (this.quickFilter = t, this.setQuickFilterParts(), this.onFilterChanged());
  }
  resetQuickFilterCache() {
    this.rowModel.forEachNode((e) => e.quickFilterAggregateText = null);
  }
  onIncludeHiddenColumnsInQuickFilterChanged() {
    this.columnModel.refreshQuickFilterColumns(), this.resetQuickFilterCache(), this.isQuickFilterPresent() && this.onFilterChanged();
  }
  refreshFiltersForAggregations() {
    this.gridOptionsService.getGroupAggFiltering() && this.onFilterChanged();
  }
  // sometimes (especially in React) the filter can call onFilterChanged when we are in the middle
  // of a render cycle. this would be bad, so we wait for render cycle to complete when this happens.
  // this happens in react when we change React State in the grid (eg setting RowCtrl's in RowContainer)
  // which results in React State getting applied in the main application, triggering a useEffect() to
  // be kicked off adn then the application calling the grid's API. in AG-6554, the custom filter was
  // getting it's useEffect() triggered in this way.
  callOnFilterChangedOutsideRenderCycle(e = {}) {
    const t = () => this.onFilterChanged(e);
    this.rowRenderer.isRefreshInProgress() ? setTimeout(t, 0) : t();
  }
  onFilterChanged(e = {}) {
    const { filterInstance: t, additionalEventAttributes: i, columns: r } = e;
    this.updateDependantFilters(), this.updateActiveFilters(), this.updateFilterFlagInColumns("filterChanged", i), this.externalFilterPresent = this.isExternalFilterPresentCallback(), this.allColumnFilters.forEach((s) => {
      s.filterPromise && s.filterPromise.then((a) => {
        a && a !== t && a.onAnyFilterChanged && a.onAnyFilterChanged();
      });
    });
    const n = {
      type: w.EVENT_FILTER_CHANGED,
      columns: r || []
    };
    i && Tr(n, i), this.processingFilterChange = !0, this.eventService.dispatchEvent(n), this.processingFilterChange = !1;
  }
  isSuppressFlashingCellsBecauseFiltering() {
    return !this.allowShowChangeAfterFilter && this.processingFilterChange;
  }
  isQuickFilterPresent() {
    return this.quickFilter !== null;
  }
  updateAggFiltering() {
    this.aggFiltering = !!this.gridOptionsService.getGroupAggFiltering();
  }
  isAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && (this.aggFiltering || this.columnModel.isPivotMode());
  }
  isNonAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && !(this.aggFiltering || this.columnModel.isPivotMode());
  }
  doesRowPassOtherFilters(e, t) {
    return this.doesRowPassFilter({ rowNode: t, filterInstanceToSkip: e });
  }
  doesRowPassQuickFilterNoCache(e, t) {
    return this.columnModel.getAllColumnsForQuickFilter().some((r) => {
      const n = this.getQuickFilterTextForColumn(r, e);
      return z(n) && n.indexOf(t) >= 0;
    });
  }
  doesRowPassQuickFilterCache(e, t) {
    return e.quickFilterAggregateText || this.aggregateRowForQuickFilter(e), e.quickFilterAggregateText.indexOf(t) >= 0;
  }
  doesRowPassQuickFilter(e) {
    const t = this.gridOptionsService.is("cacheQuickFilter");
    return this.quickFilterParts.every((i) => t ? this.doesRowPassQuickFilterCache(e, i) : this.doesRowPassQuickFilterNoCache(e, i));
  }
  doesRowPassAggregateFilters(e) {
    return !(this.isAggregateQuickFilterPresent() && !this.doesRowPassQuickFilter(e.rowNode) || this.isAggregateFilterPresent() && !this.doAggregateFiltersPass(e.rowNode, e.filterInstanceToSkip));
  }
  doesRowPassFilter(e) {
    return !(this.isNonAggregateQuickFilterPresent() && !this.doesRowPassQuickFilter(e.rowNode) || this.isExternalFilterPresent() && !this.doesExternalFilterPass(e.rowNode) || this.isColumnFilterPresent() && !this.doColumnFiltersPass(e.rowNode, e.filterInstanceToSkip));
  }
  getQuickFilterTextForColumn(e, t) {
    let i = this.valueService.getValue(e, t, !0);
    const r = e.getColDef();
    if (r.getQuickFilterText) {
      const n = {
        value: i,
        node: t,
        data: t.data,
        column: e,
        colDef: r,
        api: this.gridOptionsService.api,
        columnApi: this.gridOptionsService.columnApi,
        context: this.gridOptionsService.context
      };
      i = r.getQuickFilterText(n);
    }
    return z(i) ? i.toString().toUpperCase() : null;
  }
  aggregateRowForQuickFilter(e) {
    const t = [];
    this.columnModel.getAllColumnsForQuickFilter().forEach((r) => {
      const n = this.getQuickFilterTextForColumn(r, e);
      z(n) && t.push(n);
    }), e.quickFilterAggregateText = t.join(DC.QUICK_FILTER_SEPARATOR);
  }
  onNewRowsLoaded(e) {
    this.allColumnFilters.forEach((t) => {
      t.filterPromise.then((i) => {
        i.onNewRowsLoaded && i.onNewRowsLoaded();
      });
    }), this.updateFilterFlagInColumns(e, { afterDataChange: !0 }), this.updateActiveFilters();
  }
  createValueGetter(e) {
    return ({ node: t }) => this.valueService.getValue(e, t, !0);
  }
  getFilterComponent(e, t, i = !0) {
    var r;
    if (i)
      return ((r = this.getOrCreateFilterWrapper(e, t)) === null || r === void 0 ? void 0 : r.filterPromise) || null;
    const n = this.cachedFilter(e);
    return n ? n.filterPromise : null;
  }
  isFilterActive(e) {
    const t = this.cachedFilter(e);
    return !!t && t.filterPromise.resolveNow(!1, (i) => i.isFilterActive());
  }
  getOrCreateFilterWrapper(e, t) {
    if (!e.isFilterAllowed())
      return null;
    let i = this.cachedFilter(e);
    if (i)
      t !== "NO_UI" && this.putIntoGui(i, t);
    else {
      i = this.createFilterWrapper(e, t);
      const r = e.getColId();
      this.allColumnFilters.set(r, i), this.allColumnListeners.set(r, this.addManagedListener(e, me.EVENT_COL_DEF_CHANGED, () => this.checkDestroyFilter(r)));
    }
    return i;
  }
  cachedFilter(e) {
    return this.allColumnFilters.get(e.getColId());
  }
  getDefaultFilter(e) {
    let t;
    if (Z.__isRegistered(Q.SetFilterModule, this.context.getGridId()))
      t = "agSetColumnFilter";
    else {
      const i = e.getColDef().cellDataType;
      i === "number" ? t = "agNumberColumnFilter" : i === "date" || i === "dateString" ? t = "agDateColumnFilter" : t = "agTextColumnFilter";
    }
    return t;
  }
  getDefaultFloatingFilter(e) {
    let t;
    if (Z.__isRegistered(Q.SetFilterModule, this.context.getGridId()))
      t = "agSetColumnFloatingFilter";
    else {
      const i = e.getColDef().cellDataType;
      i === "number" ? t = "agNumberColumnFloatingFilter" : i === "date" || i === "dateString" ? t = "agDateColumnFloatingFilter" : t = "agTextColumnFloatingFilter";
    }
    return t;
  }
  createFilterInstance(e) {
    const t = this.getDefaultFilter(e), i = e.getColDef();
    let r;
    const n = Object.assign(Object.assign({}, this.createFilterParams(e, i)), { filterModifiedCallback: () => {
      const a = {
        type: w.EVENT_FILTER_MODIFIED,
        column: e,
        filterInstance: r
      };
      this.eventService.dispatchEvent(a);
    }, filterChangedCallback: (a) => {
      const l = { filterInstance: r, additionalEventAttributes: a, columns: [e] };
      this.callOnFilterChangedOutsideRenderCycle(l);
    }, doesRowPassOtherFilter: (a) => this.doesRowPassOtherFilters(r, a) }), s = this.userComponentFactory.getFilterDetails(i, n, t);
    return s ? {
      filterPromise: () => {
        const a = s.newAgStackInstance();
        return a && a.then((l) => r = l), a;
      },
      compDetails: s
    } : { filterPromise: null, compDetails: null };
  }
  createFilterParams(e, t) {
    return {
      column: e,
      colDef: mS(t),
      rowModel: this.rowModel,
      filterChangedCallback: () => {
      },
      filterModifiedCallback: () => {
      },
      valueGetter: this.createValueGetter(e),
      doesRowPassOtherFilter: () => !0,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context
    };
  }
  createFilterWrapper(e, t) {
    var i;
    const r = {
      column: e,
      filterPromise: null,
      compiledElement: null,
      guiPromise: Qe.resolve(null),
      compDetails: null
    }, { filterPromise: n, compDetails: s } = this.createFilterInstance(e);
    return r.filterPromise = (i = n == null ? void 0 : n()) !== null && i !== void 0 ? i : null, r.compDetails = s, n && this.putIntoGui(r, t), r;
  }
  putIntoGui(e, t) {
    const i = document.createElement("div");
    i.className = "ag-filter", e.guiPromise = new Qe((r) => {
      e.filterPromise.then((n) => {
        let s = n.getGui();
        z(s) || console.warn(`AG Grid: getGui method from filter returned ${s}, it should be a DOM element or an HTML template string.`), typeof s == "string" && (s = Si(s)), i.appendChild(s), r(i);
        const a = {
          type: w.EVENT_FILTER_OPENED,
          column: e.column,
          source: t,
          eGui: i
        };
        this.eventService.dispatchEvent(a);
      });
    });
  }
  onColumnsChanged() {
    const e = [];
    this.allColumnFilters.forEach((t, i) => {
      let r;
      t.column.isPrimary() ? r = this.columnModel.getPrimaryColumn(i) : r = this.columnModel.getGridColumn(i), !r && (e.push(t.column), this.disposeFilterWrapper(t, "columnChanged"), this.disposeColumnListener(i));
    }), e.length > 0 ? this.onFilterChanged({ columns: e }) : this.updateDependantFilters();
  }
  updateDependantFilters() {
    const e = this.columnModel.getGroupAutoColumns();
    e == null || e.forEach((t) => {
      t.getColDef().filter === "agGroupColumnFilter" && this.getOrCreateFilterWrapper(t, "NO_UI");
    });
  }
  // for group filters, can change dynamically whether they are allowed or not
  isFilterAllowed(e) {
    var t, i;
    if (!e.isFilterAllowed())
      return !1;
    const n = this.allColumnFilters.get(e.getColId());
    return (i = (t = n == null ? void 0 : n.filterPromise) === null || t === void 0 ? void 0 : t.resolveNow(
      !0,
      // defer to filter component isFilterAllowed if it exists
      (s) => {
        var a, l;
        return typeof ((a = s) === null || a === void 0 ? void 0 : a.isFilterAllowed) == "function" ? (l = s) === null || l === void 0 ? void 0 : l.isFilterAllowed() : !0;
      }
    )) !== null && i !== void 0 ? i : !0;
  }
  getFloatingFilterCompDetails(e, t) {
    const i = e.getColDef(), r = this.createFilterParams(e, i), n = this.userComponentFactory.mergeParamsWithApplicationProvidedParams(i, xC, r);
    let s = this.userComponentFactory.getDefaultFloatingFilterType(i, () => this.getDefaultFloatingFilter(e));
    s == null && (s = "agReadOnlyFloatingFilter");
    const l = {
      column: e,
      filterParams: n,
      currentParentModel: () => this.getCurrentFloatingFilterParentModel(e),
      parentFilterInstance: (c) => {
        const d = this.getFilterComponent(e, "NO_UI");
        d != null && d.then((u) => {
          c(ml(u));
        });
      },
      showParentFilter: t,
      suppressFilterButton: !1
      // This one might be overridden from the colDef
    };
    return this.userComponentFactory.getFloatingFilterCompDetails(i, l, s);
  }
  getCurrentFloatingFilterParentModel(e) {
    const t = this.getFilterComponent(e, "NO_UI", !1);
    return t ? t.resolveNow(null, (i) => i && i.getModel()) : null;
  }
  // destroys the filter, so it no longer takes part
  destroyFilter(e, t = "api") {
    const i = e.getColId(), r = this.allColumnFilters.get(i);
    this.disposeColumnListener(i), r && (this.disposeFilterWrapper(r, t), this.onFilterChanged({ columns: [e] }));
  }
  disposeColumnListener(e) {
    const t = this.allColumnListeners.get(e);
    t && (this.allColumnListeners.delete(e), t());
  }
  disposeFilterWrapper(e, t) {
    e.filterPromise.then((i) => {
      (i.setModel(null) || Qe.resolve()).then(() => {
        this.getContext().destroyBean(i), e.column.setFilterActive(!1, "filterDestroyed"), this.allColumnFilters.delete(e.column.getColId());
        const r = {
          type: w.EVENT_FILTER_DESTROYED,
          source: t,
          column: e.column
        };
        this.eventService.dispatchEvent(r);
      });
    });
  }
  checkDestroyFilter(e) {
    const t = this.allColumnFilters.get(e);
    if (!t)
      return;
    const i = t.column, { compDetails: r } = i.isFilterAllowed() ? this.createFilterInstance(i) : { compDetails: null };
    ((s, a) => {
      if (!a || !s)
        return !0;
      const { componentClass: l } = s, { componentClass: c } = a;
      return !(l === c || // react hooks returns new wrappers, so check nested render method
      (l == null ? void 0 : l.render) && (c == null ? void 0 : c.render) && l.render === c.render);
    })(t.compDetails, r) && this.destroyFilter(i, "columnChanged");
  }
  destroy() {
    super.destroy(), this.allColumnFilters.forEach((e) => this.disposeFilterWrapper(e, "gridDestroyed")), this.allColumnListeners.clear();
  }
};
Oo.QUICK_FILTER_SEPARATOR = `
`;
oc([
  S("valueService")
], Oo.prototype, "valueService", void 0);
oc([
  S("columnModel")
], Oo.prototype, "columnModel", void 0);
oc([
  S("rowModel")
], Oo.prototype, "rowModel", void 0);
oc([
  S("userComponentFactory")
], Oo.prototype, "userComponentFactory", void 0);
oc([
  S("rowRenderer")
], Oo.prototype, "rowRenderer", void 0);
oc([
  B
], Oo.prototype, "init", null);
Oo = DC = oc([
  q("filterManager")
], Oo);
class sb extends X {
  constructor(e, t) {
    super(e), this.ctrl = t;
  }
  getCtrl() {
    return this.ctrl;
  }
}
var kp = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class _s extends sb {
  constructor(e) {
    super(_s.TEMPLATE, e);
  }
  postConstruct() {
    const e = this.getGui(), t = {
      addOrRemoveCssClass: (i, r) => this.addOrRemoveCssClass(i, r),
      addOrRemoveBodyCssClass: (i, r) => this.eFloatingFilterBody.classList.toggle(i, r),
      setButtonWrapperDisplayed: (i) => Ke(this.eButtonWrapper, i),
      setCompDetails: (i) => this.setCompDetails(i),
      getFloatingFilterComp: () => this.compPromise,
      setWidth: (i) => e.style.width = i,
      setMenuIcon: (i) => this.eButtonShowMainFilter.appendChild(i)
    };
    this.ctrl.setComp(t, e, this.eButtonShowMainFilter, this.eFloatingFilterBody);
  }
  setCompDetails(e) {
    if (!e) {
      this.destroyFloatingFilterComp(), this.compPromise = null;
      return;
    }
    this.compPromise = e.newAgStackInstance(), this.compPromise.then((t) => this.afterCompCreated(t));
  }
  destroyFloatingFilterComp() {
    this.floatingFilterComp && (this.eFloatingFilterBody.removeChild(this.floatingFilterComp.getGui()), this.floatingFilterComp = this.destroyBean(this.floatingFilterComp));
  }
  afterCompCreated(e) {
    if (e) {
      if (!this.isAlive()) {
        this.destroyBean(e);
        return;
      }
      this.destroyFloatingFilterComp(), this.floatingFilterComp = e, this.eFloatingFilterBody.appendChild(e.getGui()), e.afterGuiAttached && e.afterGuiAttached();
    }
  }
}
_s.TEMPLATE = `<div class="ag-header-cell ag-floating-filter" role="gridcell" tabindex="-1">
            <div ref="eFloatingFilterBody" role="presentation"></div>
            <div class="ag-floating-filter-button ag-hidden" ref="eButtonWrapper" role="presentation">
                <button type="button" class="ag-button ag-floating-filter-button-button" ref="eButtonShowMainFilter" tabindex="-1"></button>
            </div>
        </div>`;
kp([
  L("eFloatingFilterBody")
], _s.prototype, "eFloatingFilterBody", void 0);
kp([
  L("eButtonWrapper")
], _s.prototype, "eButtonWrapper", void 0);
kp([
  L("eButtonShowMainFilter")
], _s.prototype, "eButtonShowMainFilter", void 0);
kp([
  B
], _s.prototype, "postConstruct", null);
kp([
  dt
], _s.prototype, "destroyFloatingFilterComp", null);
var _L = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, zt;
(function(o) {
  o.AUTO_HEIGHT = "ag-layout-auto-height", o.NORMAL = "ag-layout-normal", o.PRINT = "ag-layout-print";
})(zt || (zt = {}));
class Yv extends H {
  constructor(e) {
    super(), this.view = e;
  }
  postConstruct() {
    this.addManagedPropertyListener("domLayout", this.updateLayoutClasses.bind(this)), this.updateLayoutClasses();
  }
  updateLayoutClasses() {
    const e = this.getDomLayout(), t = {
      autoHeight: e === "autoHeight",
      normal: e === "normal",
      print: e === "print"
    }, i = t.autoHeight ? zt.AUTO_HEIGHT : t.print ? zt.PRINT : zt.NORMAL;
    this.view.updateLayoutClasses(i, t);
  }
  // returns either 'print', 'autoHeight' or 'normal' (normal is the default)
  getDomLayout() {
    var e;
    const t = (e = this.gridOptionsService.get("domLayout")) !== null && e !== void 0 ? e : "normal";
    return ["normal", "print", "autoHeight"].indexOf(t) === -1 ? (tt(() => console.warn(`AG Grid: ${t} is not valid for DOM Layout, valid values are 'normal', 'autoHeight', 'print'.`), "warn about dom layout values"), "normal") : t;
  }
}
_L([
  B
], Yv.prototype, "postConstruct", null);
var Ga = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, Ii;
(function(o) {
  o[o.Vertical = 0] = "Vertical", o[o.Horizontal = 1] = "Horizontal";
})(Ii || (Ii = {}));
var ji;
(function(o) {
  o[o.Container = 0] = "Container", o[o.FakeContainer = 1] = "FakeContainer";
})(ji || (ji = {}));
class Is extends H {
  constructor(e) {
    super(), this.lastScrollSource = [null, null], this.scrollLeft = -1, this.nextScrollTop = -1, this.scrollTop = -1, this.eBodyViewport = e, this.resetLastHScrollDebounced = Co(() => this.lastScrollSource[Ii.Horizontal] = null, 500), this.resetLastVScrollDebounced = Co(() => this.lastScrollSource[Ii.Vertical] = null, 500);
  }
  postConstruct() {
    this.enableRtl = this.gridOptionsService.is("enableRtl"), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this)), this.ctrlsService.whenReady((e) => {
      this.centerRowContainerCtrl = e.centerRowContainerCtrl, this.onDisplayedColumnsWidthChanged(), this.addScrollListener();
    });
  }
  addScrollListener() {
    const e = this.ctrlsService.getFakeHScrollComp(), t = this.ctrlsService.getFakeVScrollComp();
    this.addManagedListener(this.centerRowContainerCtrl.getViewportElement(), "scroll", this.onHScroll.bind(this)), e.onScrollCallback(this.onFakeHScroll.bind(this));
    const i = this.gridOptionsService.is("debounceVerticalScrollbar"), r = i ? Co(this.onVScroll.bind(this), 100) : this.onVScroll.bind(this), n = i ? Co(this.onFakeVScroll.bind(this), 100) : this.onFakeVScroll.bind(this);
    this.addManagedListener(this.eBodyViewport, "scroll", r), t.onScrollCallback(n);
  }
  onDisplayedColumnsWidthChanged() {
    this.enableRtl && this.horizontallyScrollHeaderCenterAndFloatingCenter();
  }
  horizontallyScrollHeaderCenterAndFloatingCenter(e) {
    if (this.centerRowContainerCtrl == null)
      return;
    e === void 0 && (e = this.centerRowContainerCtrl.getCenterViewportScrollLeft());
    const i = this.enableRtl ? e : -e, r = this.ctrlsService.getTopCenterRowContainerCtrl(), n = this.ctrlsService.getStickyTopCenterRowContainerCtrl(), s = this.ctrlsService.getBottomCenterRowContainerCtrl(), a = this.ctrlsService.getFakeHScrollComp();
    this.ctrlsService.getHeaderRowContainerCtrl().setHorizontalScroll(-i), s.setContainerTranslateX(i), r.setContainerTranslateX(i), n.setContainerTranslateX(i);
    const c = this.centerRowContainerCtrl.getViewportElement(), d = this.lastScrollSource[Ii.Horizontal] === ji.Container;
    e = Math.abs(e), d ? a.setScrollPosition(e) : Bh(c, e, this.enableRtl);
  }
  isControllingScroll(e, t) {
    return this.lastScrollSource[t] == null ? (this.lastScrollSource[t] = e, !0) : this.lastScrollSource[t] === e;
  }
  onFakeHScroll() {
    this.isControllingScroll(ji.FakeContainer, Ii.Horizontal) && this.onHScrollCommon(ji.FakeContainer);
  }
  onHScroll() {
    this.isControllingScroll(ji.Container, Ii.Horizontal) && this.onHScrollCommon(ji.Container);
  }
  onHScrollCommon(e) {
    const t = this.centerRowContainerCtrl.getViewportElement(), { scrollLeft: i } = t;
    if (this.shouldBlockScrollUpdate(Ii.Horizontal, i, !0))
      return;
    let r;
    e === ji.Container ? r = Vh(t, this.enableRtl) : r = this.ctrlsService.getFakeHScrollComp().getScrollPosition(), this.doHorizontalScroll(Math.round(r)), this.resetLastHScrollDebounced();
  }
  onFakeVScroll() {
    this.isControllingScroll(ji.FakeContainer, Ii.Vertical) && this.onVScrollCommon(ji.FakeContainer);
  }
  onVScroll() {
    this.isControllingScroll(ji.Container, Ii.Vertical) && this.onVScrollCommon(ji.Container);
  }
  onVScrollCommon(e) {
    let t;
    e === ji.Container ? t = this.eBodyViewport.scrollTop : t = this.ctrlsService.getFakeVScrollComp().getScrollPosition(), !this.shouldBlockScrollUpdate(Ii.Vertical, t, !0) && (this.animationFrameService.setScrollTop(t), this.nextScrollTop = t, e === ji.Container ? this.ctrlsService.getFakeVScrollComp().setScrollPosition(t) : this.eBodyViewport.scrollTop = t, this.gridOptionsService.is("suppressAnimationFrame") ? this.scrollGridIfNeeded() : this.animationFrameService.schedule(), this.resetLastVScrollDebounced());
  }
  doHorizontalScroll(e) {
    const t = this.ctrlsService.getFakeHScrollComp().getScrollPosition();
    this.scrollLeft === e && e === t || (this.scrollLeft = e, this.fireScrollEvent(Ii.Horizontal), this.horizontallyScrollHeaderCenterAndFloatingCenter(e), this.onHorizontalViewportChanged());
  }
  fireScrollEvent(e) {
    const t = {
      type: w.EVENT_BODY_SCROLL,
      direction: e === Ii.Horizontal ? "horizontal" : "vertical",
      left: this.scrollLeft,
      top: this.scrollTop
    };
    this.eventService.dispatchEvent(t), window.clearTimeout(this.scrollTimer), this.scrollTimer = void 0, this.scrollTimer = window.setTimeout(() => {
      const i = Object.assign(Object.assign({}, t), { type: w.EVENT_BODY_SCROLL_END });
      this.eventService.dispatchEvent(i);
    }, 100);
  }
  shouldBlockScrollUpdate(e, t, i = !1) {
    return i && !Fa() ? !1 : e === Ii.Vertical ? this.shouldBlockVerticalScroll(t) : this.shouldBlockHorizontalScroll(t);
  }
  shouldBlockVerticalScroll(e) {
    const t = Tp(this.eBodyViewport), { scrollHeight: i } = this.eBodyViewport;
    return e < 0 || e + t > i;
  }
  shouldBlockHorizontalScroll(e) {
    const t = this.centerRowContainerCtrl.getCenterWidth(), { scrollWidth: i } = this.centerRowContainerCtrl.getViewportElement();
    if (this.enableRtl && kh()) {
      if (e > 0)
        return !0;
    } else if (e < 0)
      return !0;
    return Math.abs(e) + t > i;
  }
  redrawRowsAfterScroll() {
    this.fireScrollEvent(Ii.Vertical);
  }
  onHorizontalViewportChanged() {
    this.centerRowContainerCtrl.onHorizontalViewportChanged();
  }
  // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.
  // (which happens with some implementations of tabbing). this can result in horizontal scroll getting
  // reset back to the left, however no scroll event is fired. so we need to get header to also scroll
  // back to the left to be kept in sync.
  // adding and removing the grid from the DOM both resets the scroll position and
  // triggers a resize event, so notify listeners if the scroll position has changed
  checkScrollLeft() {
    this.scrollLeft !== this.centerRowContainerCtrl.getCenterViewportScrollLeft() && this.onHScrollCommon(ji.Container);
  }
  scrollGridIfNeeded() {
    const e = this.scrollTop != this.nextScrollTop;
    return e && (this.scrollTop = this.nextScrollTop, this.redrawRowsAfterScroll()), e;
  }
  // called by scrollHorizontally method and alignedGridsService
  setHorizontalScrollPosition(e, t = !1) {
    const r = this.centerRowContainerCtrl.getViewportElement().scrollWidth - this.centerRowContainerCtrl.getCenterWidth();
    !t && this.shouldBlockScrollUpdate(Ii.Horizontal, e) && (this.enableRtl && kh() ? e = e > 0 ? 0 : r : e = Math.min(Math.max(e, 0), r)), Bh(this.centerRowContainerCtrl.getViewportElement(), Math.abs(e), this.enableRtl), this.doHorizontalScroll(e);
  }
  setVerticalScrollPosition(e) {
    this.eBodyViewport.scrollTop = e;
  }
  getVScrollPosition() {
    return {
      top: this.eBodyViewport.scrollTop,
      bottom: this.eBodyViewport.scrollTop + this.eBodyViewport.offsetHeight
    };
  }
  getHScrollPosition() {
    return this.centerRowContainerCtrl.getHScrollPosition();
  }
  isHorizontalScrollShowing() {
    return this.centerRowContainerCtrl.isHorizontalScrollShowing();
  }
  // called by the headerRootComp and moveColumnController
  scrollHorizontally(e) {
    const t = this.centerRowContainerCtrl.getViewportElement().scrollLeft;
    return this.setHorizontalScrollPosition(t + e), this.centerRowContainerCtrl.getViewportElement().scrollLeft - t;
  }
  // gets called by rowRenderer when new data loaded, as it will want to scroll to the top
  scrollToTop() {
    this.eBodyViewport.scrollTop = 0;
  }
  // Valid values for position are bottom, middle and top
  ensureNodeVisible(e, t = null) {
    const i = this.rowModel.getRowCount();
    let r = -1;
    for (let n = 0; n < i; n++) {
      const s = this.rowModel.getRow(n);
      if (typeof e == "function") {
        if (s && e(s)) {
          r = n;
          break;
        }
      } else if (e === s || e === s.data) {
        r = n;
        break;
      }
    }
    r >= 0 && this.ensureIndexVisible(r, t);
  }
  // Valid values for position are bottom, middle and top
  // position should be {'top','middle','bottom', or undefined/null}.
  // if undefined/null, then the grid will to the minimal amount of scrolling,
  // eg if grid needs to scroll up, it scrolls until row is on top,
  //    if grid needs to scroll down, it scrolls until row is on bottom,
  //    if row is already in view, grid does not scroll
  ensureIndexVisible(e, t) {
    if (this.gridOptionsService.isDomLayout("print"))
      return;
    const i = this.paginationProxy.getRowCount();
    if (typeof e != "number" || e < 0 || e >= i) {
      console.warn("AG Grid: Invalid row index for ensureIndexVisible: " + e);
      return;
    }
    this.gridOptionsService.is("pagination") && !this.gridOptionsService.is("suppressPaginationPanel") || this.paginationProxy.goToPageWithIndex(e);
    const a = this.ctrlsService.getGridBodyCtrl().getStickyTopHeight(), l = this.paginationProxy.getRow(e);
    let c;
    do {
      const d = l.rowTop, u = l.rowHeight, h = this.paginationProxy.getPixelOffset(), p = l.rowTop - h, f = p + l.rowHeight, g = this.getVScrollPosition(), v = this.heightScaler.getDivStretchOffset(), y = g.top + v, m = g.bottom + v, C = m - y, R = this.heightScaler.getScrollPositionForPixel(p), E = this.heightScaler.getScrollPositionForPixel(f - C), b = Math.min((R + E) / 2, p), T = y + a > p, D = m < f;
      let P = null;
      t === "top" ? P = R : t === "bottom" ? P = E : t === "middle" ? P = b : T ? P = R - a : D && (P = E), P !== null && (this.setVerticalScrollPosition(P), this.rowRenderer.redraw()), c = d !== l.rowTop || u !== l.rowHeight;
    } while (c);
    this.animationFrameService.flushAllFrames();
  }
  ensureColumnVisible(e, t = "auto") {
    const i = this.columnModel.getGridColumn(e);
    if (!i || i.isPinned() || !this.columnModel.isColumnDisplayed(i))
      return;
    const r = this.getPositionedHorizontalScroll(i, t);
    r !== null && this.centerRowContainerCtrl.setCenterViewportScrollLeft(r), this.centerRowContainerCtrl.onHorizontalViewportChanged(), this.animationFrameService.flushAllFrames();
  }
  getPositionedHorizontalScroll(e, t) {
    const { columnBeforeStart: i, columnAfterEnd: r } = this.isColumnOutsideViewport(e), n = this.centerRowContainerCtrl.getCenterWidth() < e.getActualWidth(), s = this.centerRowContainerCtrl.getCenterWidth(), a = this.enableRtl;
    let l = (a ? i : r) || n, c = a ? r : i;
    t !== "auto" && (l = t === "start", c = t === "end");
    const d = t === "middle";
    if (l || c || d) {
      const { colLeft: u, colMiddle: h, colRight: p } = this.getColumnBounds(e);
      return d ? h - s / 2 : l ? a ? p : u : a ? u - s : p - s;
    }
    return null;
  }
  isColumnOutsideViewport(e) {
    const { start: t, end: i } = this.getViewportBounds(), { colLeft: r, colRight: n } = this.getColumnBounds(e), s = this.enableRtl, a = s ? t > n : i < n, l = s ? i < r : t > r;
    return { columnBeforeStart: a, columnAfterEnd: l };
  }
  getColumnBounds(e) {
    const t = this.enableRtl, i = this.columnModel.getBodyContainerWidth(), r = e.getActualWidth(), n = e.getLeft(), s = t ? -1 : 1, a = t ? i - n : n, l = a + r * s, c = a + r / 2 * s;
    return { colLeft: a, colMiddle: c, colRight: l };
  }
  getViewportBounds() {
    const e = this.centerRowContainerCtrl.getCenterWidth(), t = this.centerRowContainerCtrl.getCenterViewportScrollLeft(), i = t, r = e + t;
    return { start: i, end: r, width: e };
  }
}
Ga([
  S("ctrlsService")
], Is.prototype, "ctrlsService", void 0);
Ga([
  S("animationFrameService")
], Is.prototype, "animationFrameService", void 0);
Ga([
  S("paginationProxy")
], Is.prototype, "paginationProxy", void 0);
Ga([
  S("rowModel")
], Is.prototype, "rowModel", void 0);
Ga([
  S("rowContainerHeightService")
], Is.prototype, "heightScaler", void 0);
Ga([
  S("rowRenderer")
], Is.prototype, "rowRenderer", void 0);
Ga([
  S("columnModel")
], Is.prototype, "columnModel", void 0);
Ga([
  B
], Is.prototype, "postConstruct", null);
class Xv {
  constructor(e) {
    this.tickingInterval = null, this.onScrollCallback = null, this.scrollContainer = e.scrollContainer, this.scrollHorizontally = e.scrollAxis.indexOf("x") !== -1, this.scrollVertically = e.scrollAxis.indexOf("y") !== -1, this.scrollByTick = e.scrollByTick != null ? e.scrollByTick : 20, e.onScrollCallback && (this.onScrollCallback = e.onScrollCallback), this.scrollVertically && (this.getVerticalPosition = e.getVerticalPosition, this.setVerticalPosition = e.setVerticalPosition), this.scrollHorizontally && (this.getHorizontalPosition = e.getHorizontalPosition, this.setHorizontalPosition = e.setHorizontalPosition), this.shouldSkipVerticalScroll = e.shouldSkipVerticalScroll || (() => !1), this.shouldSkipHorizontalScroll = e.shouldSkipHorizontalScroll || (() => !1);
  }
  check(e, t = !1) {
    const i = t || this.shouldSkipVerticalScroll();
    if (i && this.shouldSkipHorizontalScroll())
      return;
    const r = this.scrollContainer.getBoundingClientRect(), n = this.scrollByTick;
    this.tickLeft = e.clientX < r.left + n, this.tickRight = e.clientX > r.right - n, this.tickUp = e.clientY < r.top + n && !i, this.tickDown = e.clientY > r.bottom - n && !i, this.tickLeft || this.tickRight || this.tickUp || this.tickDown ? this.ensureTickingStarted() : this.ensureCleared();
  }
  ensureTickingStarted() {
    this.tickingInterval === null && (this.tickingInterval = window.setInterval(this.doTick.bind(this), 100), this.tickCount = 0);
  }
  doTick() {
    this.tickCount++;
    let e;
    if (e = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40, this.scrollVertically) {
      const t = this.getVerticalPosition();
      this.tickUp && this.setVerticalPosition(t - e), this.tickDown && this.setVerticalPosition(t + e);
    }
    if (this.scrollHorizontally) {
      const t = this.getHorizontalPosition();
      this.tickLeft && this.setHorizontalPosition(t - e), this.tickRight && this.setHorizontalPosition(t + e);
    }
    this.onScrollCallback && this.onScrollCallback();
  }
  ensureCleared() {
    this.tickingInterval && (window.clearInterval(this.tickingInterval), this.tickingInterval = null);
  }
}
var Sn = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Vr extends H {
  constructor(e) {
    super(), this.isMultiRowDrag = !1, this.isGridSorted = !1, this.isGridFiltered = !1, this.isRowGroupActive = !1, this.eContainer = e;
  }
  postConstruct() {
    this.gridOptionsService.isRowModelType("clientSide") && (this.clientSideRowModel = this.rowModel);
    const e = () => {
      this.onSortChanged(), this.onFilterChanged(), this.onRowGroupChanged();
    };
    this.addManagedListener(this.eventService, w.EVENT_SORT_CHANGED, this.onSortChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onRowGroupChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_MODEL_UPDATED, () => {
      e();
    }), e(), this.ctrlsService.whenReady(() => {
      const t = this.ctrlsService.getGridBodyCtrl();
      this.autoScrollService = new Xv({
        scrollContainer: t.getBodyViewportElement(),
        scrollAxis: "y",
        getVerticalPosition: () => t.getScrollFeature().getVScrollPosition().top,
        setVerticalPosition: (i) => t.getScrollFeature().setVerticalScrollPosition(i),
        onScrollCallback: () => {
          this.onDragging(this.lastDraggingEvent);
        }
      });
    });
  }
  onSortChanged() {
    this.isGridSorted = this.sortController.isSortActive();
  }
  onFilterChanged() {
    this.isGridFiltered = this.filterManager.isAnyFilterPresent();
  }
  onRowGroupChanged() {
    const e = this.columnModel.getRowGroupColumns();
    this.isRowGroupActive = !br(e);
  }
  getContainer() {
    return this.eContainer;
  }
  isInterestedIn(e) {
    return e === Dt.RowDrag;
  }
  getIconName() {
    return this.gridOptionsService.is("rowDragManaged") && this.shouldPreventRowMove() ? Te.ICON_NOT_ALLOWED : Te.ICON_MOVE;
  }
  shouldPreventRowMove() {
    return this.isGridSorted || this.isGridFiltered || this.isRowGroupActive;
  }
  getRowNodes(e) {
    if (!this.isFromThisGrid(e))
      return e.dragItem.rowNodes || [];
    const t = this.gridOptionsService.is("rowDragMultiRow"), i = [...this.selectionService.getSelectedNodes()].sort((n, s) => n.rowIndex == null || s.rowIndex == null ? 0 : this.getRowIndexNumber(n) - this.getRowIndexNumber(s)), r = e.dragItem.rowNode;
    return t && i.indexOf(r) !== -1 ? (this.isMultiRowDrag = !0, i) : (this.isMultiRowDrag = !1, [r]);
  }
  onDragEnter(e) {
    e.dragItem.rowNodes = this.getRowNodes(e), this.dispatchGridEvent(w.EVENT_ROW_DRAG_ENTER, e), this.getRowNodes(e).forEach((t) => {
      t.setDragging(!0);
    }), this.onEnterOrDragging(e);
  }
  onDragging(e) {
    this.onEnterOrDragging(e);
  }
  isFromThisGrid(e) {
    const { dragSourceDomDataKey: t } = e.dragSource;
    return t === this.gridOptionsService.getDomDataKey();
  }
  isDropZoneWithinThisGrid(e) {
    const i = this.ctrlsService.getGridBodyCtrl().getGui(), { dropZoneTarget: r } = e;
    return !i.contains(r);
  }
  onEnterOrDragging(e) {
    this.dispatchGridEvent(w.EVENT_ROW_DRAG_MOVE, e), this.lastDraggingEvent = e;
    const t = this.mouseEventService.getNormalisedPosition(e).y;
    this.gridOptionsService.is("rowDragManaged") && this.doManagedDrag(e, t), this.autoScrollService.check(e.event);
  }
  doManagedDrag(e, t) {
    const i = this.isFromThisGrid(e), r = this.gridOptionsService.is("rowDragManaged"), n = e.dragItem.rowNodes;
    r && this.shouldPreventRowMove() || (this.gridOptionsService.is("suppressMoveWhenRowDragging") || !i ? this.isDropZoneWithinThisGrid(e) || this.clientSideRowModel.highlightRowAtPixel(n[0], t) : this.moveRows(n, t));
  }
  getRowIndexNumber(e) {
    return parseInt(at(e.getRowIndexString().split("-")), 10);
  }
  moveRowAndClearHighlight(e) {
    const t = this.clientSideRowModel.getLastHighlightedRowNode(), i = t && t.highlighted === ms.Below, r = this.mouseEventService.getNormalisedPosition(e).y, n = e.dragItem.rowNodes;
    let s = i ? 1 : 0;
    if (this.isFromThisGrid(e))
      n.forEach((a) => {
        a.rowTop < r && (s -= 1);
      }), this.moveRows(n, r, s);
    else {
      const a = this.gridOptionsService.getCallback("getRowId");
      let l = this.clientSideRowModel.getRowIndexAtPixel(r) + 1;
      this.clientSideRowModel.getHighlightPosition(r) === ms.Above && l--, this.clientSideRowModel.updateRowData({
        add: n.map((c) => c.data).filter((c) => !this.clientSideRowModel.getRowNode(a ? a({ data: c, level: 0 }) : c.id)),
        addIndex: l
      });
    }
    this.clearRowHighlight();
  }
  clearRowHighlight() {
    this.clientSideRowModel.highlightRowAtPixel(null);
  }
  moveRows(e, t, i = 0) {
    this.clientSideRowModel.ensureRowsAtPixel(e, t, i) && (this.focusService.clearFocusedCell(), this.rangeService && this.rangeService.removeAllCellRanges());
  }
  addRowDropZone(e) {
    if (!e.getContainer()) {
      tt(() => console.warn("AG Grid: addRowDropZone - A container target needs to be provided"), "add-drop-zone-empty-target");
      return;
    }
    if (this.dragAndDropService.findExternalZone(e)) {
      console.warn("AG Grid: addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again.");
      return;
    }
    let t = {
      getContainer: e.getContainer
    };
    e.fromGrid ? (e.fromGrid = void 0, t = e) : (e.onDragEnter && (t.onDragEnter = (i) => {
      e.onDragEnter(this.draggingToRowDragEvent(w.EVENT_ROW_DRAG_ENTER, i));
    }), e.onDragLeave && (t.onDragLeave = (i) => {
      e.onDragLeave(this.draggingToRowDragEvent(w.EVENT_ROW_DRAG_LEAVE, i));
    }), e.onDragging && (t.onDragging = (i) => {
      e.onDragging(this.draggingToRowDragEvent(w.EVENT_ROW_DRAG_MOVE, i));
    }), e.onDragStop && (t.onDragStop = (i) => {
      e.onDragStop(this.draggingToRowDragEvent(w.EVENT_ROW_DRAG_END, i));
    })), this.dragAndDropService.addDropTarget(Object.assign({ isInterestedIn: (i) => i === Dt.RowDrag, getIconName: () => Te.ICON_MOVE, external: !0 }, t));
  }
  getRowDropZone(e) {
    const t = this.getContainer.bind(this), i = this.onDragEnter.bind(this), r = this.onDragLeave.bind(this), n = this.onDragging.bind(this), s = this.onDragStop.bind(this);
    return e ? {
      getContainer: t,
      onDragEnter: e.onDragEnter ? (a) => {
        i(a), e.onDragEnter(this.draggingToRowDragEvent(w.EVENT_ROW_DRAG_ENTER, a));
      } : i,
      onDragLeave: e.onDragLeave ? (a) => {
        r(a), e.onDragLeave(this.draggingToRowDragEvent(w.EVENT_ROW_DRAG_LEAVE, a));
      } : r,
      onDragging: e.onDragging ? (a) => {
        n(a), e.onDragging(this.draggingToRowDragEvent(w.EVENT_ROW_DRAG_MOVE, a));
      } : n,
      onDragStop: e.onDragStop ? (a) => {
        s(a), e.onDragStop(this.draggingToRowDragEvent(w.EVENT_ROW_DRAG_END, a));
      } : s,
      fromGrid: !0
      /* @private */
    } : {
      getContainer: t,
      onDragEnter: i,
      onDragLeave: r,
      onDragging: n,
      onDragStop: s,
      /* @private */
      fromGrid: !0
    };
  }
  draggingToRowDragEvent(e, t) {
    const i = this.mouseEventService.getNormalisedPosition(t).y, r = i > this.paginationProxy.getCurrentPageHeight();
    let n = -1, s;
    r || (n = this.rowModel.getRowIndexAtPixel(i), s = this.rowModel.getRow(n));
    let a;
    switch (t.vDirection) {
      case Fd.Down:
        a = "down";
        break;
      case Fd.Up:
        a = "up";
        break;
      default:
        a = null;
        break;
    }
    return {
      type: e,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context,
      event: t.event,
      node: t.dragItem.rowNode,
      nodes: t.dragItem.rowNodes,
      overIndex: n,
      overNode: s,
      y: i,
      vDirection: a
    };
  }
  dispatchGridEvent(e, t) {
    const i = this.draggingToRowDragEvent(e, t);
    this.eventService.dispatchEvent(i);
  }
  onDragLeave(e) {
    this.dispatchGridEvent(w.EVENT_ROW_DRAG_LEAVE, e), this.stopDragging(e), this.gridOptionsService.is("rowDragManaged") && this.clearRowHighlight(), this.isFromThisGrid(e) && (this.isMultiRowDrag = !1);
  }
  onDragStop(e) {
    this.dispatchGridEvent(w.EVENT_ROW_DRAG_END, e), this.stopDragging(e), this.gridOptionsService.is("rowDragManaged") && (this.gridOptionsService.is("suppressMoveWhenRowDragging") || !this.isFromThisGrid(e)) && !this.isDropZoneWithinThisGrid(e) && this.moveRowAndClearHighlight(e);
  }
  stopDragging(e) {
    this.autoScrollService.ensureCleared(), this.getRowNodes(e).forEach((t) => {
      t.setDragging(!1);
    });
  }
}
Sn([
  S("dragAndDropService")
], Vr.prototype, "dragAndDropService", void 0);
Sn([
  S("rowModel")
], Vr.prototype, "rowModel", void 0);
Sn([
  S("paginationProxy")
], Vr.prototype, "paginationProxy", void 0);
Sn([
  S("columnModel")
], Vr.prototype, "columnModel", void 0);
Sn([
  S("focusService")
], Vr.prototype, "focusService", void 0);
Sn([
  S("sortController")
], Vr.prototype, "sortController", void 0);
Sn([
  S("filterManager")
], Vr.prototype, "filterManager", void 0);
Sn([
  S("selectionService")
], Vr.prototype, "selectionService", void 0);
Sn([
  S("mouseEventService")
], Vr.prototype, "mouseEventService", void 0);
Sn([
  S("ctrlsService")
], Vr.prototype, "ctrlsService", void 0);
Sn([
  Ve("rangeService")
], Vr.prototype, "rangeService", void 0);
Sn([
  B
], Vr.prototype, "postConstruct", null);
var Br = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, Ld;
(function(o) {
  o.ANIMATION_ON = "ag-row-animation", o.ANIMATION_OFF = "ag-row-no-animation";
})(Ld || (Ld = {}));
const ax = "ag-force-vertical-scroll", IL = "ag-selectable", FL = "ag-column-moving";
class or extends H {
  constructor() {
    super(...arguments), this.stickyTopHeight = 0;
  }
  getScrollFeature() {
    return this.bodyScrollFeature;
  }
  getBodyViewportElement() {
    return this.eBodyViewport;
  }
  setComp(e, t, i, r, n, s) {
    this.comp = e, this.eGridBody = t, this.eBodyViewport = i, this.eTop = r, this.eBottom = n, this.eStickyTop = s, this.setCellTextSelection(this.gridOptionsService.is("enableCellTextSelection")), this.createManagedBean(new Yv(this.comp)), this.bodyScrollFeature = this.createManagedBean(new Is(this.eBodyViewport)), this.addRowDragListener(), this.setupRowAnimationCssClass(), this.addEventListeners(), this.addFocusListeners([r, i, n, s]), this.onGridColumnsChanged(), this.addBodyViewportListener(), this.setFloatingHeights(), this.disableBrowserDragging(), this.addStopEditingWhenGridLosesFocus(), this.ctrlsService.registerGridBodyCtrl(this);
  }
  getComp() {
    return this.comp;
  }
  addEventListeners() {
    this.addManagedListener(this.eventService, w.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_HEADER_HEIGHT_CHANGED, this.onHeaderHeightChanged.bind(this));
  }
  addFocusListeners(e) {
    e.forEach((t) => {
      this.addManagedListener(t, "focusin", (i) => {
        const { target: r } = i, n = Ol(r, "ag-root", t);
        t.classList.toggle("ag-has-focus", !n);
      }), this.addManagedListener(t, "focusout", (i) => {
        const { target: r, relatedTarget: n } = i, s = t.contains(n), a = Ol(n, "ag-root", t);
        Ol(r, "ag-root", t) || (!s || a) && t.classList.remove("ag-has-focus");
      });
    });
  }
  // used by ColumnAnimationService
  setColumnMovingCss(e) {
    this.comp.setColumnMovingCss(FL, e);
  }
  setCellTextSelection(e = !1) {
    this.comp.setCellSelectableCss(IL, e);
  }
  onScrollVisibilityChanged() {
    const e = this.scrollVisibleService.isVerticalScrollShowing();
    this.setVerticalScrollPaddingVisible(e), this.setStickyTopWidth(e);
    const t = e && this.gridOptionsService.getScrollbarWidth() || 0, i = wd() ? 16 : 0, r = `calc(100% + ${t + i}px)`;
    this.animationFrameService.requestAnimationFrame(() => this.comp.setBodyViewportWidth(r));
  }
  onGridColumnsChanged() {
    const e = this.columnModel.getAllGridColumns();
    this.comp.setColumnCount(e ? e.length : 0);
  }
  // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
  // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
  disableBrowserDragging() {
    this.addManagedListener(this.eGridBody, "dragstart", (e) => {
      if (e.target instanceof HTMLImageElement)
        return e.preventDefault(), !1;
    });
  }
  addStopEditingWhenGridLosesFocus() {
    if (!this.gridOptionsService.is("stopEditingWhenCellsLoseFocus"))
      return;
    const e = (i) => {
      const r = i.relatedTarget;
      if (Ag(r) === null) {
        this.rowRenderer.stopEditing();
        return;
      }
      let n = (
        // see if click came from inside the viewports
        t.some((s) => s.contains(r)) && this.mouseEventService.isElementInThisGrid(r)
      );
      if (!n) {
        const s = this.popupService;
        n = s.getActivePopups().some((a) => a.contains(r)) || s.isElementWithinCustomPopup(r);
      }
      n || this.rowRenderer.stopEditing();
    }, t = [this.eBodyViewport, this.eBottom, this.eTop, this.eStickyTop];
    t.forEach((i) => this.addManagedListener(i, "focusout", e));
  }
  updateRowCount() {
    const e = this.headerNavigationService.getHeaderRowCount(), t = this.rowModel.isLastRowIndexKnown() ? this.rowModel.getRowCount() : -1, i = t === -1 ? -1 : e + t;
    this.comp.setRowCount(i);
  }
  registerBodyViewportResizeListener(e) {
    this.comp.registerBodyViewportResizeListener(e);
  }
  setVerticalScrollPaddingVisible(e) {
    const t = e ? "scroll" : "hidden";
    this.comp.setPinnedTopBottomOverflowY(t);
  }
  isVerticalScrollShowing() {
    const e = this.gridOptionsService.is("alwaysShowVerticalScroll"), t = e ? ax : null, i = this.gridOptionsService.isDomLayout("normal");
    return this.comp.setAlwaysVerticalScrollClass(t, e), e || i && MT(this.eBodyViewport);
  }
  setupRowAnimationCssClass() {
    const e = () => {
      const t = this.gridOptionsService.isAnimateRows() && !this.rowContainerHeightService.isStretching(), i = t ? Ld.ANIMATION_ON : Ld.ANIMATION_OFF;
      this.comp.setRowAnimationCssOnBodyViewport(i, t);
    };
    e(), this.addManagedListener(this.eventService, w.EVENT_HEIGHT_SCALE_CHANGED, e), this.addManagedPropertyListener("animateRows", e);
  }
  getGridBodyElement() {
    return this.eGridBody;
  }
  addBodyViewportListener() {
    const e = this.onBodyViewportContextMenu.bind(this);
    this.addManagedListener(this.eBodyViewport, "contextmenu", e), this.mockContextMenuForIPad(e), this.addManagedListener(this.eBodyViewport, "wheel", this.onBodyViewportWheel.bind(this)), this.addManagedListener(this.eStickyTop, "wheel", this.onStickyTopWheel.bind(this)), this.addFullWidthContainerWheelListener();
  }
  addFullWidthContainerWheelListener() {
    const e = this.eBodyViewport.querySelector(".ag-full-width-container"), t = this.eBodyViewport.querySelector(".ag-center-cols-viewport");
    e && t && this.addManagedListener(e, "wheel", (i) => this.onFullWidthContainerWheel(i, t));
  }
  onFullWidthContainerWheel(e, t) {
    !e.deltaX || Math.abs(e.deltaY) > Math.abs(e.deltaX) || !this.mouseEventService.isEventFromThisGrid(e) || (e.preventDefault(), t.scrollBy({ left: e.deltaX }));
  }
  onBodyViewportContextMenu(e, t, i) {
    if (!e && !i)
      return;
    this.gridOptionsService.is("preventDefaultOnContextMenu") && (e || i).preventDefault();
    const { target: r } = e || t;
    if (r === this.eBodyViewport || r === this.ctrlsService.getCenterRowContainerCtrl().getViewportElement()) {
      if (!this.contextMenuFactory)
        return;
      e ? this.contextMenuFactory.onContextMenu(e, null, null, null, null, this.eGridBody) : i && this.contextMenuFactory.onContextMenu(null, i, null, null, null, this.eGridBody);
    }
  }
  mockContextMenuForIPad(e) {
    if (!Fa())
      return;
    const t = new mt(this.eBodyViewport), i = (r) => {
      e(void 0, r.touchStart, r.touchEvent);
    };
    this.addManagedListener(t, mt.EVENT_LONG_TAP, i), this.addDestroyFunc(() => t.destroy());
  }
  onBodyViewportWheel(e) {
    this.gridOptionsService.is("suppressScrollWhenPopupsAreOpen") && this.popupService.hasAnchoredPopup() && e.preventDefault();
  }
  onStickyTopWheel(e) {
    e.preventDefault(), e.offsetY && this.scrollVertically(e.deltaY);
  }
  getGui() {
    return this.eGridBody;
  }
  // called by rowDragFeature
  scrollVertically(e) {
    const t = this.eBodyViewport.scrollTop;
    return this.bodyScrollFeature.setVerticalScrollPosition(t + e), this.eBodyViewport.scrollTop - t;
  }
  addRowDragListener() {
    this.rowDragFeature = this.createManagedBean(new Vr(this.eBodyViewport)), this.dragAndDropService.addDropTarget(this.rowDragFeature);
  }
  getRowDragFeature() {
    return this.rowDragFeature;
  }
  onPinnedRowDataChanged() {
    this.setFloatingHeights();
  }
  setFloatingHeights() {
    const { pinnedRowModel: e } = this;
    let t = e.getPinnedTopTotalHeight();
    t && (t += 1);
    let i = e.getPinnedBottomTotalHeight();
    i && (i += 1), this.comp.setTopHeight(t), this.comp.setBottomHeight(i), this.comp.setTopDisplay(t ? "inherit" : "none"), this.comp.setBottomDisplay(i ? "inherit" : "none"), this.setStickyTopOffsetTop();
  }
  setStickyTopHeight(e = 0) {
    this.comp.setStickyTopHeight(`${e}px`), this.stickyTopHeight = e;
  }
  getStickyTopHeight() {
    return this.stickyTopHeight;
  }
  setStickyTopWidth(e) {
    if (!e)
      this.comp.setStickyTopWidth("100%");
    else {
      const t = this.gridOptionsService.getScrollbarWidth();
      this.comp.setStickyTopWidth(`calc(100% - ${t}px)`);
    }
  }
  onHeaderHeightChanged() {
    this.setStickyTopOffsetTop();
  }
  setStickyTopOffsetTop() {
    const t = this.ctrlsService.getGridHeaderCtrl().getHeaderHeight(), i = this.pinnedRowModel.getPinnedTopTotalHeight();
    let r = 0;
    t > 0 && (r += t + 1), i > 0 && (r += i + 1), this.comp.setStickyTopTop(`${r}px`);
  }
  // method will call itself if no available width. this covers if the grid
  // isn't visible, but is just about to be visible.
  sizeColumnsToFit(e, t) {
    const r = this.isVerticalScrollShowing() ? this.gridOptionsService.getScrollbarWidth() : 0, s = Bv(this.eGridBody) - r;
    if (s > 0) {
      this.columnModel.sizeColumnsToFit(s, "sizeColumnsToFit", !1, e);
      return;
    }
    t === void 0 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, 100);
    }, 0) : t === 100 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, 500);
    }, 100) : t === 500 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, -1);
    }, 500) : console.warn("AG Grid: tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?");
  }
  // + rangeService
  addScrollEventListener(e) {
    this.eBodyViewport.addEventListener("scroll", e, { passive: !0 });
  }
  // + focusService
  removeScrollEventListener(e) {
    this.eBodyViewport.removeEventListener("scroll", e);
  }
}
Br([
  S("animationFrameService")
], or.prototype, "animationFrameService", void 0);
Br([
  S("rowContainerHeightService")
], or.prototype, "rowContainerHeightService", void 0);
Br([
  S("ctrlsService")
], or.prototype, "ctrlsService", void 0);
Br([
  S("columnModel")
], or.prototype, "columnModel", void 0);
Br([
  S("scrollVisibleService")
], or.prototype, "scrollVisibleService", void 0);
Br([
  Ve("contextMenuFactory")
], or.prototype, "contextMenuFactory", void 0);
Br([
  S("headerNavigationService")
], or.prototype, "headerNavigationService", void 0);
Br([
  S("dragAndDropService")
], or.prototype, "dragAndDropService", void 0);
Br([
  S("pinnedRowModel")
], or.prototype, "pinnedRowModel", void 0);
Br([
  S("rowRenderer")
], or.prototype, "rowRenderer", void 0);
Br([
  S("popupService")
], or.prototype, "popupService", void 0);
Br([
  S("mouseEventService")
], or.prototype, "mouseEventService", void 0);
Br([
  S("rowModel")
], or.prototype, "rowModel", void 0);
var ga;
(function(o) {
  o[o.FILL = 0] = "FILL", o[o.RANGE = 1] = "RANGE";
})(ga || (ga = {}));
var wr;
(function(o) {
  o[o.VALUE = 0] = "VALUE", o[o.DIMENSION = 1] = "DIMENSION";
})(wr || (wr = {}));
const Ju = "ag-cell-range-selected", LL = "ag-cell-range-chart", NL = "ag-cell-range-single-cell", GL = "ag-cell-range-chart-category", kL = "ag-cell-range-handle", VL = "ag-cell-range-top", BL = "ag-cell-range-right", HL = "ag-cell-range-bottom", WL = "ag-cell-range-left";
class jL {
  constructor(e, t) {
    this.beans = e, this.cellCtrl = t;
  }
  setComp(e, t) {
    this.cellComp = e, this.eGui = t, this.onRangeSelectionChanged();
  }
  onRangeSelectionChanged() {
    this.cellComp && (this.rangeCount = this.beans.rangeService.getCellRangeCount(this.cellCtrl.getCellPosition()), this.hasChartRange = this.getHasChartRange(), this.cellComp.addOrRemoveCssClass(Ju, this.rangeCount !== 0), this.cellComp.addOrRemoveCssClass(`${Ju}-1`, this.rangeCount === 1), this.cellComp.addOrRemoveCssClass(`${Ju}-2`, this.rangeCount === 2), this.cellComp.addOrRemoveCssClass(`${Ju}-3`, this.rangeCount === 3), this.cellComp.addOrRemoveCssClass(`${Ju}-4`, this.rangeCount >= 4), this.cellComp.addOrRemoveCssClass(LL, this.hasChartRange), _d(this.eGui, this.rangeCount > 0 ? !0 : void 0), this.cellComp.addOrRemoveCssClass(NL, this.isSingleCell()), this.updateRangeBorders(), this.refreshHandle());
  }
  updateRangeBorders() {
    const e = this.getRangeBorders(), t = this.isSingleCell(), i = !t && e.top, r = !t && e.right, n = !t && e.bottom, s = !t && e.left;
    this.cellComp.addOrRemoveCssClass(VL, i), this.cellComp.addOrRemoveCssClass(BL, r), this.cellComp.addOrRemoveCssClass(HL, n), this.cellComp.addOrRemoveCssClass(WL, s);
  }
  isSingleCell() {
    const { rangeService: e } = this.beans;
    return this.rangeCount === 1 && e && !e.isMoreThanOneCell();
  }
  getHasChartRange() {
    const { rangeService: e } = this.beans;
    if (!this.rangeCount || !e)
      return !1;
    const t = e.getCellRanges();
    return t.length > 0 && t.every((i) => ln([wr.DIMENSION, wr.VALUE], i.type));
  }
  updateRangeBordersIfRangeCount() {
    this.rangeCount > 0 && (this.updateRangeBorders(), this.refreshHandle());
  }
  getRangeBorders() {
    const e = this.beans.gridOptionsService.is("enableRtl");
    let t = !1, i = !1, r = !1, n = !1;
    const s = this.cellCtrl.getCellPosition().column, { rangeService: a, columnModel: l } = this.beans;
    let c, d;
    e ? (c = l.getDisplayedColAfter(s), d = l.getDisplayedColBefore(s)) : (c = l.getDisplayedColBefore(s), d = l.getDisplayedColAfter(s));
    const u = a.getCellRanges().filter((h) => a.isCellInSpecificRange(this.cellCtrl.getCellPosition(), h));
    c || (n = !0), d || (i = !0);
    for (let h = 0; h < u.length && !(t && i && r && n); h++) {
      const p = u[h], f = a.getRangeStartRow(p), g = a.getRangeEndRow(p);
      !t && this.beans.rowPositionUtils.sameRow(f, this.cellCtrl.getCellPosition()) && (t = !0), !r && this.beans.rowPositionUtils.sameRow(g, this.cellCtrl.getCellPosition()) && (r = !0), !n && c && p.columns.indexOf(c) < 0 && (n = !0), !i && d && p.columns.indexOf(d) < 0 && (i = !0);
    }
    return { top: t, right: i, bottom: r, left: n };
  }
  refreshHandle() {
    if (!this.beans.rangeService)
      return;
    const e = this.shouldHaveSelectionHandle();
    this.selectionHandle && !e && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), e && this.addSelectionHandle(), this.cellComp.addOrRemoveCssClass(kL, !!this.selectionHandle);
  }
  shouldHaveSelectionHandle() {
    const { gridOptionsService: e, rangeService: t } = this.beans, i = t.getCellRanges(), r = i.length;
    if (this.rangeCount < 1 || r < 1)
      return !1;
    const n = at(i), s = this.cellCtrl.getCellPosition(), a = e.is("enableFillHandle") && !this.cellCtrl.isSuppressFillHandle(), l = e.is("enableRangeHandle");
    let c = r === 1 && !this.cellCtrl.isEditing() && (a || l);
    if (this.hasChartRange) {
      const u = i[0].type === wr.DIMENSION && t.isCellInSpecificRange(s, i[0]);
      this.cellComp.addOrRemoveCssClass(GL, u), c = n.type === wr.VALUE;
    }
    return c && n.endRow != null && t.isContiguousRange(n) && t.isBottomRightCell(n, s);
  }
  addSelectionHandle() {
    const { gridOptionsService: e, rangeService: t } = this.beans, i = at(t.getCellRanges()).type, n = e.is("enableFillHandle") && Se(i) ? ga.FILL : ga.RANGE;
    this.selectionHandle && this.selectionHandle.getType() !== n && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), this.selectionHandle || (this.selectionHandle = this.beans.selectionHandleFactory.createSelectionHandle(n)), this.selectionHandle.refresh(this.cellCtrl);
  }
  destroy() {
    this.beans.context.destroyBean(this.selectionHandle);
  }
}
class UL extends H {
  constructor(e, t) {
    super(), this.cellCtrl = e, this.beans = t, this.column = e.getColumn(), this.rowNode = e.getRowNode(), this.setupColSpan(), this.setupRowSpan();
  }
  setupRowSpan() {
    this.rowSpan = this.column.getRowSpan(this.rowNode);
  }
  setComp(e) {
    this.eGui = e, this.onLeftChanged(), this.onWidthChanged(), this.applyRowSpan();
  }
  onDisplayColumnsChanged() {
    const e = this.getColSpanningList();
    ia(this.colsSpanning, e) || (this.colsSpanning = e, this.onWidthChanged(), this.onLeftChanged());
  }
  setupColSpan() {
    this.column.getColDef().colSpan != null && (this.colsSpanning = this.getColSpanningList(), this.addManagedListener(this.beans.eventService, w.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayColumnsChanged.bind(this)), this.addManagedListener(this.beans.eventService, w.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onWidthChanged.bind(this)));
  }
  onWidthChanged() {
    if (!this.eGui)
      return;
    const e = this.getCellWidth();
    this.eGui.style.width = `${e}px`;
  }
  getCellWidth() {
    return this.colsSpanning ? this.colsSpanning.reduce((e, t) => e + t.getActualWidth(), 0) : this.column.getActualWidth();
  }
  getColSpanningList() {
    const e = this.column.getColSpan(this.rowNode), t = [];
    if (e === 1)
      t.push(this.column);
    else {
      let i = this.column;
      const r = this.column.getPinned();
      for (let n = 0; i && n < e && (t.push(i), i = this.beans.columnModel.getDisplayedColAfter(i), !(!i || Se(i) || r !== i.getPinned())); n++)
        ;
    }
    return t;
  }
  onLeftChanged() {
    if (!this.eGui)
      return;
    const e = this.modifyLeftForPrintLayout(this.getCellLeft());
    this.eGui.style.left = e + "px";
  }
  getCellLeft() {
    let e;
    return this.beans.gridOptionsService.is("enableRtl") && this.colsSpanning ? e = at(this.colsSpanning) : e = this.column, e.getLeft();
  }
  modifyLeftForPrintLayout(e) {
    if (!this.cellCtrl.isPrintLayout() || this.column.getPinned() === "left")
      return e;
    const t = this.beans.columnModel.getDisplayedColumnsLeftWidth();
    if (this.column.getPinned() === "right") {
      const i = this.beans.columnModel.getBodyContainerWidth();
      return t + i + (e || 0);
    }
    return t + (e || 0);
  }
  applyRowSpan() {
    if (this.rowSpan === 1)
      return;
    const t = this.beans.gridOptionsService.getRowHeightAsNumber() * this.rowSpan;
    this.eGui.style.height = `${t}px`, this.eGui.style.zIndex = "1";
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    super.destroy();
  }
}
class $L extends H {
  constructor(e, t) {
    super(), this.staticClasses = [], this.cellCtrl = e, this.beans = t, this.column = e.getColumn(), this.rowNode = e.getRowNode();
  }
  setComp(e) {
    this.cellComp = e, this.applyUserStyles(), this.applyCellClassRules(), this.applyClassesFromColDef();
  }
  applyCellClassRules() {
    const e = this.column.getColDef(), t = {
      value: this.cellCtrl.getValue(),
      data: this.rowNode.data,
      node: this.rowNode,
      colDef: e,
      column: this.column,
      rowIndex: this.rowNode.rowIndex,
      api: this.beans.gridOptionsService.api,
      columnApi: this.beans.gridOptionsService.columnApi,
      context: this.beans.gridOptionsService.context
    };
    this.beans.stylingService.processClassRules(e.cellClassRules, t, (i) => this.cellComp.addOrRemoveCssClass(i, !0), (i) => this.cellComp.addOrRemoveCssClass(i, !1));
  }
  applyUserStyles() {
    const e = this.column.getColDef();
    if (!e.cellStyle)
      return;
    let t;
    if (typeof e.cellStyle == "function") {
      const i = {
        column: this.column,
        value: this.cellCtrl.getValue(),
        colDef: e,
        data: this.rowNode.data,
        node: this.rowNode,
        rowIndex: this.rowNode.rowIndex,
        api: this.beans.gridOptionsService.api,
        columnApi: this.beans.gridOptionsService.columnApi,
        context: this.beans.gridOptionsService.context
      }, r = e.cellStyle;
      t = r(i);
    } else
      t = e.cellStyle;
    t && this.cellComp.setUserStyles(t);
  }
  applyClassesFromColDef() {
    const e = this.column.getColDef(), t = {
      value: this.cellCtrl.getValue(),
      data: this.rowNode.data,
      node: this.rowNode,
      column: this.column,
      colDef: e,
      rowIndex: this.rowNode.rowIndex,
      api: this.beans.gridOptionsService.api,
      columnApi: this.beans.gridOptionsService.columnApi,
      context: this.beans.gridOptionsService.context
    };
    this.staticClasses.length && this.staticClasses.forEach((i) => this.cellComp.addOrRemoveCssClass(i, !1)), this.staticClasses = this.beans.stylingService.getStaticCellClasses(e, t), this.staticClasses.length && this.staticClasses.forEach((i) => this.cellComp.addOrRemoveCssClass(i, !0));
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    super.destroy();
  }
}
class ab extends H {
  constructor(e, t) {
    super(), this.ctrl = e, this.beans = t;
  }
  setComp(e) {
    this.comp = e, this.setupTooltip();
  }
  setupTooltip() {
    this.browserTooltips = this.beans.gridOptionsService.is("enableBrowserTooltips"), this.updateTooltipText(), this.browserTooltips ? this.comp.setTitle(this.tooltip != null ? this.tooltip : void 0) : this.createTooltipFeatureIfNeeded();
  }
  updateTooltipText() {
    this.tooltip = this.ctrl.getTooltipValue();
  }
  createTooltipFeatureIfNeeded() {
    if (this.genericTooltipFeature != null)
      return;
    const e = {
      getTooltipParams: () => this.getTooltipParams(),
      getGui: () => this.ctrl.getGui()
    };
    this.genericTooltipFeature = this.createManagedBean(new ws(e), this.beans.context);
  }
  refreshToolTip() {
    this.updateTooltipText(), this.browserTooltips && this.comp.setTitle(this.tooltip != null ? this.tooltip : void 0);
  }
  getTooltipParams() {
    const e = this.ctrl, t = e.getColumn ? e.getColumn() : void 0, i = e.getColDef ? e.getColDef() : void 0, r = e.getRowNode ? e.getRowNode() : void 0;
    return {
      location: e.getLocation(),
      colDef: i,
      column: t,
      rowIndex: e.getRowIndex ? e.getRowIndex() : void 0,
      node: r,
      data: r ? r.data : void 0,
      value: this.getTooltipText(),
      valueFormatted: e.getValueFormatted ? e.getValueFormatted() : void 0
    };
  }
  getTooltipText() {
    return this.tooltip;
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    super.destroy();
  }
}
var Ie = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Oe = class {
  postConstruct() {
    this.doingMasterDetail = this.gridOptionsService.isMasterDetail(), this.gridOptionsService.isRowModelType("clientSide") && (this.clientSideRowModel = this.rowModel), this.gridOptionsService.isRowModelType("serverSide") && (this.serverSideRowModel = this.rowModel);
  }
};
Ie([
  S("resizeObserverService")
], Oe.prototype, "resizeObserverService", void 0);
Ie([
  S("paginationProxy")
], Oe.prototype, "paginationProxy", void 0);
Ie([
  S("context")
], Oe.prototype, "context", void 0);
Ie([
  S("columnApi")
], Oe.prototype, "columnApi", void 0);
Ie([
  S("gridApi")
], Oe.prototype, "gridApi", void 0);
Ie([
  S("gridOptionsService")
], Oe.prototype, "gridOptionsService", void 0);
Ie([
  S("expressionService")
], Oe.prototype, "expressionService", void 0);
Ie([
  S("environment")
], Oe.prototype, "environment", void 0);
Ie([
  S("rowRenderer")
], Oe.prototype, "rowRenderer", void 0);
Ie([
  S("templateService")
], Oe.prototype, "templateService", void 0);
Ie([
  S("valueService")
], Oe.prototype, "valueService", void 0);
Ie([
  S("eventService")
], Oe.prototype, "eventService", void 0);
Ie([
  S("columnModel")
], Oe.prototype, "columnModel", void 0);
Ie([
  S("headerNavigationService")
], Oe.prototype, "headerNavigationService", void 0);
Ie([
  S("navigationService")
], Oe.prototype, "navigationService", void 0);
Ie([
  S("columnAnimationService")
], Oe.prototype, "columnAnimationService", void 0);
Ie([
  Ve("rangeService")
], Oe.prototype, "rangeService", void 0);
Ie([
  S("focusService")
], Oe.prototype, "focusService", void 0);
Ie([
  Ve("contextMenuFactory")
], Oe.prototype, "contextMenuFactory", void 0);
Ie([
  S("popupService")
], Oe.prototype, "popupService", void 0);
Ie([
  S("valueFormatterService")
], Oe.prototype, "valueFormatterService", void 0);
Ie([
  S("stylingService")
], Oe.prototype, "stylingService", void 0);
Ie([
  S("columnHoverService")
], Oe.prototype, "columnHoverService", void 0);
Ie([
  S("userComponentFactory")
], Oe.prototype, "userComponentFactory", void 0);
Ie([
  S("userComponentRegistry")
], Oe.prototype, "userComponentRegistry", void 0);
Ie([
  S("animationFrameService")
], Oe.prototype, "animationFrameService", void 0);
Ie([
  S("dragService")
], Oe.prototype, "dragService", void 0);
Ie([
  S("dragAndDropService")
], Oe.prototype, "dragAndDropService", void 0);
Ie([
  S("sortController")
], Oe.prototype, "sortController", void 0);
Ie([
  S("filterManager")
], Oe.prototype, "filterManager", void 0);
Ie([
  S("rowContainerHeightService")
], Oe.prototype, "rowContainerHeightService", void 0);
Ie([
  S("frameworkOverrides")
], Oe.prototype, "frameworkOverrides", void 0);
Ie([
  S("cellPositionUtils")
], Oe.prototype, "cellPositionUtils", void 0);
Ie([
  S("rowPositionUtils")
], Oe.prototype, "rowPositionUtils", void 0);
Ie([
  S("selectionService")
], Oe.prototype, "selectionService", void 0);
Ie([
  Ve("selectionHandleFactory")
], Oe.prototype, "selectionHandleFactory", void 0);
Ie([
  S("rowCssClassCalculator")
], Oe.prototype, "rowCssClassCalculator", void 0);
Ie([
  S("rowModel")
], Oe.prototype, "rowModel", void 0);
Ie([
  S("ctrlsService")
], Oe.prototype, "ctrlsService", void 0);
Ie([
  S("ctrlsFactory")
], Oe.prototype, "ctrlsFactory", void 0);
Ie([
  S("agStackComponentsRegistry")
], Oe.prototype, "agStackComponentsRegistry", void 0);
Ie([
  S("valueCache")
], Oe.prototype, "valueCache", void 0);
Ie([
  S("rowNodeEventThrottle")
], Oe.prototype, "rowNodeEventThrottle", void 0);
Ie([
  S("localeService")
], Oe.prototype, "localeService", void 0);
Ie([
  S("valueParserService")
], Oe.prototype, "valueParserService", void 0);
Ie([
  B
], Oe.prototype, "postConstruct", null);
Oe = Ie([
  q("beans")
], Oe);
class zL extends Oe {
  constructor(e, t, i) {
    super(), this.cellCtrl = e, this.beans = t, this.column = i;
  }
  onMouseEvent(e, t) {
    if (!Eo(t))
      switch (e) {
        case "click":
          this.onCellClicked(t);
          break;
        case "mousedown":
        case "touchstart":
          this.onMouseDown(t);
          break;
        case "dblclick":
          this.onCellDoubleClicked(t);
          break;
        case "mouseout":
          this.onMouseOut(t);
          break;
        case "mouseover":
          this.onMouseOver(t);
          break;
      }
  }
  onCellClicked(e) {
    if (this.isDoubleClickOnIPad()) {
      this.onCellDoubleClicked(e), e.preventDefault();
      return;
    }
    const { eventService: t, rangeService: i, gridOptionsService: r } = this.beans, n = e.ctrlKey || e.metaKey;
    i && n && i.getCellRangeCount(this.cellCtrl.getCellPosition()) > 1 && i.intersectLastRange(!0);
    const s = this.cellCtrl.createEvent(e, w.EVENT_CELL_CLICKED);
    t.dispatchEvent(s);
    const a = this.column.getColDef();
    a.onCellClicked && window.setTimeout(() => a.onCellClicked(s), 0), (r.is("singleClickEdit") || a.singleClickEdit) && !r.is("suppressClickEdit") && this.cellCtrl.startRowOrCellEdit();
  }
  // returns true if on iPad and this is second 'click' event in 200ms
  isDoubleClickOnIPad() {
    if (!Fa() || SS("dblclick"))
      return !1;
    const e = (/* @__PURE__ */ new Date()).getTime(), t = e - this.lastIPadMouseClickEvent < 200;
    return this.lastIPadMouseClickEvent = e, t;
  }
  onCellDoubleClicked(e) {
    const t = this.column.getColDef(), i = this.cellCtrl.createEvent(e, w.EVENT_CELL_DOUBLE_CLICKED);
    this.beans.eventService.dispatchEvent(i), typeof t.onCellDoubleClicked == "function" && window.setTimeout(() => t.onCellDoubleClicked(i), 0), !this.beans.gridOptionsService.is("singleClickEdit") && !this.beans.gridOptionsService.is("suppressClickEdit") && this.cellCtrl.startRowOrCellEdit(null, e);
  }
  onMouseDown(e) {
    const { ctrlKey: t, metaKey: i, shiftKey: r } = e, n = e.target, { eventService: s, rangeService: a } = this.beans;
    if (this.isRightClickInExistingRange(e))
      return;
    const l = a && a.getCellRanges().length != 0;
    if (!r || !l) {
      const c = fn() && !this.cellCtrl.isEditing() && !FS(n);
      this.cellCtrl.focusCell(c);
    }
    if (r && l && e.preventDefault(), !this.containsWidget(n)) {
      if (a) {
        const c = this.cellCtrl.getCellPosition();
        if (r)
          a.extendLatestRangeToCell(c);
        else {
          const d = t || i;
          a.setRangeToCell(c, d);
        }
      }
      s.dispatchEvent(this.cellCtrl.createEvent(e, w.EVENT_CELL_MOUSE_DOWN));
    }
  }
  isRightClickInExistingRange(e) {
    const { rangeService: t } = this.beans;
    return !!(t && t.isCellInAnyRange(this.cellCtrl.getCellPosition()) && e.button === 2);
  }
  containsWidget(e) {
    return Ol(e, "ag-selection-checkbox", 3);
  }
  onMouseOut(e) {
    if (this.mouseStayingInsideCell(e))
      return;
    const t = this.cellCtrl.createEvent(e, w.EVENT_CELL_MOUSE_OUT);
    this.beans.eventService.dispatchEvent(t), this.beans.columnHoverService.clearMouseOver();
  }
  onMouseOver(e) {
    if (this.mouseStayingInsideCell(e))
      return;
    const t = this.cellCtrl.createEvent(e, w.EVENT_CELL_MOUSE_OVER);
    this.beans.eventService.dispatchEvent(t), this.beans.columnHoverService.setMouseOver([this.column]);
  }
  mouseStayingInsideCell(e) {
    if (!e.target || !e.relatedTarget)
      return !1;
    const t = this.cellCtrl.getGui(), i = t.contains(e.target), r = t.contains(e.relatedTarget);
    return i && r;
  }
  destroy() {
  }
}
class KL extends H {
  constructor(e, t, i, r, n) {
    super(), this.cellCtrl = e, this.beans = t, this.rowNode = r, this.rowCtrl = n;
  }
  setComp(e) {
    this.eGui = e;
  }
  onKeyDown(e) {
    const t = e.key;
    switch (t) {
      case V.ENTER:
        this.onEnterKeyDown(e);
        break;
      case V.F2:
        this.onF2KeyDown(e);
        break;
      case V.ESCAPE:
        this.onEscapeKeyDown(e);
        break;
      case V.TAB:
        this.onTabKeyDown(e);
        break;
      case V.BACKSPACE:
      case V.DELETE:
        this.onBackspaceOrDeleteKeyDown(t, e);
        break;
      case V.DOWN:
      case V.UP:
      case V.RIGHT:
      case V.LEFT:
        this.onNavigationKeyDown(e, t);
        break;
    }
  }
  onNavigationKeyDown(e, t) {
    this.cellCtrl.isEditing() || (e.shiftKey && this.cellCtrl.isRangeSelectionEnabled() ? this.onShiftRangeSelect(e) : this.beans.navigationService.navigateToNextCell(e, t, this.cellCtrl.getCellPosition(), !0), e.preventDefault());
  }
  onShiftRangeSelect(e) {
    if (!this.beans.rangeService)
      return;
    const t = this.beans.rangeService.extendLatestRangeInDirection(e);
    t && this.beans.navigationService.ensureCellVisible(t);
  }
  onTabKeyDown(e) {
    this.beans.navigationService.onTabKeyDown(this.cellCtrl, e);
  }
  onBackspaceOrDeleteKeyDown(e, t) {
    const { cellCtrl: i, beans: r, rowNode: n } = this, { gridOptionsService: s, rangeService: a, eventService: l } = r;
    i.isEditing() || (l.dispatchEvent({ type: w.EVENT_KEY_SHORTCUT_CHANGED_CELL_START }), GT(e, s.is("enableCellEditingOnBackspace")) ? a && s.isEnableRangeSelection() ? a.clearCellRangeCellValues({ dispatchWrapperEvents: !0, wrapperEventSource: "deleteKey" }) : i.isCellEditable() && n.setDataValue(i.getColumn(), null, "cellClear") : i.startRowOrCellEdit(e, t), l.dispatchEvent({ type: w.EVENT_KEY_SHORTCUT_CHANGED_CELL_END }));
  }
  onEnterKeyDown(e) {
    if (this.cellCtrl.isEditing() || this.rowCtrl.isEditing())
      this.cellCtrl.stopEditingAndFocus(!1, e.shiftKey);
    else if (this.beans.gridOptionsService.is("enterNavigatesVertically")) {
      const t = e.shiftKey ? V.UP : V.DOWN;
      this.beans.navigationService.navigateToNextCell(null, t, this.cellCtrl.getCellPosition(), !1);
    } else
      this.cellCtrl.startRowOrCellEdit(V.ENTER, e), this.cellCtrl.isEditing() && e.preventDefault();
  }
  onF2KeyDown(e) {
    this.cellCtrl.isEditing() || this.cellCtrl.startRowOrCellEdit(V.F2, e);
  }
  onEscapeKeyDown(e) {
    this.cellCtrl.isEditing() && (this.cellCtrl.stopRowOrCellEdit(!0), this.cellCtrl.focusCell(!0));
  }
  processCharacter(e) {
    if (e.target !== this.eGui || this.cellCtrl.isEditing())
      return;
    const r = e.key;
    r === " " ? this.onSpaceKeyDown(e) : (this.cellCtrl.startRowOrCellEdit(r, e), e.preventDefault());
  }
  onSpaceKeyDown(e) {
    const { gridOptionsService: t } = this.beans;
    if (!this.cellCtrl.isEditing() && t.isRowSelection()) {
      const i = this.rowNode.isSelected(), r = !i;
      if (r || !t.is("suppressRowDeselection")) {
        const n = this.beans.gridOptionsService.is("groupSelectsFiltered"), s = this.rowNode.setSelectedParams({
          newValue: r,
          rangeSelect: e.shiftKey,
          groupSelectsFiltered: n,
          event: e,
          source: "spaceKey"
        });
        i === void 0 && s === 0 && this.rowNode.setSelectedParams({
          newValue: !1,
          rangeSelect: e.shiftKey,
          groupSelectsFiltered: n,
          event: e,
          source: "spaceKey"
        });
      }
    }
    e.preventDefault();
  }
  destroy() {
    super.destroy();
  }
}
var YL = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class lx extends X {
  constructor(e, t, i) {
    super(
      /* html */
      '<div class="ag-drag-handle ag-row-drag" draggable="true"></div>'
    ), this.rowNode = e, this.column = t, this.eCell = i;
  }
  postConstruct() {
    this.getGui().appendChild(Vt("rowDrag", this.gridOptionsService, null)), this.addGuiEventListener("mousedown", (t) => {
      t.stopPropagation();
    }), this.addDragSource(), this.checkVisibility();
  }
  addDragSource() {
    this.addGuiEventListener("dragstart", this.onDragStart.bind(this));
  }
  onDragStart(e) {
    const t = this.column.getColDef().dndSourceOnRowDrag;
    e.dataTransfer.setDragImage(this.eCell, 0, 0);
    const i = () => {
      try {
        const r = JSON.stringify(this.rowNode.data);
        e.dataTransfer.setData("application/json", r), e.dataTransfer.setData("text/plain", r);
      } catch (r) {
      }
    };
    if (t) {
      const r = {
        rowNode: this.rowNode,
        dragEvent: e,
        api: this.gridOptionsService.api,
        columnApi: this.gridOptionsService.columnApi,
        context: this.gridOptionsService.context
      };
      t(r);
    } else
      i();
  }
  checkVisibility() {
    const e = this.column.isDndSource(this.rowNode);
    this.setDisplayed(e);
  }
}
YL([
  B
], lx.prototype, "postConstruct", null);
const XL = "ag-cell", qL = "ag-cell-auto-height", ZL = "ag-cell-normal-height", QL = "ag-cell-focus", JL = "ag-cell-first-right-pinned", eN = "ag-cell-last-left-pinned", tN = "ag-cell-not-inline-editing", iN = "ag-column-hover", rN = "ag-cell-wrap-text";
let nN = 0;
class un extends H {
  constructor(e, t, i, r) {
    super(), this.cellRangeFeature = null, this.cellPositionFeature = null, this.cellCustomStyleFeature = null, this.tooltipFeature = null, this.cellMouseListenerFeature = null, this.cellKeyboardListenerFeature = null, this.suppressRefreshCell = !1, this.onCellCompAttachedFuncs = [], this.column = e, this.rowNode = t, this.beans = i, this.rowCtrl = r, this.instanceId = e.getId() + "-" + nN++, this.createCellPosition(), this.addFeatures();
  }
  shouldRestoreFocus() {
    return this.beans.focusService.shouldRestoreFocus(this.cellPosition);
  }
  addFeatures() {
    this.cellPositionFeature = new UL(this, this.beans), this.addDestroyFunc(() => {
      var t;
      (t = this.cellPositionFeature) === null || t === void 0 || t.destroy(), this.cellPositionFeature = null;
    }), this.cellCustomStyleFeature = new $L(this, this.beans), this.addDestroyFunc(() => {
      var t;
      (t = this.cellCustomStyleFeature) === null || t === void 0 || t.destroy(), this.cellCustomStyleFeature = null;
    }), this.cellMouseListenerFeature = new zL(this, this.beans, this.column), this.addDestroyFunc(() => {
      var t;
      (t = this.cellMouseListenerFeature) === null || t === void 0 || t.destroy(), this.cellMouseListenerFeature = null;
    }), this.cellKeyboardListenerFeature = new KL(this, this.beans, this.column, this.rowNode, this.rowCtrl), this.addDestroyFunc(() => {
      var t;
      (t = this.cellKeyboardListenerFeature) === null || t === void 0 || t.destroy(), this.cellKeyboardListenerFeature = null;
    }), this.beans.rangeService && this.beans.gridOptionsService.isEnableRangeSelection() && (this.cellRangeFeature = new jL(this.beans, this), this.addDestroyFunc(() => {
      var t;
      (t = this.cellRangeFeature) === null || t === void 0 || t.destroy(), this.cellRangeFeature = null;
    })), this.column.isTooltipEnabled() && this.addTooltipFeature();
  }
  addTooltipFeature() {
    const t = {
      getColumn: () => this.column,
      getColDef: () => this.column.getColDef(),
      getRowIndex: () => this.cellPosition.rowIndex,
      getRowNode: () => this.rowNode,
      getGui: () => this.getGui(),
      getLocation: () => "cell",
      getTooltipValue: () => {
        const i = this.column.getColDef(), r = this.rowNode.data;
        if (i.tooltipField && z(r))
          return bd(r, i.tooltipField, this.column.isTooltipFieldContainsDots());
        const n = i.tooltipValueGetter;
        return n ? n({
          location: "cell",
          api: this.beans.gridOptionsService.api,
          columnApi: this.beans.gridOptionsService.columnApi,
          context: this.beans.gridOptionsService.context,
          colDef: this.column.getColDef(),
          column: this.column,
          rowIndex: this.cellPosition.rowIndex,
          node: this.rowNode,
          data: this.rowNode.data,
          value: this.value,
          valueFormatted: this.valueFormatted
        }) : null;
      },
      // this makes no sense, why is the cell formatted value passed to the tooltip???
      getValueFormatted: () => this.valueFormatted
    };
    this.tooltipFeature = new ab(t, this.beans), this.addDestroyFunc(() => {
      var i;
      (i = this.tooltipFeature) === null || i === void 0 || i.destroy(), this.tooltipFeature = null;
    });
  }
  setComp(e, t, i, r, n) {
    var s, a, l, c;
    this.cellComp = e, this.eGui = t, this.printLayout = r, this.updateAndFormatValue(!0), this.addDomData(), this.onCellFocused(), this.applyStaticCssClasses(), this.setWrapText(), this.onFirstRightPinnedChanged(), this.onLastLeftPinnedChanged(), this.onColumnHover(), this.setupControlComps(), i && this.setupAutoHeight(i), this.setAriaColIndex(), this.beans.gridOptionsService.is("suppressCellFocus") || this.cellComp.setTabIndex(-1);
    const d = xo(this.column.getId());
    this.cellComp.setColId(d), this.cellComp.setRole("gridcell"), (s = this.cellPositionFeature) === null || s === void 0 || s.setComp(t), (a = this.cellCustomStyleFeature) === null || a === void 0 || a.setComp(e), (l = this.tooltipFeature) === null || l === void 0 || l.setComp(e), (c = this.cellKeyboardListenerFeature) === null || c === void 0 || c.setComp(this.eGui), this.cellRangeFeature && this.cellRangeFeature.setComp(e, t), n && this.isCellEditable() ? this.startEditing() : this.showValue(), this.onCellCompAttachedFuncs.length && (this.onCellCompAttachedFuncs.forEach((u) => u()), this.onCellCompAttachedFuncs = []);
  }
  setupAutoHeight(e) {
    if (!this.column.isAutoHeight())
      return;
    const t = e.parentElement, i = this.beans.gridOptionsService.getRowHeightForNode(this.rowNode).height, r = (a) => {
      if (this.editing || !this.isAlive())
        return;
      const { paddingTop: l, paddingBottom: c, borderBottomWidth: d, borderTopWidth: u } = La(t), h = l + c + d + u, f = e.offsetHeight + h;
      if (a < 5) {
        const v = this.beans.gridOptionsService.getDocument(), y = !v || !v.contains(e), m = f == 0;
        if (y || m) {
          this.beans.frameworkOverrides.setTimeout(() => r(a + 1), 0);
          return;
        }
      }
      const g = Math.max(f, i);
      this.rowNode.setRowAutoHeight(g, this.column);
    }, n = () => r(0);
    n();
    const s = this.beans.resizeObserverService.observeResize(e, n);
    this.addDestroyFunc(() => {
      s(), this.rowNode.setRowAutoHeight(void 0, this.column);
    });
  }
  getInstanceId() {
    return this.instanceId;
  }
  showValue(e = !1) {
    const t = this.valueFormatted != null ? this.valueFormatted : this.value, i = this.createCellRendererParams(), r = this.beans.userComponentFactory.getCellRendererDetails(this.column.getColDef(), i);
    this.cellComp.setRenderDetails(r, t, e), this.refreshHandle();
  }
  setupControlComps() {
    const e = this.column.getColDef();
    this.includeSelection = this.isIncludeControl(e.checkboxSelection), this.includeRowDrag = this.isIncludeControl(e.rowDrag), this.includeDndSource = this.isIncludeControl(e.dndSource), this.cellComp.setIncludeSelection(this.includeSelection), this.cellComp.setIncludeDndSource(this.includeDndSource), this.cellComp.setIncludeRowDrag(this.includeRowDrag);
  }
  isForceWrapper() {
    return this.beans.gridOptionsService.is("enableCellTextSelection") || this.column.isAutoHeight();
  }
  isIncludeControl(e) {
    return this.rowNode.rowPinned != null ? !1 : typeof e == "function" || e === !0;
  }
  refreshShouldDestroy() {
    const e = this.column.getColDef(), t = this.includeSelection != this.isIncludeControl(e.checkboxSelection), i = this.includeRowDrag != this.isIncludeControl(e.rowDrag), r = this.includeDndSource != this.isIncludeControl(e.dndSource);
    return t || i || r;
  }
  // either called internally if single cell editing, or called by rowRenderer if row editing
  startEditing(e = null, t = !1, i = null) {
    if (!this.isCellEditable() || this.editing)
      return;
    if (!this.cellComp) {
      this.onCellCompAttachedFuncs.push(() => {
        this.startEditing(e, t, i);
      });
      return;
    }
    const r = this.createCellEditorParams(e, t), n = this.column.getColDef(), s = this.beans.userComponentFactory.getCellEditorDetails(n, r), a = (s == null ? void 0 : s.popupFromSelector) != null ? s.popupFromSelector : !!n.cellEditorPopup, l = (s == null ? void 0 : s.popupPositionFromSelector) != null ? s.popupPositionFromSelector : n.cellEditorPopupPosition;
    this.setEditing(!0), this.cellComp.setEditDetails(s, a, l);
    const c = this.createEvent(i, w.EVENT_CELL_EDITING_STARTED);
    this.beans.eventService.dispatchEvent(c);
  }
  setEditing(e) {
    this.editing !== e && (this.editing = e, this.refreshHandle());
  }
  // pass in 'true' to cancel the editing.
  stopRowOrCellEdit(e = !1) {
    this.beans.gridOptionsService.get("editType") === "fullRow" ? this.rowCtrl.stopRowEditing(e) : this.stopEditing(e);
  }
  onPopupEditorClosed() {
    this.isEditing() && this.stopEditingAndFocus();
  }
  takeValueFromCellEditor(e) {
    const t = { newValueExists: !1 };
    if (e)
      return t;
    const i = this.cellComp.getCellEditor();
    return !i || i.isCancelAfterEnd && i.isCancelAfterEnd() ? t : {
      newValue: i.getValue(),
      newValueExists: !0
    };
  }
  /**
   * @returns `True` if the value changes, otherwise `False`.
   */
  saveNewValue(e, t) {
    if (t === e)
      return !1;
    this.suppressRefreshCell = !0;
    const i = this.rowNode.setDataValue(this.column, t, "edit");
    return this.suppressRefreshCell = !1, i;
  }
  /**
   * Ends the Cell Editing
   * @param cancel `True` if the edit process is being canceled.
   * @returns `True` if the value of the `GridCell` has been updated, otherwise `False`.
   */
  stopEditing(e = !1) {
    if (!this.editing)
      return !1;
    const { newValue: t, newValueExists: i } = this.takeValueFromCellEditor(e), r = this.rowNode.getValueFromValueService(this.column);
    let n = !1;
    return i && (n = this.saveNewValue(r, t)), this.setEditing(!1), this.cellComp.setEditDetails(), this.updateAndFormatValue(), this.refreshCell({ forceRefresh: !0, suppressFlash: !0 }), this.dispatchEditingStoppedEvent(r, t, !e && !!n), n;
  }
  dispatchEditingStoppedEvent(e, t, i) {
    const r = Object.assign(Object.assign({}, this.createEvent(null, w.EVENT_CELL_EDITING_STOPPED)), {
      oldValue: e,
      newValue: t,
      valueChanged: i
    });
    this.beans.eventService.dispatchEvent(r);
  }
  createCellEditorParams(e, t) {
    return {
      value: this.rowNode.getValueFromValueService(this.column),
      eventKey: e,
      column: this.column,
      colDef: this.column.getColDef(),
      rowIndex: this.getCellPosition().rowIndex,
      node: this.rowNode,
      data: this.rowNode.data,
      api: this.beans.gridOptionsService.api,
      cellStartedEdit: t,
      columnApi: this.beans.gridOptionsService.columnApi,
      context: this.beans.gridOptionsService.context,
      onKeyDown: this.onKeyDown.bind(this),
      stopEditing: this.stopEditingAndFocus.bind(this),
      eGridCell: this.getGui(),
      parseValue: this.parseValue.bind(this),
      formatValue: this.formatValue.bind(this)
    };
  }
  createCellRendererParams() {
    return {
      value: this.value,
      valueFormatted: this.valueFormatted,
      getValue: () => this.rowNode.getValueFromValueService(this.column),
      setValue: (t) => this.beans.valueService.setValue(this.rowNode, this.column, t),
      formatValue: this.formatValue.bind(this),
      data: this.rowNode.data,
      node: this.rowNode,
      pinned: this.column.getPinned(),
      colDef: this.column.getColDef(),
      column: this.column,
      rowIndex: this.getCellPosition().rowIndex,
      api: this.beans.gridOptionsService.api,
      columnApi: this.beans.gridOptionsService.columnApi,
      context: this.beans.gridOptionsService.context,
      refreshCell: this.refreshCell.bind(this),
      eGridCell: this.getGui(),
      eParentOfValue: this.cellComp.getParentOfValue(),
      registerRowDragger: (t, i, r, n) => this.registerRowDragger(t, i, n)
    };
  }
  parseValue(e) {
    return this.beans.valueParserService.parseValue(this.column, this.rowNode, e, this.getValue());
  }
  setFocusOutOnEditor() {
    if (!this.editing)
      return;
    const e = this.cellComp.getCellEditor();
    e && e.focusOut && e.focusOut();
  }
  setFocusInOnEditor() {
    if (!this.editing)
      return;
    const e = this.cellComp.getCellEditor();
    e && e.focusIn ? e.focusIn() : this.focusCell(!0);
  }
  onCellChanged(e) {
    if (!this.cellComp)
      return;
    e.column === this.column && this.refreshCell({});
  }
  // + stop editing {forceRefresh: true, suppressFlash: true}
  // + event cellChanged {}
  // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything
  // + rowCtrl: event dataChanged {suppressFlash: !update, newData: !update}
  // + rowCtrl: api refreshCells() {animate: true/false}
  // + rowRenderer: api softRefreshView() {}
  refreshCell(e) {
    var t, i, r;
    if (this.suppressRefreshCell || this.editing || !this.cellComp)
      return;
    const n = this.column.getColDef(), s = e != null && !!e.newData, a = e != null && !!e.suppressFlash || !!n.suppressCellFlash, l = n.field == null && n.valueGetter == null && n.showRowGroup == null, c = e && e.forceRefresh || l || s, d = this.updateAndFormatValue();
    if (c || d) {
      this.showValue(s);
      const h = this.beans.filterManager.isSuppressFlashingCellsBecauseFiltering();
      !a && !h && (this.beans.gridOptionsService.is("enableCellChangeFlash") || n.enableCellChangeFlash) && this.flashCell(), (t = this.cellCustomStyleFeature) === null || t === void 0 || t.applyUserStyles(), (i = this.cellCustomStyleFeature) === null || i === void 0 || i.applyClassesFromColDef();
    }
    this.refreshToolTip(), (r = this.cellCustomStyleFeature) === null || r === void 0 || r.applyCellClassRules();
  }
  // cell editors call this, when they want to stop for reasons other
  // than what we pick up on. eg selecting from a dropdown ends editing.
  stopEditingAndFocus(e = !1, t = !1) {
    this.stopRowOrCellEdit(), this.focusCell(!0), e || this.navigateAfterEdit(t);
  }
  navigateAfterEdit(e) {
    if (this.beans.gridOptionsService.is("enterNavigatesVerticallyAfterEdit")) {
      const i = e ? V.UP : V.DOWN;
      this.beans.navigationService.navigateToNextCell(null, i, this.getCellPosition(), !1);
    }
  }
  // user can also call this via API
  flashCell(e) {
    const t = e && e.flashDelay, i = e && e.fadeDelay;
    this.animateCell("data-changed", t, i);
  }
  animateCell(e, t, i) {
    var r, n;
    const s = `ag-cell-${e}`, a = `ag-cell-${e}-animation`, { gridOptionsService: l } = this.beans;
    t || (t = (r = l.getNum("cellFlashDelay")) !== null && r !== void 0 ? r : 500), z(i) || (i = (n = l.getNum("cellFadeDelay")) !== null && n !== void 0 ? n : 1e3), this.cellComp.addOrRemoveCssClass(s, !0), this.cellComp.addOrRemoveCssClass(a, !1), window.setTimeout(() => {
      this.isAlive() && (this.cellComp.addOrRemoveCssClass(s, !1), this.cellComp.addOrRemoveCssClass(a, !0), this.eGui.style.transition = `background-color ${i}ms`, window.setTimeout(() => {
        this.isAlive() && (this.cellComp.addOrRemoveCssClass(a, !1), this.eGui.style.transition = "");
      }, i));
    }, t);
  }
  onFlashCells(e) {
    if (!this.cellComp)
      return;
    const t = this.beans.cellPositionUtils.createId(this.getCellPosition());
    e.cells[t] && this.animateCell("highlight");
  }
  isCellEditable() {
    return this.column.isCellEditable(this.rowNode);
  }
  isSuppressFillHandle() {
    return this.column.isSuppressFillHandle();
  }
  formatValue(e) {
    const t = this.callValueFormatter(e);
    return t != null ? t : e;
  }
  callValueFormatter(e) {
    return this.beans.valueFormatterService.formatValue(this.column, this.rowNode, e);
  }
  updateAndFormatValue(e = !1) {
    const t = this.value, i = this.valueFormatted;
    return this.value = this.rowNode.getValueFromValueService(this.column), this.valueFormatted = this.callValueFormatter(this.value), e ? !0 : !this.valuesAreEqual(t, this.value) || this.valueFormatted != i;
  }
  valuesAreEqual(e, t) {
    const i = this.column.getColDef();
    return i.equals ? i.equals(e, t) : e === t;
  }
  getComp() {
    return this.cellComp;
  }
  getValue() {
    return this.value;
  }
  getValueFormatted() {
    return this.valueFormatted;
  }
  addDomData() {
    const e = this.getGui();
    this.beans.gridOptionsService.setDomData(e, un.DOM_DATA_KEY_CELL_CTRL, this), this.addDestroyFunc(() => this.beans.gridOptionsService.setDomData(e, un.DOM_DATA_KEY_CELL_CTRL, null));
  }
  createEvent(e, t) {
    return {
      type: t,
      node: this.rowNode,
      data: this.rowNode.data,
      value: this.value,
      column: this.column,
      colDef: this.column.getColDef(),
      context: this.beans.gridOptionsService.context,
      api: this.beans.gridApi,
      columnApi: this.beans.columnApi,
      rowPinned: this.rowNode.rowPinned,
      event: e,
      rowIndex: this.rowNode.rowIndex
    };
  }
  processCharacter(e) {
    var t;
    (t = this.cellKeyboardListenerFeature) === null || t === void 0 || t.processCharacter(e);
  }
  onKeyDown(e) {
    var t;
    (t = this.cellKeyboardListenerFeature) === null || t === void 0 || t.onKeyDown(e);
  }
  onMouseEvent(e, t) {
    var i;
    (i = this.cellMouseListenerFeature) === null || i === void 0 || i.onMouseEvent(e, t);
  }
  getGui() {
    return this.eGui;
  }
  refreshToolTip() {
    var e;
    (e = this.tooltipFeature) === null || e === void 0 || e.refreshToolTip();
  }
  getColSpanningList() {
    return this.cellPositionFeature.getColSpanningList();
  }
  onLeftChanged() {
    var e;
    this.cellComp && ((e = this.cellPositionFeature) === null || e === void 0 || e.onLeftChanged());
  }
  onDisplayedColumnsChanged() {
    this.eGui && this.setAriaColIndex();
  }
  setAriaColIndex() {
    const e = this.beans.columnModel.getAriaColumnIndex(this.column);
    OS(this.getGui(), e);
  }
  isSuppressNavigable() {
    return this.column.isSuppressNavigable(this.rowNode);
  }
  onWidthChanged() {
    var e;
    return (e = this.cellPositionFeature) === null || e === void 0 ? void 0 : e.onWidthChanged();
  }
  getColumn() {
    return this.column;
  }
  getRowNode() {
    return this.rowNode;
  }
  getBeans() {
    return this.beans;
  }
  isPrintLayout() {
    return this.printLayout;
  }
  appendChild(e) {
    this.eGui.appendChild(e);
  }
  refreshHandle() {
    this.cellRangeFeature && this.cellRangeFeature.refreshHandle();
  }
  getCellPosition() {
    return this.cellPosition;
  }
  isEditing() {
    return this.editing;
  }
  // called by rowRenderer when user navigates via tab key
  startRowOrCellEdit(e, t = null) {
    this.cellComp && (this.beans.gridOptionsService.get("editType") === "fullRow" ? this.rowCtrl.startRowEditing(e, this) : this.startEditing(e, !0, t));
  }
  getRowCtrl() {
    return this.rowCtrl;
  }
  getRowPosition() {
    return {
      rowIndex: this.cellPosition.rowIndex,
      rowPinned: this.cellPosition.rowPinned
    };
  }
  updateRangeBordersIfRangeCount() {
    this.cellComp && this.cellRangeFeature && this.cellRangeFeature.updateRangeBordersIfRangeCount();
  }
  onRangeSelectionChanged() {
    this.cellComp && this.cellRangeFeature && this.cellRangeFeature.onRangeSelectionChanged();
  }
  isRangeSelectionEnabled() {
    return this.cellRangeFeature != null;
  }
  focusCell(e = !1) {
    this.beans.focusService.setFocusedCell({
      rowIndex: this.getCellPosition().rowIndex,
      column: this.column,
      rowPinned: this.rowNode.rowPinned,
      forceBrowserFocus: e
    });
  }
  onRowIndexChanged() {
    this.createCellPosition(), this.onCellFocused(), this.cellRangeFeature && this.cellRangeFeature.onRangeSelectionChanged();
  }
  onFirstRightPinnedChanged() {
    if (!this.cellComp)
      return;
    const e = this.column.isFirstRightPinned();
    this.cellComp.addOrRemoveCssClass(JL, e);
  }
  onLastLeftPinnedChanged() {
    if (!this.cellComp)
      return;
    const e = this.column.isLastLeftPinned();
    this.cellComp.addOrRemoveCssClass(eN, e);
  }
  onCellFocused(e) {
    if (!this.cellComp || this.beans.gridOptionsService.is("suppressCellFocus"))
      return;
    const t = this.beans.focusService.isCellFocused(this.cellPosition);
    this.cellComp.addOrRemoveCssClass(QL, t), t && e && e.forceBrowserFocus && this.cellComp.getFocusableElement().focus({ preventScroll: !!e.preventScrollOnBrowserFocus });
    const i = this.beans.gridOptionsService.get("editType") === "fullRow";
    !t && !i && this.editing && this.stopRowOrCellEdit();
  }
  createCellPosition() {
    this.cellPosition = {
      rowIndex: this.rowNode.rowIndex,
      rowPinned: ca(this.rowNode.rowPinned),
      column: this.column
    };
  }
  // CSS Classes that only get applied once, they never change
  applyStaticCssClasses() {
    this.cellComp.addOrRemoveCssClass(XL, !0), this.cellComp.addOrRemoveCssClass(tN, !0);
    const e = this.column.isAutoHeight() == !0;
    this.cellComp.addOrRemoveCssClass(qL, e), this.cellComp.addOrRemoveCssClass(ZL, !e);
  }
  onColumnHover() {
    if (!this.cellComp || !this.beans.gridOptionsService.is("columnHoverHighlight"))
      return;
    const e = this.beans.columnHoverService.isHovered(this.column);
    this.cellComp.addOrRemoveCssClass(iN, e);
  }
  onColDefChanged() {
    this.cellComp && (this.setWrapText(), this.editing || this.refreshCell({ forceRefresh: !0, suppressFlash: !0 }));
  }
  setWrapText() {
    const e = this.column.getColDef().wrapText == !0;
    this.cellComp.addOrRemoveCssClass(rN, e);
  }
  dispatchCellContextMenuEvent(e) {
    const t = this.column.getColDef(), i = this.createEvent(e, w.EVENT_CELL_CONTEXT_MENU);
    this.beans.eventService.dispatchEvent(i), t.onCellContextMenu && window.setTimeout(() => t.onCellContextMenu(i), 0);
  }
  getCellRenderer() {
    return this.cellComp ? this.cellComp.getCellRenderer() : null;
  }
  getCellEditor() {
    return this.cellComp ? this.cellComp.getCellEditor() : null;
  }
  destroy() {
    this.onCellCompAttachedFuncs = [], super.destroy();
  }
  createSelectionCheckbox() {
    const e = new $v();
    return this.beans.context.createBean(e), e.init({ rowNode: this.rowNode, column: this.column }), e;
  }
  createDndSource() {
    const e = new lx(this.rowNode, this.column, this.eGui);
    return this.beans.context.createBean(e), e;
  }
  registerRowDragger(e, t, i) {
    if (this.customRowDragComp) {
      this.customRowDragComp.setDragElement(e, t);
      return;
    }
    const r = this.createRowDragComp(e, t, i);
    r && (this.customRowDragComp = r, this.addDestroyFunc(() => {
      this.beans.context.destroyBean(r), this.customRowDragComp = null;
    }));
  }
  createRowDragComp(e, t, i) {
    const r = this.beans.gridOptionsService.is("pagination"), n = this.beans.gridOptionsService.is("rowDragManaged"), s = this.beans.gridOptionsService.isRowModelType("clientSide");
    if (n) {
      if (!s) {
        tt(() => console.warn("AG Grid: managed row dragging is only allowed in the Client Side Row Model"), "CellComp.addRowDragging");
        return;
      }
      if (r) {
        tt(() => console.warn("AG Grid: managed row dragging is not possible when doing pagination"), "CellComp.addRowDragging");
        return;
      }
    }
    const a = new Il(() => this.value, this.rowNode, this.column, e, t, i);
    return this.beans.context.createBean(a), a;
  }
}
un.DOM_DATA_KEY_CELL_CTRL = "cellCtrl";
var er;
(function(o) {
  o.Normal = "Normal", o.FullWidth = "FullWidth", o.FullWidthLoading = "FullWidthLoading", o.FullWidthGroup = "FullWidthGroup", o.FullWidthDetail = "FullWidthDetail";
})(er || (er = {}));
let oN = 0;
class Gn extends H {
  constructor(e, t, i, r, n) {
    super(), this.allRowGuis = [], this.active = !0, this.centerCellCtrls = { list: [], map: {} }, this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} }, this.slideInAnimation = {
      left: !1,
      center: !1,
      right: !1,
      fullWidth: !1
    }, this.fadeInAnimation = {
      left: !1,
      center: !1,
      right: !1,
      fullWidth: !1
    }, this.lastMouseDownOnDragger = !1, this.updateColumnListsPending = !1, this.businessKeySanitised = null, this.beans = t, this.gridOptionsService = t.gridOptionsService, this.rowNode = e, this.paginationPage = t.paginationProxy.getCurrentPage(), this.useAnimationFrameForCreate = r, this.printLayout = n, this.instanceId = e.id + "-" + oN++, this.setAnimateFlags(i), this.initRowBusinessKey(), this.rowFocused = t.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned), this.rowLevel = t.rowCssClassCalculator.calculateRowLevel(this.rowNode), this.setRowType(), this.addListeners();
  }
  initRowBusinessKey() {
    this.businessKeyForNodeFunc = this.gridOptionsService.get("getBusinessKeyForNode"), this.updateRowBusinessKey();
  }
  updateRowBusinessKey() {
    if (typeof this.businessKeyForNodeFunc != "function")
      return;
    const e = this.businessKeyForNodeFunc(this.rowNode);
    this.businessKeySanitised = xo(e);
  }
  isSticky() {
    return this.rowNode.sticky;
  }
  getBeans() {
    return this.beans;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setComp(e, t, i) {
    const r = { rowComp: e, element: t, containerType: i };
    this.allRowGuis.push(r), i === Li.LEFT ? this.leftGui = r : i === Li.RIGHT ? this.rightGui = r : i === Li.FULL_WIDTH ? this.fullWidthGui = r : this.centerGui = r, this.initialiseRowComp(r), this.rowType !== "FullWidthLoading" && !this.rowNode.rowPinned && this.beans.rowRenderer.dispatchFirstDataRenderedEvent();
  }
  unsetComp(e) {
    this.allRowGuis = this.allRowGuis.filter((t) => t.containerType !== e), e === Li.LEFT ? this.leftGui = void 0 : e === Li.RIGHT ? this.rightGui = void 0 : e === Li.FULL_WIDTH && (this.fullWidthGui = void 0);
  }
  isCacheable() {
    return this.rowType === er.FullWidthDetail && this.gridOptionsService.is("keepDetailRows");
  }
  setCached(e) {
    const t = e ? "none" : "";
    this.allRowGuis.forEach((i) => i.element.style.display = t);
  }
  initialiseRowComp(e) {
    const t = this.gridOptionsService;
    this.listenOnDomOrder(e), this.onRowHeightChanged(e), this.updateRowIndexes(e), this.setFocusedClasses(e), this.setStylesFromGridOptions(e), t.isRowSelection() && this.rowNode.selectable && this.onRowSelected(e), this.updateColumnLists(!this.useAnimationFrameForCreate);
    const i = e.rowComp;
    i.setRole("row"), this.getInitialRowClasses(e.containerType).forEach((n) => i.addOrRemoveCssClass(n, !0)), this.executeSlideAndFadeAnimations(e), this.rowNode.group && Ln(e.element, this.rowNode.expanded == !0), this.setRowCompRowId(i), this.setRowCompRowBusinessKey(i), this.isFullWidth() && !this.gridOptionsService.is("suppressCellFocus") && i.setTabIndex(-1), t.setDomData(e.element, Gn.DOM_DATA_KEY_ROW_CTRL, this), this.addDestroyFunc(() => t.setDomData(e.element, Gn.DOM_DATA_KEY_ROW_CTRL, null)), this.useAnimationFrameForCreate ? this.beans.animationFrameService.createTask(this.addHoverFunctionality.bind(this, e.element), this.rowNode.rowIndex, "createTasksP2") : this.addHoverFunctionality(e.element), this.isFullWidth() && this.setupFullWidth(e), t.is("rowDragEntireRow") && this.addRowDraggerToRow(e), this.useAnimationFrameForCreate && this.beans.animationFrameService.addDestroyTask(() => {
      this.isAlive() && e.rowComp.addOrRemoveCssClass("ag-after-created", !0);
    }), this.executeProcessRowPostCreateFunc();
  }
  setRowCompRowBusinessKey(e) {
    this.businessKeySanitised != null && e.setRowBusinessKey(this.businessKeySanitised);
  }
  setRowCompRowId(e) {
    const t = xo(this.rowNode.id);
    t != null && e.setRowId(t);
  }
  executeSlideAndFadeAnimations(e) {
    const { containerType: t } = e;
    this.slideInAnimation[t] && (fC(() => {
      this.onTopChanged();
    }), this.slideInAnimation[t] = !1), this.fadeInAnimation[t] && (fC(() => {
      e.rowComp.addOrRemoveCssClass("ag-opacity-zero", !1);
    }), this.fadeInAnimation[t] = !1);
  }
  addRowDraggerToRow(e) {
    if (this.gridOptionsService.isEnableRangeSelection()) {
      tt(() => {
        console.warn("AG Grid: Setting `rowDragEntireRow: true` in the gridOptions doesn't work with `enableRangeSelection: true`");
      }, "rowDragAndRangeSelectionEnabled");
      return;
    }
    const t = this.beans.localeService.getLocaleTextFunc(), i = new Il(() => `1 ${t("rowDragRow", "row")}`, this.rowNode, void 0, e.element, void 0, !0);
    this.createManagedBean(i, this.beans.context);
  }
  setupFullWidth(e) {
    const t = this.getPinnedForContainer(e.containerType), i = this.createFullWidthParams(e.element, t);
    if (this.rowType == er.FullWidthDetail && !Z.__assertRegistered(Q.MasterDetailModule, "cell renderer 'agDetailCellRenderer' (for master detail)", this.beans.context.getGridId()))
      return;
    let r;
    switch (this.rowType) {
      case er.FullWidthDetail:
        r = this.beans.userComponentFactory.getFullWidthDetailCellRendererDetails(i);
        break;
      case er.FullWidthGroup:
        r = this.beans.userComponentFactory.getFullWidthGroupCellRendererDetails(i);
        break;
      case er.FullWidthLoading:
        r = this.beans.userComponentFactory.getFullWidthLoadingCellRendererDetails(i);
        break;
      default:
        r = this.beans.userComponentFactory.getFullWidthCellRendererDetails(i);
        break;
    }
    e.rowComp.showFullWidth(r);
  }
  isPrintLayout() {
    return this.printLayout;
  }
  getFullWidthCellRenderer() {
    var e, t;
    return (t = (e = this.fullWidthGui) === null || e === void 0 ? void 0 : e.rowComp) === null || t === void 0 ? void 0 : t.getFullWidthCellRenderer();
  }
  // use by autoWidthCalculator, as it clones the elements
  getCellElement(e) {
    const t = this.getCellCtrl(e);
    return t ? t.getGui() : null;
  }
  executeProcessRowPostCreateFunc() {
    var e;
    const t = this.gridOptionsService.getCallback("processRowPostCreate");
    if (!t || !this.areAllContainersReady())
      return;
    const i = {
      eRow: (e = this.centerGui) === null || e === void 0 ? void 0 : e.element,
      ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
      ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
      node: this.rowNode,
      rowIndex: this.rowNode.rowIndex,
      addRenderedRowListener: this.addEventListener.bind(this)
    };
    t(i);
  }
  areAllContainersReady() {
    const e = !!this.leftGui || !this.beans.columnModel.isPinningLeft(), t = !!this.centerGui, i = !!this.rightGui || !this.beans.columnModel.isPinningRight();
    return e && t && i;
  }
  setRowType() {
    const e = this.rowNode.stub, t = this.rowNode.isFullWidthCell(), i = this.beans.doingMasterDetail && this.rowNode.detail, r = this.beans.columnModel.isPivotMode(), s = !!this.rowNode.group && !this.rowNode.footer && this.gridOptionsService.isGroupUseEntireRow(r);
    e ? this.rowType = er.FullWidthLoading : i ? this.rowType = er.FullWidthDetail : t ? this.rowType = er.FullWidth : s ? this.rowType = er.FullWidthGroup : this.rowType = er.Normal;
  }
  updateColumnLists(e = !1, t = !1) {
    if (this.isFullWidth())
      return;
    if (e || this.gridOptionsService.is("suppressAnimationFrame") || this.printLayout) {
      this.updateColumnListsImpl(t);
      return;
    }
    this.updateColumnListsPending || (this.beans.animationFrameService.createTask(() => {
      this.active && this.updateColumnListsImpl(!0);
    }, this.rowNode.rowIndex, "createTasksP1"), this.updateColumnListsPending = !0);
  }
  createCellCtrls(e, t, i = null) {
    const r = {
      list: [],
      map: {}
    }, n = (s, a) => {
      r.list.push(a), r.map[s] = a;
    };
    return t.forEach((s) => {
      const a = s.getInstanceId();
      let l = e.map[a];
      l || (l = new un(s, this.rowNode, this.beans, this)), n(a, l);
    }), e.list.forEach((s) => {
      if (r.map[s.getColumn().getInstanceId()] != null)
        return;
      if (!this.isCellEligibleToBeRemoved(s, i)) {
        n(s.getColumn().getInstanceId(), s);
        return;
      }
      s.destroy();
    }), r;
  }
  updateColumnListsImpl(e = !1) {
    this.updateColumnListsPending = !1;
    const t = this.beans.columnModel;
    if (this.printLayout)
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, t.getAllDisplayedColumns()), this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} };
    else {
      const i = t.getViewportCenterColumnsForRow(this.rowNode);
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, i);
      const r = t.getDisplayedLeftColumnsForRow(this.rowNode);
      this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, r, "left");
      const n = t.getDisplayedRightColumnsForRow(this.rowNode);
      this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, n, "right");
    }
    this.allRowGuis.forEach((i) => {
      const r = i.containerType === Li.LEFT ? this.leftCellCtrls : i.containerType === Li.RIGHT ? this.rightCellCtrls : this.centerCellCtrls;
      i.rowComp.setCellCtrls(r.list, e);
    });
  }
  isCellEligibleToBeRemoved(e, t) {
    if (e.getColumn().getPinned() != t)
      return !0;
    const s = e.isEditing(), a = this.beans.focusService.isCellFocused(e.getCellPosition());
    if (s || a) {
      const c = e.getColumn();
      return !(this.beans.columnModel.getAllDisplayedColumns().indexOf(c) >= 0);
    }
    return !0;
  }
  listenOnDomOrder(e) {
    const t = () => {
      const i = this.gridOptionsService.is("ensureDomOrder"), r = this.gridOptionsService.isDomLayout("print");
      e.rowComp.setDomOrder(i || r);
    };
    this.addManagedPropertyListener("domLayout", t), t();
  }
  setAnimateFlags(e) {
    if (this.isSticky() || !e)
      return;
    const t = z(this.rowNode.oldRowTop), i = this.beans.columnModel.isPinningLeft(), r = this.beans.columnModel.isPinningRight();
    t ? (this.slideInAnimation.center = !0, this.slideInAnimation.left = i, this.slideInAnimation.right = r) : (this.fadeInAnimation.center = !0, this.fadeInAnimation.left = i, this.fadeInAnimation.right = r);
  }
  isEditing() {
    return this.editingRow;
  }
  stopRowEditing(e) {
    this.stopEditing(e);
  }
  isFullWidth() {
    return this.rowType !== er.Normal;
  }
  getRowType() {
    return this.rowType;
  }
  refreshFullWidth() {
    const e = (a, l) => {
      if (!a)
        return !0;
      const c = a.rowComp.getFullWidthCellRenderer();
      if (!c || !c.refresh)
        return !1;
      const d = this.createFullWidthParams(a.element, l);
      return c.refresh(d);
    }, t = e(this.fullWidthGui, null), i = e(this.centerGui, null), r = e(this.leftGui, "left"), n = e(this.rightGui, "right");
    return t && i && r && n;
  }
  addListeners() {
    this.addManagedListener(this.rowNode, re.EVENT_HEIGHT_CHANGED, () => this.onRowHeightChanged()), this.addManagedListener(this.rowNode, re.EVENT_ROW_SELECTED, () => this.onRowSelected()), this.addManagedListener(this.rowNode, re.EVENT_ROW_INDEX_CHANGED, this.onRowIndexChanged.bind(this)), this.addManagedListener(this.rowNode, re.EVENT_TOP_CHANGED, this.onTopChanged.bind(this)), this.addManagedListener(this.rowNode, re.EVENT_EXPANDED_CHANGED, this.updateExpandedCss.bind(this)), this.addManagedListener(this.rowNode, re.EVENT_HAS_CHILDREN_CHANGED, this.updateExpandedCss.bind(this)), this.addManagedListener(this.rowNode, re.EVENT_DATA_CHANGED, this.onRowNodeDataChanged.bind(this)), this.addManagedListener(this.rowNode, re.EVENT_CELL_CHANGED, this.onRowNodeCellChanged.bind(this)), this.addManagedListener(this.rowNode, re.EVENT_HIGHLIGHT_CHANGED, this.onRowNodeHighlightChanged.bind(this)), this.addManagedListener(this.rowNode, re.EVENT_DRAGGING_CHANGED, this.onRowNodeDraggingChanged.bind(this)), this.addManagedListener(this.rowNode, re.EVENT_UI_LEVEL_CHANGED, this.onUiLevelChanged.bind(this));
    const e = this.beans.eventService;
    this.addManagedListener(e, w.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED, this.onPaginationPixelOffsetChanged.bind(this)), this.addManagedListener(e, w.EVENT_HEIGHT_SCALE_CHANGED, this.onTopChanged.bind(this)), this.addManagedListener(e, w.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(e, w.EVENT_VIRTUAL_COLUMNS_CHANGED, this.onVirtualColumnsChanged.bind(this)), this.addManagedListener(e, w.EVENT_CELL_FOCUSED, this.onCellFocused.bind(this)), this.addManagedListener(e, w.EVENT_CELL_FOCUS_CLEARED, this.onCellFocusCleared.bind(this)), this.addManagedListener(e, w.EVENT_PAGINATION_CHANGED, this.onPaginationChanged.bind(this)), this.addManagedListener(e, w.EVENT_MODEL_UPDATED, this.onModelUpdated.bind(this)), this.addManagedListener(e, w.EVENT_COLUMN_MOVED, this.onColumnMoved.bind(this)), this.addListenersForCellComps();
  }
  onColumnMoved() {
    this.updateColumnLists();
  }
  addListenersForCellComps() {
    this.addManagedListener(this.rowNode, re.EVENT_ROW_INDEX_CHANGED, () => {
      this.getAllCellCtrls().forEach((e) => e.onRowIndexChanged());
    }), this.addManagedListener(this.rowNode, re.EVENT_CELL_CHANGED, (e) => {
      this.getAllCellCtrls().forEach((t) => t.onCellChanged(e));
    });
  }
  onRowNodeDataChanged(e) {
    if (this.rowNode.detailNode && this.beans.rowRenderer.refreshFullWidthRow(this.rowNode.detailNode), this.isFullWidth()) {
      this.beans.rowRenderer.refreshFullWidthRow(this.rowNode);
      return;
    }
    this.getAllCellCtrls().forEach((t) => t.refreshCell({
      suppressFlash: !e.update,
      newData: !e.update
    })), this.allRowGuis.forEach((t) => {
      this.setRowCompRowId(t.rowComp), this.updateRowBusinessKey(), this.setRowCompRowBusinessKey(t.rowComp);
    }), this.onRowSelected(), this.postProcessCss();
  }
  onRowNodeCellChanged() {
    this.postProcessCss();
  }
  postProcessCss() {
    this.setStylesFromGridOptions(), this.postProcessClassesFromGridOptions(), this.postProcessRowClassRules(), this.postProcessRowDragging();
  }
  onRowNodeHighlightChanged() {
    const e = this.rowNode.highlighted;
    this.allRowGuis.forEach((t) => {
      const i = e === ms.Above, r = e === ms.Below;
      t.rowComp.addOrRemoveCssClass("ag-row-highlight-above", i), t.rowComp.addOrRemoveCssClass("ag-row-highlight-below", r);
    });
  }
  onRowNodeDraggingChanged() {
    this.postProcessRowDragging();
  }
  postProcessRowDragging() {
    const e = this.rowNode.dragging;
    this.allRowGuis.forEach((t) => t.rowComp.addOrRemoveCssClass("ag-row-dragging", e));
  }
  updateExpandedCss() {
    const e = this.rowNode.isExpandable(), t = this.rowNode.expanded == !0;
    this.allRowGuis.forEach((i) => {
      i.rowComp.addOrRemoveCssClass("ag-row-group", e), i.rowComp.addOrRemoveCssClass("ag-row-group-expanded", e && t), i.rowComp.addOrRemoveCssClass("ag-row-group-contracted", e && !t), Ln(i.element, e && t);
    });
  }
  onDisplayedColumnsChanged() {
    this.updateColumnLists(!0), this.beans.columnModel.wasAutoRowHeightEverActive() && this.rowNode.checkAutoHeights();
  }
  onVirtualColumnsChanged() {
    this.updateColumnLists(!1, !0);
  }
  getRowPosition() {
    return {
      rowPinned: ca(this.rowNode.rowPinned),
      rowIndex: this.rowNode.rowIndex
    };
  }
  onKeyboardNavigate(e) {
    const t = this.allRowGuis.find((l) => l.element.contains(e.target));
    if (!((t ? t.element : null) === e.target))
      return;
    const n = this.rowNode, s = this.beans.focusService.getFocusedCell(), a = {
      rowIndex: n.rowIndex,
      rowPinned: n.rowPinned,
      column: s && s.column
    };
    this.beans.navigationService.navigateToNextCell(e, e.key, a, !0), e.preventDefault();
  }
  onTabKeyDown(e) {
    if (e.defaultPrevented || Eo(e))
      return;
    const t = this.allRowGuis.find((s) => s.element.contains(e.target)), i = t ? t.element : null, r = i === e.target;
    let n = null;
    r || (n = this.beans.focusService.findNextFocusableElement(i, !1, e.shiftKey)), (this.isFullWidth() && r || !n) && this.beans.navigationService.onTabKeyDown(this, e);
  }
  onFullWidthRowFocused(e) {
    var t;
    const i = this.rowNode, r = e ? this.isFullWidth() && e.rowIndex === i.rowIndex && e.rowPinned == i.rowPinned : !1, n = this.fullWidthGui ? this.fullWidthGui.element : (t = this.centerGui) === null || t === void 0 ? void 0 : t.element;
    n && (n.classList.toggle("ag-full-width-focus", r), r && n.focus({ preventScroll: !0 }));
  }
  refreshCell(e) {
    this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, e), this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, e), this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, e), this.updateColumnLists();
  }
  removeCellCtrl(e, t) {
    const i = {
      list: [],
      map: {}
    };
    return e.list.forEach((r) => {
      r !== t && (i.list.push(r), i.map[r.getInstanceId()] = r);
    }), i;
  }
  onMouseEvent(e, t) {
    switch (e) {
      case "dblclick":
        this.onRowDblClick(t);
        break;
      case "click":
        this.onRowClick(t);
        break;
      case "touchstart":
      case "mousedown":
        this.onRowMouseDown(t);
        break;
    }
  }
  createRowEvent(e, t) {
    return {
      type: e,
      node: this.rowNode,
      data: this.rowNode.data,
      rowIndex: this.rowNode.rowIndex,
      rowPinned: this.rowNode.rowPinned,
      context: this.gridOptionsService.context,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      event: t
    };
  }
  createRowEventWithSource(e, t) {
    const i = this.createRowEvent(e, t);
    return i.source = this, i;
  }
  onRowDblClick(e) {
    if (Eo(e))
      return;
    const t = this.createRowEventWithSource(w.EVENT_ROW_DOUBLE_CLICKED, e);
    this.beans.eventService.dispatchEvent(t);
  }
  onRowMouseDown(e) {
    if (this.lastMouseDownOnDragger = Ol(e.target, "ag-row-drag", 3), !this.isFullWidth())
      return;
    const t = this.rowNode, i = this.beans.columnModel;
    this.beans.rangeService && this.beans.rangeService.removeAllCellRanges(), this.beans.focusService.setFocusedCell({
      rowIndex: t.rowIndex,
      column: i.getAllDisplayedColumns()[0],
      rowPinned: t.rowPinned,
      forceBrowserFocus: !0
    });
  }
  onRowClick(e) {
    if (Eo(e) || this.lastMouseDownOnDragger)
      return;
    const i = this.createRowEventWithSource(w.EVENT_ROW_CLICKED, e);
    this.beans.eventService.dispatchEvent(i);
    const r = e.ctrlKey || e.metaKey, n = e.shiftKey;
    if (
      // we do not allow selecting groups by clicking (as the click here expands the group), or if it's a detail row,
      // so return if it's a group row
      this.gridOptionsService.is("groupSelectsChildren") && this.rowNode.group || // this is needed so we don't unselect other rows when we click this row, eg if this row is not selectable,
      // and we click it, the selection should not change (ie any currently selected row should stay selected)
      !this.rowNode.selectable || // we also don't allow selection of pinned rows
      this.rowNode.rowPinned || // if no selection method enabled, do nothing
      !this.gridOptionsService.isRowSelection() || // if click selection suppressed, do nothing
      this.gridOptionsService.is("suppressRowClickSelection")
    )
      return;
    const a = this.gridOptionsService.is("rowMultiSelectWithClick"), l = !this.gridOptionsService.is("suppressRowDeselection"), c = "rowClicked";
    if (this.rowNode.isSelected())
      a ? this.rowNode.setSelectedParams({ newValue: !1, event: e, source: c }) : r ? l && this.rowNode.setSelectedParams({ newValue: !1, event: e, source: c }) : this.rowNode.setSelectedParams({ newValue: !0, clearSelection: !n, rangeSelect: n, event: e, source: c });
    else {
      const d = a ? !1 : !r;
      this.rowNode.setSelectedParams({ newValue: !0, clearSelection: d, rangeSelect: n, event: e, source: c });
    }
  }
  setupDetailRowAutoHeight(e) {
    if (this.rowType !== er.FullWidthDetail || !this.gridOptionsService.is("detailRowAutoHeight"))
      return;
    const t = () => {
      const r = e.clientHeight;
      if (r != null && r > 0) {
        const n = () => {
          this.rowNode.setRowHeight(r), this.beans.clientSideRowModel ? this.beans.clientSideRowModel.onRowHeightChanged() : this.beans.serverSideRowModel && this.beans.serverSideRowModel.onRowHeightChanged();
        };
        this.beans.frameworkOverrides.setTimeout(n, 0);
      }
    }, i = this.beans.resizeObserverService.observeResize(e, t);
    this.addDestroyFunc(i), t();
  }
  createFullWidthParams(e, t) {
    return {
      fullWidth: !0,
      data: this.rowNode.data,
      node: this.rowNode,
      value: this.rowNode.key,
      valueFormatted: this.rowNode.key,
      rowIndex: this.rowNode.rowIndex,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context,
      // these need to be taken out, as part of 'afterAttached' now
      eGridCell: e,
      eParentOfValue: e,
      pinned: t,
      addRenderedRowListener: this.addEventListener.bind(this),
      registerRowDragger: (r, n, s, a) => this.addFullWidthRowDragging(r, n, s, a)
    };
  }
  addFullWidthRowDragging(e, t, i = "", r) {
    if (!this.isFullWidth())
      return;
    const n = new Il(() => i, this.rowNode, void 0, e, t, r);
    this.createManagedBean(n, this.beans.context);
  }
  onUiLevelChanged() {
    const e = this.beans.rowCssClassCalculator.calculateRowLevel(this.rowNode);
    if (this.rowLevel != e) {
      const t = "ag-row-level-" + e, i = "ag-row-level-" + this.rowLevel;
      this.allRowGuis.forEach((r) => {
        r.rowComp.addOrRemoveCssClass(t, !0), r.rowComp.addOrRemoveCssClass(i, !1);
      });
    }
    this.rowLevel = e;
  }
  isFirstRowOnPage() {
    return this.rowNode.rowIndex === this.beans.paginationProxy.getPageFirstRow();
  }
  isLastRowOnPage() {
    return this.rowNode.rowIndex === this.beans.paginationProxy.getPageLastRow();
  }
  onModelUpdated() {
    this.refreshFirstAndLastRowStyles();
  }
  refreshFirstAndLastRowStyles() {
    const e = this.isFirstRowOnPage(), t = this.isLastRowOnPage();
    this.firstRowOnPage !== e && (this.firstRowOnPage = e, this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass("ag-row-first", e))), this.lastRowOnPage !== t && (this.lastRowOnPage = t, this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass("ag-row-last", t)));
  }
  stopEditing(e = !1) {
    if (this.stoppingRowEdit)
      return;
    const t = this.getAllCellCtrls(), i = this.editingRow;
    this.stoppingRowEdit = !0;
    let r = !1;
    for (const n of t) {
      const s = n.stopEditing(e);
      i && !e && !r && s && (r = !0);
    }
    if (r) {
      const n = this.createRowEvent(w.EVENT_ROW_VALUE_CHANGED);
      this.beans.eventService.dispatchEvent(n);
    }
    i && this.setEditingRow(!1), this.stoppingRowEdit = !1;
  }
  setInlineEditingCss(e) {
    this.allRowGuis.forEach((t) => {
      t.rowComp.addOrRemoveCssClass("ag-row-inline-editing", e), t.rowComp.addOrRemoveCssClass("ag-row-not-inline-editing", !e);
    });
  }
  setEditingRow(e) {
    this.editingRow = e, this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass("ag-row-editing", e));
    const t = e ? this.createRowEvent(w.EVENT_ROW_EDITING_STARTED) : this.createRowEvent(w.EVENT_ROW_EDITING_STOPPED);
    this.beans.eventService.dispatchEvent(t);
  }
  startRowEditing(e = null, t = null, i = null) {
    if (this.editingRow)
      return;
    this.getAllCellCtrls().reduce((n, s) => {
      const a = s === t;
      return a ? s.startEditing(e, a, i) : s.startEditing(null, a, i), n ? !0 : s.isEditing();
    }, !1) && this.setEditingRow(!0);
  }
  getAllCellCtrls() {
    return this.leftCellCtrls.list.length === 0 && this.rightCellCtrls.list.length === 0 ? this.centerCellCtrls.list : [...this.centerCellCtrls.list, ...this.leftCellCtrls.list, ...this.rightCellCtrls.list];
  }
  postProcessClassesFromGridOptions() {
    const e = this.beans.rowCssClassCalculator.processClassesFromGridOptions(this.rowNode);
    !e || !e.length || e.forEach((t) => {
      this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass(t, !0));
    });
  }
  postProcessRowClassRules() {
    this.beans.rowCssClassCalculator.processRowClassRules(this.rowNode, (e) => {
      this.allRowGuis.forEach((t) => t.rowComp.addOrRemoveCssClass(e, !0));
    }, (e) => {
      this.allRowGuis.forEach((t) => t.rowComp.addOrRemoveCssClass(e, !1));
    });
  }
  setStylesFromGridOptions(e) {
    const t = this.processStylesFromGridOptions();
    this.forEachGui(e, (i) => i.rowComp.setUserStyles(t));
  }
  getPinnedForContainer(e) {
    return e === Li.LEFT ? "left" : e === Li.RIGHT ? "right" : null;
  }
  getInitialRowClasses(e) {
    const t = this.getPinnedForContainer(e), i = {
      rowNode: this.rowNode,
      rowFocused: this.rowFocused,
      fadeRowIn: this.fadeInAnimation[e],
      rowIsEven: this.rowNode.rowIndex % 2 === 0,
      rowLevel: this.rowLevel,
      fullWidthRow: this.isFullWidth(),
      firstRowOnPage: this.isFirstRowOnPage(),
      lastRowOnPage: this.isLastRowOnPage(),
      printLayout: this.printLayout,
      expandable: this.rowNode.isExpandable(),
      pinned: t
    };
    return this.beans.rowCssClassCalculator.getInitialRowClasses(i);
  }
  processStylesFromGridOptions() {
    const e = this.gridOptionsService.get("rowStyle");
    if (e && typeof e == "function") {
      console.warn("AG Grid: rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead");
      return;
    }
    const t = this.gridOptionsService.getCallback("getRowStyle");
    let i;
    if (t) {
      const r = {
        data: this.rowNode.data,
        node: this.rowNode,
        rowIndex: this.rowNode.rowIndex
      };
      i = t(r);
    }
    return Object.assign({}, e, i);
  }
  onRowSelected(e) {
    const t = !!this.rowNode.isSelected();
    this.forEachGui(e, (i) => {
      i.rowComp.addOrRemoveCssClass("ag-row-selected", t), _d(i.element, t ? !0 : void 0);
      const r = this.createAriaLabel();
      Ia(i.element, r == null ? "" : r);
    });
  }
  createAriaLabel() {
    const e = this.rowNode.isSelected();
    return e && this.gridOptionsService.is("suppressRowDeselection") ? void 0 : this.beans.localeService.getLocaleTextFunc()(e ? "ariaRowDeselect" : "ariaRowSelect", `Press SPACE to ${e ? "deselect" : "select"} this row.`);
  }
  isUseAnimationFrameForCreate() {
    return this.useAnimationFrameForCreate;
  }
  addHoverFunctionality(e) {
    this.active && (this.addManagedListener(e, "mouseenter", () => this.rowNode.onMouseEnter()), this.addManagedListener(e, "mouseleave", () => this.rowNode.onMouseLeave()), this.addManagedListener(this.rowNode, re.EVENT_MOUSE_ENTER, () => {
      !this.beans.dragService.isDragging() && !this.gridOptionsService.is("suppressRowHoverHighlight") && (e.classList.add("ag-row-hover"), this.rowNode.setHovered(!0));
    }), this.addManagedListener(this.rowNode, re.EVENT_MOUSE_LEAVE, () => {
      e.classList.remove("ag-row-hover"), this.rowNode.setHovered(!1);
    }));
  }
  // for animation, we don't want to animate entry or exit to a very far away pixel,
  // otherwise the row would move so fast, it would appear to disappear. so this method
  // moves the row closer to the viewport if it is far away, so the row slide in / out
  // at a speed the user can see.
  roundRowTopToBounds(e) {
    const i = this.beans.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(), r = this.applyPaginationOffset(i.top, !0) - 100, n = this.applyPaginationOffset(i.bottom, !0) + 100;
    return Math.min(Math.max(r, e), n);
  }
  getFrameworkOverrides() {
    return this.beans.frameworkOverrides;
  }
  forEachGui(e, t) {
    (e ? [e] : this.allRowGuis).forEach(t);
  }
  onRowHeightChanged(e) {
    if (this.rowNode.rowHeight == null)
      return;
    const t = this.rowNode.rowHeight, i = this.beans.environment.getDefaultRowHeight(), n = this.gridOptionsService.isGetRowHeightFunction() ? this.gridOptionsService.getRowHeightForNode(this.rowNode).height : void 0, s = n ? `${Math.min(i, n) - 2}px` : void 0;
    this.forEachGui(e, (a) => {
      a.element.style.height = `${t}px`, s && a.element.style.setProperty("--ag-line-height", s);
    });
  }
  addEventListener(e, t) {
    super.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    super.removeEventListener(e, t);
  }
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroyFirstPass() {
    this.active = !1, this.gridOptionsService.isAnimateRows() && this.setupRemoveAnimation(), this.rowNode.setHovered(!1);
    const e = this.createRowEvent(w.EVENT_VIRTUAL_ROW_REMOVED);
    this.dispatchEvent(e), this.beans.eventService.dispatchEvent(e), super.destroy();
  }
  setupRemoveAnimation() {
    if (this.isSticky())
      return;
    if (this.rowNode.rowTop != null) {
      const t = this.roundRowTopToBounds(this.rowNode.rowTop);
      this.setRowTop(t);
    } else
      this.allRowGuis.forEach((t) => t.rowComp.addOrRemoveCssClass("ag-opacity-zero", !0));
  }
  destroySecondPass() {
    this.allRowGuis.length = 0;
    const e = (t) => (t.list.forEach((i) => i.destroy()), { list: [], map: {} });
    this.centerCellCtrls = e(this.centerCellCtrls), this.leftCellCtrls = e(this.leftCellCtrls), this.rightCellCtrls = e(this.rightCellCtrls);
  }
  setFocusedClasses(e) {
    this.forEachGui(e, (t) => {
      t.rowComp.addOrRemoveCssClass("ag-row-focus", this.rowFocused), t.rowComp.addOrRemoveCssClass("ag-row-no-focus", !this.rowFocused);
    });
  }
  onCellFocused() {
    this.onCellFocusChanged();
  }
  onCellFocusCleared() {
    this.onCellFocusChanged();
  }
  onCellFocusChanged() {
    const e = this.beans.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
    e !== this.rowFocused && (this.rowFocused = e, this.setFocusedClasses()), !e && this.editingRow && this.stopEditing(!1);
  }
  onPaginationChanged() {
    const e = this.beans.paginationProxy.getCurrentPage();
    this.paginationPage !== e && (this.paginationPage = e, this.onTopChanged()), this.refreshFirstAndLastRowStyles();
  }
  onTopChanged() {
    this.setRowTop(this.rowNode.rowTop);
  }
  onPaginationPixelOffsetChanged() {
    this.onTopChanged();
  }
  // applies pagination offset, eg if on second page, and page height is 500px, then removes
  // 500px from the top position, so a row with rowTop 600px is displayed at location 100px.
  // reverse will take the offset away rather than add.
  applyPaginationOffset(e, t = !1) {
    if (this.rowNode.isRowPinned() || this.rowNode.sticky)
      return e;
    const i = this.beans.paginationProxy.getPixelOffset();
    return e + i * (t ? 1 : -1);
  }
  setRowTop(e) {
    if (!this.printLayout && z(e)) {
      const t = this.applyPaginationOffset(e), n = `${this.rowNode.isRowPinned() || this.rowNode.sticky ? t : this.beans.rowContainerHeightService.getRealPixelPosition(t)}px`;
      this.setRowTopStyle(n);
    }
  }
  // the top needs to be set into the DOM element when the element is created, not updated afterwards.
  // otherwise the transition would not work, as it would be transitioning from zero (the unset value).
  // for example, suppose a row that is outside the viewport, then user does a filter to remove other rows
  // and this row now appears in the viewport, and the row moves up (ie it was under the viewport and not rendered,
  // but now is in the viewport) then a new RowComp is created, however it should have it's position initialised
  // to below the viewport, so the row will appear to animate up. if we didn't set the initial position at creation
  // time, the row would animate down (ie from position zero).
  getInitialRowTop(e) {
    return this.gridOptionsService.is("suppressRowTransform") ? this.getInitialRowTopShared(e) : void 0;
  }
  getInitialTransform(e) {
    return this.gridOptionsService.is("suppressRowTransform") ? void 0 : `translateY(${this.getInitialRowTopShared(e)})`;
  }
  getInitialRowTopShared(e) {
    if (this.printLayout)
      return "";
    let t;
    if (this.isSticky())
      t = this.rowNode.stickyRowTop;
    else {
      const i = this.slideInAnimation[e] ? this.roundRowTopToBounds(this.rowNode.oldRowTop) : this.rowNode.rowTop, r = this.applyPaginationOffset(i);
      t = this.rowNode.isRowPinned() ? r : this.beans.rowContainerHeightService.getRealPixelPosition(r);
    }
    return t + "px";
  }
  setRowTopStyle(e) {
    const t = this.gridOptionsService.is("suppressRowTransform");
    this.allRowGuis.forEach((i) => t ? i.rowComp.setTop(e) : i.rowComp.setTransform(`translateY(${e})`));
  }
  getRowNode() {
    return this.rowNode;
  }
  getCellCtrl(e) {
    let t = null;
    return this.getAllCellCtrls().forEach((i) => {
      i.getColumn() == e && (t = i);
    }), t != null || this.getAllCellCtrls().forEach((i) => {
      i.getColSpanningList().indexOf(e) >= 0 && (t = i);
    }), t;
  }
  onRowIndexChanged() {
    this.rowNode.rowIndex != null && (this.onCellFocusChanged(), this.updateRowIndexes(), this.postProcessCss());
  }
  updateRowIndexes(e) {
    const t = this.rowNode.getRowIndexString(), i = this.beans.headerNavigationService.getHeaderRowCount(), r = this.rowNode.rowIndex % 2 === 0, n = i + this.rowNode.rowIndex + 1;
    this.forEachGui(e, (s) => {
      s.rowComp.setRowIndex(t), s.rowComp.addOrRemoveCssClass("ag-row-even", r), s.rowComp.addOrRemoveCssClass("ag-row-odd", !r), DS(s.element, n);
    });
  }
  // returns the pinned left container, either the normal one, or the embedded full with one if exists
  getPinnedLeftRowElement() {
    return this.leftGui ? this.leftGui.element : void 0;
  }
  // returns the pinned right container, either the normal one, or the embedded full with one if exists
  getPinnedRightRowElement() {
    return this.rightGui ? this.rightGui.element : void 0;
  }
  // returns the body container, either the normal one, or the embedded full with one if exists
  getBodyRowElement() {
    return this.centerGui ? this.centerGui.element : void 0;
  }
  // returns the full width container
  getFullWidthRowElement() {
    return this.fullWidthGui ? this.fullWidthGui.element : void 0;
  }
}
Gn.DOM_DATA_KEY_ROW_CTRL = "renderedRow";
var Hr = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class sr extends H {
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addKeyboardListeners(), this.addMouseListeners(), this.mockContextMenuForIPad();
  }
  addKeyboardListeners() {
    const e = "keydown", t = this.processKeyboardEvent.bind(this, e);
    this.addManagedListener(this.element, e, t);
  }
  addMouseListeners() {
    ["dblclick", "contextmenu", "mouseover", "mouseout", "click", SS("touchstart") ? "touchstart" : "mousedown"].forEach((i) => {
      const r = this.processMouseEvent.bind(this, i);
      this.addManagedListener(this.element, i, r);
    });
  }
  processMouseEvent(e, t) {
    if (!this.mouseEventService.isEventFromThisGrid(t) || Eo(t))
      return;
    const i = this.getRowForEvent(t), r = this.mouseEventService.getRenderedCellForEvent(t);
    e === "contextmenu" ? this.handleContextMenuMouseEvent(t, null, i, r) : (r && r.onMouseEvent(e, t), i && i.onMouseEvent(e, t));
  }
  mockContextMenuForIPad() {
    if (!Fa())
      return;
    const e = new mt(this.element), t = (i) => {
      const r = this.getRowForEvent(i.touchEvent), n = this.mouseEventService.getRenderedCellForEvent(i.touchEvent);
      this.handleContextMenuMouseEvent(null, i.touchEvent, r, n);
    };
    this.addManagedListener(e, mt.EVENT_LONG_TAP, t), this.addDestroyFunc(() => e.destroy());
  }
  getRowForEvent(e) {
    let t = e.target;
    for (; t; ) {
      const i = this.gridOptionsService.getDomData(t, Gn.DOM_DATA_KEY_ROW_CTRL);
      if (i)
        return i;
      t = t.parentElement;
    }
    return null;
  }
  handleContextMenuMouseEvent(e, t, i, r) {
    const n = i ? i.getRowNode() : null, s = r ? r.getColumn() : null;
    let a = null;
    if (s) {
      const d = e || t;
      r.dispatchCellContextMenuEvent(d), a = this.valueService.getValue(s, n);
    }
    const l = this.ctrlsService.getGridBodyCtrl(), c = r ? r.getGui() : l.getGridBodyElement();
    this.contextMenuFactory && this.contextMenuFactory.onContextMenu(e, t, n, s, a, c);
  }
  getControlsForEventTarget(e) {
    return {
      cellCtrl: Dg(this.gridOptionsService, e, un.DOM_DATA_KEY_CELL_CTRL),
      rowCtrl: Dg(this.gridOptionsService, e, Gn.DOM_DATA_KEY_ROW_CTRL)
    };
  }
  processKeyboardEvent(e, t) {
    const { cellCtrl: i, rowCtrl: r } = this.getControlsForEventTarget(t.target);
    t.defaultPrevented || (i ? this.processCellKeyboardEvent(i, e, t) : r && r.isFullWidth() && this.processFullWidthRowKeyboardEvent(r, e, t));
  }
  processCellKeyboardEvent(e, t, i) {
    const r = e.getRowNode(), n = e.getColumn(), s = e.isEditing();
    if (!Mg(this.gridOptionsService, i, r, n, s) && t === "keydown" && (!s && this.navigationService.handlePageScrollingKey(i) || e.onKeyDown(i), this.doGridOperations(i, e.isEditing()), WS(i) && e.processCharacter(i)), t === "keydown") {
      const l = e.createEvent(i, w.EVENT_CELL_KEY_DOWN);
      this.eventService.dispatchEvent(l);
    }
  }
  processFullWidthRowKeyboardEvent(e, t, i) {
    const r = e.getRowNode(), n = this.focusService.getFocusedCell(), s = n && n.column;
    if (!Mg(this.gridOptionsService, i, r, s, !1)) {
      const l = i.key;
      if (t === "keydown")
        switch (l) {
          case V.PAGE_HOME:
          case V.PAGE_END:
          case V.PAGE_UP:
          case V.PAGE_DOWN:
            this.navigationService.handlePageScrollingKey(i, !0);
            break;
          case V.UP:
          case V.DOWN:
            e.onKeyboardNavigate(i);
            break;
          case V.TAB:
            e.onTabKeyDown(i);
            break;
        }
    }
    if (t === "keydown") {
      const l = e.createRowEvent(w.EVENT_CELL_KEY_DOWN, i);
      this.eventService.dispatchEvent(l);
    }
  }
  doGridOperations(e, t) {
    if (!e.ctrlKey && !e.metaKey || t || !this.mouseEventService.isEventFromThisGrid(e))
      return;
    const i = NT(e);
    if (i === V.A)
      return this.onCtrlAndA(e);
    if (i === V.C)
      return this.onCtrlAndC(e);
    if (i === V.D)
      return this.onCtrlAndD(e);
    if (i === V.V)
      return this.onCtrlAndV(e);
    if (i === V.X)
      return this.onCtrlAndX(e);
    if (i === V.Y)
      return this.onCtrlAndY();
    if (i === V.Z)
      return this.onCtrlAndZ(e);
  }
  onCtrlAndA(e) {
    const { pinnedRowModel: t, paginationProxy: i, rangeService: r } = this;
    if (r && i.isRowsToRender()) {
      const [n, s] = [
        t.isEmpty("top"),
        t.isEmpty("bottom")
      ], a = n ? null : "top";
      let l, c;
      s ? (l = null, c = this.paginationProxy.getRowCount() - 1) : (l = "bottom", c = t.getPinnedBottomRowData().length - 1);
      const d = this.columnModel.getAllDisplayedColumns();
      if (br(d))
        return;
      r.setCellRange({
        rowStartIndex: 0,
        rowStartPinned: a,
        rowEndIndex: c,
        rowEndPinned: l,
        columnStart: d[0],
        columnEnd: at(d)
      });
    }
    e.preventDefault();
  }
  onCtrlAndC(e) {
    if (!this.clipboardService || this.gridOptionsService.is("enableCellTextSelection"))
      return;
    const { cellCtrl: t, rowCtrl: i } = this.getControlsForEventTarget(e.target);
    t != null && t.isEditing() || i != null && i.isEditing() || (e.preventDefault(), this.clipboardService.copyToClipboard());
  }
  onCtrlAndX(e) {
    if (!this.clipboardService || this.gridOptionsService.is("enableCellTextSelection") || this.gridOptionsService.is("suppressCutToClipboard"))
      return;
    const { cellCtrl: t, rowCtrl: i } = this.getControlsForEventTarget(e.target);
    t != null && t.isEditing() || i != null && i.isEditing() || (e.preventDefault(), this.clipboardService.cutToClipboard(void 0, "ui"));
  }
  onCtrlAndV(e) {
    const { cellCtrl: t, rowCtrl: i } = this.getControlsForEventTarget(e.target);
    t != null && t.isEditing() || i != null && i.isEditing() || this.clipboardService && !this.gridOptionsService.is("suppressClipboardPaste") && this.clipboardService.pasteFromClipboard();
  }
  onCtrlAndD(e) {
    this.clipboardService && !this.gridOptionsService.is("suppressClipboardPaste") && this.clipboardService.copyRangeDown(), e.preventDefault();
  }
  onCtrlAndZ(e) {
    this.gridOptionsService.is("undoRedoCellEditing") && (e.preventDefault(), e.shiftKey ? this.undoRedoService.redo("ui") : this.undoRedoService.undo("ui"));
  }
  onCtrlAndY() {
    this.undoRedoService.redo("ui");
  }
}
Hr([
  S("mouseEventService")
], sr.prototype, "mouseEventService", void 0);
Hr([
  S("valueService")
], sr.prototype, "valueService", void 0);
Hr([
  Ve("contextMenuFactory")
], sr.prototype, "contextMenuFactory", void 0);
Hr([
  S("ctrlsService")
], sr.prototype, "ctrlsService", void 0);
Hr([
  S("navigationService")
], sr.prototype, "navigationService", void 0);
Hr([
  S("focusService")
], sr.prototype, "focusService", void 0);
Hr([
  S("undoRedoService")
], sr.prototype, "undoRedoService", void 0);
Hr([
  S("columnModel")
], sr.prototype, "columnModel", void 0);
Hr([
  S("paginationProxy")
], sr.prototype, "paginationProxy", void 0);
Hr([
  S("pinnedRowModel")
], sr.prototype, "pinnedRowModel", void 0);
Hr([
  Ve("rangeService")
], sr.prototype, "rangeService", void 0);
Hr([
  Ve("clipboardService")
], sr.prototype, "clipboardService", void 0);
Hr([
  B
], sr.prototype, "postConstruct", null);
var qv = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Vp extends H {
  constructor(e) {
    super(), this.centerContainerCtrl = e;
  }
  postConstruct() {
    this.ctrlsService.whenReady(() => {
      this.gridBodyCtrl = this.ctrlsService.getGridBodyCtrl(), this.listenForResize();
    }), this.addManagedListener(this.eventService, w.EVENT_SCROLLBAR_WIDTH_CHANGED, this.onScrollbarWidthChanged.bind(this));
  }
  listenForResize() {
    const e = () => this.onCenterViewportResized();
    this.centerContainerCtrl.registerViewportResizeListener(e), this.gridBodyCtrl.registerBodyViewportResizeListener(e);
  }
  onScrollbarWidthChanged() {
    this.checkViewportAndScrolls();
  }
  onCenterViewportResized() {
    if (this.centerContainerCtrl.isViewportVisible()) {
      this.checkViewportAndScrolls();
      const e = this.centerContainerCtrl.getCenterWidth();
      e !== this.centerWidth && (this.centerWidth = e, this.columnModel.refreshFlexedColumns({ viewportWidth: this.centerWidth, updateBodyWidths: !0, fireResizedEvent: !0 }));
    } else
      this.bodyHeight = 0;
  }
  // gets called every time the viewport size changes. we use this to check visibility of scrollbars
  // in the grid panel, and also to check size and position of viewport for row and column virtualisation.
  checkViewportAndScrolls() {
    this.updateScrollVisibleService(), this.checkBodyHeight(), this.onHorizontalViewportChanged(), this.gridBodyCtrl.getScrollFeature().checkScrollLeft();
  }
  getBodyHeight() {
    return this.bodyHeight;
  }
  checkBodyHeight() {
    const e = this.gridBodyCtrl.getBodyViewportElement(), t = Tp(e);
    if (this.bodyHeight !== t) {
      this.bodyHeight = t;
      const i = {
        type: w.EVENT_BODY_HEIGHT_CHANGED
      };
      this.eventService.dispatchEvent(i);
    }
  }
  updateScrollVisibleService() {
    this.updateScrollVisibleServiceImpl(), setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
  }
  updateScrollVisibleServiceImpl() {
    const e = {
      horizontalScrollShowing: this.isHorizontalScrollShowing(),
      verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing()
    };
    this.scrollVisibleService.setScrollsVisible(e);
  }
  isHorizontalScrollShowing() {
    return this.centerContainerCtrl.isHorizontalScrollShowing();
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged() {
    const e = this.centerContainerCtrl.getCenterWidth(), t = this.centerContainerCtrl.getViewportScrollLeft();
    this.columnModel.setViewportPosition(e, t);
  }
}
qv([
  S("ctrlsService")
], Vp.prototype, "ctrlsService", void 0);
qv([
  S("columnModel")
], Vp.prototype, "columnModel", void 0);
qv([
  S("scrollVisibleService")
], Vp.prototype, "scrollVisibleService", void 0);
qv([
  B
], Vp.prototype, "postConstruct", null);
var cx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class lb extends H {
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addManagedListener(this.eventService, w.EVENT_LEFT_PINNED_WIDTH_CHANGED, this.onPinnedLeftWidthChanged.bind(this));
  }
  onPinnedLeftWidthChanged() {
    const e = this.pinnedWidthService.getPinnedLeftWidth(), t = e > 0;
    Ke(this.element, t), dn(this.element, e);
  }
  getWidth() {
    return this.pinnedWidthService.getPinnedLeftWidth();
  }
}
cx([
  S("pinnedWidthService")
], lb.prototype, "pinnedWidthService", void 0);
cx([
  B
], lb.prototype, "postConstruct", null);
var dx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class cb extends H {
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addManagedListener(this.eventService, w.EVENT_RIGHT_PINNED_WIDTH_CHANGED, this.onPinnedRightWidthChanged.bind(this));
  }
  onPinnedRightWidthChanged() {
    const e = this.pinnedWidthService.getPinnedRightWidth(), t = e > 0;
    Ke(this.element, t), dn(this.element, e);
  }
  getWidth() {
    return this.pinnedWidthService.getPinnedRightWidth();
  }
}
dx([
  S("pinnedWidthService")
], cb.prototype, "pinnedWidthService", void 0);
dx([
  B
], cb.prototype, "postConstruct", null);
var ux = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Zv extends H {
  constructor(e, t) {
    super(), this.eContainer = e, this.eWrapper = t;
  }
  postConstruct() {
    this.addManagedListener(this.eventService, w.EVENT_ROW_CONTAINER_HEIGHT_CHANGED, this.onHeightChanged.bind(this));
  }
  onHeightChanged() {
    const e = this.maxDivHeightScaler.getUiContainerHeight(), t = e != null ? `${e}px` : "";
    this.eContainer.style.height = t, this.eWrapper && (this.eWrapper.style.height = t);
  }
}
ux([
  S("rowContainerHeightService")
], Zv.prototype, "maxDivHeightScaler", void 0);
ux([
  B
], Zv.prototype, "postConstruct", null);
var db = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Qv extends H {
  constructor(e) {
    super(), this.eContainer = e;
  }
  postConstruct() {
    if (!this.gridOptionsService.isEnableRangeSelection() || // no range selection if no property
    Se(this.rangeService))
      return;
    const e = {
      eElement: this.eContainer,
      onDragStart: this.rangeService.onDragStart.bind(this.rangeService),
      onDragStop: this.rangeService.onDragStop.bind(this.rangeService),
      onDragging: this.rangeService.onDragging.bind(this.rangeService)
    };
    this.dragService.addDragSource(e), this.addDestroyFunc(() => this.dragService.removeDragSource(e));
  }
}
db([
  Ve("rangeService")
], Qv.prototype, "rangeService", void 0);
db([
  S("dragService")
], Qv.prototype, "dragService", void 0);
db([
  B
], Qv.prototype, "postConstruct", null);
var ub = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class hu extends H {
  constructor(e, t = !1) {
    super(), this.callback = e, this.addSpacer = t;
  }
  postConstruct() {
    const e = this.setWidth.bind(this);
    this.addManagedPropertyListener("domLayout", e), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_CHANGED, e), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, e), this.addManagedListener(this.eventService, w.EVENT_LEFT_PINNED_WIDTH_CHANGED, e), this.addSpacer && (this.addManagedListener(this.eventService, w.EVENT_RIGHT_PINNED_WIDTH_CHANGED, e), this.addManagedListener(this.eventService, w.EVENT_SCROLL_VISIBILITY_CHANGED, e), this.addManagedListener(this.eventService, w.EVENT_SCROLLBAR_WIDTH_CHANGED, e)), this.setWidth();
  }
  setWidth() {
    const { columnModel: e } = this, t = this.gridOptionsService.isDomLayout("print"), i = e.getBodyContainerWidth(), r = e.getDisplayedColumnsLeftWidth(), n = e.getDisplayedColumnsRightWidth();
    let s;
    t ? s = i + r + n : (s = i, this.addSpacer && (this.gridOptionsService.is("enableRtl") ? r : n) === 0 && this.scrollVisibleService.isVerticalScrollShowing() && (s += this.gridOptionsService.getScrollbarWidth())), this.callback(s);
  }
}
ub([
  S("columnModel")
], hu.prototype, "columnModel", void 0);
ub([
  S("scrollVisibleService")
], hu.prototype, "scrollVisibleService", void 0);
ub([
  B
], hu.prototype, "postConstruct", null);
var ka = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, U;
(function(o) {
  o.LEFT = "left", o.RIGHT = "right", o.CENTER = "center", o.FULL_WIDTH = "fullWidth", o.TOP_LEFT = "topLeft", o.TOP_RIGHT = "topRight", o.TOP_CENTER = "topCenter", o.TOP_FULL_WIDTH = "topFullWidth", o.STICKY_TOP_LEFT = "stickyTopLeft", o.STICKY_TOP_RIGHT = "stickyTopRight", o.STICKY_TOP_CENTER = "stickyTopCenter", o.STICKY_TOP_FULL_WIDTH = "stickyTopFullWidth", o.BOTTOM_LEFT = "bottomLeft", o.BOTTOM_RIGHT = "bottomRight", o.BOTTOM_CENTER = "bottomCenter", o.BOTTOM_FULL_WIDTH = "bottomFullWidth";
})(U || (U = {}));
var Li;
(function(o) {
  o.LEFT = "left", o.RIGHT = "right", o.CENTER = "center", o.FULL_WIDTH = "fullWidth";
})(Li || (Li = {}));
function sN(o) {
  switch (o) {
    case U.CENTER:
    case U.TOP_CENTER:
    case U.STICKY_TOP_CENTER:
    case U.BOTTOM_CENTER:
      return Li.CENTER;
    case U.LEFT:
    case U.TOP_LEFT:
    case U.STICKY_TOP_LEFT:
    case U.BOTTOM_LEFT:
      return Li.LEFT;
    case U.RIGHT:
    case U.TOP_RIGHT:
    case U.STICKY_TOP_RIGHT:
    case U.BOTTOM_RIGHT:
      return Li.RIGHT;
    case U.FULL_WIDTH:
    case U.TOP_FULL_WIDTH:
    case U.STICKY_TOP_FULL_WIDTH:
    case U.BOTTOM_FULL_WIDTH:
      return Li.FULL_WIDTH;
    default:
      throw Error("Invalid Row Container Type");
  }
}
const aN = us([
  [U.CENTER, "ag-center-cols-container"],
  [U.LEFT, "ag-pinned-left-cols-container"],
  [U.RIGHT, "ag-pinned-right-cols-container"],
  [U.FULL_WIDTH, "ag-full-width-container"],
  [U.TOP_CENTER, "ag-floating-top-container"],
  [U.TOP_LEFT, "ag-pinned-left-floating-top"],
  [U.TOP_RIGHT, "ag-pinned-right-floating-top"],
  [U.TOP_FULL_WIDTH, "ag-floating-top-full-width-container"],
  [U.STICKY_TOP_CENTER, "ag-sticky-top-container"],
  [U.STICKY_TOP_LEFT, "ag-pinned-left-sticky-top"],
  [U.STICKY_TOP_RIGHT, "ag-pinned-right-sticky-top"],
  [U.STICKY_TOP_FULL_WIDTH, "ag-sticky-top-full-width-container"],
  [U.BOTTOM_CENTER, "ag-floating-bottom-container"],
  [U.BOTTOM_LEFT, "ag-pinned-left-floating-bottom"],
  [U.BOTTOM_RIGHT, "ag-pinned-right-floating-bottom"],
  [U.BOTTOM_FULL_WIDTH, "ag-floating-bottom-full-width-container"]
]), lN = us([
  [U.CENTER, "ag-center-cols-viewport"],
  [U.TOP_CENTER, "ag-floating-top-viewport"],
  [U.STICKY_TOP_CENTER, "ag-sticky-top-viewport"],
  [U.BOTTOM_CENTER, "ag-floating-bottom-viewport"]
]), cN = us([
  [U.CENTER, "ag-center-cols-clipper"]
]);
class bn extends H {
  constructor(e) {
    super(), this.visible = !0, this.EMPTY_CTRLS = [], this.name = e, this.isFullWithContainer = this.name === U.TOP_FULL_WIDTH || this.name === U.STICKY_TOP_FULL_WIDTH || this.name === U.BOTTOM_FULL_WIDTH || this.name === U.FULL_WIDTH;
  }
  static getRowContainerCssClasses(e) {
    const t = aN.get(e), i = lN.get(e), r = cN.get(e);
    return { container: t, viewport: i, wrapper: r };
  }
  static getPinned(e) {
    switch (e) {
      case U.BOTTOM_LEFT:
      case U.TOP_LEFT:
      case U.STICKY_TOP_LEFT:
      case U.LEFT:
        return "left";
      case U.BOTTOM_RIGHT:
      case U.TOP_RIGHT:
      case U.STICKY_TOP_RIGHT:
      case U.RIGHT:
        return "right";
      default:
        return null;
    }
  }
  postConstruct() {
    this.enableRtl = this.gridOptionsService.is("enableRtl"), this.embedFullWidthRows = this.gridOptionsService.is("embedFullWidthRows"), this.forContainers([U.CENTER], () => this.viewportSizeFeature = this.createManagedBean(new Vp(this)));
  }
  registerWithCtrlsService() {
    switch (this.name) {
      case U.CENTER:
        this.ctrlsService.registerCenterRowContainerCtrl(this);
        break;
      case U.LEFT:
        this.ctrlsService.registerLeftRowContainerCtrl(this);
        break;
      case U.RIGHT:
        this.ctrlsService.registerRightRowContainerCtrl(this);
        break;
      case U.TOP_CENTER:
        this.ctrlsService.registerTopCenterRowContainerCtrl(this);
        break;
      case U.TOP_LEFT:
        this.ctrlsService.registerTopLeftRowContainerCon(this);
        break;
      case U.TOP_RIGHT:
        this.ctrlsService.registerTopRightRowContainerCtrl(this);
        break;
      case U.STICKY_TOP_CENTER:
        this.ctrlsService.registerStickyTopCenterRowContainerCtrl(this);
        break;
      case U.STICKY_TOP_LEFT:
        this.ctrlsService.registerStickyTopLeftRowContainerCon(this);
        break;
      case U.STICKY_TOP_RIGHT:
        this.ctrlsService.registerStickyTopRightRowContainerCtrl(this);
        break;
      case U.BOTTOM_CENTER:
        this.ctrlsService.registerBottomCenterRowContainerCtrl(this);
        break;
      case U.BOTTOM_LEFT:
        this.ctrlsService.registerBottomLeftRowContainerCtrl(this);
        break;
      case U.BOTTOM_RIGHT:
        this.ctrlsService.registerBottomRightRowContainerCtrl(this);
        break;
    }
  }
  forContainers(e, t) {
    e.indexOf(this.name) >= 0 && t();
  }
  getContainerElement() {
    return this.eContainer;
  }
  getViewportSizeFeature() {
    return this.viewportSizeFeature;
  }
  setComp(e, t, i, r) {
    this.comp = e, this.eContainer = t, this.eViewport = i, this.eWrapper = r, this.createManagedBean(new sr(this.eContainer)), this.addPreventScrollWhileDragging(), this.listenOnDomOrder(), this.stopHScrollOnPinnedRows();
    const n = [U.TOP_CENTER, U.TOP_LEFT, U.TOP_RIGHT], s = [U.STICKY_TOP_CENTER, U.STICKY_TOP_LEFT, U.STICKY_TOP_RIGHT], a = [U.BOTTOM_CENTER, U.BOTTOM_LEFT, U.BOTTOM_RIGHT], l = [U.CENTER, U.LEFT, U.RIGHT], c = [...n, ...a, ...l, ...s], d = [U.CENTER, U.LEFT, U.RIGHT, U.FULL_WIDTH], u = [U.CENTER, U.TOP_CENTER, U.STICKY_TOP_CENTER, U.BOTTOM_CENTER], h = [U.LEFT, U.BOTTOM_LEFT, U.TOP_LEFT, U.STICKY_TOP_LEFT], p = [U.RIGHT, U.BOTTOM_RIGHT, U.TOP_RIGHT, U.STICKY_TOP_RIGHT];
    this.forContainers(h, () => {
      this.pinnedWidthFeature = this.createManagedBean(new lb(this.eContainer)), this.addManagedListener(this.eventService, w.EVENT_LEFT_PINNED_WIDTH_CHANGED, () => this.onPinnedWidthChanged());
    }), this.forContainers(p, () => {
      this.pinnedWidthFeature = this.createManagedBean(new cb(this.eContainer)), this.addManagedListener(this.eventService, w.EVENT_RIGHT_PINNED_WIDTH_CHANGED, () => this.onPinnedWidthChanged());
    }), this.forContainers(d, () => this.createManagedBean(new Zv(this.eContainer, this.eWrapper))), this.forContainers(c, () => this.createManagedBean(new Qv(this.eContainer))), this.forContainers(u, () => this.createManagedBean(new hu((f) => this.comp.setContainerWidth(`${f}px`)))), wd() && (this.forContainers([U.CENTER], () => {
      const f = this.enableRtl ? w.EVENT_LEFT_PINNED_WIDTH_CHANGED : w.EVENT_RIGHT_PINNED_WIDTH_CHANGED;
      this.addManagedListener(this.eventService, f, () => this.refreshPaddingForFakeScrollbar());
    }), this.refreshPaddingForFakeScrollbar()), this.addListeners(), this.registerWithCtrlsService();
  }
  refreshPaddingForFakeScrollbar() {
    const { enableRtl: e, columnModel: t, name: i, eWrapper: r, eContainer: n } = this, s = e ? U.LEFT : U.RIGHT;
    this.forContainers([U.CENTER, s], () => {
      const a = t.getContainerWidth(s), l = e ? "marginLeft" : "marginRight";
      i === U.CENTER ? r.style[l] = a ? "0px" : "16px" : n.style[l] = a ? "16px" : "0px";
    });
  }
  addListeners() {
    this.addManagedListener(this.eventService, w.EVENT_SCROLL_VISIBILITY_CHANGED, () => this.onScrollVisibilityChanged()), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_CHANGED, () => this.onDisplayedColumnsChanged()), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, () => this.onDisplayedColumnsWidthChanged()), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_ROWS_CHANGED, (e) => this.onDisplayedRowsChanged(e.afterScroll)), this.onScrollVisibilityChanged(), this.onDisplayedColumnsChanged(), this.onDisplayedColumnsWidthChanged(), this.onDisplayedRowsChanged();
  }
  listenOnDomOrder() {
    if ([U.STICKY_TOP_CENTER, U.STICKY_TOP_LEFT, U.STICKY_TOP_RIGHT, U.STICKY_TOP_FULL_WIDTH].indexOf(this.name) >= 0) {
      this.comp.setDomOrder(!0);
      return;
    }
    const i = () => {
      const r = this.gridOptionsService.is("ensureDomOrder"), n = this.gridOptionsService.isDomLayout("print");
      this.comp.setDomOrder(r || n);
    };
    this.addManagedPropertyListener("domLayout", i), i();
  }
  // when editing a pinned row, if the cell is half outside the scrollable area, the browser can
  // scroll the column into view. we do not want this, the pinned sections should never scroll.
  // so we listen to scrolls on these containers and reset the scroll if we find one.
  stopHScrollOnPinnedRows() {
    this.forContainers([U.TOP_CENTER, U.STICKY_TOP_CENTER, U.BOTTOM_CENTER], () => {
      const e = () => this.eViewport.scrollLeft = 0;
      this.addManagedListener(this.eViewport, "scroll", e);
    });
  }
  onDisplayedColumnsChanged() {
    this.forContainers([U.CENTER], () => this.onHorizontalViewportChanged());
  }
  onDisplayedColumnsWidthChanged() {
    this.forContainers([U.CENTER], () => this.onHorizontalViewportChanged());
  }
  onScrollVisibilityChanged() {
    const e = this.gridOptionsService.getScrollbarWidth() || 0;
    if (this.name === U.CENTER) {
      const i = this.scrollVisibleService.isHorizontalScrollShowing() ? e : 0, r = i == 0 ? "100%" : `calc(100% + ${i}px)`;
      this.animationFrameService.requestAnimationFrame(() => this.comp.setViewportHeight(r));
    }
    if (this.name === U.FULL_WIDTH) {
      const i = `calc(100% - ${wd() ? 16 : 0}px)`;
      this.eContainer.style.setProperty("width", i);
    }
  }
  // this methods prevents the grid views from being scrolled while the dragService is being used
  // eg. the view should not scroll up and down while dragging rows using the rowDragComp.
  addPreventScrollWhileDragging() {
    const e = (t) => {
      this.dragService.isDragging() && t.cancelable && t.preventDefault();
    };
    this.eContainer.addEventListener("touchmove", e, { passive: !1 }), this.addDestroyFunc(() => this.eContainer.removeEventListener("touchmove", e));
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged() {
    const e = this.getCenterWidth(), t = this.getCenterViewportScrollLeft();
    this.columnModel.setViewportPosition(e, t);
  }
  getCenterWidth() {
    return Bv(this.eViewport);
  }
  getCenterViewportScrollLeft() {
    return Vh(this.eViewport, this.enableRtl);
  }
  registerViewportResizeListener(e) {
    const t = this.resizeObserverService.observeResize(this.eViewport, e);
    this.addDestroyFunc(() => t());
  }
  isViewportVisible() {
    return Ms(this.eViewport);
  }
  getViewportScrollLeft() {
    return Vh(this.eViewport, this.enableRtl);
  }
  isHorizontalScrollShowing() {
    return this.gridOptionsService.is("alwaysShowHorizontalScroll") || AT(this.eViewport);
  }
  getViewportElement() {
    return this.eViewport;
  }
  setContainerTranslateX(e) {
    this.eContainer.style.transform = `translateX(${e}px)`;
  }
  getHScrollPosition() {
    return {
      left: this.eViewport.scrollLeft,
      right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
    };
  }
  setCenterViewportScrollLeft(e) {
    Bh(this.eViewport, e, this.enableRtl);
  }
  isContainerVisible() {
    return !bn.getPinned(this.name) || !!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0;
  }
  onPinnedWidthChanged() {
    const e = this.isContainerVisible();
    this.visible != e && (this.visible = e, this.onDisplayedRowsChanged()), wd() && this.refreshPaddingForFakeScrollbar();
  }
  onDisplayedRowsChanged(e = !1) {
    if (this.visible) {
      const t = this.gridOptionsService.isDomLayout("print"), i = (n) => {
        const s = n.isFullWidth(), a = this.embedFullWidthRows || t;
        return this.isFullWithContainer ? !a && s : a || !s;
      }, r = this.getRowCtrls().filter(i);
      this.comp.setRowCtrls(r, e);
    } else
      this.comp.setRowCtrls(this.EMPTY_CTRLS, !1);
  }
  getRowCtrls() {
    switch (this.name) {
      case U.TOP_CENTER:
      case U.TOP_LEFT:
      case U.TOP_RIGHT:
      case U.TOP_FULL_WIDTH:
        return this.rowRenderer.getTopRowCtrls();
      case U.STICKY_TOP_CENTER:
      case U.STICKY_TOP_LEFT:
      case U.STICKY_TOP_RIGHT:
      case U.STICKY_TOP_FULL_WIDTH:
        return this.rowRenderer.getStickyTopRowCtrls();
      case U.BOTTOM_CENTER:
      case U.BOTTOM_LEFT:
      case U.BOTTOM_RIGHT:
      case U.BOTTOM_FULL_WIDTH:
        return this.rowRenderer.getBottomRowCtrls();
      default:
        return this.rowRenderer.getRowCtrls();
    }
  }
}
ka([
  S("scrollVisibleService")
], bn.prototype, "scrollVisibleService", void 0);
ka([
  S("dragService")
], bn.prototype, "dragService", void 0);
ka([
  S("ctrlsService")
], bn.prototype, "ctrlsService", void 0);
ka([
  S("columnModel")
], bn.prototype, "columnModel", void 0);
ka([
  S("resizeObserverService")
], bn.prototype, "resizeObserverService", void 0);
ka([
  S("animationFrameService")
], bn.prototype, "animationFrameService", void 0);
ka([
  S("rowRenderer")
], bn.prototype, "rowRenderer", void 0);
ka([
  B
], bn.prototype, "postConstruct", null);
var Go = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const dN = (
  /* html */
  `<div class="ag-root ag-unselectable" role="treegrid">
        <ag-header-root ref="gridHeader"></ag-header-root>
        <div class="ag-floating-top" ref="eTop" role="presentation">
            <ag-row-container ref="topLeftContainer" name="${U.TOP_LEFT}"></ag-row-container>
            <ag-row-container ref="topCenterContainer" name="${U.TOP_CENTER}"></ag-row-container>
            <ag-row-container ref="topRightContainer" name="${U.TOP_RIGHT}"></ag-row-container>
            <ag-row-container ref="topFullWidthContainer" name="${U.TOP_FULL_WIDTH}"></ag-row-container>
        </div>
        <div class="ag-body" ref="eBody" role="presentation">
            <div class="ag-body-clipper" ref="eBodyClipper" role="presentation">
                <div class="ag-body-viewport" ref="eBodyViewport" role="presentation">
                    <ag-row-container ref="leftContainer" name="${U.LEFT}"></ag-row-container>
                    <ag-row-container ref="centerContainer" name="${U.CENTER}"></ag-row-container>
                    <ag-row-container ref="rightContainer" name="${U.RIGHT}"></ag-row-container>
                    <ag-row-container ref="fullWidthContainer" name="${U.FULL_WIDTH}"></ag-row-container>
                </div>
            </div>
            <ag-fake-vertical-scroll></ag-fake-vertical-scroll>
        </div>
        <div class="ag-sticky-top" ref="eStickyTop" role="presentation">
            <ag-row-container ref="stickyTopLeftContainer" name="${U.STICKY_TOP_LEFT}"></ag-row-container>
            <ag-row-container ref="stickyTopCenterContainer" name="${U.STICKY_TOP_CENTER}"></ag-row-container>
            <ag-row-container ref="stickyTopRightContainer" name="${U.STICKY_TOP_RIGHT}"></ag-row-container>
            <ag-row-container ref="stickyTopFullWidthContainer" name="${U.STICKY_TOP_FULL_WIDTH}"></ag-row-container>
        </div>
        <div class="ag-floating-bottom" ref="eBottom" role="presentation">
            <ag-row-container ref="bottomLeftContainer" name="${U.BOTTOM_LEFT}"></ag-row-container>
            <ag-row-container ref="bottomCenterContainer" name="${U.BOTTOM_CENTER}"></ag-row-container>
            <ag-row-container ref="bottomRightContainer" name="${U.BOTTOM_RIGHT}"></ag-row-container>
            <ag-row-container ref="bottomFullWidthContainer" name="${U.BOTTOM_FULL_WIDTH}"></ag-row-container>
        </div>
        <ag-fake-horizontal-scroll></ag-fake-horizontal-scroll>
        <ag-overlay-wrapper></ag-overlay-wrapper>
    </div>`
);
class Kn extends X {
  constructor() {
    super(dN);
  }
  init() {
    const e = (i, r) => {
      const n = `${i}px`;
      r.style.minHeight = n, r.style.height = n;
    }, t = {
      setRowAnimationCssOnBodyViewport: (i, r) => this.setRowAnimationCssOnBodyViewport(i, r),
      setColumnCount: (i) => vT(this.getGui(), i),
      setRowCount: (i) => gT(this.getGui(), i),
      setTopHeight: (i) => e(i, this.eTop),
      setBottomHeight: (i) => e(i, this.eBottom),
      setTopDisplay: (i) => this.eTop.style.display = i,
      setBottomDisplay: (i) => this.eBottom.style.display = i,
      setStickyTopHeight: (i) => this.eStickyTop.style.height = i,
      setStickyTopTop: (i) => this.eStickyTop.style.top = i,
      setStickyTopWidth: (i) => this.eStickyTop.style.width = i,
      setColumnMovingCss: (i, r) => this.addOrRemoveCssClass(i, r),
      updateLayoutClasses: (i, r) => {
        [
          this.eBodyViewport.classList,
          this.eBodyClipper.classList,
          this.eBody.classList
        ].forEach((s) => {
          s.toggle(zt.AUTO_HEIGHT, r.autoHeight), s.toggle(zt.NORMAL, r.normal), s.toggle(zt.PRINT, r.print);
        }), this.addOrRemoveCssClass(zt.AUTO_HEIGHT, r.autoHeight), this.addOrRemoveCssClass(zt.NORMAL, r.normal), this.addOrRemoveCssClass(zt.PRINT, r.print);
      },
      setAlwaysVerticalScrollClass: (i, r) => this.eBodyViewport.classList.toggle(ax, r),
      registerBodyViewportResizeListener: (i) => {
        const r = this.resizeObserverService.observeResize(this.eBodyViewport, i);
        this.addDestroyFunc(() => r());
      },
      setPinnedTopBottomOverflowY: (i) => this.eTop.style.overflowY = this.eBottom.style.overflowY = i,
      setCellSelectableCss: (i, r) => {
        [this.eTop, this.eBodyViewport, this.eBottom].forEach((n) => n.classList.toggle(i, r));
      },
      setBodyViewportWidth: (i) => this.eBodyViewport.style.width = i
    };
    this.ctrl = this.createManagedBean(new or()), this.ctrl.setComp(t, this.getGui(), this.eBodyViewport, this.eTop, this.eBottom, this.eStickyTop), (this.rangeService || this.gridOptionsService.get("rowSelection") === "multiple") && fT(this.getGui(), !0);
  }
  setRowAnimationCssOnBodyViewport(e, t) {
    const i = this.eBodyViewport.classList;
    i.toggle(Ld.ANIMATION_ON, t), i.toggle(Ld.ANIMATION_OFF, !t);
  }
  getFloatingTopBottom() {
    return [this.eTop, this.eBottom];
  }
}
Go([
  S("resizeObserverService")
], Kn.prototype, "resizeObserverService", void 0);
Go([
  Ve("rangeService")
], Kn.prototype, "rangeService", void 0);
Go([
  L("eBodyViewport")
], Kn.prototype, "eBodyViewport", void 0);
Go([
  L("eStickyTop")
], Kn.prototype, "eStickyTop", void 0);
Go([
  L("eTop")
], Kn.prototype, "eTop", void 0);
Go([
  L("eBottom")
], Kn.prototype, "eBottom", void 0);
Go([
  L("gridHeader")
], Kn.prototype, "headerRootComp", void 0);
Go([
  L("eBodyClipper")
], Kn.prototype, "eBodyClipper", void 0);
Go([
  L("eBody")
], Kn.prototype, "eBody", void 0);
Go([
  B
], Kn.prototype, "init", null);
var hb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let jh = class extends H {
  postConstruct() {
    this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this));
  }
  onDisplayedColumnsChanged() {
    this.update();
  }
  onDisplayedColumnsWidthChanged() {
    this.update();
  }
  update() {
    this.updateImpl(), setTimeout(this.updateImpl.bind(this), 500);
  }
  updateImpl() {
    const e = this.ctrlsService.getCenterRowContainerCtrl();
    if (!e)
      return;
    const t = {
      horizontalScrollShowing: e.isHorizontalScrollShowing(),
      verticalScrollShowing: this.isVerticalScrollShowing()
    };
    this.setScrollsVisible(t);
  }
  setScrollsVisible(e) {
    if (this.horizontalScrollShowing !== e.horizontalScrollShowing || this.verticalScrollShowing !== e.verticalScrollShowing) {
      this.horizontalScrollShowing = e.horizontalScrollShowing, this.verticalScrollShowing = e.verticalScrollShowing;
      const i = {
        type: w.EVENT_SCROLL_VISIBILITY_CHANGED
      };
      this.eventService.dispatchEvent(i);
    }
  }
  // used by pagination service - to know page height
  isHorizontalScrollShowing() {
    return this.horizontalScrollShowing;
  }
  // used by header container
  isVerticalScrollShowing() {
    return this.verticalScrollShowing;
  }
};
hb([
  S("ctrlsService")
], jh.prototype, "ctrlsService", void 0);
hb([
  B
], jh.prototype, "postConstruct", null);
jh = hb([
  q("scrollVisibleService")
], jh);
var hx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, fh;
let Nd = fh = class extends H {
  constructor() {
    super(...arguments), this.gridInstanceId = fh.gridInstanceSequence.next();
  }
  // we put the instance id onto the main DOM element. this is used for events, when grids are inside grids,
  // so the grid can work out if the even came from this grid or a grid inside this one. see the ctrl+v logic
  // for where this is used.
  stampTopLevelGridCompWithGridInstance(e) {
    e[fh.GRID_DOM_KEY] = this.gridInstanceId;
  }
  getRenderedCellForEvent(e) {
    return Dg(this.gridOptionsService, e.target, un.DOM_DATA_KEY_CELL_CTRL);
  }
  // walks the path of the event, and returns true if this grid is the first one that it finds. if doing
  // master / detail grids, and a child grid is found, then it returns false. this stops things like copy/paste
  // getting executed on many grids at the same time.
  isEventFromThisGrid(e) {
    return this.isElementInThisGrid(e.target);
  }
  isElementInThisGrid(e) {
    let t = e;
    for (; t; ) {
      const i = t[fh.GRID_DOM_KEY];
      if (z(i))
        return i === this.gridInstanceId;
      t = t.parentElement;
    }
    return !1;
  }
  getCellPositionForEvent(e) {
    const t = this.getRenderedCellForEvent(e);
    return t ? t.getCellPosition() : null;
  }
  getNormalisedPosition(e) {
    const t = this.gridOptionsService.isDomLayout("normal"), i = e;
    let r, n;
    if (i.clientX != null || i.clientY != null ? (r = i.clientX, n = i.clientY) : (r = i.x, n = i.y), t) {
      const s = this.ctrlsService.getGridBodyCtrl(), a = s.getScrollFeature().getVScrollPosition(), l = s.getScrollFeature().getHScrollPosition();
      r += l.left, n += a.top;
    }
    return { x: r, y: n };
  }
};
Nd.gridInstanceSequence = new Ei();
Nd.GRID_DOM_KEY = "__ag_grid_instance";
hx([
  S("ctrlsService")
], Nd.prototype, "ctrlsService", void 0);
Nd = fh = hx([
  q("mouseEventService")
], Nd);
var ar = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Bi = class extends H {
  constructor() {
    super(), this.onPageDown = gC(this.onPageDown, 100), this.onPageUp = gC(this.onPageUp, 100);
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  handlePageScrollingKey(e, t = !1) {
    const i = e.key, r = e.altKey, n = e.ctrlKey || e.metaKey, s = !!this.rangeService && e.shiftKey, a = this.mouseEventService.getCellPositionForEvent(e);
    let l = !1;
    switch (i) {
      case V.PAGE_HOME:
      case V.PAGE_END:
        !n && !r && (this.onHomeOrEndKey(i), l = !0);
        break;
      case V.LEFT:
      case V.RIGHT:
      case V.UP:
      case V.DOWN:
        if (!a)
          return !1;
        n && !r && !s && (this.onCtrlUpDownLeftRight(i, a), l = !0);
        break;
      case V.PAGE_DOWN:
      case V.PAGE_UP:
        !n && !r && (l = this.handlePageUpDown(i, a, t));
        break;
    }
    return l && e.preventDefault(), l;
  }
  handlePageUpDown(e, t, i) {
    return i && (t = this.focusService.getFocusedCell()), t ? (e === V.PAGE_UP ? this.onPageUp(t) : this.onPageDown(t), !0) : !1;
  }
  navigateTo(e) {
    const { scrollIndex: t, scrollType: i, scrollColumn: r, focusIndex: n, focusColumn: s } = e;
    if (z(r) && !r.isPinned() && this.gridBodyCon.getScrollFeature().ensureColumnVisible(r), z(t) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(t, i), e.isAsync || this.gridBodyCon.getScrollFeature().ensureIndexVisible(n), this.focusService.setFocusedCell({ rowIndex: n, column: s, rowPinned: null, forceBrowserFocus: !0 }), this.rangeService) {
      const a = { rowIndex: n, rowPinned: null, column: s };
      this.rangeService.setRangeToCell(a);
    }
  }
  // this method is throttled, see the `constructor`
  onPageDown(e) {
    const i = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(), r = this.getViewportHeight(), n = this.paginationProxy.getPixelOffset(), s = i.top + r, a = this.paginationProxy.getRowIndexAtPixel(s + n);
    this.columnModel.isAutoRowHeightActive() ? this.navigateToNextPageWithAutoHeight(e, a) : this.navigateToNextPage(e, a);
  }
  // this method is throttled, see the `constructor`
  onPageUp(e) {
    const i = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(), r = this.paginationProxy.getPixelOffset(), n = i.top, s = this.paginationProxy.getRowIndexAtPixel(n + r);
    this.columnModel.isAutoRowHeightActive() ? this.navigateToNextPageWithAutoHeight(e, s, !0) : this.navigateToNextPage(e, s, !0);
  }
  navigateToNextPage(e, t, i = !1) {
    const r = this.getViewportHeight(), n = this.paginationProxy.getPageFirstRow(), s = this.paginationProxy.getPageLastRow(), a = this.paginationProxy.getPixelOffset(), l = this.paginationProxy.getRow(e.rowIndex), c = i ? (l == null ? void 0 : l.rowHeight) - r - a : r - a, d = (l == null ? void 0 : l.rowTop) + c;
    let u = this.paginationProxy.getRowIndexAtPixel(d + a);
    if (u === e.rowIndex) {
      const p = i ? -1 : 1;
      t = u = e.rowIndex + p;
    }
    let h;
    i ? (h = "bottom", u < n && (u = n), t < n && (t = n)) : (h = "top", u > s && (u = s), t > s && (t = s)), this.isRowTallerThanView(u) && (t = u, h = "top"), this.navigateTo({
      scrollIndex: t,
      scrollType: h,
      scrollColumn: null,
      focusIndex: u,
      focusColumn: e.column
    });
  }
  navigateToNextPageWithAutoHeight(e, t, i = !1) {
    this.navigateTo({
      scrollIndex: t,
      scrollType: i ? "bottom" : "top",
      scrollColumn: null,
      focusIndex: t,
      focusColumn: e.column
    }), setTimeout(() => {
      const r = this.getNextFocusIndexForAutoHeight(e, i);
      this.navigateTo({
        scrollIndex: t,
        scrollType: i ? "bottom" : "top",
        scrollColumn: null,
        focusIndex: r,
        focusColumn: e.column,
        isAsync: !0
      });
    }, 50);
  }
  getNextFocusIndexForAutoHeight(e, t = !1) {
    var i;
    const r = t ? -1 : 1, n = this.getViewportHeight(), s = this.paginationProxy.getPageLastRow();
    let a = 0, l = e.rowIndex;
    for (; l >= 0 && l <= s; ) {
      const c = this.paginationProxy.getRow(l);
      if (c) {
        const d = (i = c.rowHeight) !== null && i !== void 0 ? i : 0;
        if (a + d > n)
          break;
        a += d;
      }
      l += r;
    }
    return Math.max(0, Math.min(l, s));
  }
  getViewportHeight() {
    const t = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(), i = this.gridOptionsService.getScrollbarWidth();
    let r = t.bottom - t.top;
    return this.ctrlsService.getCenterRowContainerCtrl().isHorizontalScrollShowing() && (r -= i), r;
  }
  isRowTallerThanView(e) {
    const t = this.paginationProxy.getRow(e);
    if (!t)
      return !1;
    const i = t.rowHeight;
    return typeof i != "number" ? !1 : i > this.getViewportHeight();
  }
  onCtrlUpDownLeftRight(e, t) {
    const i = this.cellNavigationService.getNextCellToFocus(e, t, !0), { rowIndex: r, column: n } = i;
    this.navigateTo({
      scrollIndex: r,
      scrollType: null,
      scrollColumn: n,
      focusIndex: r,
      focusColumn: n
    });
  }
  // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring
  // same cell into view (which means either scroll all the way up, or all the way down).
  onHomeOrEndKey(e) {
    const t = e === V.PAGE_HOME, i = this.columnModel.getAllDisplayedColumns(), r = t ? i[0] : at(i), n = t ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();
    this.navigateTo({
      scrollIndex: n,
      scrollType: null,
      scrollColumn: r,
      focusIndex: n,
      focusColumn: r
    });
  }
  // result of keyboard event
  onTabKeyDown(e, t) {
    const i = t.shiftKey;
    if (this.tabToNextCellCommon(e, i, t)) {
      t.preventDefault();
      return;
    }
    if (i) {
      const { rowIndex: n, rowPinned: s } = e.getRowPosition();
      (s ? n === 0 : n === this.paginationProxy.getPageFirstRow()) && (this.gridOptionsService.getNum("headerHeight") === 0 ? this.focusService.focusNextGridCoreContainer(!0, !0) : (t.preventDefault(), this.focusService.focusLastHeader(t)));
    } else
      e instanceof un && e.focusCell(!0), this.focusService.focusNextGridCoreContainer(i) && t.preventDefault();
  }
  // comes from API
  tabToNextCell(e, t) {
    const i = this.focusService.getFocusedCell();
    if (!i)
      return !1;
    let r = this.getCellByPosition(i);
    return !r && (r = this.rowRenderer.getRowByPosition(i), !r || !r.isFullWidth()) ? !1 : this.tabToNextCellCommon(r, e, t);
  }
  tabToNextCellCommon(e, t, i) {
    let r = e.isEditing();
    if (!r && e instanceof un) {
      const a = e.getRowCtrl();
      a && (r = a.isEditing());
    }
    let n;
    return r ? this.gridOptionsService.get("editType") === "fullRow" ? n = this.moveToNextEditingRow(e, t, i) : n = this.moveToNextEditingCell(e, t, i) : n = this.moveToNextCellNotEditing(e, t), n || !!this.focusService.getFocusedHeader();
  }
  moveToNextEditingCell(e, t, i = null) {
    const r = e.getCellPosition();
    e.getGui().focus(), e.stopEditing();
    const n = this.findNextCellToFocusOn(r, t, !0);
    return n == null ? !1 : (n.startEditing(null, !0, i), n.focusCell(!1), !0);
  }
  moveToNextEditingRow(e, t, i = null) {
    const r = e.getCellPosition(), n = this.findNextCellToFocusOn(r, t, !0);
    if (n == null)
      return !1;
    const s = n.getCellPosition(), a = this.isCellEditable(r), l = this.isCellEditable(s), c = s && r.rowIndex === s.rowIndex && r.rowPinned === s.rowPinned;
    return a && e.setFocusOutOnEditor(), c || (e.getRowCtrl().stopEditing(), n.getRowCtrl().startRowEditing(void 0, void 0, i)), l ? (n.setFocusInOnEditor(), n.focusCell()) : n.focusCell(!0), !0;
  }
  moveToNextCellNotEditing(e, t) {
    const i = this.columnModel.getAllDisplayedColumns();
    let r;
    e instanceof Gn ? r = Object.assign(Object.assign({}, e.getRowPosition()), { column: t ? i[0] : at(i) }) : r = e.getCellPosition();
    const n = this.findNextCellToFocusOn(r, t, !1);
    if (n instanceof un)
      n.focusCell(!0);
    else if (n)
      return this.tryToFocusFullWidthRow(n.getRowPosition(), t);
    return z(n);
  }
  // called by the cell, when tab is pressed while editing.
  // @return: RenderedCell when navigation successful, otherwise null
  findNextCellToFocusOn(e, t, i) {
    let r = e;
    for (; ; ) {
      e !== r && (e = r), t || (r = this.getLastCellOfColSpan(r)), r = this.cellNavigationService.getNextTabbedCell(r, t);
      const n = this.gridOptionsService.getCallback("tabToNextCell");
      if (z(n)) {
        const c = n({
          backwards: t,
          editing: i,
          previousCellPosition: e,
          nextCellPosition: r || null
        });
        z(c) ? (c.floating && (tt(() => {
          console.warn("AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?");
        }, "no floating in userCell"), c.rowPinned = c.floating), r = {
          rowIndex: c.rowIndex,
          column: c.column,
          rowPinned: c.rowPinned
        }) : r = null;
      }
      if (!r)
        return null;
      if (r.rowIndex < 0) {
        const l = this.headerNavigationService.getHeaderRowCount();
        return this.focusService.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: l + r.rowIndex,
            column: r.column
          }
        }), null;
      }
      const s = this.gridOptionsService.get("editType") === "fullRow";
      if (i && !s && !this.isCellEditable(r))
        continue;
      this.ensureCellVisible(r);
      const a = this.getCellByPosition(r);
      if (!a) {
        const l = this.rowRenderer.getRowByPosition(r);
        if (!l || !l.isFullWidth() || i)
          continue;
        return l;
      }
      if (!a.isSuppressNavigable())
        return this.rangeService && this.rangeService.setRangeToCell(r), a;
    }
  }
  isCellEditable(e) {
    const t = this.lookupRowNodeForCell(e);
    return t ? e.column.isCellEditable(t) : !1;
  }
  getCellByPosition(e) {
    const t = this.rowRenderer.getRowByPosition(e);
    return t ? t.getCellCtrl(e.column) : null;
  }
  lookupRowNodeForCell(e) {
    return e.rowPinned === "top" ? this.pinnedRowModel.getPinnedTopRow(e.rowIndex) : e.rowPinned === "bottom" ? this.pinnedRowModel.getPinnedBottomRow(e.rowIndex) : this.paginationProxy.getRow(e.rowIndex);
  }
  // we use index for rows, but column object for columns, as the next column (by index) might not
  // be visible (header grouping) so it's not reliable, so using the column object instead.
  navigateToNextCell(e, t, i, r) {
    let n = i, s = !1;
    for (; n && (n === i || !this.isValidNavigateCell(n)); )
      this.gridOptionsService.is("enableRtl") ? t === V.LEFT && (n = this.getLastCellOfColSpan(n)) : t === V.RIGHT && (n = this.getLastCellOfColSpan(n)), n = this.cellNavigationService.getNextCellToFocus(t, n), s = Se(n);
    if (s && e && e.key === V.UP && (n = {
      rowIndex: -1,
      rowPinned: null,
      column: i.column
    }), r) {
      const l = this.gridOptionsService.getCallback("navigateToNextCell");
      if (z(l)) {
        const d = l({
          key: t,
          previousCellPosition: i,
          nextCellPosition: n || null,
          event: e
        });
        z(d) ? (d.floating && (tt(() => {
          console.warn("AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?");
        }, "no floating in userCell"), d.rowPinned = d.floating), n = {
          rowPinned: d.rowPinned,
          rowIndex: d.rowIndex,
          column: d.column
        }) : n = null;
      }
    }
    if (!n)
      return;
    if (n.rowIndex < 0) {
      const l = this.headerNavigationService.getHeaderRowCount();
      this.focusService.focusHeaderPosition({
        headerPosition: { headerRowIndex: l + n.rowIndex, column: i.column },
        event: e || void 0
      });
      return;
    }
    const a = this.getNormalisedPosition(n);
    a ? this.focusPosition(a) : this.tryToFocusFullWidthRow(n);
  }
  getNormalisedPosition(e) {
    this.ensureCellVisible(e);
    const t = this.getCellByPosition(e);
    return t ? (e = t.getCellPosition(), this.ensureCellVisible(e), e) : null;
  }
  tryToFocusFullWidthRow(e, t = !1) {
    const i = this.columnModel.getAllDisplayedColumns(), r = this.rowRenderer.getRowByPosition(e);
    if (!r || !r.isFullWidth())
      return !1;
    const n = this.focusService.getFocusedCell(), s = {
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: e.column || (t ? at(i) : i[0])
    };
    this.focusPosition(s);
    const a = n != null ? this.rowPositionUtils.before(s, n) : !1, l = {
      type: w.EVENT_FULL_WIDTH_ROW_FOCUSED,
      rowIndex: s.rowIndex,
      rowPinned: s.rowPinned,
      column: s.column,
      isFullWidthCell: !0,
      floating: s.rowPinned,
      fromBelow: a
    };
    return this.eventService.dispatchEvent(l), !0;
  }
  focusPosition(e) {
    this.focusService.setFocusedCell({
      rowIndex: e.rowIndex,
      column: e.column,
      rowPinned: e.rowPinned,
      forceBrowserFocus: !0
    }), this.rangeService && this.rangeService.setRangeToCell(e);
  }
  isValidNavigateCell(e) {
    return !!this.rowPositionUtils.getRowNode(e);
  }
  getLastCellOfColSpan(e) {
    const t = this.getCellByPosition(e);
    if (!t)
      return e;
    const i = t.getColSpanningList();
    return i.length === 1 ? e : {
      rowIndex: e.rowIndex,
      column: at(i),
      rowPinned: e.rowPinned
    };
  }
  ensureCellVisible(e) {
    const t = this.gridOptionsService.isGroupRowsSticky(), i = this.rowModel.getRow(e.rowIndex);
    !(t && (i == null ? void 0 : i.sticky)) && Se(e.rowPinned) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(e.rowIndex), e.column.isPinned() || this.gridBodyCon.getScrollFeature().ensureColumnVisible(e.column);
  }
};
ar([
  S("mouseEventService")
], Bi.prototype, "mouseEventService", void 0);
ar([
  S("paginationProxy")
], Bi.prototype, "paginationProxy", void 0);
ar([
  S("focusService")
], Bi.prototype, "focusService", void 0);
ar([
  Ve("rangeService")
], Bi.prototype, "rangeService", void 0);
ar([
  S("columnModel")
], Bi.prototype, "columnModel", void 0);
ar([
  S("rowModel")
], Bi.prototype, "rowModel", void 0);
ar([
  S("ctrlsService")
], Bi.prototype, "ctrlsService", void 0);
ar([
  S("rowRenderer")
], Bi.prototype, "rowRenderer", void 0);
ar([
  S("headerNavigationService")
], Bi.prototype, "headerNavigationService", void 0);
ar([
  S("rowPositionUtils")
], Bi.prototype, "rowPositionUtils", void 0);
ar([
  S("cellNavigationService")
], Bi.prototype, "cellNavigationService", void 0);
ar([
  S("pinnedRowModel")
], Bi.prototype, "pinnedRowModel", void 0);
ar([
  B
], Bi.prototype, "postConstruct", null);
Bi = ar([
  q("navigationService")
], Bi);
var uN = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Bp extends rc {
  constructor(e) {
    super(
      /* html */
      '<div class="ag-popup-editor" tabindex="-1"/>'
    ), this.params = e;
  }
  postConstruct() {
    this.gridOptionsService.setDomData(this.getGui(), Bp.DOM_KEY_POPUP_EDITOR_WRAPPER, !0), this.addKeyDownListener();
  }
  addKeyDownListener() {
    const e = this.getGui(), t = this.params, i = (r) => {
      Mg(this.gridOptionsService, r, t.node, t.column, !0) || t.onKeyDown(r);
    };
    this.addManagedListener(e, "keydown", i);
  }
}
Bp.DOM_KEY_POPUP_EDITOR_WRAPPER = "popupEditorWrapper";
uN([
  B
], Bp.prototype, "postConstruct", null);
class hN extends X {
  constructor(e, t, i, r, n) {
    super(), this.rendererVersion = 0, this.editorVersion = 0, this.beans = e, this.column = t.getColumn(), this.rowNode = t.getRowNode(), this.rowCtrl = t.getRowCtrl(), this.eRow = r, this.setTemplate(
      /* html */
      `<div comp-id="${this.getCompId()}"/>`
    );
    const s = this.getGui();
    this.forceWrapper = t.isForceWrapper(), this.refreshWrapper(!1);
    const a = (c, d, u) => {
      const h = u || s;
      d != null && d != "" ? h.setAttribute(c, d) : h.removeAttribute(c);
    }, l = {
      addOrRemoveCssClass: (c, d) => this.addOrRemoveCssClass(c, d),
      setUserStyles: (c) => VS(s, c),
      getFocusableElement: () => this.getFocusableElement(),
      setTabIndex: (c) => a("tabindex", c.toString()),
      setRole: (c) => ci(s, c),
      setColId: (c) => a("col-id", c),
      setTitle: (c) => a("title", c),
      setIncludeSelection: (c) => this.includeSelection = c,
      setIncludeRowDrag: (c) => this.includeRowDrag = c,
      setIncludeDndSource: (c) => this.includeDndSource = c,
      setRenderDetails: (c, d, u) => this.setRenderDetails(c, d, u),
      setEditDetails: (c, d, u) => this.setEditDetails(c, d, u),
      getCellEditor: () => this.cellEditor || null,
      getCellRenderer: () => this.cellRenderer || null,
      getParentOfValue: () => this.getParentOfValue()
    };
    this.cellCtrl = t, t.setComp(l, this.getGui(), this.eCellWrapper, i, n);
  }
  getParentOfValue() {
    return this.eCellValue ? this.eCellValue : this.eCellWrapper ? this.eCellWrapper : this.getGui();
  }
  setRenderDetails(e, t, i) {
    if (this.cellEditor && !this.cellEditorPopupWrapper)
      return;
    this.firstRender = this.firstRender == null;
    const n = this.refreshWrapper(!1);
    this.refreshEditStyles(!1), e ? !(i || n) && this.refreshCellRenderer(e) || (this.destroyRenderer(), this.createCellRendererInstance(e)) : (this.destroyRenderer(), this.insertValueWithoutCellRenderer(t));
  }
  setEditDetails(e, t, i) {
    e ? this.createCellEditorInstance(e, t, i) : this.destroyEditor();
  }
  removeControls() {
    this.checkboxSelectionComp = this.beans.context.destroyBean(this.checkboxSelectionComp), this.dndSourceComp = this.beans.context.destroyBean(this.dndSourceComp), this.rowDraggingComp = this.beans.context.destroyBean(this.rowDraggingComp);
  }
  // returns true if wrapper was changed
  refreshWrapper(e) {
    const t = this.includeRowDrag || this.includeDndSource || this.includeSelection, i = t || this.forceWrapper, r = i && this.eCellWrapper == null;
    r && (this.eCellWrapper = Si(
      /* html */
      '<div class="ag-cell-wrapper" role="presentation"></div>'
    ), this.getGui().appendChild(this.eCellWrapper));
    const n = !i && this.eCellWrapper != null;
    n && (fs(this.eCellWrapper), this.eCellWrapper = void 0), this.addOrRemoveCssClass("ag-cell-value", !i);
    const s = !e && i, a = s && this.eCellValue == null;
    a && (this.eCellValue = Si(
      /* html */
      '<span class="ag-cell-value" role="presentation"></span>'
    ), this.eCellWrapper.appendChild(this.eCellValue));
    const l = !s && this.eCellValue != null;
    l && (fs(this.eCellValue), this.eCellValue = void 0);
    const c = r || n || a || l;
    return c && this.removeControls(), e || t && this.addControls(), c;
  }
  addControls() {
    this.includeRowDrag && this.rowDraggingComp == null && (this.rowDraggingComp = this.cellCtrl.createRowDragComp(), this.rowDraggingComp && this.eCellWrapper.insertBefore(this.rowDraggingComp.getGui(), this.eCellValue)), this.includeDndSource && this.dndSourceComp == null && (this.dndSourceComp = this.cellCtrl.createDndSource(), this.eCellWrapper.insertBefore(this.dndSourceComp.getGui(), this.eCellValue)), this.includeSelection && this.checkboxSelectionComp == null && (this.checkboxSelectionComp = this.cellCtrl.createSelectionCheckbox(), this.eCellWrapper.insertBefore(this.checkboxSelectionComp.getGui(), this.eCellValue));
  }
  createCellEditorInstance(e, t, i) {
    const r = this.editorVersion, n = e.newAgStackInstance();
    if (!n)
      return;
    const { params: s } = e;
    n.then((l) => this.afterCellEditorCreated(r, l, s, t, i)), Se(this.cellEditor) && s.cellStartedEdit && this.cellCtrl.focusCell(!0);
  }
  insertValueWithoutCellRenderer(e) {
    const t = this.getParentOfValue();
    Or(t);
    const i = e != null ? xo(e) : null;
    i != null && (t.innerHTML = i);
  }
  destroyEditorAndRenderer() {
    this.destroyRenderer(), this.destroyEditor();
  }
  destroyRenderer() {
    const { context: e } = this.beans;
    this.cellRenderer = e.destroyBean(this.cellRenderer), fs(this.cellRendererGui), this.cellRendererGui = null, this.rendererVersion++;
  }
  destroyEditor() {
    const { context: e } = this.beans;
    this.hideEditorPopup && this.hideEditorPopup(), this.hideEditorPopup = void 0, this.cellEditor = e.destroyBean(this.cellEditor), this.cellEditorPopupWrapper = e.destroyBean(this.cellEditorPopupWrapper), fs(this.cellEditorGui), this.cellEditorGui = null, this.editorVersion++;
  }
  refreshCellRenderer(e) {
    if (this.cellRenderer == null || this.cellRenderer.refresh == null || this.cellRendererClass !== e.componentClass)
      return !1;
    const t = this.cellRenderer.refresh(e.params);
    return t === !0 || t === void 0;
  }
  createCellRendererInstance(e) {
    const i = !this.beans.gridOptionsService.is("suppressAnimationFrame"), r = this.rendererVersion, { componentClass: n } = e, s = () => {
      if (this.rendererVersion !== r || !this.isAlive())
        return;
      const l = e.newAgStackInstance(), c = this.afterCellRendererCreated.bind(this, r, n);
      l && l.then(c);
    };
    i && this.firstRender ? this.beans.animationFrameService.createTask(s, this.rowNode.rowIndex, "createTasksP2") : s();
  }
  getCtrl() {
    return this.cellCtrl;
  }
  getRowCtrl() {
    return this.rowCtrl;
  }
  getCellRenderer() {
    return this.cellRenderer;
  }
  getCellEditor() {
    return this.cellEditor;
  }
  afterCellRendererCreated(e, t, i) {
    if (!this.isAlive() || e !== this.rendererVersion) {
      this.beans.context.destroyBean(i);
      return;
    }
    if (this.cellRenderer = i, this.cellRendererClass = t, this.cellRendererGui = this.cellRenderer.getGui(), this.cellRendererGui != null) {
      const n = this.getParentOfValue();
      Or(n), n.appendChild(this.cellRendererGui);
    }
  }
  afterCellEditorCreated(e, t, i, r, n) {
    if (e !== this.editorVersion) {
      this.beans.context.destroyBean(t);
      return;
    }
    if (t.isCancelBeforeStart && t.isCancelBeforeStart()) {
      this.beans.context.destroyBean(t), this.cellCtrl.stopEditing(!0);
      return;
    }
    if (!t.getGui) {
      console.warn(`AG Grid: cellEditor for column ${this.column.getId()} is missing getGui() method`), this.beans.context.destroyBean(t);
      return;
    }
    this.cellEditor = t, this.cellEditorGui = t.getGui();
    const l = r || t.isPopup !== void 0 && t.isPopup();
    l ? this.addPopupCellEditor(i, n) : this.addInCellEditor(), this.refreshEditStyles(!0, l), t.afterGuiAttached && t.afterGuiAttached();
  }
  refreshEditStyles(e, t) {
    var i;
    this.addOrRemoveCssClass("ag-cell-inline-editing", e && !t), this.addOrRemoveCssClass("ag-cell-popup-editing", e && !!t), this.addOrRemoveCssClass("ag-cell-not-inline-editing", !e || !!t), (i = this.rowCtrl) === null || i === void 0 || i.setInlineEditingCss(e);
  }
  addInCellEditor() {
    const e = this.getGui(), t = this.beans.gridOptionsService.getDocument();
    e.contains(t.activeElement) && e.focus(), this.destroyRenderer(), this.refreshWrapper(!0), this.clearParentOfValue(), this.cellEditorGui && this.getParentOfValue().appendChild(this.cellEditorGui);
  }
  addPopupCellEditor(e, t) {
    this.beans.gridOptionsService.get("editType") === "fullRow" && console.warn("AG Grid: popup cellEditor does not work with fullRowEdit - you cannot use them both - either turn off fullRowEdit, or stop using popup editors.");
    const i = this.cellEditor;
    this.cellEditorPopupWrapper = this.beans.context.createBean(new Bp(e));
    const r = this.cellEditorPopupWrapper.getGui();
    this.cellEditorGui && r.appendChild(this.cellEditorGui);
    const n = this.beans.popupService, s = this.beans.gridOptionsService.is("stopEditingWhenCellsLoseFocus"), a = t != null ? t : i.getPopupPosition ? i.getPopupPosition() : "over", l = this.beans.gridOptionsService.is("enableRtl"), c = {
      ePopup: r,
      column: this.column,
      rowNode: this.rowNode,
      type: "popupCellEditor",
      eventSource: this.getGui(),
      position: a,
      alignSide: l ? "right" : "left",
      keepWithinBounds: !0
    }, d = n.positionPopupByComponent.bind(n, c), u = this.beans.localeService.getLocaleTextFunc(), h = n.addPopup({
      modal: s,
      eChild: r,
      closeOnEsc: !0,
      closedCallback: () => {
        this.cellCtrl.onPopupEditorClosed();
      },
      anchorToElement: this.getGui(),
      positionCallback: d,
      ariaLabel: u("ariaLabelCellEditor", "Cell Editor")
    });
    h && (this.hideEditorPopup = h.hideFunc);
  }
  detach() {
    this.eRow.removeChild(this.getGui());
  }
  // if the row is also getting destroyed, then we don't need to remove from dom,
  // as the row will also get removed, so no need to take out the cells from the row
  // if the row is going (removing is an expensive operation, so only need to remove
  // the top part)
  //
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroy() {
    this.cellCtrl.stopEditing(), this.destroyEditorAndRenderer(), this.removeControls(), super.destroy();
  }
  clearParentOfValue() {
    const e = this.getGui(), t = this.beans.gridOptionsService.getDocument();
    e.contains(t.activeElement) && Vv() && e.focus({ preventScroll: !0 }), Or(this.getParentOfValue());
  }
}
class pN extends X {
  constructor(e, t, i) {
    super(), this.cellComps = {}, this.beans = t, this.rowCtrl = e, this.setTemplate(
      /* html */
      `<div comp-id="${this.getCompId()}" style="${this.getInitialStyle(i)}"/>`
    );
    const r = this.getGui(), n = r.style, s = {
      setDomOrder: (a) => this.domOrder = a,
      setCellCtrls: (a) => this.setCellCtrls(a),
      showFullWidth: (a) => this.showFullWidth(a),
      getFullWidthCellRenderer: () => this.getFullWidthCellRenderer(),
      addOrRemoveCssClass: (a, l) => this.addOrRemoveCssClass(a, l),
      setUserStyles: (a) => VS(r, a),
      setTop: (a) => n.top = a,
      setTransform: (a) => n.transform = a,
      setRowIndex: (a) => r.setAttribute("row-index", a),
      setRole: (a) => ci(r, a),
      setRowId: (a) => r.setAttribute("row-id", a),
      setRowBusinessKey: (a) => r.setAttribute("row-business-key", a),
      setTabIndex: (a) => r.setAttribute("tabindex", a.toString())
    };
    e.setComp(s, this.getGui(), i), this.addDestroyFunc(() => {
      e.unsetComp(i);
    });
  }
  getInitialStyle(e) {
    const t = this.rowCtrl.getInitialTransform(e), i = this.rowCtrl.getInitialRowTop(e);
    return t ? `transform: ${t}` : `top: ${i}`;
  }
  showFullWidth(e) {
    const t = (r) => {
      if (this.isAlive()) {
        const n = r.getGui();
        this.getGui().appendChild(n), this.rowCtrl.setupDetailRowAutoHeight(n), this.setFullWidthRowComp(r);
      } else
        this.beans.context.destroyBean(r);
    }, i = e.newAgStackInstance();
    i && i.then(t);
  }
  setCellCtrls(e) {
    const t = Object.assign({}, this.cellComps);
    e.forEach((r) => {
      const n = r.getInstanceId();
      this.cellComps[n] == null ? this.newCellComp(r) : t[n] = null;
    });
    const i = To(t).filter((r) => r != null);
    this.destroyCells(i), this.ensureDomOrder(e);
  }
  ensureDomOrder(e) {
    if (!this.domOrder)
      return;
    const t = [];
    e.forEach((i) => {
      const r = this.cellComps[i.getInstanceId()];
      r && t.push(r.getGui());
    }), kS(this.getGui(), t);
  }
  newCellComp(e) {
    const t = new hN(this.beans, e, this.rowCtrl.isPrintLayout(), this.getGui(), this.rowCtrl.isEditing());
    this.cellComps[e.getInstanceId()] = t, this.getGui().appendChild(t.getGui());
  }
  destroy() {
    super.destroy(), this.destroyAllCells();
  }
  destroyAllCells() {
    const e = To(this.cellComps).filter((t) => t != null);
    this.destroyCells(e);
  }
  setFullWidthRowComp(e) {
    this.fullWidthCellRenderer && console.error("AG Grid - should not be setting fullWidthRowComponent twice"), this.fullWidthCellRenderer = e, this.addDestroyFunc(() => {
      this.fullWidthCellRenderer = this.beans.context.destroyBean(this.fullWidthCellRenderer);
    });
  }
  getFullWidthCellRenderer() {
    return this.fullWidthCellRenderer;
  }
  destroyCells(e) {
    e.forEach((t) => {
      if (!t)
        return;
      const i = t.getCtrl().getInstanceId();
      this.cellComps[i] === t && (t.detach(), t.destroy(), this.cellComps[i] = null);
    });
  }
}
var pu = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
function fN() {
  const o = X.elementGettingCreated.getAttribute("name"), e = bn.getRowContainerCssClasses(o);
  let t;
  const i = o === U.CENTER, r = o === U.TOP_CENTER || o === U.STICKY_TOP_CENTER || o === U.BOTTOM_CENTER;
  return i ? t = /* html */
  `<div class="${e.wrapper}" ref="eWrapper" role="presentation">
                <div class="${e.viewport}" ref="eViewport" role="presentation">
                    <div class="${e.container}" ref="eContainer"></div>
                </div>
            </div>` : r ? t = /* html */
  `<div class="${e.viewport}" ref="eViewport" role="presentation">
                <div class="${e.container}" ref="eContainer"></div>
            </div>` : t = /* html */
  `<div class="${e.container}" ref="eContainer"></div>`, t;
}
class sc extends X {
  constructor() {
    super(fN()), this.rowComps = {}, this.name = X.elementGettingCreated.getAttribute("name"), this.type = sN(this.name);
  }
  postConstruct() {
    const e = {
      setViewportHeight: (i) => this.eViewport.style.height = i,
      setRowCtrls: (i) => this.setRowCtrls(i),
      setDomOrder: (i) => {
        this.domOrder = i;
      },
      setContainerWidth: (i) => this.eContainer.style.width = i
    };
    this.createManagedBean(new bn(this.name)).setComp(e, this.eContainer, this.eViewport, this.eWrapper);
  }
  preDestroy() {
    this.setRowCtrls([]);
  }
  setRowCtrls(e) {
    const t = Object.assign({}, this.rowComps);
    this.rowComps = {}, this.lastPlacedElement = null;
    const i = (r) => {
      const n = r.getInstanceId(), s = t[n];
      if (s)
        this.rowComps[n] = s, delete t[n], this.ensureDomOrder(s.getGui());
      else {
        if (!r.getRowNode().displayed)
          return;
        const a = new pN(r, this.beans, this.type);
        this.rowComps[n] = a, this.appendRow(a.getGui());
      }
    };
    e.forEach(i), To(t).forEach((r) => {
      this.eContainer.removeChild(r.getGui()), r.destroy();
    }), ci(this.eContainer, e.length ? "rowgroup" : "presentation");
  }
  appendRow(e) {
    this.domOrder ? PT(this.eContainer, e, this.lastPlacedElement) : this.eContainer.appendChild(e), this.lastPlacedElement = e;
  }
  ensureDomOrder(e) {
    this.domOrder && (GS(this.eContainer, e, this.lastPlacedElement), this.lastPlacedElement = e);
  }
}
pu([
  S("beans")
], sc.prototype, "beans", void 0);
pu([
  L("eViewport")
], sc.prototype, "eViewport", void 0);
pu([
  L("eContainer")
], sc.prototype, "eContainer", void 0);
pu([
  L("eWrapper")
], sc.prototype, "eWrapper", void 0);
pu([
  B
], sc.prototype, "postConstruct", null);
pu([
  dt
], sc.prototype, "preDestroy", null);
var px = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class pb {
  constructor(e) {
    this.columnsToAggregate = [], this.columnsToGroup = [], this.columnsToPivot = [], this.pinned = e;
  }
  /** Callback for when drag enters */
  onDragEnter(e) {
    if (this.clearColumnsList(), this.gridOptionsService.is("functionsReadOnly"))
      return;
    const t = e.dragItem.columns;
    t && t.forEach((i) => {
      i.isPrimary() && (i.isAnyFunctionActive() || (i.isAllowValue() ? this.columnsToAggregate.push(i) : i.isAllowRowGroup() ? this.columnsToGroup.push(i) : i.isAllowPivot() && this.columnsToPivot.push(i)));
    });
  }
  getIconName() {
    return this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length > 0 ? this.pinned ? Te.ICON_PINNED : Te.ICON_MOVE : null;
  }
  /** Callback for when drag leaves */
  onDragLeave(e) {
    this.clearColumnsList();
  }
  clearColumnsList() {
    this.columnsToAggregate.length = 0, this.columnsToGroup.length = 0, this.columnsToPivot.length = 0;
  }
  /** Callback for when dragging */
  onDragging(e) {
  }
  /** Callback for when drag stops */
  onDragStop(e) {
    this.columnsToAggregate.length > 0 && this.columnModel.addValueColumns(this.columnsToAggregate, "toolPanelDragAndDrop"), this.columnsToGroup.length > 0 && this.columnModel.addRowGroupColumns(this.columnsToGroup, "toolPanelDragAndDrop"), this.columnsToPivot.length > 0 && this.columnModel.addPivotColumns(this.columnsToPivot, "toolPanelDragAndDrop");
  }
}
px([
  S("columnModel")
], pb.prototype, "columnModel", void 0);
px([
  S("gridOptionsService")
], pb.prototype, "gridOptionsService", void 0);
var Hp = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class fu {
  constructor(e, t) {
    this.needToMoveLeft = !1, this.needToMoveRight = !1, this.lastMovedInfo = null, this.pinned = e, this.eContainer = t, this.centerContainer = !z(e);
  }
  init() {
    this.ctrlsService.whenReady(() => {
      this.gridBodyCon = this.ctrlsService.getGridBodyCtrl();
    });
  }
  getIconName() {
    return this.pinned ? Te.ICON_PINNED : Te.ICON_MOVE;
  }
  onDragEnter(e) {
    const t = e.dragItem.columns;
    if (e.dragSource.type === Dt.ToolPanel)
      this.setColumnsVisible(t, !0, "uiColumnDragged");
    else {
      const r = e.dragItem.visibleState, n = (t || []).filter((s) => r[s.getId()]);
      this.setColumnsVisible(n, !0, "uiColumnDragged");
    }
    this.setColumnsPinned(t, this.pinned, "uiColumnDragged"), this.onDragging(e, !0, !0);
  }
  onDragLeave() {
    this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  setColumnsVisible(e, t, i = "api") {
    if (e) {
      const r = e.filter((n) => !n.getColDef().lockVisible);
      this.columnModel.setColumnsVisible(r, t, i);
    }
  }
  setColumnsPinned(e, t, i = "api") {
    if (e) {
      const r = e.filter((n) => !n.getColDef().lockPinned);
      this.columnModel.setColumnsPinned(r, t, i);
    }
  }
  onDragStop() {
    this.onDragging(this.lastDraggingEvent, !1, !0, !0), this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  normaliseX(e) {
    return this.gridOptionsService.is("enableRtl") && (e = this.eContainer.clientWidth - e), this.centerContainer && (e += this.ctrlsService.getCenterRowContainerCtrl().getCenterViewportScrollLeft()), e;
  }
  checkCenterForScrolling(e) {
    if (this.centerContainer) {
      const t = this.ctrlsService.getCenterRowContainerCtrl().getCenterViewportScrollLeft(), i = t + this.ctrlsService.getCenterRowContainerCtrl().getCenterWidth();
      this.gridOptionsService.is("enableRtl") ? (this.needToMoveRight = e < t + 50, this.needToMoveLeft = e > i - 50) : (this.needToMoveLeft = e < t + 50, this.needToMoveRight = e > i - 50), this.needToMoveLeft || this.needToMoveRight ? this.ensureIntervalStarted() : this.ensureIntervalCleared();
    }
  }
  onDragging(e = this.lastDraggingEvent, t = !1, i = !1, r = !1) {
    var n;
    if (r) {
      if (this.lastMovedInfo) {
        const { columns: d, toIndex: u } = this.lastMovedInfo;
        this.moveColumns(d, u, "uiColumnMoved", !0);
      }
      return;
    }
    if (this.lastDraggingEvent = e, Se(e.hDirection))
      return;
    const s = this.normaliseX(e.x);
    t || this.checkCenterForScrolling(s);
    const a = this.normaliseDirection(e.hDirection), l = e.dragSource.type, c = ((n = e.dragSource.getDragItem().columns) === null || n === void 0 ? void 0 : n.filter((d) => d.getColDef().lockPinned ? d.getPinned() == this.pinned : !0)) || [];
    this.attemptMoveColumns({ dragSourceType: l, allMovingColumns: c, hDirection: a, mouseX: s, fromEnter: t, fakeEvent: i });
  }
  normaliseDirection(e) {
    if (this.gridOptionsService.is("enableRtl"))
      switch (e) {
        case fo.Left:
          return fo.Right;
        case fo.Right:
          return fo.Left;
        default:
          console.error(`AG Grid: Unknown direction ${e}`);
      }
    else
      return e;
  }
  attemptMoveColumns(e) {
    const { dragSourceType: t, hDirection: i, mouseX: r, fromEnter: n, fakeEvent: s } = e, a = i === fo.Left, l = i === fo.Right;
    let { allMovingColumns: c } = e;
    if (t === Dt.HeaderCell) {
      let m = [];
      c.forEach((C) => {
        let R = null, E = C.getParent();
        for (; E != null && E.getDisplayedLeafColumns().length === 1; )
          R = E, E = E.getParent();
        R != null ? R.getProvidedColumnGroup().getLeafColumns().forEach((T) => {
          m.includes(T) || m.push(T);
        }) : m.includes(C) || m.push(C);
      }), c = m;
    }
    const d = c.slice();
    this.columnModel.sortColumnsLikeGridColumns(d);
    const u = this.calculateValidMoves(d, l, r), h = this.calculateOldIndex(d);
    if (u.length === 0)
      return;
    const p = u[0];
    let f = h !== null && !n;
    if (t == Dt.HeaderCell && (f = h !== null), f && !s && (a && p >= h || l && p <= h))
      return;
    const g = this.columnModel.getAllDisplayedColumns();
    let v = [], y = null;
    for (let m = 0; m < u.length; m++) {
      const C = u[m], R = this.columnModel.getProposedColumnOrder(d, C);
      if (!this.columnModel.doesOrderPassRules(R))
        continue;
      const E = R.filter((T) => g.includes(T));
      if (y === null)
        y = E;
      else if (!x.areEqual(E, y))
        break;
      const b = this.groupFragCount(R);
      v.push({ move: C, fragCount: b });
    }
    v.length !== 0 && (v.sort((m, C) => m.fragCount - C.fragCount), this.moveColumns(c, v[0].move, "uiColumnMoved", !1));
  }
  // returns the index of the first column in the list ONLY if the cols are all beside
  // each other. if the cols are not beside each other, then returns null
  calculateOldIndex(e) {
    const t = this.columnModel.getAllGridColumns(), i = YR(e.map((l) => t.indexOf(l))), r = i[0];
    return at(i) - r !== i.length - 1 ? null : r;
  }
  moveColumns(e, t, i, r) {
    this.columnModel.moveColumns(e, t, i, r), this.lastMovedInfo = r ? null : { columns: e, toIndex: t };
  }
  // A measure of how fragmented in terms of groups an order of columns is
  groupFragCount(e) {
    function t(r) {
      let n = [], s = r.getOriginalParent();
      for (; s != null; )
        n.push(s), s = s.getOriginalParent();
      return n;
    }
    let i = 0;
    for (let r = 0; r < e.length - 1; r++) {
      let n = t(e[r]), s = t(e[r + 1]);
      [n, s] = n.length > s.length ? [n, s] : [s, n], n.forEach((a) => {
        s.indexOf(a) === -1 && i++;
      });
    }
    return i;
  }
  calculateValidMoves(e, t, i) {
    if (this.gridOptionsService.is("suppressMovableColumns") || e.some((g) => g.getColDef().suppressMovable))
      return [];
    const n = this.columnModel.getDisplayedColumns(this.pinned), s = this.columnModel.getAllGridColumns(), a = n.filter((g) => ln(e, g)), l = n.filter((g) => !ln(e, g)), c = s.filter((g) => !ln(e, g));
    let d = 0, u = i;
    if (t) {
      let g = 0;
      a.forEach((v) => g += v.getActualWidth()), u -= g;
    }
    if (u > 0) {
      for (let g = 0; g < l.length; g++) {
        const v = l[g];
        if (u -= v.getActualWidth(), u < 0)
          break;
        d++;
      }
      t && d++;
    }
    let h;
    if (d > 0) {
      const g = l[d - 1];
      h = c.indexOf(g) + 1;
    } else
      h = c.indexOf(l[0]), h === -1 && (h = 0);
    const p = [h], f = (g, v) => g - v;
    if (t) {
      let g = h + 1;
      const v = s.length - 1;
      for (; g <= v; )
        p.push(g), g++;
      p.sort(f);
    } else {
      let g = h;
      const v = s.length - 1;
      let y = s[g];
      for (; g <= v && this.isColumnHidden(n, y); )
        g++, p.push(g), y = s[g];
      g = h - 1;
      const m = 0;
      for (; g >= m; )
        p.push(g), g--;
      p.sort(f).reverse();
    }
    return p;
  }
  // isHidden takes into account visible=false and group=closed, ie it is not displayed
  isColumnHidden(e, t) {
    return e.indexOf(t) < 0;
  }
  ensureIntervalStarted() {
    this.movingIntervalId || (this.intervalCount = 0, this.failedMoveAttempts = 0, this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100), this.needToMoveLeft ? this.dragAndDropService.setGhostIcon(Te.ICON_LEFT, !0) : this.dragAndDropService.setGhostIcon(Te.ICON_RIGHT, !0));
  }
  ensureIntervalCleared() {
    this.movingIntervalId && (window.clearInterval(this.movingIntervalId), this.movingIntervalId = null, this.dragAndDropService.setGhostIcon(Te.ICON_MOVE));
  }
  moveInterval() {
    let e;
    this.intervalCount++, e = 10 + this.intervalCount * 5, e > 100 && (e = 100);
    let t = null;
    const i = this.gridBodyCon.getScrollFeature();
    if (this.needToMoveLeft ? t = i.scrollHorizontally(-e) : this.needToMoveRight && (t = i.scrollHorizontally(e)), t !== 0)
      this.onDragging(this.lastDraggingEvent), this.failedMoveAttempts = 0;
    else {
      this.failedMoveAttempts++;
      const n = this.lastDraggingEvent.dragItem.columns.filter((s) => !s.getColDef().lockPinned);
      if (n.length > 0 && (this.dragAndDropService.setGhostIcon(Te.ICON_PINNED), this.failedMoveAttempts > 7)) {
        const s = this.needToMoveLeft ? "left" : "right";
        this.setColumnsPinned(n, s, "uiColumnDragged"), this.dragAndDropService.nudge();
      }
    }
  }
}
Hp([
  S("columnModel")
], fu.prototype, "columnModel", void 0);
Hp([
  S("dragAndDropService")
], fu.prototype, "dragAndDropService", void 0);
Hp([
  S("gridOptionsService")
], fu.prototype, "gridOptionsService", void 0);
Hp([
  S("ctrlsService")
], fu.prototype, "ctrlsService", void 0);
Hp([
  B
], fu.prototype, "init", null);
var Wp = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class gu extends H {
  constructor(e, t) {
    super(), this.pinned = e, this.eContainer = t;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      switch (this.pinned) {
        case "left":
          this.eSecondaryContainers = [
            [e.gridBodyCtrl.getBodyViewportElement(), e.leftRowContainerCtrl.getContainerElement()],
            [e.bottomLeftRowContainerCtrl.getContainerElement()],
            [e.topLeftRowContainerCtrl.getContainerElement()]
          ];
          break;
        case "right":
          this.eSecondaryContainers = [
            [e.gridBodyCtrl.getBodyViewportElement(), e.rightRowContainerCtrl.getContainerElement()],
            [e.bottomRightRowContainerCtrl.getContainerElement()],
            [e.topRightRowContainerCtrl.getContainerElement()]
          ];
          break;
        default:
          this.eSecondaryContainers = [
            [e.gridBodyCtrl.getBodyViewportElement(), e.centerRowContainerCtrl.getViewportElement()],
            [e.bottomCenterRowContainerCtrl.getViewportElement()],
            [e.topCenterRowContainerCtrl.getViewportElement()]
          ];
          break;
      }
    });
  }
  isInterestedIn(e) {
    return e === Dt.HeaderCell || e === Dt.ToolPanel && this.gridOptionsService.is("allowDragFromColumnsToolPanel");
  }
  getSecondaryContainers() {
    return this.eSecondaryContainers;
  }
  getContainer() {
    return this.eContainer;
  }
  init() {
    this.moveColumnFeature = this.createManagedBean(new fu(this.pinned, this.eContainer)), this.bodyDropPivotTarget = this.createManagedBean(new pb(this.pinned)), this.dragAndDropService.addDropTarget(this);
  }
  getIconName() {
    return this.currentDropListener.getIconName();
  }
  // we want to use the bodyPivotTarget if the user is dragging columns in from the toolPanel
  // and we are in pivot mode, as it has to logic to set pivot/value/group on the columns when
  // dropped into the grid's body.
  isDropColumnInPivotMode(e) {
    return this.columnModel.isPivotMode() && e.dragSource.type === Dt.ToolPanel;
  }
  onDragEnter(e) {
    this.currentDropListener = this.isDropColumnInPivotMode(e) ? this.bodyDropPivotTarget : this.moveColumnFeature, this.currentDropListener.onDragEnter(e);
  }
  onDragLeave(e) {
    this.currentDropListener.onDragLeave(e);
  }
  onDragging(e) {
    this.currentDropListener.onDragging(e);
  }
  onDragStop(e) {
    this.currentDropListener.onDragStop(e);
  }
}
Wp([
  S("dragAndDropService")
], gu.prototype, "dragAndDropService", void 0);
Wp([
  S("columnModel")
], gu.prototype, "columnModel", void 0);
Wp([
  S("ctrlsService")
], gu.prototype, "ctrlsService", void 0);
Wp([
  B
], gu.prototype, "postConstruct", null);
Wp([
  B
], gu.prototype, "init", null);
class jp {
  static getHeaderClassesFromColDef(e, t, i, r) {
    return Se(e) ? [] : this.getColumnClassesFromCollDef(e.headerClass, e, t, i, r);
  }
  static getToolPanelClassesFromColDef(e, t, i, r) {
    return Se(e) ? [] : this.getColumnClassesFromCollDef(e.toolPanelClass, e, t, i, r);
  }
  static getClassParams(e, t, i, r) {
    return {
      // bad naming, as colDef here can be a group or a column,
      // however most people won't appreciate the difference,
      // so keeping it as colDef to avoid confusion.
      colDef: e,
      column: i,
      columnGroup: r,
      api: t.api,
      columnApi: t.columnApi,
      context: t.context
    };
  }
  static getColumnClassesFromCollDef(e, t, i, r, n) {
    if (Se(e))
      return [];
    let s;
    if (typeof e == "function") {
      const a = this.getClassParams(t, i, r, n);
      s = e(a);
    } else
      s = e;
    return typeof s == "string" ? [s] : Array.isArray(s) ? [...s] : [];
  }
}
var Jv = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Va extends sb {
  constructor(e) {
    super(Va.TEMPLATE, e), this.headerCompVersion = 0, this.column = e.getColumnGroupChild(), this.pinned = e.getPinned();
  }
  postConstruct() {
    const e = this.getGui(), t = (n, s, a) => {
      const l = a || e;
      s != null && s != "" ? l.setAttribute(n, s) : l.removeAttribute(n);
    }, i = {
      setWidth: (n) => e.style.width = n,
      addOrRemoveCssClass: (n, s) => this.addOrRemoveCssClass(n, s),
      setColId: (n) => t("col-id", n),
      setTitle: (n) => t("title", n),
      setAriaDescription: (n) => cT(e, n),
      setAriaSort: (n) => n ? yT(e, n) : CT(e),
      setUserCompDetails: (n) => this.setUserCompDetails(n),
      getUserCompInstance: () => this.headerComp
    };
    this.ctrl.setComp(i, this.getGui(), this.eResize, this.eHeaderCompWrapper);
    const r = this.ctrl.getSelectAllGui();
    this.eResize.insertAdjacentElement("afterend", r);
  }
  destroyHeaderComp() {
    this.headerComp && (this.eHeaderCompWrapper.removeChild(this.headerCompGui), this.headerComp = this.destroyBean(this.headerComp), this.headerCompGui = void 0);
  }
  setUserCompDetails(e) {
    this.headerCompVersion++;
    const t = this.headerCompVersion;
    e.newAgStackInstance().then((i) => this.afterCompCreated(t, i));
  }
  afterCompCreated(e, t) {
    if (e != this.headerCompVersion || !this.isAlive()) {
      this.destroyBean(t);
      return;
    }
    this.destroyHeaderComp(), this.headerComp = t, this.headerCompGui = t.getGui(), this.eHeaderCompWrapper.appendChild(this.headerCompGui), this.ctrl.setDragSource(this.getGui());
  }
}
Va.TEMPLATE = `<div class="ag-header-cell" role="columnheader" tabindex="-1">
            <div ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
            <div ref="eHeaderCompWrapper" class="ag-header-cell-comp-wrapper" role="presentation"></div>
        </div>`;
Jv([
  L("eResize")
], Va.prototype, "eResize", void 0);
Jv([
  L("eHeaderCompWrapper")
], Va.prototype, "eHeaderCompWrapper", void 0);
Jv([
  B
], Va.prototype, "postConstruct", null);
Jv([
  dt
], Va.prototype, "destroyHeaderComp", null);
var fb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class ac extends sb {
  constructor(e) {
    super(ac.TEMPLATE, e);
  }
  postConstruct() {
    const e = this.getGui(), t = (r, n) => n != null ? e.setAttribute(r, n) : e.removeAttribute(r), i = {
      addOrRemoveCssClass: (r, n) => this.addOrRemoveCssClass(r, n),
      setResizableDisplayed: (r) => Ke(this.eResize, r),
      setWidth: (r) => e.style.width = r,
      setColId: (r) => e.setAttribute("col-id", r),
      setAriaExpanded: (r) => t("aria-expanded", r),
      setTitle: (r) => t("title", r),
      setUserCompDetails: (r) => this.setUserCompDetails(r)
    };
    this.ctrl.setComp(i, e, this.eResize);
  }
  setUserCompDetails(e) {
    e.newAgStackInstance().then((t) => this.afterHeaderCompCreated(t));
  }
  afterHeaderCompCreated(e) {
    const t = () => this.destroyBean(e);
    if (!this.isAlive()) {
      t();
      return;
    }
    const i = this.getGui(), r = e.getGui();
    i.appendChild(r), this.addDestroyFunc(t), this.ctrl.setDragSource(i);
  }
}
ac.TEMPLATE = `<div class="ag-header-group-cell" role="columnheader" tabindex="-1">
            <div ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
        </div>`;
fb([
  S("userComponentFactory")
], ac.prototype, "userComponentFactory", void 0);
fb([
  L("eResize")
], ac.prototype, "eResize", void 0);
fb([
  B
], ac.prototype, "postConstruct", null);
var fx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, bi;
(function(o) {
  o.COLUMN_GROUP = "group", o.COLUMN = "column", o.FLOATING_FILTER = "filter";
})(bi || (bi = {}));
class gb extends X {
  constructor(e) {
    super(), this.headerComps = {};
    const t = e.getType() == bi.COLUMN_GROUP ? "ag-header-row-column-group" : e.getType() == bi.FLOATING_FILTER ? "ag-header-row-column-filter" : "ag-header-row-column";
    this.setTemplate(
      /* html */
      `<div class="ag-header-row ${t}" role="row"></div>`
    ), this.ctrl = e;
  }
  //noinspection JSUnusedLocalSymbols
  init() {
    const e = {
      setTransform: (t) => this.getGui().style.transform = t,
      setHeight: (t) => this.getGui().style.height = t,
      setTop: (t) => this.getGui().style.top = t,
      setHeaderCtrls: (t) => this.setHeaderCtrls(t),
      setWidth: (t) => this.getGui().style.width = t,
      setAriaRowIndex: (t) => DS(this.getGui(), t)
    };
    this.ctrl.setComp(e);
  }
  destroyHeaderCtrls() {
    this.setHeaderCtrls([]);
  }
  setHeaderCtrls(e) {
    if (!this.isAlive())
      return;
    const t = this.headerComps;
    this.headerComps = {}, e.forEach((n) => {
      const s = n.getInstanceId();
      let a = t[s];
      delete t[s], a == null && (a = this.createHeaderComp(n), this.getGui().appendChild(a.getGui())), this.headerComps[s] = a;
    }), Ct(t, (n, s) => {
      this.getGui().removeChild(s.getGui()), this.destroyBean(s);
    });
    const i = this.gridOptionsService.is("ensureDomOrder"), r = this.gridOptionsService.isDomLayout("print");
    if (i || r) {
      const n = To(this.headerComps);
      n.sort((a, l) => {
        const c = a.getCtrl().getColumnGroupChild().getLeft(), d = l.getCtrl().getColumnGroupChild().getLeft();
        return c - d;
      });
      const s = n.map((a) => a.getGui());
      kS(this.getGui(), s);
    }
  }
  createHeaderComp(e) {
    let t;
    switch (this.ctrl.getType()) {
      case bi.COLUMN_GROUP:
        t = new ac(e);
        break;
      case bi.FLOATING_FILTER:
        t = new _s(e);
        break;
      default:
        t = new Va(e);
        break;
    }
    return this.createBean(t), t.setParentComponent(this), t;
  }
}
fx([
  B
], gb.prototype, "init", null);
fx([
  dt
], gb.prototype, "destroyHeaderCtrls", null);
var vb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let gN = 0;
class ko extends H {
  constructor(e, t) {
    super(), this.lastFocusEvent = null, this.columnGroupChild = e, this.parentRowCtrl = t, this.instanceId = e.getUniqueId() + "-" + gN++;
  }
  shouldStopEventPropagation(e) {
    const { headerRowIndex: t, column: i } = this.focusService.getFocusedHeader();
    return LT(this.gridOptionsService, e, t, i);
  }
  getWrapperHasFocus() {
    return this.gridOptionsService.getDocument().activeElement === this.eGui;
  }
  setGui(e) {
    this.eGui = e, this.addDomData();
  }
  handleKeyDown(e) {
    const t = this.getWrapperHasFocus();
    switch (e.key) {
      case V.PAGE_DOWN:
      case V.PAGE_UP:
      case V.PAGE_HOME:
      case V.PAGE_END:
        t && e.preventDefault();
    }
  }
  addDomData() {
    const e = ko.DOM_DATA_KEY_HEADER_CTRL;
    this.gridOptionsService.setDomData(this.eGui, e, this), this.addDestroyFunc(() => this.gridOptionsService.setDomData(this.eGui, e, null));
  }
  getGui() {
    return this.eGui;
  }
  focus(e) {
    return this.eGui ? (this.lastFocusEvent = e || null, this.eGui.focus(), !0) : !1;
  }
  getRowIndex() {
    return this.parentRowCtrl.getRowIndex();
  }
  getParentRowCtrl() {
    return this.parentRowCtrl;
  }
  getPinned() {
    return this.parentRowCtrl.getPinned();
  }
  getInstanceId() {
    return this.instanceId;
  }
  getColumnGroupChild() {
    return this.columnGroupChild;
  }
}
ko.DOM_DATA_KEY_HEADER_CTRL = "headerCtrl";
vb([
  S("focusService")
], ko.prototype, "focusService", void 0);
vb([
  S("beans")
], ko.prototype, "beans", void 0);
vb([
  S("userComponentFactory")
], ko.prototype, "userComponentFactory", void 0);
var vN = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class em extends H {
  constructor(e, t, i, r) {
    super(), this.columnOrGroup = e, this.eCell = t, this.ariaEl = this.eCell.querySelector("[role=columnheader]") || this.eCell, this.colsSpanning = r, this.beans = i;
  }
  setColsSpanning(e) {
    this.colsSpanning = e, this.onLeftChanged();
  }
  getColumnOrGroup() {
    return this.beans.gridOptionsService.is("enableRtl") && this.colsSpanning ? at(this.colsSpanning) : this.columnOrGroup;
  }
  postConstruct() {
    this.addManagedListener(this.columnOrGroup, me.EVENT_LEFT_CHANGED, this.onLeftChanged.bind(this)), this.setLeftFirstTime(), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onLeftChanged.bind(this)), this.addManagedPropertyListener("domLayout", this.onLeftChanged.bind(this));
  }
  setLeftFirstTime() {
    const e = this.beans.gridOptionsService.is("suppressColumnMoveAnimation"), t = z(this.columnOrGroup.getOldLeft());
    this.beans.columnAnimationService.isActive() && t && !e ? this.animateInLeft() : this.onLeftChanged();
  }
  animateInLeft() {
    const e = this.getColumnOrGroup(), t = e.getLeft(), i = e.getOldLeft(), r = this.modifyLeftForPrintLayout(e, i), n = this.modifyLeftForPrintLayout(e, t);
    this.setLeft(r), this.actualLeft = n, this.beans.columnAnimationService.executeNextVMTurn(() => {
      this.actualLeft === n && this.setLeft(n);
    });
  }
  onLeftChanged() {
    const e = this.getColumnOrGroup(), t = e.getLeft();
    this.actualLeft = this.modifyLeftForPrintLayout(e, t), this.setLeft(this.actualLeft);
  }
  modifyLeftForPrintLayout(e, t) {
    if (!this.beans.gridOptionsService.isDomLayout("print") || e.getPinned() === "left")
      return t;
    const r = this.beans.columnModel.getDisplayedColumnsLeftWidth();
    if (e.getPinned() === "right") {
      const n = this.beans.columnModel.getBodyContainerWidth();
      return r + n + t;
    }
    return r + t;
  }
  setLeft(e) {
    z(e) && (this.eCell.style.left = `${e}px`);
    let t;
    if (this.columnOrGroup instanceof me)
      t = this.columnOrGroup;
    else {
      const n = this.columnOrGroup.getLeafColumns();
      if (!n.length)
        return;
      n.length > 1 && mT(this.ariaEl, n.length), t = n[0];
    }
    const i = this.beans.columnModel.getAriaColumnIndex(t);
    OS(this.ariaEl, i);
  }
}
vN([
  B
], em.prototype, "postConstruct", null);
var gx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Up extends H {
  constructor(e, t) {
    super(), this.columns = e, this.element = t;
  }
  postConstruct() {
    this.gridOptionsService.is("columnHoverHighlight") && this.addMouseHoverListeners();
  }
  addMouseHoverListeners() {
    this.addManagedListener(this.element, "mouseout", this.onMouseOut.bind(this)), this.addManagedListener(this.element, "mouseover", this.onMouseOver.bind(this));
  }
  onMouseOut() {
    this.columnHoverService.clearMouseOver();
  }
  onMouseOver() {
    this.columnHoverService.setMouseOver(this.columns);
  }
}
gx([
  S("columnHoverService")
], Up.prototype, "columnHoverService", void 0);
gx([
  B
], Up.prototype, "postConstruct", null);
var mb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class tm extends ko {
  constructor(e, t) {
    super(e, t), this.iconCreated = !1, this.column = e;
  }
  setComp(e, t, i, r) {
    super.setGui(t), this.comp = e, this.eButtonShowMainFilter = i, this.eFloatingFilterBody = r, this.setupActive(), this.setupWidth(), this.setupLeft(), this.setupHover(), this.setupFocus(), this.setupAria(), this.setupFilterButton(), this.setupUserComp(), this.setupSyncWithFilter(), this.setupUi(), this.addManagedListener(this.eButtonShowMainFilter, "click", this.showParentFilter.bind(this)), this.setupFilterChangedListener(), this.addManagedListener(this.column, me.EVENT_COL_DEF_CHANGED, this.onColDefChanged.bind(this));
  }
  setupActive() {
    const e = this.column.getColDef(), t = !!e.filter, i = !!e.floatingFilter;
    this.active = t && i;
  }
  setupUi() {
    if (this.comp.setButtonWrapperDisplayed(!this.suppressFilterButton && this.active), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton), !this.active || this.iconCreated)
      return;
    const e = Vt("filter", this.gridOptionsService, this.column);
    e && (this.iconCreated = !0, this.eButtonShowMainFilter.appendChild(e));
  }
  setupFocus() {
    this.createManagedBean(new Ji(this.eGui, {
      shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
      onTabKeyDown: this.onTabKeyDown.bind(this),
      handleKeyDown: this.handleKeyDown.bind(this),
      onFocusIn: this.onFocusIn.bind(this)
    }));
  }
  setupAria() {
    const e = this.localeService.getLocaleTextFunc();
    Ia(this.eButtonShowMainFilter, e("ariaFilterMenuOpen", "Open Filter Menu"));
  }
  onTabKeyDown(e) {
    if (this.gridOptionsService.getDocument().activeElement === this.eGui)
      return;
    const n = this.focusService.findNextFocusableElement(this.eGui, null, e.shiftKey);
    if (n) {
      this.beans.headerNavigationService.scrollToColumn(this.column), e.preventDefault(), n.focus();
      return;
    }
    const s = this.findNextColumnWithFloatingFilter(e.shiftKey);
    s && this.focusService.focusHeaderPosition({
      headerPosition: {
        headerRowIndex: this.getParentRowCtrl().getRowIndex(),
        column: s
      },
      event: e
    }) && e.preventDefault();
  }
  findNextColumnWithFloatingFilter(e) {
    const t = this.beans.columnModel;
    let i = this.column;
    do
      if (i = e ? t.getDisplayedColBefore(i) : t.getDisplayedColAfter(i), !i)
        break;
    while (!i.getColDef().filter || !i.getColDef().floatingFilter);
    return i;
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    switch (e.key) {
      case V.UP:
      case V.DOWN:
        t || e.preventDefault();
      case V.LEFT:
      case V.RIGHT:
        if (t)
          return;
        e.stopPropagation();
      case V.ENTER:
        t && this.focusService.focusInto(this.eGui) && e.preventDefault();
        break;
      case V.ESCAPE:
        t || this.eGui.focus();
    }
  }
  onFocusIn(e) {
    if (this.eGui.contains(e.relatedTarget))
      return;
    const i = !!e.relatedTarget && !e.relatedTarget.classList.contains("ag-floating-filter"), r = !!e.relatedTarget && Ol(e.relatedTarget, "ag-floating-filter");
    if (i && r && e.target === this.eGui) {
      const s = this.lastFocusEvent, a = !!(s && s.key === V.TAB);
      if (s && a) {
        const l = s.shiftKey;
        this.focusService.focusInto(this.eGui, l);
      }
    }
    const n = this.getRowIndex();
    this.beans.focusService.setFocusedHeader(n, this.column);
  }
  setupHover() {
    this.createManagedBean(new Up([this.column], this.eGui));
    const e = () => {
      if (!this.gridOptionsService.is("columnHoverHighlight"))
        return;
      const t = this.columnHoverService.isHovered(this.column);
      this.comp.addOrRemoveCssClass("ag-column-hover", t);
    };
    this.addManagedListener(this.eventService, w.EVENT_COLUMN_HOVER_CHANGED, e), e();
  }
  setupLeft() {
    const e = new em(this.column, this.eGui, this.beans);
    this.createManagedBean(e);
  }
  setupFilterButton() {
    const e = this.column.getColDef();
    this.suppressFilterButton = e.floatingFilterComponentParams ? !!e.floatingFilterComponentParams.suppressFilterButton : !1;
  }
  setupUserComp() {
    if (!this.active)
      return;
    const e = this.filterManager.getFloatingFilterCompDetails(this.column, () => this.showParentFilter());
    e && this.setCompDetails(e);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setCompDetails(e);
  }
  showParentFilter() {
    const e = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
    this.menuFactory.showMenuAfterButtonClick(this.column, e, "floatingFilter", "filterMenuTab", ["filterMenuTab"]);
  }
  setupSyncWithFilter() {
    if (!this.active)
      return;
    const e = (t) => {
      const i = this.comp.getFloatingFilterComp();
      i && i.then((r) => {
        if (r) {
          const n = this.filterManager.getCurrentFloatingFilterParentModel(this.column);
          r.onParentModelChanged(n, t);
        }
      });
    };
    this.destroySyncListener = this.addManagedListener(this.column, me.EVENT_FILTER_CHANGED, e), this.filterManager.isFilterActive(this.column) && e(null);
  }
  setupWidth() {
    const e = () => {
      const t = `${this.column.getActualWidth()}px`;
      this.comp.setWidth(t);
    };
    this.addManagedListener(this.column, me.EVENT_WIDTH_CHANGED, e), e();
  }
  setupFilterChangedListener() {
    this.active && (this.destroyFilterChangedListener = this.addManagedListener(this.column, me.EVENT_FILTER_CHANGED, this.updateFilterButton.bind(this)));
  }
  updateFilterButton() {
    !this.suppressFilterButton && this.comp && this.comp.setButtonWrapperDisplayed(this.filterManager.isFilterAllowed(this.column));
  }
  onColDefChanged() {
    var e, t;
    const i = this.active;
    this.setupActive();
    const r = !i && this.active;
    i && !this.active && ((e = this.destroySyncListener) === null || e === void 0 || e.call(this), (t = this.destroyFilterChangedListener) === null || t === void 0 || t.call(this));
    const n = this.active ? this.filterManager.getFloatingFilterCompDetails(this.column, () => this.showParentFilter()) : null, s = this.comp.getFloatingFilterComp();
    !s || !n ? this.updateCompDetails(n, r) : s.then((a) => {
      var l;
      (!a || ((l = this.userCompDetails) === null || l === void 0 ? void 0 : l.componentClass) !== n.componentClass) && this.updateCompDetails(n, r);
    });
  }
  updateCompDetails(e, t) {
    this.setCompDetails(e), this.setupFilterButton(), this.setupUi(), t && (this.setupSyncWithFilter(), this.setupFilterChangedListener());
  }
}
mb([
  S("filterManager")
], tm.prototype, "filterManager", void 0);
mb([
  S("columnHoverService")
], tm.prototype, "columnHoverService", void 0);
mb([
  S("menuFactory")
], tm.prototype, "menuFactory", void 0);
var yb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class im extends H {
  constructor(e, t, i, r, n) {
    super(), this.pinned = e, this.column = t, this.eResize = i, this.comp = r, this.ctrl = n;
  }
  postConstruct() {
    const e = this.column.getColDef(), t = [];
    let i, r;
    const n = () => {
      if (Ke(this.eResize, i), !i)
        return;
      const l = this.horizontalResizeService.addResizeBar({
        eResizeBar: this.eResize,
        onResizeStart: this.onResizeStart.bind(this),
        onResizing: this.onResizing.bind(this, !1),
        onResizeEnd: this.onResizing.bind(this, !0)
      });
      if (t.push(l), r) {
        const c = this.gridOptionsService.is("skipHeaderOnAutoSize"), d = () => {
          this.columnModel.autoSizeColumn(this.column, c, "uiColumnResized");
        };
        this.eResize.addEventListener("dblclick", d);
        const u = new mt(this.eResize);
        u.addEventListener(mt.EVENT_DOUBLE_TAP, d), this.addDestroyFunc(() => {
          this.eResize.removeEventListener("dblclick", d), u.removeEventListener(mt.EVENT_DOUBLE_TAP, d), u.destroy();
        });
      }
    }, s = () => {
      t.forEach((l) => l()), t.length = 0;
    }, a = () => {
      const l = this.column.isResizable(), c = !this.gridOptionsService.is("suppressAutoSize") && !e.suppressAutoSize;
      (l !== i || c !== r) && (i = l, r = c, s(), n());
    };
    a(), this.addDestroyFunc(s), this.ctrl.addRefreshFunction(a);
  }
  onResizing(e, t) {
    const i = this.normaliseResizeAmount(t), r = [{ key: this.column, newWidth: this.resizeStartWidth + i }];
    this.columnModel.setColumnWidths(r, this.resizeWithShiftKey, e, "uiColumnResized"), e && this.comp.addOrRemoveCssClass("ag-column-resizing", !1);
  }
  onResizeStart(e) {
    this.resizeStartWidth = this.column.getActualWidth(), this.resizeWithShiftKey = e, this.comp.addOrRemoveCssClass("ag-column-resizing", !0);
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderGroupCell - should refactor out?
  normaliseResizeAmount(e) {
    let t = e;
    const i = this.pinned !== "left", r = this.pinned === "right";
    return this.gridOptionsService.is("enableRtl") ? i && (t *= -1) : r && (t *= -1), t;
  }
}
yb([
  S("horizontalResizeService")
], im.prototype, "horizontalResizeService", void 0);
yb([
  S("columnModel")
], im.prototype, "columnModel", void 0);
yb([
  B
], im.prototype, "postConstruct", null);
var rm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class $p extends H {
  constructor(e) {
    super(), this.cbSelectAllVisible = !1, this.processingEventFromCheckbox = !1, this.column = e;
    const t = e.getColDef();
    this.filteredOnly = !!(t != null && t.headerCheckboxSelectionFilteredOnly), this.currentPageOnly = !!(t != null && t.headerCheckboxSelectionCurrentPageOnly);
  }
  onSpaceKeyDown(e) {
    const t = this.cbSelectAll, i = this.gridOptionsService.getDocument();
    t.isDisplayed() && !t.getGui().contains(i.activeElement) && (e.preventDefault(), t.setValue(!t.getValue()));
  }
  getCheckboxGui() {
    return this.cbSelectAll.getGui();
  }
  setComp(e) {
    this.headerCellCtrl = e, this.cbSelectAll = this.createManagedBean(new rr()), this.cbSelectAll.addCssClass("ag-header-select-all"), ci(this.cbSelectAll.getGui(), "presentation"), this.showOrHideSelectAll(), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, this.showOrHideSelectAll.bind(this)), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_CHANGED, this.showOrHideSelectAll.bind(this)), this.addManagedListener(this.eventService, w.EVENT_SELECTION_CHANGED, this.onSelectionChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_PAGINATION_CHANGED, this.onSelectionChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_MODEL_UPDATED, this.onModelChanged.bind(this)), this.addManagedListener(this.cbSelectAll, rr.EVENT_CHANGED, this.onCbSelectAll.bind(this)), Nv(this.cbSelectAll.getGui(), !0), this.cbSelectAll.getInputElement().setAttribute("tabindex", "-1"), this.refreshSelectAllLabel();
  }
  showOrHideSelectAll() {
    this.cbSelectAllVisible = this.isCheckboxSelection(), this.cbSelectAll.setDisplayed(this.cbSelectAllVisible, { skipAriaHidden: !0 }), this.cbSelectAllVisible && (this.checkRightRowModelType("selectAllCheckbox"), this.updateStateOfCheckbox()), this.refreshSelectAllLabel();
  }
  onModelChanged() {
    this.cbSelectAllVisible && this.updateStateOfCheckbox();
  }
  onSelectionChanged() {
    this.cbSelectAllVisible && this.updateStateOfCheckbox();
  }
  updateStateOfCheckbox() {
    if (this.processingEventFromCheckbox)
      return;
    this.processingEventFromCheckbox = !0;
    const e = this.selectionService.getSelectAllState(this.filteredOnly, this.currentPageOnly);
    this.cbSelectAll.setValue(e), this.refreshSelectAllLabel(), this.processingEventFromCheckbox = !1;
  }
  refreshSelectAllLabel() {
    const e = this.localeService.getLocaleTextFunc(), i = this.cbSelectAll.getValue() ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked"), r = e("ariaRowSelectAll", "Press Space to toggle all rows selection");
    this.cbSelectAllVisible ? this.headerCellCtrl.setAriaDescriptionProperty("selectAll", `${r} (${i})`) : this.headerCellCtrl.setAriaDescriptionProperty("selectAll", null), this.cbSelectAll.setInputAriaLabel(`${r} (${i})`), this.headerCellCtrl.refreshAriaDescription();
  }
  checkRightRowModelType(e) {
    const t = this.rowModel.getType();
    return t === "clientSide" || t === "serverSide" ? !0 : (console.warn(`AG Grid: ${e} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${t}.`), !1);
  }
  onCbSelectAll() {
    if (this.processingEventFromCheckbox || !this.cbSelectAllVisible)
      return;
    const e = this.cbSelectAll.getValue();
    let t = "uiSelectAll";
    this.currentPageOnly ? t = "uiSelectAllCurrentPage" : this.filteredOnly && (t = "uiSelectAllFiltered");
    const i = {
      source: t,
      justFiltered: this.filteredOnly,
      justCurrentPage: this.currentPageOnly
    };
    e ? this.selectionService.selectAllRowNodes(i) : this.selectionService.deselectAllRowNodes(i);
  }
  isCheckboxSelection() {
    let e = this.column.getColDef().headerCheckboxSelection;
    if (typeof e == "function") {
      const t = e, i = {
        column: this.column,
        colDef: this.column.getColDef(),
        columnApi: this.columnApi,
        api: this.gridApi,
        context: this.gridOptionsService.context
      };
      e = t(i);
    }
    return e ? this.checkRightRowModelType("headerCheckboxSelection") : !1;
  }
}
rm([
  S("gridApi")
], $p.prototype, "gridApi", void 0);
rm([
  S("columnApi")
], $p.prototype, "columnApi", void 0);
rm([
  S("rowModel")
], $p.prototype, "rowModel", void 0);
rm([
  S("selectionService")
], $p.prototype, "selectionService", void 0);
var vx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, Rd;
(function(o) {
  o.TAB_GUARD = "ag-tab-guard", o.TAB_GUARD_TOP = "ag-tab-guard-top", o.TAB_GUARD_BOTTOM = "ag-tab-guard-bottom";
})(Rd || (Rd = {}));
class Cb extends H {
  constructor(e) {
    super(), this.skipTabGuardFocus = !1;
    const { comp: t, eTopGuard: i, eBottomGuard: r, focusInnerElement: n, onFocusIn: s, onFocusOut: a, shouldStopEventPropagation: l, onTabKeyDown: c, handleKeyDown: d, eFocusableElement: u } = e;
    this.comp = t, this.eTopGuard = i, this.eBottomGuard = r, this.providedFocusInnerElement = n, this.eFocusableElement = u, this.providedFocusIn = s, this.providedFocusOut = a, this.providedShouldStopEventPropagation = l, this.providedOnTabKeyDown = c, this.providedHandleKeyDown = d;
  }
  postConstruct() {
    this.createManagedBean(new Ji(this.eFocusableElement, {
      shouldStopEventPropagation: () => this.shouldStopEventPropagation(),
      onTabKeyDown: (e) => this.onTabKeyDown(e),
      handleKeyDown: (e) => this.handleKeyDown(e),
      onFocusIn: (e) => this.onFocusIn(e),
      onFocusOut: (e) => this.onFocusOut(e)
    })), this.activateTabGuards(), [this.eTopGuard, this.eBottomGuard].forEach((e) => this.addManagedListener(e, "focus", this.onFocus.bind(this)));
  }
  handleKeyDown(e) {
    this.providedHandleKeyDown && this.providedHandleKeyDown(e);
  }
  tabGuardsAreActive() {
    return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
  }
  shouldStopEventPropagation() {
    return this.providedShouldStopEventPropagation ? this.providedShouldStopEventPropagation() : !1;
  }
  activateTabGuards() {
    const e = this.gridOptionsService.getNum("tabIndex") || 0;
    this.comp.setTabIndex(e.toString());
  }
  deactivateTabGuards() {
    this.comp.setTabIndex();
  }
  onFocus(e) {
    if (this.skipTabGuardFocus) {
      this.skipTabGuardFocus = !1;
      return;
    }
    const t = e.target === this.eBottomGuard;
    this.providedFocusInnerElement ? this.providedFocusInnerElement(t) : this.focusInnerElement(t);
  }
  onFocusIn(e) {
    this.providedFocusIn && this.providedFocusIn(e) || this.deactivateTabGuards();
  }
  onFocusOut(e) {
    this.providedFocusOut && this.providedFocusOut(e) || this.eFocusableElement.contains(e.relatedTarget) || this.activateTabGuards();
  }
  onTabKeyDown(e) {
    if (this.providedOnTabKeyDown) {
      this.providedOnTabKeyDown(e);
      return;
    }
    if (e.defaultPrevented)
      return;
    const t = this.tabGuardsAreActive();
    t && this.deactivateTabGuards();
    const i = this.getNextFocusableElement(e.shiftKey);
    t && setTimeout(() => this.activateTabGuards(), 0), i && (i.focus(), e.preventDefault());
  }
  focusInnerElement(e = !1) {
    const t = this.focusService.findFocusableElements(this.eFocusableElement);
    this.tabGuardsAreActive() && (t.splice(0, 1), t.splice(t.length - 1, 1)), t.length && t[e ? t.length - 1 : 0].focus({ preventScroll: !0 });
  }
  getNextFocusableElement(e) {
    return this.focusService.findNextFocusableElement(this.eFocusableElement, !1, e);
  }
  forceFocusOutOfContainer(e = !1) {
    const t = e ? this.eTopGuard : this.eBottomGuard;
    this.activateTabGuards(), this.skipTabGuardFocus = !0, t.focus();
  }
}
vx([
  S("focusService")
], Cb.prototype, "focusService", void 0);
vx([
  B
], Cb.prototype, "postConstruct", null);
var Yn = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, _i;
let Ht = _i = class extends H {
  /**
   * Adds a gridCore to the list of the gridCores monitoring Keyboard Mode
   * in a specific HTMLDocument.
   *
   * @param doc {Document} - The Document containing the gridCore.
   * @param gridCore {GridComp} - The GridCore to be monitored.
   */
  static addKeyboardModeEvents(e, t) {
    const i = _i.instancesMonitored.get(e);
    i && i.length > 0 ? i.indexOf(t) === -1 && i.push(t) : (_i.instancesMonitored.set(e, [t]), e.addEventListener("keydown", _i.toggleKeyboardMode), e.addEventListener("mousedown", _i.toggleKeyboardMode));
  }
  /**
   * Removes a gridCore from the list of the gridCores monitoring Keyboard Mode
   * in a specific HTMLDocument.
   *
   * @param doc {Document} - The Document containing the gridCore.
   * @param gridCore {GridComp} - The GridCore to be removed.
   */
  static removeKeyboardModeEvents(e, t) {
    const i = _i.instancesMonitored.get(e);
    let r = [];
    i && i.length && (r = [...i].filter((n) => n !== t), _i.instancesMonitored.set(e, r)), r.length === 0 && (e.removeEventListener("keydown", _i.toggleKeyboardMode), e.removeEventListener("mousedown", _i.toggleKeyboardMode));
  }
  /**
   * This method will be called by `keydown` and `mousedown` events on all Documents monitoring
   * KeyboardMode. It will then fire a KEYBOARD_FOCUS, MOUSE_FOCUS on each gridCore present in
   * the Document allowing each gridCore to maintain a state for KeyboardMode.
   *
   * @param event {KeyboardEvent | MouseEvent | TouchEvent} - The event triggered.
   */
  static toggleKeyboardMode(e) {
    const t = _i.keyboardModeActive, i = e.type === "keydown";
    if (i && (e.ctrlKey || e.metaKey || e.altKey) || t && i || !t && !i)
      return;
    _i.keyboardModeActive = i;
    const r = e.target.ownerDocument;
    if (!r)
      return;
    const n = _i.instancesMonitored.get(r);
    n && n.forEach((s) => {
      s.dispatchEvent({ type: i ? w.EVENT_KEYBOARD_FOCUS : w.EVENT_MOUSE_FOCUS });
    });
  }
  init() {
    const e = this.clearFocusedCell.bind(this);
    this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_MODE_CHANGED, e), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverythingChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_GROUP_OPENED, e), this.addManagedListener(this.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, e), this.ctrlsService.whenReady((t) => {
      this.gridCtrl = t.gridCtrl;
      const i = this.gridOptionsService.getDocument();
      _i.addKeyboardModeEvents(i, this.gridCtrl), this.addDestroyFunc(() => this.unregisterGridCompController(this.gridCtrl));
    });
  }
  unregisterGridCompController(e) {
    const t = this.gridOptionsService.getDocument();
    _i.removeKeyboardModeEvents(t, e);
  }
  onColumnEverythingChanged() {
    if (!this.focusedCellPosition)
      return;
    const e = this.focusedCellPosition.column, t = this.columnModel.getGridColumn(e.getId());
    e !== t && this.clearFocusedCell();
  }
  isKeyboardMode() {
    return _i.keyboardModeActive;
  }
  // we check if the browser is focusing something, and if it is, and
  // it's the cell we think is focused, then return the cell. so this
  // methods returns the cell if a) we think it has focus and b) the
  // browser thinks it has focus. this then returns nothing if we
  // first focus a cell, then second click outside the grid, as then the
  // grid cell will still be focused as far as the grid is concerned,
  // however the browser focus will have moved somewhere else.
  getFocusCellToUseAfterRefresh() {
    const e = this.gridOptionsService.getDocument();
    return this.gridOptionsService.is("suppressFocusAfterRefresh") || !this.focusedCellPosition || this.isDomDataMissingInHierarchy(e.activeElement, Gn.DOM_DATA_KEY_ROW_CTRL) ? null : this.focusedCellPosition;
  }
  getFocusHeaderToUseAfterRefresh() {
    const e = this.gridOptionsService.getDocument();
    return this.gridOptionsService.is("suppressFocusAfterRefresh") || !this.focusedHeaderPosition || this.isDomDataMissingInHierarchy(e.activeElement, ko.DOM_DATA_KEY_HEADER_CTRL) ? null : this.focusedHeaderPosition;
  }
  isDomDataMissingInHierarchy(e, t) {
    let i = e;
    for (; i; ) {
      if (this.gridOptionsService.getDomData(i, t))
        return !1;
      i = i.parentNode;
    }
    return !0;
  }
  getFocusedCell() {
    return this.focusedCellPosition;
  }
  shouldRestoreFocus(e) {
    return this.isCellRestoreFocused(e) ? (setTimeout(() => {
      this.restoredFocusedCellPosition = null;
    }, 0), !0) : !1;
  }
  isCellRestoreFocused(e) {
    return this.restoredFocusedCellPosition == null ? !1 : this.cellPositionUtils.equals(e, this.restoredFocusedCellPosition);
  }
  setRestoreFocusedCell(e) {
    this.getFrameworkOverrides().renderingEngine === "react" && (this.restoredFocusedCellPosition = e);
  }
  getFocusEventParams() {
    const { rowIndex: e, rowPinned: t, column: i } = this.focusedCellPosition, r = {
      rowIndex: e,
      rowPinned: t,
      column: i,
      isFullWidthCell: !1
    }, n = this.rowRenderer.getRowByPosition({ rowIndex: e, rowPinned: t });
    return n && (r.isFullWidthCell = n.isFullWidth()), r;
  }
  clearFocusedCell() {
    if (this.restoredFocusedCellPosition = null, this.focusedCellPosition == null)
      return;
    const e = Object.assign({ type: w.EVENT_CELL_FOCUS_CLEARED }, this.getFocusEventParams());
    this.focusedCellPosition = null, this.eventService.dispatchEvent(e);
  }
  setFocusedCell(e) {
    const { column: t, rowIndex: i, rowPinned: r, forceBrowserFocus: n = !1, preventScrollOnBrowserFocus: s = !1 } = e, a = this.columnModel.getGridColumn(t);
    if (!a) {
      this.focusedCellPosition = null;
      return;
    }
    this.focusedCellPosition = a ? {
      rowIndex: i,
      rowPinned: ca(r),
      column: a
    } : null;
    const l = Object.assign(Object.assign({ type: w.EVENT_CELL_FOCUSED }, this.getFocusEventParams()), {
      forceBrowserFocus: n,
      preventScrollOnBrowserFocus: s,
      floating: null
    });
    this.eventService.dispatchEvent(l);
  }
  isCellFocused(e) {
    return this.focusedCellPosition == null ? !1 : this.cellPositionUtils.equals(e, this.focusedCellPosition);
  }
  isRowNodeFocused(e) {
    return this.isRowFocused(e.rowIndex, e.rowPinned);
  }
  isHeaderWrapperFocused(e) {
    if (this.focusedHeaderPosition == null)
      return !1;
    const t = e.getColumnGroupChild(), i = e.getRowIndex(), r = e.getPinned(), { column: n, headerRowIndex: s } = this.focusedHeaderPosition;
    return t === n && i === s && r == n.getPinned();
  }
  clearFocusedHeader() {
    this.focusedHeaderPosition = null;
  }
  getFocusedHeader() {
    return this.focusedHeaderPosition;
  }
  setFocusedHeader(e, t) {
    this.focusedHeaderPosition = { headerRowIndex: e, column: t };
  }
  focusHeaderPosition(e) {
    const { direction: t, fromTab: i, allowUserOverride: r, event: n } = e;
    let { headerPosition: s } = e;
    if (r) {
      const c = this.getFocusedHeader(), d = this.headerNavigationService.getHeaderRowCount();
      if (i) {
        const u = this.gridOptionsService.getCallback("tabToNextHeader");
        u && (s = u({
          backwards: t === "Before",
          previousHeaderPosition: c,
          nextHeaderPosition: s,
          headerRowCount: d
        }));
      } else {
        const u = this.gridOptionsService.getCallback("navigateToNextHeader");
        if (u && n) {
          const h = {
            key: n.key,
            previousHeaderPosition: c,
            nextHeaderPosition: s,
            headerRowCount: d,
            event: n
          };
          s = u(h);
        }
      }
    }
    return s ? s.headerRowIndex === -1 ? this.focusGridView(s.column) : (this.headerNavigationService.scrollToColumn(s.column, t), this.ctrlsService.getHeaderRowContainerCtrl(s.column.getPinned()).focusHeader(s.headerRowIndex, s.column, n)) : !1;
  }
  focusFirstHeader() {
    let e = this.columnModel.getAllDisplayedColumns()[0];
    return e ? (e.getParent() && (e = this.columnModel.getColumnGroupAtLevel(e, 0)), this.focusHeaderPosition({
      headerPosition: { headerRowIndex: 0, column: e }
    })) : !1;
  }
  focusLastHeader(e) {
    const t = this.headerNavigationService.getHeaderRowCount() - 1, i = at(this.columnModel.getAllDisplayedColumns());
    return this.focusHeaderPosition({
      headerPosition: { headerRowIndex: t, column: i },
      event: e
    });
  }
  isAnyCellFocused() {
    return !!this.focusedCellPosition;
  }
  isRowFocused(e, t) {
    return this.focusedCellPosition == null ? !1 : this.focusedCellPosition.rowIndex === e && this.focusedCellPosition.rowPinned === ca(t);
  }
  findFocusableElements(e, t, i = !1) {
    const r = DT;
    let n = IS;
    t && (n += ", " + t), i && (n += ', [tabindex="-1"]');
    const s = Array.prototype.slice.apply(e.querySelectorAll(r)), a = Array.prototype.slice.apply(e.querySelectorAll(n));
    return a.length ? ((c, d) => c.filter((u) => d.indexOf(u) === -1))(s, a) : s;
  }
  focusInto(e, t = !1, i = !1) {
    const r = this.findFocusableElements(e, null, i), n = t ? at(r) : r[0];
    return n ? (n.focus({ preventScroll: !0 }), !0) : !1;
  }
  findFocusableElementBeforeTabGuard(e, t) {
    if (!t)
      return null;
    const i = this.findFocusableElements(e), r = i.indexOf(t);
    if (r === -1)
      return null;
    let n = -1;
    for (let s = r - 1; s >= 0; s--)
      if (i[s].classList.contains(Rd.TAB_GUARD_TOP)) {
        n = s;
        break;
      }
    return n <= 0 ? null : i[n - 1];
  }
  findNextFocusableElement(e = this.eGridDiv, t, i) {
    const r = this.findFocusableElements(e, t ? ':not([tabindex="-1"])' : null), s = this.gridOptionsService.getDocument().activeElement;
    let a;
    t ? a = r.findIndex((c) => c.contains(s)) : a = r.indexOf(s);
    const l = a + (i ? -1 : 1);
    return l < 0 || l >= r.length ? null : r[l];
  }
  isTargetUnderManagedComponent(e, t) {
    if (!t)
      return !1;
    const i = e.querySelectorAll(`.${Ji.FOCUS_MANAGED_CLASS}`);
    if (!i.length)
      return !1;
    for (let r = 0; r < i.length; r++)
      if (i[r].contains(t))
        return !0;
    return !1;
  }
  findTabbableParent(e, t = 5) {
    let i = 0;
    for (; e && Ag(e) === null && ++i <= t; )
      e = e.parentElement;
    return Ag(e) === null ? null : e;
  }
  focusGridView(e, t) {
    if (this.gridOptionsService.is("suppressCellFocus"))
      return t ? this.focusLastHeader() : this.focusNextGridCoreContainer(!1);
    const i = t ? this.rowPositionUtils.getLastRow() : this.rowPositionUtils.getFirstRow();
    if (!i)
      return !1;
    const { rowIndex: r, rowPinned: n } = i, s = this.getFocusedHeader();
    if (!e && s && (e = s.column), r == null || !e)
      return !1;
    if (this.navigationService.ensureCellVisible({ rowIndex: r, column: e, rowPinned: n }), this.setFocusedCell({
      rowIndex: r,
      column: e,
      rowPinned: ca(n),
      forceBrowserFocus: !0
    }), this.rangeService) {
      const a = { rowIndex: r, rowPinned: n, column: e };
      this.rangeService.setRangeToCell(a);
    }
    return !0;
  }
  focusNextGridCoreContainer(e, t = !1) {
    return !t && this.gridCtrl.focusNextInnerContainer(e) ? !0 : ((t || !e && !this.gridCtrl.isDetailGrid()) && this.gridCtrl.forceFocusOutOfContainer(e), !1);
  }
};
Ht.AG_KEYBOARD_FOCUS = "ag-keyboard-focus";
Ht.keyboardModeActive = !1;
Ht.instancesMonitored = /* @__PURE__ */ new Map();
Yn([
  S("eGridDiv")
], Ht.prototype, "eGridDiv", void 0);
Yn([
  S("columnModel")
], Ht.prototype, "columnModel", void 0);
Yn([
  S("headerNavigationService")
], Ht.prototype, "headerNavigationService", void 0);
Yn([
  S("rowRenderer")
], Ht.prototype, "rowRenderer", void 0);
Yn([
  S("rowPositionUtils")
], Ht.prototype, "rowPositionUtils", void 0);
Yn([
  S("cellPositionUtils")
], Ht.prototype, "cellPositionUtils", void 0);
Yn([
  Ve("rangeService")
], Ht.prototype, "rangeService", void 0);
Yn([
  S("navigationService")
], Ht.prototype, "navigationService", void 0);
Yn([
  S("ctrlsService")
], Ht.prototype, "ctrlsService", void 0);
Yn([
  B
], Ht.prototype, "init", null);
Ht = _i = Yn([
  q("focusService")
], Ht);
var Fs = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Vo extends ko {
  constructor(e, t) {
    super(e, t), this.refreshFunctions = [], this.userHeaderClasses = /* @__PURE__ */ new Set(), this.ariaDescriptionProperties = /* @__PURE__ */ new Map(), this.column = e;
  }
  setComp(e, t, i, r) {
    super.setGui(t), this.comp = e, this.updateState(), this.setupWidth(), this.setupMovingCss(), this.setupMenuClass(), this.setupSortableClass(), this.setupWrapTextClass(), this.refreshSpanHeaderHeight(), this.setupAutoHeight(r), this.addColumnHoverListener(), this.setupFilterCss(), this.setupColId(), this.setupClassesFromColDef(), this.setupTooltip(), this.addActiveHeaderMouseListeners(), this.setupSelectAll(), this.setupUserComp(), this.refreshAria(), this.createManagedBean(new im(this.getPinned(), this.column, i, e, this)), this.createManagedBean(new Up([this.column], t)), this.createManagedBean(new em(this.column, t, this.beans)), this.createManagedBean(new Ji(t, {
      shouldStopEventPropagation: (n) => this.shouldStopEventPropagation(n),
      onTabKeyDown: () => null,
      handleKeyDown: this.handleKeyDown.bind(this),
      onFocusIn: this.onFocusIn.bind(this),
      onFocusOut: this.onFocusOut.bind(this)
    })), this.addMouseDownListenerIfNeeded(t), this.addManagedListener(this.column, me.EVENT_COL_DEF_CHANGED, this.onColDefChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_VALUE_CHANGED, this.onColumnValueChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onColumnRowGroupChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_CHANGED, this.onColumnPivotChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_HEADER_HEIGHT_CHANGED, this.onHeaderHeightChanged.bind(this));
  }
  addMouseDownListenerIfNeeded(e) {
    if (!fn())
      return;
    const t = ["mousedown", "touchstart"], i = this.gridOptionsService.getDocument();
    t.forEach((r) => {
      this.addManagedListener(e, r, (n) => {
        const s = i.activeElement;
        s !== e && !e.contains(s) && (e.focus(), Ht.toggleKeyboardMode(n));
      });
    });
  }
  setupUserComp() {
    const e = this.lookupUserCompDetails();
    this.setCompDetails(e);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setUserCompDetails(e);
  }
  lookupUserCompDetails() {
    const e = this.createParams(), t = this.column.getColDef();
    return this.userComponentFactory.getHeaderCompDetails(t, e);
  }
  createParams() {
    const e = this.column.getColDef();
    return {
      column: this.column,
      displayName: this.displayName,
      enableSorting: e.sortable,
      enableMenu: this.menuEnabled,
      showColumnMenu: (i) => {
        this.gridApi.showColumnMenuAfterButtonClick(this.column, i);
      },
      progressSort: (i) => {
        this.sortController.progressSort(this.column, !!i, "uiColumnSorted");
      },
      setSort: (i, r) => {
        this.sortController.setSortForColumn(this.column, i, !!r, "uiColumnSorted");
      },
      api: this.gridApi,
      columnApi: this.columnApi,
      context: this.gridOptionsService.context,
      eGridHeader: this.getGui()
    };
  }
  setupSelectAll() {
    this.selectAllFeature = this.createManagedBean(new $p(this.column)), this.selectAllFeature.setComp(this);
  }
  getSelectAllGui() {
    return this.selectAllFeature.getCheckboxGui();
  }
  handleKeyDown(e) {
    super.handleKeyDown(e), e.key === V.SPACE && this.selectAllFeature.onSpaceKeyDown(e), e.key === V.ENTER && this.onEnterKeyDown(e);
  }
  onEnterKeyDown(e) {
    const t = this.comp.getUserCompInstance();
    if (t) {
      if (e.ctrlKey || e.metaKey)
        this.menuEnabled && t.showMenu && (e.preventDefault(), t.showMenu());
      else if (this.sortable) {
        const i = e.shiftKey;
        this.sortController.progressSort(this.column, i, "uiColumnSorted");
      }
    }
  }
  isMenuEnabled() {
    return this.menuEnabled;
  }
  onFocusIn(e) {
    if (!this.getGui().contains(e.relatedTarget)) {
      const t = this.getRowIndex();
      this.focusService.setFocusedHeader(t, this.column);
    }
    this.setActiveHeader(!0);
  }
  onFocusOut(e) {
    this.getGui().contains(e.relatedTarget) || this.setActiveHeader(!1);
  }
  setupTooltip() {
    const e = {
      getColumn: () => this.column,
      getColDef: () => this.column.getColDef(),
      getGui: () => this.eGui,
      getLocation: () => "header",
      getTooltipValue: () => this.column.getColDef().headerTooltip
    }, t = this.createManagedBean(new ab(e, this.beans));
    t.setComp(this.comp), this.refreshFunctions.push(() => t.refreshToolTip());
  }
  setupClassesFromColDef() {
    const e = () => {
      const t = this.column.getColDef(), i = jp.getHeaderClassesFromColDef(t, this.gridOptionsService, this.column, null), r = this.userHeaderClasses;
      this.userHeaderClasses = new Set(i), i.forEach((n) => {
        r.has(n) ? r.delete(n) : this.comp.addOrRemoveCssClass(n, !0);
      }), r.forEach((n) => this.comp.addOrRemoveCssClass(n, !1));
    };
    this.refreshFunctions.push(e), e();
  }
  setDragSource(e) {
    if (this.dragSourceElement = e, this.removeDragSource(), !e || !this.draggable)
      return;
    const t = !this.gridOptionsService.is("suppressDragLeaveHidesColumns");
    this.moveDragSource = {
      type: Dt.HeaderCell,
      eElement: e,
      defaultIconName: t ? Te.ICON_HIDE : Te.ICON_NOT_ALLOWED,
      getDragItem: () => this.createDragItem(),
      dragItemName: this.displayName,
      onDragStarted: () => this.column.setMoving(!0, "uiColumnMoved"),
      onDragStopped: () => this.column.setMoving(!1, "uiColumnMoved"),
      onGridEnter: (i) => {
        var r;
        if (t) {
          const n = ((r = i == null ? void 0 : i.columns) === null || r === void 0 ? void 0 : r.filter((s) => !s.getColDef().lockVisible)) || [];
          this.columnModel.setColumnsVisible(n, !0, "uiColumnMoved");
        }
      },
      onGridExit: (i) => {
        var r;
        if (t) {
          const n = ((r = i == null ? void 0 : i.columns) === null || r === void 0 ? void 0 : r.filter((s) => !s.getColDef().lockVisible)) || [];
          this.columnModel.setColumnsVisible(n, !1, "uiColumnMoved");
        }
      }
    }, this.dragAndDropService.addDragSource(this.moveDragSource, !0);
  }
  createDragItem() {
    const e = {};
    return e[this.column.getId()] = this.column.isVisible(), {
      columns: [this.column],
      visibleState: e
    };
  }
  removeDragSource() {
    this.moveDragSource && (this.dragAndDropService.removeDragSource(this.moveDragSource), this.moveDragSource = void 0);
  }
  onColDefChanged() {
    this.refresh();
  }
  updateState() {
    const e = this.column.getColDef();
    this.menuEnabled = this.menuFactory.isMenuEnabled(this.column) && !e.suppressMenu, this.sortable = e.sortable, this.displayName = this.calculateDisplayName(), this.draggable = this.workOutDraggable();
  }
  addRefreshFunction(e) {
    this.refreshFunctions.push(e);
  }
  refresh() {
    this.updateState(), this.refreshHeaderComp(), this.refreshAria(), this.refreshFunctions.forEach((e) => e());
  }
  refreshHeaderComp() {
    const e = this.lookupUserCompDetails();
    (this.comp.getUserCompInstance() != null && this.userCompDetails.componentClass == e.componentClass ? this.attemptHeaderCompRefresh(e.params) : !1) ? this.setDragSource(this.dragSourceElement) : this.setCompDetails(e);
  }
  attemptHeaderCompRefresh(e) {
    const t = this.comp.getUserCompInstance();
    return !t || !t.refresh ? !1 : t.refresh(e);
  }
  calculateDisplayName() {
    return this.columnModel.getDisplayNameForColumn(this.column, "header", !0);
  }
  checkDisplayName() {
    this.displayName !== this.calculateDisplayName() && this.refresh();
  }
  workOutDraggable() {
    const e = this.column.getColDef();
    return !!(!this.gridOptionsService.is("suppressMovableColumns") && !e.suppressMovable && !e.lockPosition) || !!e.enableRowGroup || !!e.enablePivot;
  }
  onColumnRowGroupChanged() {
    this.checkDisplayName();
  }
  onColumnPivotChanged() {
    this.checkDisplayName();
  }
  onColumnValueChanged() {
    this.checkDisplayName();
  }
  setupWidth() {
    const e = () => {
      const t = this.column.getActualWidth();
      this.comp.setWidth(`${t}px`);
    };
    this.addManagedListener(this.column, me.EVENT_WIDTH_CHANGED, e), e();
  }
  setupMovingCss() {
    const e = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
    };
    this.addManagedListener(this.column, me.EVENT_MOVING_CHANGED, e), e();
  }
  setupMenuClass() {
    const e = () => {
      this.comp.addOrRemoveCssClass("ag-column-menu-visible", this.column.isMenuVisible());
    };
    this.addManagedListener(this.column, me.EVENT_MENU_VISIBLE_CHANGED, e), e();
  }
  setupSortableClass() {
    const e = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-sortable", !!this.sortable);
    };
    e(), this.addRefreshFunction(e), this.addManagedListener(this.eventService, me.EVENT_SORT_CHANGED, this.refreshAriaSort.bind(this));
  }
  setupWrapTextClass() {
    const e = () => {
      const t = !!this.column.getColDef().wrapHeaderText;
      this.comp.addOrRemoveCssClass("ag-header-cell-wrap-text", t);
    };
    e(), this.addRefreshFunction(e);
  }
  onHeaderHeightChanged() {
    this.refreshSpanHeaderHeight();
  }
  refreshSpanHeaderHeight() {
    const { eGui: e, column: t, comp: i, columnModel: r, gridOptionsService: n } = this;
    if (!t.isSpanHeaderHeight())
      return;
    const { numberOfParents: s, isSpanningTotal: a } = this.getColumnGroupPaddingInfo();
    if (i.addOrRemoveCssClass("ag-header-span-height", s > 0), s === 0)
      return;
    i.addOrRemoveCssClass("ag-header-span-total", a);
    const c = n.is("pivotMode") ? r.getPivotGroupHeaderHeight() : r.getGroupHeaderHeight(), d = r.getColumnHeaderRowHeight(), u = s * c;
    e.style.setProperty("top", `${-u}px`), e.style.setProperty("height", `${d + u}px`);
  }
  getColumnGroupPaddingInfo() {
    let e = this.column.getParent();
    if (!e || !e.isPadding())
      return { numberOfParents: 0, isSpanningTotal: !1 };
    const t = e.getPaddingLevel() + 1;
    let i = !0;
    for (; e; ) {
      if (!e.isPadding()) {
        i = !1;
        break;
      }
      e = e.getParent();
    }
    return { numberOfParents: t, isSpanningTotal: i };
  }
  setupAutoHeight(e) {
    const t = (l) => {
      if (!this.isAlive())
        return;
      const { paddingTop: c, paddingBottom: d, borderBottomWidth: u, borderTopWidth: h } = La(this.getGui()), p = c + d + u + h, g = e.offsetHeight + p;
      if (l < 5) {
        const v = this.beans.gridOptionsService.getDocument(), y = !v || !v.contains(e), m = g == 0;
        if (y || m) {
          this.beans.frameworkOverrides.setTimeout(() => t(l + 1), 0);
          return;
        }
      }
      this.columnModel.setColumnHeaderHeight(this.column, g);
    };
    let i = !1, r;
    const n = () => {
      const l = this.column.isAutoHeaderHeight();
      l && !i && s(), !l && i && a();
    }, s = () => {
      i = !0, t(0), this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", !0), r = this.resizeObserverService.observeResize(e, () => t(0));
    }, a = () => {
      i = !1, r && r(), this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", !1), r = void 0;
    };
    n(), this.addDestroyFunc(() => a()), this.addManagedListener(this.column, me.EVENT_WIDTH_CHANGED, () => i && t(0)), this.addManagedListener(this.eventService, me.EVENT_SORT_CHANGED, () => {
      i && this.beans.frameworkOverrides.setTimeout(() => t(0));
    }), this.addRefreshFunction(n);
  }
  refreshAriaSort() {
    if (this.sortable) {
      const e = this.localeService.getLocaleTextFunc(), t = this.sortController.getDisplaySortForColumn(this.column) || null;
      this.comp.setAriaSort(sT(t)), this.setAriaDescriptionProperty("sort", e("ariaSortableColumn", "Press ENTER to sort."));
    } else
      this.comp.setAriaSort(), this.setAriaDescriptionProperty("sort", null);
  }
  refreshAriaMenu() {
    if (this.menuEnabled) {
      const e = this.localeService.getLocaleTextFunc();
      this.setAriaDescriptionProperty("menu", e("ariaMenuColumn", "Press CTRL ENTER to open column menu."));
    } else
      this.setAriaDescriptionProperty("menu", null);
  }
  setAriaDescriptionProperty(e, t) {
    t != null ? this.ariaDescriptionProperties.set(e, t) : this.ariaDescriptionProperties.delete(e);
  }
  refreshAriaDescription() {
    const e = Array.from(this.ariaDescriptionProperties.values());
    this.comp.setAriaDescription(e.length ? e.join(" ") : void 0);
  }
  refreshAria() {
    this.refreshAriaSort(), this.refreshAriaMenu(), this.refreshAriaDescription();
  }
  addColumnHoverListener() {
    const e = () => {
      if (!this.gridOptionsService.is("columnHoverHighlight"))
        return;
      const t = this.columnHoverService.isHovered(this.column);
      this.comp.addOrRemoveCssClass("ag-column-hover", t);
    };
    this.addManagedListener(this.eventService, w.EVENT_COLUMN_HOVER_CHANGED, e), e();
  }
  setupFilterCss() {
    const e = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-filtered", this.column.isFilterActive());
    };
    this.addManagedListener(this.column, me.EVENT_FILTER_ACTIVE_CHANGED, e), e();
  }
  setupColId() {
    this.comp.setColId(this.column.getColId());
  }
  addActiveHeaderMouseListeners() {
    const e = (t) => this.setActiveHeader(t.type === "mouseenter");
    this.addManagedListener(this.getGui(), "mouseenter", e), this.addManagedListener(this.getGui(), "mouseleave", e);
  }
  setActiveHeader(e) {
    this.comp.addOrRemoveCssClass("ag-header-active", e);
  }
}
Fs([
  S("columnModel")
], Vo.prototype, "columnModel", void 0);
Fs([
  S("columnHoverService")
], Vo.prototype, "columnHoverService", void 0);
Fs([
  S("sortController")
], Vo.prototype, "sortController", void 0);
Fs([
  S("menuFactory")
], Vo.prototype, "menuFactory", void 0);
Fs([
  S("dragAndDropService")
], Vo.prototype, "dragAndDropService", void 0);
Fs([
  S("resizeObserverService")
], Vo.prototype, "resizeObserverService", void 0);
Fs([
  S("gridApi")
], Vo.prototype, "gridApi", void 0);
Fs([
  S("columnApi")
], Vo.prototype, "columnApi", void 0);
Fs([
  dt
], Vo.prototype, "removeDragSource", null);
var nm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class zp extends H {
  constructor(e, t, i, r) {
    super(), this.eResize = t, this.comp = e, this.pinned = i, this.columnGroup = r;
  }
  postConstruct() {
    if (!this.columnGroup.isResizable()) {
      this.comp.setResizableDisplayed(!1);
      return;
    }
    const e = this.horizontalResizeService.addResizeBar({
      eResizeBar: this.eResize,
      onResizeStart: this.onResizeStart.bind(this),
      onResizing: this.onResizing.bind(this, !1),
      onResizeEnd: this.onResizing.bind(this, !0)
    });
    if (this.addDestroyFunc(e), !this.gridOptionsService.is("suppressAutoSize")) {
      const t = this.gridOptionsService.is("skipHeaderOnAutoSize");
      this.eResize.addEventListener("dblclick", () => {
        const i = [];
        this.columnGroup.getDisplayedLeafColumns().forEach((n) => {
          n.getColDef().suppressAutoSize || i.push(n.getColId());
        }), i.length > 0 && this.columnModel.autoSizeColumns({
          columns: i,
          skipHeader: t,
          stopAtGroup: this.columnGroup,
          source: "uiColumnResized"
        }), this.resizeLeafColumnsToFit("uiColumnResized");
      });
    }
  }
  onResizeStart(e) {
    this.calculateInitialValues();
    let t = null;
    if (e && (t = this.columnModel.getDisplayedGroupAfter(this.columnGroup)), t) {
      const i = t.getDisplayedLeafColumns();
      this.resizeTakeFromCols = i.filter((r) => r.isResizable()), this.resizeTakeFromStartWidth = 0, this.resizeTakeFromCols.forEach((r) => this.resizeTakeFromStartWidth += r.getActualWidth()), this.resizeTakeFromRatios = [], this.resizeTakeFromCols.forEach((r) => this.resizeTakeFromRatios.push(r.getActualWidth() / this.resizeTakeFromStartWidth));
    } else
      this.resizeTakeFromCols = null, this.resizeTakeFromStartWidth = null, this.resizeTakeFromRatios = null;
    this.comp.addOrRemoveCssClass("ag-column-resizing", !0);
  }
  onResizing(e, t, i = "uiColumnResized") {
    const r = this.normaliseDragChange(t), n = this.resizeStartWidth + r;
    this.resizeColumns(n, i, e);
  }
  resizeLeafColumnsToFit(e) {
    const t = this.autoWidthCalculator.getPreferredWidthForColumnGroup(this.columnGroup);
    this.calculateInitialValues(), t > this.resizeStartWidth && this.resizeColumns(t, e, !0);
  }
  resizeColumns(e, t, i = !0) {
    const r = [];
    if (r.push({
      columns: this.resizeCols,
      ratios: this.resizeRatios,
      width: e
    }), this.resizeTakeFromCols) {
      const n = e - this.resizeStartWidth;
      r.push({
        columns: this.resizeTakeFromCols,
        ratios: this.resizeTakeFromRatios,
        width: this.resizeTakeFromStartWidth - n
      });
    }
    this.columnModel.resizeColumnSets({
      resizeSets: r,
      finished: i,
      source: t
    }), i && this.comp.addOrRemoveCssClass("ag-column-resizing", !1);
  }
  calculateInitialValues() {
    const e = this.columnGroup.getDisplayedLeafColumns();
    this.resizeCols = e.filter((t) => t.isResizable()), this.resizeStartWidth = 0, this.resizeCols.forEach((t) => this.resizeStartWidth += t.getActualWidth()), this.resizeRatios = [], this.resizeCols.forEach((t) => this.resizeRatios.push(t.getActualWidth() / this.resizeStartWidth));
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderCell - should refactor out?
  normaliseDragChange(e) {
    let t = e;
    return this.gridOptionsService.is("enableRtl") ? this.pinned !== "left" && (t *= -1) : this.pinned === "right" && (t *= -1), t;
  }
}
nm([
  S("horizontalResizeService")
], zp.prototype, "horizontalResizeService", void 0);
nm([
  S("autoWidthCalculator")
], zp.prototype, "autoWidthCalculator", void 0);
nm([
  S("columnModel")
], zp.prototype, "columnModel", void 0);
nm([
  B
], zp.prototype, "postConstruct", null);
var mN = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class mx extends H {
  constructor(e, t) {
    super(), this.removeChildListenersFuncs = [], this.columnGroup = t, this.comp = e;
  }
  postConstruct() {
    this.addListenersToChildrenColumns(), this.addManagedListener(this.columnGroup, pt.EVENT_DISPLAYED_CHILDREN_CHANGED, this.onDisplayedChildrenChanged.bind(this)), this.onWidthChanged(), this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
  }
  addListenersToChildrenColumns() {
    this.removeListenersOnChildrenColumns();
    const e = this.onWidthChanged.bind(this);
    this.columnGroup.getLeafColumns().forEach((t) => {
      t.addEventListener("widthChanged", e), t.addEventListener("visibleChanged", e), this.removeChildListenersFuncs.push(() => {
        t.removeEventListener("widthChanged", e), t.removeEventListener("visibleChanged", e);
      });
    });
  }
  removeListenersOnChildrenColumns() {
    this.removeChildListenersFuncs.forEach((e) => e()), this.removeChildListenersFuncs = [];
  }
  onDisplayedChildrenChanged() {
    this.addListenersToChildrenColumns(), this.onWidthChanged();
  }
  onWidthChanged() {
    const e = this.columnGroup.getActualWidth();
    this.comp.setWidth(`${e}px`), this.comp.addOrRemoveCssClass("ag-hidden", e === 0);
  }
}
mN([
  B
], mx.prototype, "postConstruct", null);
var om = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Kp extends ko {
  constructor(e, t) {
    super(e, t), this.columnGroup = e;
  }
  setComp(e, t, i) {
    super.setGui(t), this.comp = e, this.displayName = this.columnModel.getDisplayNameForColumnGroup(this.columnGroup, "header"), this.addClasses(), this.addAttributes(), this.setupMovingCss(), this.setupExpandable(), this.setupTooltip(), this.setupUserComp();
    const r = this.getParentRowCtrl().getPinned(), n = this.columnGroup.getProvidedColumnGroup().getLeafColumns();
    this.createManagedBean(new Up(n, t)), this.createManagedBean(new em(this.columnGroup, t, this.beans)), this.createManagedBean(new mx(e, this.columnGroup)), this.groupResizeFeature = this.createManagedBean(new zp(e, i, r, this.columnGroup)), this.createManagedBean(new Ji(t, {
      shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
      onTabKeyDown: () => {
      },
      handleKeyDown: this.handleKeyDown.bind(this),
      onFocusIn: this.onFocusIn.bind(this)
    }));
  }
  resizeLeafColumnsToFit(e) {
    this.groupResizeFeature && this.groupResizeFeature.resizeLeafColumnsToFit(e);
  }
  setupUserComp() {
    let e = this.displayName;
    const t = {
      displayName: this.displayName,
      columnGroup: this.columnGroup,
      setExpanded: (r) => {
        this.columnModel.setColumnGroupOpened(this.columnGroup.getProvidedColumnGroup(), r, "gridInitializing");
      },
      api: this.gridApi,
      columnApi: this.columnApi,
      context: this.gridOptionsService.context
    };
    if (!e) {
      let r = this.columnGroup;
      const n = r.getLeafColumns();
      for (; r.getParent() && r.getParent().getLeafColumns().length === n.length; )
        r = r.getParent();
      const s = r.getColGroupDef();
      s && (e = s.headerName), e || (e = n ? this.columnModel.getDisplayNameForColumn(n[0], "header", !0) : "");
    }
    const i = this.userComponentFactory.getHeaderGroupCompDetails(t);
    this.comp.setUserCompDetails(i);
  }
  setupTooltip() {
    const e = this.columnGroup.getColGroupDef(), t = {
      getColumn: () => this.columnGroup,
      getGui: () => this.eGui,
      getLocation: () => "headerGroup",
      getTooltipValue: () => e && e.headerTooltip
    };
    e && (t.getColDef = () => e), this.createManagedBean(new ab(t, this.beans)).setComp(this.comp);
  }
  setupExpandable() {
    const e = this.columnGroup.getProvidedColumnGroup();
    this.refreshExpanded(), this.addManagedListener(e, Be.EVENT_EXPANDABLE_CHANGED, this.refreshExpanded.bind(this)), this.addManagedListener(e, Be.EVENT_EXPANDED_CHANGED, this.refreshExpanded.bind(this));
  }
  refreshExpanded() {
    const e = this.columnGroup;
    this.expandable = e.isExpandable();
    const t = e.isExpanded();
    this.expandable ? this.comp.setAriaExpanded(t ? "true" : "false") : this.comp.setAriaExpanded(void 0);
  }
  addAttributes() {
    this.comp.setColId(this.columnGroup.getUniqueId());
  }
  addClasses() {
    const e = this.columnGroup.getColGroupDef(), t = jp.getHeaderClassesFromColDef(e, this.gridOptionsService, null, this.columnGroup);
    this.columnGroup.isPadding() ? (t.push("ag-header-group-cell-no-group"), this.columnGroup.getLeafColumns().every((r) => r.isSpanHeaderHeight()) && t.push("ag-header-span-height")) : t.push("ag-header-group-cell-with-group"), t.forEach((i) => this.comp.addOrRemoveCssClass(i, !0));
  }
  setupMovingCss() {
    const t = this.columnGroup.getProvidedColumnGroup().getLeafColumns(), i = () => this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.columnGroup.isMoving());
    t.forEach((r) => {
      this.addManagedListener(r, me.EVENT_MOVING_CHANGED, i);
    }), i();
  }
  onFocusIn(e) {
    if (!this.eGui.contains(e.relatedTarget)) {
      const t = this.getRowIndex();
      this.beans.focusService.setFocusedHeader(t, this.columnGroup);
    }
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    if (!(!this.expandable || !t) && e.key === V.ENTER) {
      const i = this.columnGroup, r = !i.isExpanded();
      this.columnModel.setColumnGroupOpened(i.getProvidedColumnGroup(), r, "uiColumnExpanded");
    }
  }
  // unlike columns, this will only get called once, as we don't react on props on column groups
  // (we will always destroy and recreate this comp if something changes)
  setDragSource(e) {
    if (this.isSuppressMoving())
      return;
    const t = this.columnGroup.getProvidedColumnGroup().getLeafColumns(), i = !this.gridOptionsService.is("suppressDragLeaveHidesColumns"), r = {
      type: Dt.HeaderCell,
      eElement: e,
      defaultIconName: i ? Te.ICON_HIDE : Te.ICON_NOT_ALLOWED,
      dragItemName: this.displayName,
      // we add in the original group leaf columns, so we move both visible and non-visible items
      getDragItem: this.getDragItemForGroup.bind(this),
      onDragStarted: () => t.forEach((n) => n.setMoving(!0, "uiColumnDragged")),
      onDragStopped: () => t.forEach((n) => n.setMoving(!1, "uiColumnDragged")),
      onGridEnter: (n) => {
        var s;
        if (i) {
          const a = ((s = n == null ? void 0 : n.columns) === null || s === void 0 ? void 0 : s.filter((l) => !l.getColDef().lockVisible)) || [];
          this.columnModel.setColumnsVisible(a, !0, "uiColumnMoved");
        }
      },
      onGridExit: (n) => {
        var s;
        if (i) {
          const a = ((s = n == null ? void 0 : n.columns) === null || s === void 0 ? void 0 : s.filter((l) => !l.getColDef().lockVisible)) || [];
          this.columnModel.setColumnsVisible(a, !1, "uiColumnMoved");
        }
      }
    };
    this.dragAndDropService.addDragSource(r, !0), this.addDestroyFunc(() => this.dragAndDropService.removeDragSource(r));
  }
  // when moving the columns, we want to move all the columns (contained within the DragItem) in this group in one go,
  // and in the order they are currently in the screen.
  getDragItemForGroup() {
    const e = this.columnGroup.getProvidedColumnGroup().getLeafColumns(), t = {};
    e.forEach((r) => t[r.getId()] = r.isVisible());
    const i = [];
    return this.columnModel.getAllDisplayedColumns().forEach((r) => {
      e.indexOf(r) >= 0 && (i.push(r), Ni(e, r));
    }), e.forEach((r) => i.push(r)), {
      columns: i,
      visibleState: t
    };
  }
  isSuppressMoving() {
    let e = !1;
    return this.columnGroup.getLeafColumns().forEach((i) => {
      (i.getColDef().suppressMovable || i.getColDef().lockPosition) && (e = !0);
    }), e || this.gridOptionsService.is("suppressMovableColumns");
  }
}
om([
  S("columnModel")
], Kp.prototype, "columnModel", void 0);
om([
  S("dragAndDropService")
], Kp.prototype, "dragAndDropService", void 0);
om([
  S("gridApi")
], Kp.prototype, "gridApi", void 0);
om([
  S("columnApi")
], Kp.prototype, "columnApi", void 0);
var yx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let yN = 0;
class wh extends H {
  constructor(e, t, i) {
    super(), this.instanceId = yN++, this.headerCellCtrls = {}, this.rowIndex = e, this.pinned = t, this.type = i;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setComp(e) {
    this.comp = e, this.onRowHeightChanged(), this.onVirtualColumnsChanged(), this.setWidth(), this.addEventListeners(), fn() && this.comp.setTransform("translateZ(0)"), e.setAriaRowIndex(this.rowIndex + 1);
  }
  addEventListeners() {
    this.addManagedListener(this.eventService, w.EVENT_COLUMN_RESIZED, this.onColumnResized.bind(this)), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_VIRTUAL_COLUMNS_CHANGED, this.onVirtualColumnsChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_HEADER_HEIGHT_CHANGED, this.onRowHeightChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_GRID_STYLES_CHANGED, this.onRowHeightChanged.bind(this)), this.addManagedPropertyListener("domLayout", this.onDisplayedColumnsChanged.bind(this)), this.addManagedPropertyListener("headerHeight", this.onRowHeightChanged.bind(this)), this.addManagedPropertyListener("pivotHeaderHeight", this.onRowHeightChanged.bind(this)), this.addManagedPropertyListener("groupHeaderHeight", this.onRowHeightChanged.bind(this)), this.addManagedPropertyListener("pivotGroupHeaderHeight", this.onRowHeightChanged.bind(this)), this.addManagedPropertyListener("floatingFiltersHeight", this.onRowHeightChanged.bind(this));
  }
  getHeaderCellCtrl(e) {
    return Dl(this.headerCellCtrls).find((t) => t.getColumnGroupChild() === e);
  }
  onDisplayedColumnsChanged() {
    this.onVirtualColumnsChanged(), this.setWidth(), this.onRowHeightChanged();
  }
  getType() {
    return this.type;
  }
  onColumnResized() {
    this.setWidth();
  }
  setWidth() {
    const e = this.getWidthForRow();
    this.comp.setWidth(`${e}px`);
  }
  getWidthForRow() {
    return this.gridOptionsService.isDomLayout("print") ? this.pinned != null ? 0 : this.columnModel.getContainerWidth("right") + this.columnModel.getContainerWidth("left") + this.columnModel.getContainerWidth(null) : this.columnModel.getContainerWidth(this.pinned);
  }
  onRowHeightChanged() {
    let e = this.columnModel.getHeaderRowCount();
    const t = [];
    let i = 0;
    this.columnModel.hasFloatingFilters() && (e++, i = 1);
    const r = this.columnModel.getColumnGroupHeaderRowHeight(), n = this.columnModel.getColumnHeaderRowHeight(), s = 1 + i, a = e - s;
    for (let d = 0; d < a; d++)
      t.push(r);
    t.push(n);
    for (let d = 0; d < i; d++)
      t.push(this.columnModel.getFloatingFiltersHeight());
    let l = 0;
    for (let d = 0; d < this.rowIndex; d++)
      l += t[d];
    const c = t[this.rowIndex] + "px";
    this.comp.setTop(l + "px"), this.comp.setHeight(c);
  }
  getPinned() {
    return this.pinned;
  }
  getRowIndex() {
    return this.rowIndex;
  }
  onVirtualColumnsChanged() {
    const e = this.headerCellCtrls;
    this.headerCellCtrls = {}, this.getColumnsInViewport().forEach((n) => {
      if (n.isEmptyGroup())
        return;
      const s = n.getUniqueId();
      let a = e[s];
      if (delete e[s], a && a.getColumnGroupChild() != n && (this.destroyBean(a), a = void 0), a == null)
        switch (this.type) {
          case bi.FLOATING_FILTER:
            a = this.createBean(new tm(n, this));
            break;
          case bi.COLUMN_GROUP:
            a = this.createBean(new Kp(n, this));
            break;
          default:
            a = this.createBean(new Vo(n, this));
            break;
        }
      this.headerCellCtrls[s] = a;
    });
    const i = (n) => this.focusService.isHeaderWrapperFocused(n) ? this.columnModel.isDisplayed(n.getColumnGroupChild()) : !1;
    Ct(e, (n, s) => {
      i(s) ? this.headerCellCtrls[n] = s : this.destroyBean(s);
    });
    const r = To(this.headerCellCtrls);
    this.comp.setHeaderCtrls(r);
  }
  getColumnsInViewport() {
    return this.gridOptionsService.isDomLayout("print") ? this.getColumnsInViewportPrintLayout() : this.getColumnsInViewportNormalLayout();
  }
  getColumnsInViewportPrintLayout() {
    if (this.pinned != null)
      return [];
    let e = [];
    const t = this.getActualDepth();
    return ["left", null, "right"].forEach((i) => {
      const r = this.columnModel.getVirtualHeaderGroupRow(i, t);
      e = e.concat(r);
    }), e;
  }
  getActualDepth() {
    return this.type == bi.FLOATING_FILTER ? this.rowIndex - 1 : this.rowIndex;
  }
  getColumnsInViewportNormalLayout() {
    return this.columnModel.getVirtualHeaderGroupRow(this.pinned, this.getActualDepth());
  }
  focusHeader(e, t) {
    const r = To(this.headerCellCtrls).find((n) => n.getColumnGroupChild() == e);
    return r ? (r.focus(t), !0) : !1;
  }
  destroy() {
    Ct(this.headerCellCtrls, (e, t) => {
      this.destroyBean(t);
    }), this.headerCellCtrls = {}, super.destroy();
  }
}
yx([
  S("columnModel")
], wh.prototype, "columnModel", void 0);
yx([
  S("focusService")
], wh.prototype, "focusService", void 0);
var Yp = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class vu extends H {
  constructor(e) {
    super(), this.hidden = !1, this.includeFloatingFilter = !1, this.groupsRowCtrls = [], this.pinned = e;
  }
  setComp(e, t) {
    this.comp = e, this.eViewport = t, this.setupCenterWidth(), this.setupPinnedWidth(), this.setupDragAndDrop(this.eViewport), this.addManagedListener(this.eventService, w.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.ctrlsService.registerHeaderContainer(this, this.pinned), this.columnModel.isReady() && this.refresh();
  }
  setupDragAndDrop(e) {
    const t = new gu(this.pinned, e);
    this.createManagedBean(t);
  }
  refresh(e = !1) {
    const t = new Ei(), i = this.focusService.getFocusHeaderToUseAfterRefresh(), r = () => {
      const l = this.columnModel.getHeaderRowCount() - 1;
      this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
      for (let c = 0; c < l; c++) {
        const d = this.createBean(new wh(t.next(), this.pinned, bi.COLUMN_GROUP));
        this.groupsRowCtrls.push(d);
      }
    }, n = () => {
      const l = t.next(), c = !this.hidden && (this.columnsRowCtrl == null || !e || this.columnsRowCtrl.getRowIndex() !== l);
      (c || this.hidden) && (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)), c && (this.columnsRowCtrl = this.createBean(new wh(l, this.pinned, bi.COLUMN)));
    }, s = () => {
      this.includeFloatingFilter = this.columnModel.hasFloatingFilters() && !this.hidden;
      const l = () => {
        this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
      };
      if (!this.includeFloatingFilter) {
        l();
        return;
      }
      const c = t.next();
      if (this.filtersRowCtrl) {
        const d = this.filtersRowCtrl.getRowIndex() !== c;
        (!e || d) && l();
      }
      this.filtersRowCtrl || (this.filtersRowCtrl = this.createBean(new wh(c, this.pinned, bi.FLOATING_FILTER)));
    };
    r(), n(), s();
    const a = this.getAllCtrls();
    this.comp.setCtrls(a), this.restoreFocusOnHeader(i);
  }
  restoreFocusOnHeader(e) {
    e == null || e.column.getPinned() != this.pinned || this.focusService.focusHeaderPosition({ headerPosition: e });
  }
  getAllCtrls() {
    const e = [...this.groupsRowCtrls];
    return this.columnsRowCtrl && e.push(this.columnsRowCtrl), this.filtersRowCtrl && e.push(this.filtersRowCtrl), e;
  }
  // grid cols have changed - this also means the number of rows in the header can have
  // changed. so we remove all the old rows and insert new ones for a complete refresh
  onGridColumnsChanged() {
    this.refresh(!0);
  }
  onDisplayedColumnsChanged() {
    const e = this.columnModel.hasFloatingFilters() && !this.hidden;
    this.includeFloatingFilter !== e && this.refresh(!0);
  }
  setupCenterWidth() {
    this.pinned == null && this.createManagedBean(new hu((e) => this.comp.setCenterWidth(`${e}px`), !0));
  }
  setHorizontalScroll(e) {
    this.comp.setViewportScrollLeft(e);
  }
  setupPinnedWidth() {
    if (this.pinned == null)
      return;
    const e = this.pinned === "left", t = this.pinned === "right";
    this.hidden = !0;
    const i = () => {
      const r = e ? this.pinnedWidthService.getPinnedLeftWidth() : this.pinnedWidthService.getPinnedRightWidth();
      if (r == null)
        return;
      const n = r == 0, s = this.hidden !== n, a = this.gridOptionsService.is("enableRtl"), l = this.gridOptionsService.getScrollbarWidth(), d = this.scrollVisibleService.isVerticalScrollShowing() && (a && e || !a && t) ? r + l : r;
      this.comp.setPinnedContainerWidth(`${d}px`), this.comp.setDisplayed(!n), s && (this.hidden = n, this.refresh());
    };
    this.addManagedListener(this.eventService, w.EVENT_LEFT_PINNED_WIDTH_CHANGED, i), this.addManagedListener(this.eventService, w.EVENT_RIGHT_PINNED_WIDTH_CHANGED, i), this.addManagedListener(this.eventService, w.EVENT_SCROLL_VISIBILITY_CHANGED, i), this.addManagedListener(this.eventService, w.EVENT_SCROLLBAR_WIDTH_CHANGED, i);
  }
  getHeaderCtrlForColumn(e) {
    if (e instanceof me)
      return this.columnsRowCtrl ? this.columnsRowCtrl.getHeaderCellCtrl(e) : void 0;
    if (this.groupsRowCtrls.length !== 0)
      for (let t = 0; t < this.groupsRowCtrls.length; t++) {
        const i = this.groupsRowCtrls[t].getHeaderCellCtrl(e);
        if (i)
          return i;
      }
  }
  getHtmlElementForColumnHeader(e) {
    const t = this.getHeaderCtrlForColumn(e);
    return t ? t.getGui() : null;
  }
  getRowType(e) {
    const i = this.getAllCtrls()[e];
    return i ? i.getType() : void 0;
  }
  focusHeader(e, t, i) {
    const n = this.getAllCtrls()[e];
    return n ? n.focusHeader(t, i) : !1;
  }
  getRowCount() {
    return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0);
  }
  destroy() {
    this.filtersRowCtrl && (this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl)), this.columnsRowCtrl && (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)), this.groupsRowCtrls && this.groupsRowCtrls.length && (this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls)), super.destroy();
  }
}
Yp([
  S("ctrlsService")
], vu.prototype, "ctrlsService", void 0);
Yp([
  S("scrollVisibleService")
], vu.prototype, "scrollVisibleService", void 0);
Yp([
  S("pinnedWidthService")
], vu.prototype, "pinnedWidthService", void 0);
Yp([
  S("columnModel")
], vu.prototype, "columnModel", void 0);
Yp([
  S("focusService")
], vu.prototype, "focusService", void 0);
var Sb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Ar extends X {
  constructor(e) {
    super(), this.headerRowComps = {}, this.rowCompsList = [], this.pinned = e;
  }
  init() {
    this.selectAndSetTemplate();
    const e = {
      setDisplayed: (i) => this.setDisplayed(i),
      setCtrls: (i) => this.setCtrls(i),
      // only gets called for center section
      setCenterWidth: (i) => this.eCenterContainer.style.width = i,
      setViewportScrollLeft: (i) => this.getGui().scrollLeft = i,
      // only gets called for pinned sections
      setPinnedContainerWidth: (i) => {
        const r = this.getGui();
        r.style.width = i, r.style.maxWidth = i, r.style.minWidth = i;
      }
    };
    this.createManagedBean(new vu(this.pinned)).setComp(e, this.getGui());
  }
  selectAndSetTemplate() {
    const e = this.pinned == "left", t = this.pinned == "right", i = e ? Ar.PINNED_LEFT_TEMPLATE : t ? Ar.PINNED_RIGHT_TEMPLATE : Ar.CENTER_TEMPLATE;
    this.setTemplate(i), this.eRowContainer = this.eCenterContainer ? this.eCenterContainer : this.getGui();
  }
  destroyRowComps() {
    this.setCtrls([]);
  }
  destroyRowComp(e) {
    this.destroyBean(e), this.eRowContainer.removeChild(e.getGui());
  }
  setCtrls(e) {
    const t = this.headerRowComps;
    this.headerRowComps = {}, this.rowCompsList = [];
    let i;
    const r = (n) => {
      const s = n.getGui();
      s.parentElement != this.eRowContainer && this.eRowContainer.appendChild(s), i && GS(this.eRowContainer, s, i), i = s;
    };
    e.forEach((n) => {
      const s = n.getInstanceId(), a = t[s];
      delete t[s];
      const l = a || this.createBean(new gb(n));
      this.headerRowComps[s] = l, this.rowCompsList.push(l), r(l);
    }), To(t).forEach((n) => this.destroyRowComp(n));
  }
}
Ar.PINNED_LEFT_TEMPLATE = '<div class="ag-pinned-left-header" role="presentation"></div>';
Ar.PINNED_RIGHT_TEMPLATE = '<div class="ag-pinned-right-header" role="presentation"></div>';
Ar.CENTER_TEMPLATE = `<div class="ag-header-viewport" role="presentation">
            <div class="ag-header-container" ref="eCenterContainer" role="rowgroup"></div>
        </div>`;
Sb([
  L("eCenterContainer")
], Ar.prototype, "eCenterContainer", void 0);
Sb([
  B
], Ar.prototype, "init", null);
Sb([
  dt
], Ar.prototype, "destroyRowComps", null);
var Xp = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, go;
(function(o) {
  o[o.UP = 0] = "UP", o[o.DOWN = 1] = "DOWN", o[o.LEFT = 2] = "LEFT", o[o.RIGHT = 3] = "RIGHT";
})(go || (go = {}));
let Ll = class extends H {
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  getHeaderRowCount() {
    const e = this.ctrlsService.getHeaderRowContainerCtrl();
    return e ? e.getRowCount() : 0;
  }
  /*
   * This method navigates grid header vertically
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateVertically(e, t, i) {
    if (t || (t = this.focusService.getFocusedHeader()), !t)
      return !1;
    const { headerRowIndex: r, column: n } = t, s = this.getHeaderRowCount(), a = e === go.UP;
    let { nextRow: l, nextFocusColumn: c } = a ? this.headerPositionUtils.getColumnVisibleParent(n, r) : this.headerPositionUtils.getColumnVisibleChild(n, r), d = !1;
    return l < 0 && (l = 0, c = n, d = !0), l >= s && (l = -1), !d && !c ? !1 : this.focusService.focusHeaderPosition({
      headerPosition: { headerRowIndex: l, column: c },
      allowUserOverride: !0,
      event: i
    });
  }
  /*
   * This method navigates grid header horizontally
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateHorizontally(e, t = !1, i) {
    const r = this.focusService.getFocusedHeader(), n = e === go.LEFT, s = this.gridOptionsService.is("enableRtl");
    let a, l;
    return n !== s ? (l = "Before", a = this.headerPositionUtils.findHeader(r, l)) : (l = "After", a = this.headerPositionUtils.findHeader(r, l)), a || !t ? this.focusService.focusHeaderPosition({
      headerPosition: a,
      direction: l,
      fromTab: t,
      allowUserOverride: !0,
      event: i
    }) : this.focusNextHeaderRow(r, l, i);
  }
  focusNextHeaderRow(e, t, i) {
    const r = e.headerRowIndex;
    let n = null, s;
    return t === "Before" ? r > 0 && (s = r - 1, n = this.headerPositionUtils.findColAtEdgeForHeaderRow(s, "end")) : (s = r + 1, n = this.headerPositionUtils.findColAtEdgeForHeaderRow(s, "start")), this.focusService.focusHeaderPosition({
      headerPosition: n,
      direction: t,
      fromTab: !0,
      allowUserOverride: !0,
      event: i
    });
  }
  scrollToColumn(e, t = "After") {
    if (e.getPinned())
      return;
    let i;
    if (e instanceof pt) {
      const r = e.getDisplayedLeafColumns();
      i = t === "Before" ? at(r) : r[0];
    } else
      i = e;
    this.gridBodyCon.getScrollFeature().ensureColumnVisible(i);
  }
};
Xp([
  S("focusService")
], Ll.prototype, "focusService", void 0);
Xp([
  S("headerPositionUtils")
], Ll.prototype, "headerPositionUtils", void 0);
Xp([
  S("ctrlsService")
], Ll.prototype, "ctrlsService", void 0);
Xp([
  B
], Ll.prototype, "postConstruct", null);
Ll = Xp([
  q("headerNavigationService")
], Ll);
var sm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class qp extends H {
  setComp(e, t, i) {
    this.comp = e, this.eGui = t, this.createManagedBean(new Ji(i, {
      onTabKeyDown: this.onTabKeyDown.bind(this),
      handleKeyDown: this.handleKeyDown.bind(this),
      onFocusOut: this.onFocusOut.bind(this)
    })), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onPivotModeChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.onPivotModeChanged(), this.setupHeaderHeight(), this.ctrlsService.registerGridHeaderCtrl(this);
  }
  setupHeaderHeight() {
    const e = this.setHeaderHeight.bind(this);
    e(), this.addManagedPropertyListener("headerHeight", e), this.addManagedPropertyListener("pivotHeaderHeight", e), this.addManagedPropertyListener("groupHeaderHeight", e), this.addManagedPropertyListener("pivotGroupHeaderHeight", e), this.addManagedPropertyListener("floatingFiltersHeight", e), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_CHANGED, e), this.addManagedListener(this.eventService, w.EVENT_COLUMN_HEADER_HEIGHT_CHANGED, e), this.addManagedListener(this.eventService, w.EVENT_GRID_STYLES_CHANGED, e);
  }
  getHeaderHeight() {
    return this.headerHeight;
  }
  setHeaderHeight() {
    const { columnModel: e } = this;
    let t = 0, i = e.getHeaderRowCount(), r;
    e.hasFloatingFilters() && (i++, t = 1);
    const s = this.columnModel.getColumnGroupHeaderRowHeight(), a = this.columnModel.getColumnHeaderRowHeight(), l = 1 + t, c = i - l;
    if (r = t * e.getFloatingFiltersHeight(), r += c * s, r += a, this.headerHeight === r)
      return;
    this.headerHeight = r;
    const d = `${r + 1}px`;
    this.comp.setHeightAndMinHeight(d), this.eventService.dispatchEvent({
      type: w.EVENT_HEADER_HEIGHT_CHANGED
    });
  }
  onPivotModeChanged() {
    const e = this.columnModel.isPivotMode();
    this.comp.addOrRemoveCssClass("ag-pivot-on", e), this.comp.addOrRemoveCssClass("ag-pivot-off", !e);
  }
  onDisplayedColumnsChanged() {
    const t = this.columnModel.getAllDisplayedColumns().some((i) => i.isSpanHeaderHeight());
    this.comp.addOrRemoveCssClass("ag-header-allow-overflow", t);
  }
  onTabKeyDown(e) {
    const t = this.gridOptionsService.is("enableRtl"), i = e.shiftKey !== t ? go.LEFT : go.RIGHT;
    (this.headerNavigationService.navigateHorizontally(i, !0, e) || this.focusService.focusNextGridCoreContainer(e.shiftKey)) && e.preventDefault();
  }
  handleKeyDown(e) {
    let t = null;
    switch (e.key) {
      case V.LEFT:
        t = go.LEFT;
      case V.RIGHT:
        z(t) || (t = go.RIGHT), this.headerNavigationService.navigateHorizontally(t, !1, e);
        break;
      case V.UP:
        t = go.UP;
      case V.DOWN:
        z(t) || (t = go.DOWN), this.headerNavigationService.navigateVertically(t, null, e) && e.preventDefault();
        break;
      default:
        return;
    }
  }
  onFocusOut(e) {
    const t = this.gridOptionsService.getDocument(), { relatedTarget: i } = e;
    !i && this.eGui.contains(t.activeElement) || this.eGui.contains(i) || this.focusService.clearFocusedHeader();
  }
}
sm([
  S("headerNavigationService")
], qp.prototype, "headerNavigationService", void 0);
sm([
  S("focusService")
], qp.prototype, "focusService", void 0);
sm([
  S("columnModel")
], qp.prototype, "columnModel", void 0);
sm([
  S("ctrlsService")
], qp.prototype, "ctrlsService", void 0);
var CN = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Zp extends X {
  constructor() {
    super(Zp.TEMPLATE);
  }
  postConstruct() {
    const e = {
      addOrRemoveCssClass: (r, n) => this.addOrRemoveCssClass(r, n),
      setHeightAndMinHeight: (r) => {
        this.getGui().style.height = r, this.getGui().style.minHeight = r;
      }
    };
    this.createManagedBean(new qp()).setComp(e, this.getGui(), this.getFocusableElement());
    const i = (r) => {
      this.createManagedBean(r), this.appendChild(r);
    };
    i(new Ar("left")), i(new Ar(null)), i(new Ar("right"));
  }
}
Zp.TEMPLATE = '<div class="ag-header" role="presentation"/>';
CN([
  B
], Zp.prototype, "postConstruct", null);
var bb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Uh = class extends H {
  addResizeBar(e) {
    const t = {
      dragStartPixels: e.dragStartPixels || 0,
      eElement: e.eResizeBar,
      onDragStart: this.onDragStart.bind(this, e),
      onDragStop: this.onDragStop.bind(this, e),
      onDragging: this.onDragging.bind(this, e),
      includeTouch: !0,
      stopPropagationForTouch: !0
    };
    return this.dragService.addDragSource(t), () => this.dragService.removeDragSource(t);
  }
  onDragStart(e, t) {
    this.dragStartX = t.clientX, this.setResizeIcons();
    const i = t instanceof MouseEvent && t.shiftKey === !0;
    e.onResizeStart(i);
  }
  setResizeIcons() {
    const e = this.ctrlsService.getGridCtrl();
    e.setResizeCursor(!0), e.disableUserSelect(!0);
  }
  onDragStop(e, t) {
    e.onResizeEnd(this.resizeAmount), this.resetIcons();
  }
  resetIcons() {
    const e = this.ctrlsService.getGridCtrl();
    e.setResizeCursor(!1), e.disableUserSelect(!1);
  }
  onDragging(e, t) {
    this.resizeAmount = t.clientX - this.dragStartX, e.onResizing(this.resizeAmount);
  }
};
bb([
  S("dragService")
], Uh.prototype, "dragService", void 0);
bb([
  S("ctrlsService")
], Uh.prototype, "ctrlsService", void 0);
Uh = bb([
  q("horizontalResizeService")
], Uh);
var Qp = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Nl = class extends H {
  hideActiveMenu() {
    this.hidePopup && this.hidePopup();
  }
  showMenuAfterMouseEvent(e, t) {
    this.showPopup(e, (i) => {
      this.popupService.positionPopupUnderMouseEvent({
        column: e,
        type: "columnMenu",
        mouseEvent: t,
        ePopup: i
      });
    }, "columnMenu", t.target);
  }
  showMenuAfterButtonClick(e, t, i) {
    this.showPopup(e, (r) => {
      this.popupService.positionPopupByComponent({
        type: i,
        eventSource: t,
        ePopup: r,
        keepWithinBounds: !0,
        position: "under",
        column: e
      });
    }, i, t);
  }
  showPopup(e, t, i, r) {
    const n = this.filterManager.getOrCreateFilterWrapper(e, "COLUMN_MENU");
    if (!n)
      throw new Error("AG Grid - unable to show popup filter, filter instantiation failed");
    const s = document.createElement("div");
    ci(s, "presentation"), s.classList.add("ag-menu"), this.tabListener = this.addManagedListener(s, "keydown", (p) => this.trapFocusWithin(p, s)), n.guiPromise.then((p) => s.appendChild(p));
    let a;
    const l = () => {
      var p;
      return (p = n.filterPromise) === null || p === void 0 ? void 0 : p.then((f) => {
        var g;
        return (g = f == null ? void 0 : f.afterGuiDetached) === null || g === void 0 ? void 0 : g.call(f);
      });
    }, c = r || this.ctrlsService.getGridBodyCtrl().getGui(), d = (p) => {
      e.setMenuVisible(!1, "contextMenu");
      const f = p instanceof KeyboardEvent;
      if (this.tabListener && (this.tabListener = this.tabListener()), f && r && Ms(r)) {
        const g = this.focusService.findTabbableParent(r);
        g && g.focus();
      }
      l();
    }, u = this.localeService.getLocaleTextFunc(), h = this.popupService.addPopup({
      modal: !0,
      eChild: s,
      closeOnEsc: !0,
      closedCallback: d,
      positionCallback: () => t(s),
      anchorToElement: c,
      ariaLabel: u("ariaLabelColumnMenu", "Column Menu")
    });
    h && (this.hidePopup = a = h.hideFunc), n.filterPromise.then((p) => {
      t(s), p.afterGuiAttached && p.afterGuiAttached({ container: i, hidePopup: a });
    }), e.setMenuVisible(!0, "contextMenu");
  }
  trapFocusWithin(e, t) {
    e.key !== V.TAB || e.defaultPrevented || this.focusService.findNextFocusableElement(t, !1, e.shiftKey) || (e.preventDefault(), this.focusService.focusInto(t, e.shiftKey));
  }
  isMenuEnabled(e) {
    return e.isFilterAllowed() && e.getMenuTabs(["filterMenuTab"]).includes("filterMenuTab");
  }
};
Qp([
  S("filterManager")
], Nl.prototype, "filterManager", void 0);
Qp([
  S("popupService")
], Nl.prototype, "popupService", void 0);
Qp([
  S("focusService")
], Nl.prototype, "focusService", void 0);
Qp([
  S("ctrlsService")
], Nl.prototype, "ctrlsService", void 0);
Nl = Qp([
  q("menuFactory")
], Nl);
var am = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Ba extends X {
  constructor(e) {
    super(Ba.getTemplate(e.cssClass)), this.items = [], this.tabbedItemScrollMap = /* @__PURE__ */ new Map(), this.params = e, e.items && e.items.forEach((t) => this.addItem(t));
  }
  postConstruct() {
    this.createManagedBean(new Ji(this.getFocusableElement(), {
      onTabKeyDown: this.onTabKeyDown.bind(this),
      handleKeyDown: this.handleKeyDown.bind(this)
    })), this.addDestroyFunc(() => {
      var e, t, i;
      return (i = (t = (e = this.activeItem) === null || e === void 0 ? void 0 : e.tabbedItem) === null || t === void 0 ? void 0 : t.afterDetachedCallback) === null || i === void 0 ? void 0 : i.call(t);
    });
  }
  static getTemplate(e) {
    return (
      /* html */
      `<div class="ag-tabs ${e}">
            <div ref="eHeader" role="tablist" class="ag-tabs-header ${e ? `${e}-header` : ""}"></div>
            <div ref="eBody" role="presentation" class="ag-tabs-body ${e ? `${e}-body` : ""}"></div>
        </div>`
    );
  }
  handleKeyDown(e) {
    const t = this.gridOptionsService.getDocument();
    switch (e.key) {
      case V.RIGHT:
      case V.LEFT:
        if (!this.eHeader.contains(t.activeElement))
          return;
        const i = e.key === V.RIGHT, r = this.gridOptionsService.is("enableRtl"), n = this.items.indexOf(this.activeItem), s = i !== r ? Math.min(n + 1, this.items.length - 1) : Math.max(n - 1, 0);
        if (n === s)
          return;
        e.preventDefault();
        const a = this.items[s];
        this.showItemWrapper(a), a.eHeaderButton.focus();
        break;
      case V.UP:
      case V.DOWN:
        e.stopPropagation();
        break;
    }
  }
  onTabKeyDown(e) {
    if (e.defaultPrevented)
      return;
    const { focusService: t, eHeader: i, eBody: r, activeItem: n } = this, a = this.gridOptionsService.getDocument().activeElement, l = e.target;
    if (e.preventDefault(), i.contains(a)) {
      t.focusInto(r, e.shiftKey);
      return;
    }
    let c = null;
    t.isTargetUnderManagedComponent(r, l) && (e.shiftKey && (c = this.focusService.findFocusableElementBeforeTabGuard(r, l)), c || (c = n.eHeaderButton)), !c && r.contains(a) && (c = t.findNextFocusableElement(r, !1, e.shiftKey), c || (c = n.eHeaderButton)), c && c.focus();
  }
  setAfterAttachedParams(e) {
    this.afterAttachedParams = e;
  }
  showFirstItem() {
    this.items.length > 0 && this.showItemWrapper(this.items[0]);
  }
  addItem(e) {
    const t = document.createElement("span");
    ci(t, "tab"), t.setAttribute("tabindex", "-1"), t.appendChild(e.title), t.classList.add("ag-tab"), this.eHeader.appendChild(t), Ia(t, e.titleLabel);
    const i = {
      tabbedItem: e,
      eHeaderButton: t
    };
    this.items.push(i), t.addEventListener("click", this.showItemWrapper.bind(this, i));
  }
  showItem(e) {
    const t = this.items.find((i) => i.tabbedItem === e);
    t && this.showItemWrapper(t);
  }
  showItemWrapper(e) {
    var t, i;
    const { tabbedItem: r, eHeaderButton: n } = e;
    if (this.params.onItemClicked && this.params.onItemClicked({ item: r }), this.activeItem === e) {
      jR(this.params.onActiveItemClicked);
      return;
    }
    this.lastScrollListener && (this.lastScrollListener = this.lastScrollListener()), Or(this.eBody), r.bodyPromise.then((s) => {
      this.eBody.appendChild(s);
      const a = !this.focusService.isKeyboardMode();
      if (this.focusService.focusInto(this.eBody, !1, a), r.afterAttachedCallback && r.afterAttachedCallback(this.afterAttachedParams), this.params.keepScrollPosition) {
        const l = r.getScrollableContainer && r.getScrollableContainer() || s;
        this.lastScrollListener = this.addManagedListener(l, "scroll", () => {
          this.tabbedItemScrollMap.set(r.name, l.scrollTop);
        });
        const c = this.tabbedItemScrollMap.get(r.name);
        c !== void 0 && setTimeout(() => {
          l.scrollTop = c;
        }, 0);
      }
    }), this.activeItem && (this.activeItem.eHeaderButton.classList.remove("ag-tab-selected"), (i = (t = this.activeItem.tabbedItem).afterDetachedCallback) === null || i === void 0 || i.call(t)), n.classList.add("ag-tab-selected"), this.activeItem = e;
  }
}
am([
  S("focusService")
], Ba.prototype, "focusService", void 0);
am([
  L("eHeader")
], Ba.prototype, "eHeader", void 0);
am([
  L("eBody")
], Ba.prototype, "eBody", void 0);
am([
  B
], Ba.prototype, "postConstruct", null);
var SN = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const bN = 50;
let OC = class extends H {
  constructor() {
    super(...arguments), this.polyfillFunctions = [];
  }
  observeResize(e, t) {
    const i = this.gridOptionsService.getWindow(), r = () => {
      const l = new i.ResizeObserver(t);
      return l.observe(e), () => l.disconnect();
    }, n = () => {
      let l = TC(e), c = RC(e), d = !0;
      const u = () => {
        if (d) {
          const h = TC(e), p = RC(e);
          (h !== l || p !== c) && (l = h, c = p, t()), this.doNextPolyfillTurn(u);
        }
      };
      return u(), () => d = !1;
    }, s = this.gridOptionsService.is("suppressBrowserResizeObserver");
    return !!i.ResizeObserver && !s ? r() : n();
  }
  doNextPolyfillTurn(e) {
    this.polyfillFunctions.push(e), this.schedulePolyfill();
  }
  schedulePolyfill() {
    if (this.polyfillScheduled)
      return;
    const e = () => {
      const t = this.polyfillFunctions;
      this.polyfillScheduled = !1, this.polyfillFunctions = [], t.forEach((i) => i());
    };
    this.polyfillScheduled = !0, this.getFrameworkOverrides().setTimeout(e, bN);
  }
};
OC = SN([
  q("resizeObserverService")
], OC);
var lm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Gd = class extends H {
  constructor() {
    super(...arguments), this.createTasksP1 = { list: [], sorted: !1 }, this.createTasksP2 = { list: [], sorted: !1 }, this.destroyTasks = [], this.ticking = !1, this.scrollGoingDown = !0, this.lastPage = 0, this.lastScrollTop = 0, this.taskCount = 0, this.cancelledTasks = /* @__PURE__ */ new Set();
  }
  setScrollTop(e) {
    const t = this.gridOptionsService.is("pagination");
    if (this.scrollGoingDown = e >= this.lastScrollTop, t && e === 0) {
      const i = this.paginationProxy.getCurrentPage();
      i !== this.lastPage && (this.lastPage = i, this.scrollGoingDown = !0);
    }
    this.lastScrollTop = e;
  }
  init() {
    this.useAnimationFrame = !this.gridOptionsService.is("suppressAnimationFrame");
  }
  isOn() {
    return this.useAnimationFrame;
  }
  // this method is for our AG Grid sanity only - if animation frames are turned off,
  // then no place in the code should be looking to add any work to be done in animation
  // frames. this stops bugs - where some code is asking for a frame to be executed
  // when it should not.
  verifyAnimationFrameOn(e) {
    this.useAnimationFrame === !1 && console.warn(`AG Grid: AnimationFrameService.${e} called but animation frames are off`);
  }
  createTask(e, t, i) {
    this.verifyAnimationFrameOn(i);
    const r = { task: e, index: t, createOrder: ++this.taskCount };
    this.addTaskToList(this[i], r), this.schedule();
  }
  cancelTask(e) {
    this.cancelledTasks.add(e);
  }
  addTaskToList(e, t) {
    e.list.push(t), e.sorted = !1;
  }
  sortTaskList(e) {
    if (e.sorted)
      return;
    const t = this.scrollGoingDown ? 1 : -1;
    e.list.sort((i, r) => i.index !== r.index ? t * (r.index - i.index) : r.createOrder - i.createOrder), e.sorted = !0;
  }
  addDestroyTask(e) {
    this.verifyAnimationFrameOn("createTasksP3"), this.destroyTasks.push(e), this.schedule();
  }
  executeFrame(e) {
    this.verifyAnimationFrameOn("executeFrame");
    const t = this.createTasksP1, i = t.list, r = this.createTasksP2, n = r.list, s = this.destroyTasks, a = (/* @__PURE__ */ new Date()).getTime();
    let l = (/* @__PURE__ */ new Date()).getTime() - a;
    const c = e <= 0, d = this.ctrlsService.getGridBodyCtrl();
    for (; c || l < e; ) {
      if (!d.getScrollFeature().scrollGridIfNeeded()) {
        let h;
        if (i.length)
          this.sortTaskList(t), h = i.pop().task;
        else if (n.length)
          this.sortTaskList(r), h = n.pop().task;
        else if (s.length)
          h = s.pop();
        else {
          this.cancelledTasks.clear();
          break;
        }
        this.cancelledTasks.has(h) || h();
      }
      l = (/* @__PURE__ */ new Date()).getTime() - a;
    }
    i.length || n.length || s.length ? this.requestFrame() : this.stopTicking();
  }
  stopTicking() {
    this.ticking = !1;
  }
  flushAllFrames() {
    this.useAnimationFrame && this.executeFrame(-1);
  }
  schedule() {
    this.useAnimationFrame && (this.ticking || (this.ticking = !0, this.requestFrame()));
  }
  requestFrame() {
    const e = this.executeFrame.bind(this, 60);
    this.requestAnimationFrame(e);
  }
  requestAnimationFrame(e) {
    const t = this.gridOptionsService.getWindow();
    t.requestAnimationFrame ? t.requestAnimationFrame(e) : t.webkitRequestAnimationFrame ? t.webkitRequestAnimationFrame(e) : t.setTimeout(e, 0);
  }
  isQueueEmpty() {
    return !this.ticking;
  }
  // a debounce utility used for parts of the app involved with rendering.
  // the advantage over normal debounce is the client can call flushAllFrames()
  // to make sure all rendering is complete. we don't wait any milliseconds,
  // as this is intended to batch calls in one VM turn.
  debounce(e) {
    let t = !1;
    return () => {
      if (!this.isOn()) {
        this.getFrameworkOverrides().setTimeout(e, 0);
        return;
      }
      t || (t = !0, this.addDestroyTask(() => {
        t = !1, e();
      }));
    };
  }
};
lm([
  S("ctrlsService")
], Gd.prototype, "ctrlsService", void 0);
lm([
  S("paginationProxy")
], Gd.prototype, "paginationProxy", void 0);
lm([
  B
], Gd.prototype, "init", null);
Gd = lm([
  q("animationFrameService")
], Gd);
var Jp = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Gl = class extends H {
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.centerRowContainerCtrl = e.centerRowContainerCtrl;
    });
  }
  // this is the trick: we create a dummy container and clone all the cells
  // into the dummy, then check the dummy's width. then destroy the dummy
  // as we don't need it any more.
  // drawback: only the cells visible on the screen are considered
  getPreferredWidthForColumn(e, t) {
    const i = this.getHeaderCellForColumn(e);
    if (!i)
      return -1;
    const r = this.rowRenderer.getAllCellsForColumn(e);
    return t || r.push(i), this.addElementsToContainerAndGetWidth(r);
  }
  getPreferredWidthForColumnGroup(e) {
    const t = this.getHeaderCellForColumn(e);
    return t ? this.addElementsToContainerAndGetWidth([t]) : -1;
  }
  addElementsToContainerAndGetWidth(e) {
    const t = document.createElement("form");
    t.style.position = "fixed";
    const i = this.centerRowContainerCtrl.getContainerElement();
    e.forEach((s) => this.cloneItemIntoDummy(s, t)), i.appendChild(t);
    const r = t.offsetWidth;
    i.removeChild(t);
    const n = this.getAutoSizePadding();
    return r + n;
  }
  getAutoSizePadding() {
    const e = this.gridOptionsService.getNum("autoSizePadding");
    return e != null && e >= 0 ? e : 20;
  }
  getHeaderCellForColumn(e) {
    let t = null;
    return this.ctrlsService.getHeaderRowContainerCtrls().forEach((i) => {
      const r = i.getHtmlElementForColumnHeader(e);
      r != null && (t = r);
    }), t;
  }
  cloneItemIntoDummy(e, t) {
    const i = e.cloneNode(!0);
    i.style.width = "", i.style.position = "static", i.style.left = "";
    const r = document.createElement("div"), n = r.classList;
    ["ag-header-cell", "ag-header-group-cell"].some((l) => i.classList.contains(l)) ? (n.add("ag-header", "ag-header-row"), r.style.position = "static") : n.add("ag-row");
    let a = e.parentElement;
    for (; a; ) {
      if (["ag-header-row", "ag-row"].some((c) => a.classList.contains(c))) {
        for (let c = 0; c < a.classList.length; c++) {
          const d = a.classList[c];
          d != "ag-row-position-absolute" && n.add(d);
        }
        break;
      }
      a = a.parentElement;
    }
    r.appendChild(i), t.appendChild(r);
  }
};
Jp([
  S("rowRenderer")
], Gl.prototype, "rowRenderer", void 0);
Jp([
  S("ctrlsService")
], Gl.prototype, "ctrlsService", void 0);
Jp([
  S("rowCssClassCalculator")
], Gl.prototype, "rowCssClassCalculator", void 0);
Jp([
  B
], Gl.prototype, "postConstruct", null);
Gl = Jp([
  q("autoWidthCalculator")
], Gl);
var cm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class ef extends H {
  constructor(e, t) {
    super(), this.createRowCon = e, this.destroyRowCtrls = t, this.stickyRowCtrls = [], this.containerHeight = 0;
  }
  postConstruct() {
    this.isClientSide = this.rowModel.getType() === "clientSide", this.ctrlsService.whenReady((e) => {
      this.gridBodyCtrl = e.gridBodyCtrl;
    });
  }
  getStickyRowCtrls() {
    return this.stickyRowCtrls;
  }
  checkStickyRows() {
    let e = 0;
    if (!this.gridOptionsService.isGroupRowsSticky()) {
      this.refreshNodesAndContainerHeight([], e);
      return;
    }
    const t = [], i = this.rowRenderer.getFirstVisibleVerticalPixel(), r = (n) => {
      var s, a, l;
      t.push(n);
      let c;
      if (this.isClientSide) {
        let u = n;
        for (; u.expanded; )
          if (u.master)
            u = u.detailNode;
          else if (u.childrenAfterSort) {
            if (u.childrenAfterSort.length === 0)
              break;
            u = at(u.childrenAfterSort);
          }
        c = u.rowTop + u.rowHeight;
      } else if (n.master)
        c = n.detailNode.rowTop + n.detailNode.rowHeight;
      else {
        const u = (s = n.childStore) === null || s === void 0 ? void 0 : s.getStoreBounds();
        c = ((a = u == null ? void 0 : u.heightPx) !== null && a !== void 0 ? a : 0) + ((l = u == null ? void 0 : u.topPx) !== null && l !== void 0 ? l : 0);
      }
      const d = i + e + n.rowHeight;
      c < d ? n.stickyRowTop = e + (c - d) : n.stickyRowTop = e, e = 0, t.forEach((u) => {
        const h = u.stickyRowTop + u.rowHeight;
        e < h && (e = h);
      });
    };
    for (; ; ) {
      const n = i + e, s = this.rowModel.getRowIndexAtPixel(n), a = this.rowModel.getRow(s);
      if (a == null || a.level < 0)
        break;
      const l = [];
      let c = a.parent;
      for (; c.level >= 0; )
        l.push(c), c = c.parent;
      const d = l.reverse().find((u) => t.indexOf(u) < 0 && u.displayed);
      if (d) {
        r(d);
        continue;
      }
      if (a.isExpandable() && a.expanded && a.rowTop < n) {
        r(a);
        continue;
      }
      break;
    }
    this.refreshNodesAndContainerHeight(t, e);
  }
  refreshStickyNode(e) {
    const t = [];
    for (let i = 0; i < this.stickyRowCtrls.length; i++) {
      const r = this.stickyRowCtrls[i].getRowNode();
      r !== e && t.push(r);
    }
    this.refreshNodesAndContainerHeight(t, this.containerHeight), this.checkStickyRows();
  }
  refreshNodesAndContainerHeight(e, t) {
    const i = this.stickyRowCtrls.filter((a) => e.indexOf(a.getRowNode()) === -1), r = e.filter((a) => this.stickyRowCtrls.findIndex((l) => l.getRowNode() === a) === -1), n = {};
    i.forEach((a) => {
      n[a.getRowNode().id] = a, this.stickyRowCtrls = this.stickyRowCtrls.filter((l) => l !== a);
    });
    for (const a of Object.values(n))
      a.getRowNode().sticky = !1;
    this.destroyRowCtrls(n, !1);
    const s = r.map((a) => (a.sticky = !0, this.createRowCon(a, !1, !1)));
    this.stickyRowCtrls.push(...s), this.stickyRowCtrls.forEach((a) => a.setRowTop(a.getRowNode().stickyRowTop)), this.stickyRowCtrls.sort((a, l) => l.getRowNode().rowIndex - a.getRowNode().rowIndex), this.containerHeight !== t && (this.containerHeight = t, this.gridBodyCtrl.setStickyTopHeight(t));
  }
}
cm([
  S("rowModel")
], ef.prototype, "rowModel", void 0);
cm([
  S("rowRenderer")
], ef.prototype, "rowRenderer", void 0);
cm([
  S("ctrlsService")
], ef.prototype, "ctrlsService", void 0);
cm([
  B
], ef.prototype, "postConstruct", null);
var Xn = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const wN = 10;
let Ir = class extends H {
  constructor() {
    super(...arguments), this.destroyFuncsForColumnListeners = [], this.rowCtrlsByRowIndex = {}, this.zombieRowCtrls = {}, this.allRowCtrls = [], this.topRowCtrls = [], this.bottomRowCtrls = [], this.refreshInProgress = !1, this.dataFirstRenderedFired = !1;
  }
  postConstruct() {
    this.ctrlsService.whenReady(() => {
      this.gridBodyCtrl = this.ctrlsService.getGridBodyCtrl(), this.initialise();
    });
  }
  initialise() {
    if (this.addManagedListener(this.eventService, w.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this)), this.addManagedListener(this.eventService, w.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_BODY_SCROLL, this.onBodyScroll.bind(this)), this.addManagedListener(this.eventService, w.EVENT_BODY_HEIGHT_CHANGED, this.redraw.bind(this)), this.addManagedPropertyListener("domLayout", this.onDomLayoutChanged.bind(this)), this.addManagedPropertyListener("rowClass", this.redrawRows.bind(this)), this.gridOptionsService.isGroupRowsSticky()) {
      const e = this.rowModel.getType();
      (e === "clientSide" || e === "serverSide") && (this.stickyRowFeature = this.createManagedBean(new ef(this.createRowCon.bind(this), this.destroyRowCtrls.bind(this))));
    }
    this.registerCellEventListeners(), this.initialiseCache(), this.printLayout = this.gridOptionsService.isDomLayout("print"), this.embedFullWidthRows = this.printLayout || this.gridOptionsService.is("embedFullWidthRows"), this.redrawAfterModelUpdate();
  }
  initialiseCache() {
    if (this.gridOptionsService.is("keepDetailRows")) {
      const e = this.getKeepDetailRowsCount(), t = e != null ? e : 3;
      this.cachedRowCtrls = new EN(t);
    }
  }
  getKeepDetailRowsCount() {
    const e = this.gridOptionsService.getNum("keepDetailRowsCount");
    return z(e) && e > 0 ? e : wN;
  }
  getRowCtrls() {
    return this.allRowCtrls;
  }
  getStickyTopRowCtrls() {
    return this.stickyRowFeature ? this.stickyRowFeature.getStickyRowCtrls() : [];
  }
  updateAllRowCtrls() {
    const e = To(this.rowCtrlsByRowIndex), t = this.gridOptionsService.is("ensureDomOrder"), i = this.gridOptionsService.isDomLayout("print");
    (t || i) && e.sort((s, a) => s.getRowNode().rowIndex - a.getRowNode.rowIndex);
    const r = To(this.zombieRowCtrls), n = this.cachedRowCtrls ? this.cachedRowCtrls.getEntries() : [];
    this.allRowCtrls = [...e, ...r, ...n];
  }
  onCellFocusChanged(e) {
    this.getAllCellCtrls().forEach((t) => t.onCellFocused(e)), this.getFullWidthRowCtrls().forEach((t) => t.onFullWidthRowFocused(e));
  }
  // in a clean design, each cell would register for each of these events. however when scrolling, all the cells
  // registering and de-registering for events is a performance bottleneck. so we register here once and inform
  // all active cells.
  registerCellEventListeners() {
    this.addManagedListener(this.eventService, w.EVENT_CELL_FOCUSED, (t) => {
      this.onCellFocusChanged(t);
    }), this.addManagedListener(this.eventService, w.EVENT_CELL_FOCUS_CLEARED, () => {
      this.onCellFocusChanged();
    }), this.addManagedListener(this.eventService, w.EVENT_FLASH_CELLS, (t) => {
      this.getAllCellCtrls().forEach((i) => i.onFlashCells(t));
    }), this.addManagedListener(this.eventService, w.EVENT_COLUMN_HOVER_CHANGED, () => {
      this.getAllCellCtrls().forEach((t) => t.onColumnHover());
    }), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_CHANGED, () => {
      this.getAllCellCtrls().forEach((t) => t.onDisplayedColumnsChanged());
    }), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, () => {
      this.printLayout && this.getAllCellCtrls().forEach((t) => t.onLeftChanged());
    }), this.gridOptionsService.isEnableRangeSelection() && (this.addManagedListener(this.eventService, w.EVENT_RANGE_SELECTION_CHANGED, () => {
      this.getAllCellCtrls().forEach((t) => t.onRangeSelectionChanged());
    }), this.addManagedListener(this.eventService, w.EVENT_COLUMN_MOVED, () => {
      this.getAllCellCtrls().forEach((t) => t.updateRangeBordersIfRangeCount());
    }), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PINNED, () => {
      this.getAllCellCtrls().forEach((t) => t.updateRangeBordersIfRangeCount());
    }), this.addManagedListener(this.eventService, w.EVENT_COLUMN_VISIBLE, () => {
      this.getAllCellCtrls().forEach((t) => t.updateRangeBordersIfRangeCount());
    })), this.refreshListenersToColumnsForCellComps(), this.addManagedListener(this.eventService, w.EVENT_GRID_COLUMNS_CHANGED, this.refreshListenersToColumnsForCellComps.bind(this)), this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
  }
  // executes all functions in destroyFuncsForColumnListeners and then clears the list
  removeGridColumnListeners() {
    this.destroyFuncsForColumnListeners.forEach((e) => e()), this.destroyFuncsForColumnListeners.length = 0;
  }
  // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.
  // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to
  // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here
  // once instead.
  refreshListenersToColumnsForCellComps() {
    this.removeGridColumnListeners();
    const e = this.columnModel.getAllGridColumns();
    e && e.forEach((t) => {
      const i = (c) => {
        this.getAllCellCtrls().forEach((d) => {
          d.getColumn() === t && c(d);
        });
      }, r = () => {
        i((c) => c.onLeftChanged());
      }, n = () => {
        i((c) => c.onWidthChanged());
      }, s = () => {
        i((c) => c.onFirstRightPinnedChanged());
      }, a = () => {
        i((c) => c.onLastLeftPinnedChanged());
      }, l = () => {
        i((c) => c.onColDefChanged());
      };
      t.addEventListener("leftChanged", r), t.addEventListener("widthChanged", n), t.addEventListener("firstRightPinnedChanged", s), t.addEventListener("lastLeftPinnedChanged", a), t.addEventListener("colDefChanged", l), this.destroyFuncsForColumnListeners.push(() => {
        t.removeEventListener("leftChanged", r), t.removeEventListener("widthChanged", n), t.removeEventListener("firstRightPinnedChanged", s), t.removeEventListener("lastLeftPinnedChanged", a), t.removeEventListener("colDefChanged", l);
      });
    });
  }
  onDomLayoutChanged() {
    const e = this.gridOptionsService.isDomLayout("print"), t = e || this.gridOptionsService.is("embedFullWidthRows"), i = t !== this.embedFullWidthRows || this.printLayout !== e;
    this.printLayout = e, this.embedFullWidthRows = t, i && this.redrawAfterModelUpdate({ domLayoutChanged: !0 });
  }
  // for row models that have datasources, when we update the datasource, we need to force the rowRenderer
  // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.
  datasourceChanged() {
    this.firstRenderedRow = 0, this.lastRenderedRow = -1;
    const e = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(e);
  }
  onPageLoaded(e) {
    const t = {
      recycleRows: e.keepRenderedRows,
      animate: e.animate,
      newData: e.newData,
      newPage: e.newPage,
      // because this is a model updated event (not pinned rows), we
      // can skip updating the pinned rows. this is needed so that if user
      // is doing transaction updates, the pinned rows are not getting constantly
      // trashed - or editing cells in pinned rows are not refreshed and put into read mode
      onlyBody: !0
    };
    this.redrawAfterModelUpdate(t);
  }
  getAllCellsForColumn(e) {
    const t = [];
    return this.getAllRowCtrls().forEach((i) => {
      const r = i.getCellElement(e);
      r && t.push(r);
    }), t;
  }
  refreshFloatingRowComps() {
    this.refreshFloatingRows(this.topRowCtrls, this.pinnedRowModel.getPinnedTopRowData()), this.refreshFloatingRows(this.bottomRowCtrls, this.pinnedRowModel.getPinnedBottomRowData());
  }
  getTopRowCtrls() {
    return this.topRowCtrls;
  }
  getBottomRowCtrls() {
    return this.bottomRowCtrls;
  }
  refreshFloatingRows(e, t) {
    e.forEach((i) => {
      i.destroyFirstPass(), i.destroySecondPass();
    }), e.length = 0, t && t.forEach((i) => {
      const r = new Gn(i, this.beans, !1, !1, this.printLayout);
      e.push(r);
    });
  }
  onPinnedRowDataChanged() {
    const e = {
      recycleRows: !0
    };
    this.redrawAfterModelUpdate(e);
  }
  // if the row nodes are not rendered, no index is returned
  getRenderedIndexesForRowNodes(e) {
    const t = [];
    return Se(e) || Ct(this.rowCtrlsByRowIndex, (i, r) => {
      const n = r.getRowNode();
      e.indexOf(n) >= 0 && t.push(i);
    }), t;
  }
  redrawRows(e) {
    const t = e != null && e.length > 0;
    if (t) {
      const i = this.getRenderedIndexesForRowNodes(e);
      this.removeRowCtrls(i);
    }
    this.redrawAfterModelUpdate({
      recycleRows: t
    });
  }
  getCellToRestoreFocusToAfterRefresh(e) {
    const t = e != null && e.suppressKeepFocus ? null : this.focusService.getFocusCellToUseAfterRefresh();
    if (t == null)
      return null;
    const r = this.gridOptionsService.getDocument().activeElement, n = this.gridOptionsService.getDomData(r, un.DOM_DATA_KEY_CELL_CTRL), s = this.gridOptionsService.getDomData(r, Gn.DOM_DATA_KEY_ROW_CTRL);
    return n || s ? t : null;
  }
  // gets called from:
  // +) initialisation (in registerGridComp) params = null
  // +) onDomLayoutChanged, params = null
  // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true
  // +) onPinnedRowDataChanged, recycleRows = true
  // +) redrawRows (from Grid API), recycleRows = true/false
  redrawAfterModelUpdate(e = {}) {
    this.getLockOnRefresh();
    const t = this.getCellToRestoreFocusToAfterRefresh(e);
    this.updateContainerHeights(), this.scrollToTopIfNewData(e);
    const i = !e.domLayoutChanged && !!e.recycleRows, r = e.animate && this.gridOptionsService.isAnimateRows(), n = i ? this.getRowsToRecycle() : null;
    i || this.removeAllRowComps(), this.recycleRows(n, r), this.gridBodyCtrl.updateRowCount(), e.onlyBody || this.refreshFloatingRowComps(), this.dispatchDisplayedRowsChanged(), t != null && this.restoreFocusedCell(t), this.releaseLockOnRefresh();
  }
  scrollToTopIfNewData(e) {
    const t = e.newData || e.newPage, i = this.gridOptionsService.is("suppressScrollOnNewData");
    t && !i && this.gridBodyCtrl.getScrollFeature().scrollToTop();
  }
  updateContainerHeights() {
    if (this.printLayout) {
      this.rowContainerHeightService.setModelHeight(null);
      return;
    }
    let e = this.paginationProxy.getCurrentPageHeight();
    e === 0 && (e = 1), this.rowContainerHeightService.setModelHeight(e);
  }
  getLockOnRefresh() {
    if (this.refreshInProgress)
      throw new Error("AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. Your code probably called a grid API method while the grid was in the render stage. To overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). To see what part of your code that caused the refresh check this stacktrace.");
    this.refreshInProgress = !0;
  }
  releaseLockOnRefresh() {
    this.refreshInProgress = !1;
  }
  isRefreshInProgress() {
    return this.refreshInProgress;
  }
  // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
  // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
  // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
  // edited cell).
  restoreFocusedCell(e) {
    e && (this.focusService.setRestoreFocusedCell(e), this.onCellFocusChanged({
      rowIndex: e.rowIndex,
      column: e.column,
      rowPinned: e.rowPinned,
      forceBrowserFocus: !0,
      preventScrollOnBrowserFocus: !0,
      api: this.beans.gridApi,
      columnApi: this.beans.columnApi,
      context: this.beans.gridOptionsService.context,
      type: "mock"
    }));
  }
  stopEditing(e = !1) {
    this.getAllRowCtrls().forEach((t) => {
      t.stopEditing(e);
    });
  }
  getAllCellCtrls() {
    const e = [], t = this.getAllRowCtrls(), i = t.length;
    for (let r = 0; r < i; r++) {
      const n = t[r].getAllCellCtrls(), s = n.length;
      for (let a = 0; a < s; a++)
        e.push(n[a]);
    }
    return e;
  }
  getAllRowCtrls() {
    const e = this.stickyRowFeature && this.stickyRowFeature.getStickyRowCtrls() || [], t = [...this.topRowCtrls, ...this.bottomRowCtrls, ...e];
    for (const i of Object.keys(this.rowCtrlsByRowIndex))
      t.push(this.rowCtrlsByRowIndex[i]);
    return t;
  }
  addRenderedRowListener(e, t, i) {
    const r = this.rowCtrlsByRowIndex[t];
    r && r.addEventListener(e, i);
  }
  flashCells(e = {}) {
    const { flashDelay: t, fadeDelay: i } = e;
    this.getCellCtrls(e.rowNodes, e.columns).forEach((r) => r.flashCell({ flashDelay: t, fadeDelay: i }));
  }
  refreshCells(e = {}) {
    const t = {
      forceRefresh: e.force,
      newData: !1,
      suppressFlash: e.suppressFlash
    };
    this.getCellCtrls(e.rowNodes, e.columns).forEach((i) => {
      if (i.refreshShouldDestroy()) {
        const r = i.getRowCtrl();
        r && r.refreshCell(i);
      } else
        i.refreshCell(t);
    }), this.refreshFullWidthRows(e.rowNodes);
  }
  getCellRendererInstances(e) {
    var t;
    const i = this.getCellCtrls(e.rowNodes, e.columns).map((s) => s.getCellRenderer()).filter((s) => s != null);
    if (!((t = e.columns) === null || t === void 0) && t.length)
      return i;
    const r = [], n = this.mapRowNodes(e.rowNodes);
    return this.getAllRowCtrls().forEach((s) => {
      if (n && !this.isRowInMap(s.getRowNode(), n) || !s.isFullWidth())
        return;
      const a = s.getFullWidthCellRenderer();
      a && r.push(a);
    }), [...r, ...i];
  }
  getCellEditorInstances(e) {
    const t = [];
    return this.getCellCtrls(e.rowNodes, e.columns).forEach((i) => {
      const r = i.getCellEditor();
      r && t.push(r);
    }), t;
  }
  getEditingCells() {
    const e = [];
    return this.getAllCellCtrls().forEach((t) => {
      if (t.isEditing()) {
        const i = t.getCellPosition();
        e.push(i);
      }
    }), e;
  }
  mapRowNodes(e) {
    if (!e)
      return;
    const t = {
      top: {},
      bottom: {},
      normal: {}
    };
    return e.forEach((i) => {
      const r = i.id;
      i.rowPinned === "top" ? t.top[r] = i : i.rowPinned === "bottom" ? t.bottom[r] = i : t.normal[r] = i;
    }), t;
  }
  isRowInMap(e, t) {
    const i = e.id, r = e.rowPinned;
    return r === "bottom" ? t.bottom[i] != null : r === "top" ? t.top[i] != null : t.normal[i] != null;
  }
  // returns CellCtrl's that match the provided rowNodes and columns. eg if one row node
  // and two columns provided, that identifies 4 cells, so 4 CellCtrl's returned.
  getCellCtrls(e, t) {
    const i = this.mapRowNodes(e), r = [];
    let n;
    z(t) && (n = {}, t.forEach((a) => {
      const l = this.columnModel.getGridColumn(a);
      z(l) && (n[l.getId()] = !0);
    }));
    const s = (a) => {
      const l = a.getRowNode();
      i != null && !this.isRowInMap(l, i) || a.getAllCellCtrls().forEach((c) => {
        const d = c.getColumn().getId();
        n && !n[d] || r.push(c);
      });
    };
    return this.getAllRowCtrls().forEach((a) => s(a)), r;
  }
  destroy() {
    this.removeAllRowComps(), super.destroy();
  }
  removeAllRowComps() {
    const e = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(e);
  }
  getRowsToRecycle() {
    const e = [];
    Ct(this.rowCtrlsByRowIndex, (i, r) => {
      r.getRowNode().id == null && e.push(i);
    }), this.removeRowCtrls(e);
    const t = {};
    return Ct(this.rowCtrlsByRowIndex, (i, r) => {
      const n = r.getRowNode();
      t[n.id] = r;
    }), this.rowCtrlsByRowIndex = {}, t;
  }
  // takes array of row indexes
  removeRowCtrls(e) {
    e.forEach((t) => {
      const i = this.rowCtrlsByRowIndex[t];
      i && (i.destroyFirstPass(), i.destroySecondPass()), delete this.rowCtrlsByRowIndex[t];
    });
  }
  onBodyScroll(e) {
    e.direction === "vertical" && this.redraw();
  }
  // gets called when rows don't change, but viewport does, so after:
  // 1) height of grid body changes, ie number of displayed rows has changed
  // 2) grid scrolled to new position
  // 3) ensure index visible (which is a scroll)
  redraw(e = !0) {
    let t;
    if (this.stickyRowFeature && Vv() && (t = this.getCellToRestoreFocusToAfterRefresh() || void 0), this.getLockOnRefresh(), this.recycleRows(null, !1, e), this.releaseLockOnRefresh(), this.dispatchDisplayedRowsChanged(e), t != null) {
      const i = this.getCellToRestoreFocusToAfterRefresh();
      t != null && i == null && (this.animationFrameService.flushAllFrames(), this.restoreFocusedCell(t));
    }
  }
  removeRowCompsNotToDraw(e) {
    const t = {};
    e.forEach((n) => t[n] = !0);
    const r = Object.keys(this.rowCtrlsByRowIndex).filter((n) => !t[n]);
    this.removeRowCtrls(r);
  }
  calculateIndexesToDraw(e) {
    let t = xT(this.firstRenderedRow, this.lastRenderedRow);
    const i = (r, n) => {
      const s = n.getRowNode().rowIndex;
      s != null && (s < this.firstRenderedRow || s > this.lastRenderedRow) && this.doNotUnVirtualiseRow(n) && t.push(s);
    };
    return Ct(this.rowCtrlsByRowIndex, i), Ct(e, i), t.sort((r, n) => r - n), t = t.filter((r) => {
      const n = this.paginationProxy.getRow(r);
      return n && !n.sticky;
    }), t;
  }
  recycleRows(e, t = !1, i = !1) {
    this.rowContainerHeightService.updateOffset(), this.workOutFirstAndLastRowsToRender(), this.stickyRowFeature && this.stickyRowFeature.checkStickyRows();
    const r = this.calculateIndexesToDraw(e);
    this.removeRowCompsNotToDraw(r), this.printLayout && (t = !1), r.forEach((n) => {
      this.createOrUpdateRowCtrl(n, e, t, i);
    }), e && (i && !this.gridOptionsService.is("suppressAnimationFrame") && !this.printLayout ? this.beans.animationFrameService.addDestroyTask(() => {
      this.destroyRowCtrls(e, t), this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
    }) : this.destroyRowCtrls(e, t)), this.updateAllRowCtrls();
  }
  dispatchDisplayedRowsChanged(e = !1) {
    const t = { type: w.EVENT_DISPLAYED_ROWS_CHANGED, afterScroll: e };
    this.eventService.dispatchEvent(t);
  }
  onDisplayedColumnsChanged() {
    const e = this.columnModel.isPinningLeft(), t = this.columnModel.isPinningRight();
    (this.pinningLeft !== e || t !== this.pinningRight) && (this.pinningLeft = e, this.pinningRight = t, this.embedFullWidthRows && this.redrawFullWidthEmbeddedRows());
  }
  // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,
  // then it should go into the pinned left area if pinning left, or the center area if not pinning.
  redrawFullWidthEmbeddedRows() {
    const e = [];
    this.getFullWidthRowCtrls().forEach((t) => {
      const i = t.getRowNode().rowIndex;
      e.push(i.toString());
    }), this.refreshFloatingRowComps(), this.removeRowCtrls(e), this.redraw();
  }
  getFullWidthRowCtrls(e) {
    const t = this.mapRowNodes(e);
    return this.getAllRowCtrls().filter((i) => {
      if (!i.isFullWidth())
        return !1;
      const r = i.getRowNode();
      return !(t != null && !this.isRowInMap(r, t));
    });
  }
  refreshFullWidthRow(e) {
    this.refreshFullWidthRows([e]);
  }
  refreshFullWidthRows(e) {
    const t = this.getFullWidthRowCtrls(e);
    let i = !1;
    const r = [];
    t.forEach((n) => {
      if (n.refreshFullWidth())
        return;
      const a = n.getRowNode();
      a.sticky ? this.stickyRowFeature.refreshStickyNode(a) : r.push(a.rowIndex), i = !0;
    }), r.length > 0 && this.removeRowCtrls(r), i && this.redraw(!1);
  }
  createOrUpdateRowCtrl(e, t, i, r) {
    let n, s = this.rowCtrlsByRowIndex[e];
    if (s || (n = this.paginationProxy.getRow(e), z(n) && z(t) && t[n.id] && n.alreadyRendered && (s = t[n.id], t[n.id] = null)), !s)
      if (n || (n = this.paginationProxy.getRow(e)), z(n))
        s = this.createRowCon(n, i, r);
      else
        return;
    return n && (n.alreadyRendered = !0), this.rowCtrlsByRowIndex[e] = s, s;
  }
  destroyRowCtrls(e, t) {
    const i = [];
    Ct(e, (r, n) => {
      if (n) {
        if (this.cachedRowCtrls && n.isCacheable()) {
          this.cachedRowCtrls.addRow(n);
          return;
        }
        n.destroyFirstPass(), t ? (this.zombieRowCtrls[n.getInstanceId()] = n, i.push(() => {
          n.destroySecondPass(), delete this.zombieRowCtrls[n.getInstanceId()];
        })) : n.destroySecondPass();
      }
    }), t && (i.push(() => {
      this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
    }), HR(i));
  }
  getRowBuffer() {
    let e = this.gridOptionsService.getNum("rowBuffer");
    return typeof e == "number" ? e < 0 && (tt(() => console.warn("AG Grid: rowBuffer should not be negative"), "warn rowBuffer negative"), e = 0, this.gridOptionsService.set("rowBuffer", 0)) : e = 10, e;
  }
  getRowBufferInPixels() {
    const e = this.getRowBuffer(), t = this.gridOptionsService.getRowHeightAsNumber();
    return e * t;
  }
  workOutFirstAndLastRowsToRender() {
    let e, t;
    if (!this.paginationProxy.isRowsToRender())
      e = 0, t = -1;
    else if (this.printLayout)
      e = this.paginationProxy.getPageFirstRow(), t = this.paginationProxy.getPageLastRow();
    else {
      const l = this.getRowBufferInPixels(), c = this.ctrlsService.getGridBodyCtrl(), d = this.gridOptionsService.is("suppressRowVirtualisation");
      let u = !1, h, p;
      do {
        const m = this.paginationProxy.getPixelOffset(), { pageFirstPixel: C, pageLastPixel: R } = this.paginationProxy.getCurrentPagePixelRange(), E = this.rowContainerHeightService.getDivStretchOffset(), b = c.getScrollFeature().getVScrollPosition(), T = b.top, D = b.bottom;
        d ? (h = C + E, p = R + E) : (h = Math.max(T + m - l, C) + E, p = Math.min(D + m + l, R) + E), this.firstVisibleVPixel = Math.max(T + m, C) + E, u = this.ensureAllRowsInRangeHaveHeightsCalculated(h, p);
      } while (u);
      let f = this.paginationProxy.getRowIndexAtPixel(h), g = this.paginationProxy.getRowIndexAtPixel(p);
      const v = this.paginationProxy.getPageFirstRow(), y = this.paginationProxy.getPageLastRow();
      f < v && (f = v), g > y && (g = y), e = f, t = g;
    }
    const i = this.gridOptionsService.isDomLayout("normal"), r = this.gridOptionsService.is("suppressMaxRenderedRowRestriction"), n = Math.max(this.getRowBuffer(), 500);
    i && !r && t - e > n && (t = e + n);
    const s = e !== this.firstRenderedRow, a = t !== this.lastRenderedRow;
    if (s || a) {
      this.firstRenderedRow = e, this.lastRenderedRow = t;
      const l = {
        type: w.EVENT_VIEWPORT_CHANGED,
        firstRow: e,
        lastRow: t
      };
      this.eventService.dispatchEvent(l);
    }
  }
  /**
   * This event will only be fired once, and is queued until after the browser next renders.
   * This allows us to fire an event during the start of the render cycle, when we first see data being rendered
   * but not execute the event until all of the data has finished being rendered to the dom.
   */
  dispatchFirstDataRenderedEvent() {
    if (this.dataFirstRenderedFired)
      return;
    this.dataFirstRenderedFired = !0;
    const e = {
      type: w.EVENT_FIRST_DATA_RENDERED,
      firstRow: this.firstRenderedRow,
      lastRow: this.lastRenderedRow
    };
    window.requestAnimationFrame(() => {
      this.beans.eventService.dispatchEvent(e);
    });
  }
  ensureAllRowsInRangeHaveHeightsCalculated(e, t) {
    const i = this.paginationProxy.ensureRowHeightsValid(e, t, -1, -1);
    return i && this.updateContainerHeights(), i;
  }
  getFirstVisibleVerticalPixel() {
    return this.firstVisibleVPixel;
  }
  getFirstVirtualRenderedRow() {
    return this.firstRenderedRow;
  }
  getLastVirtualRenderedRow() {
    return this.lastRenderedRow;
  }
  // check that none of the rows to remove are editing or focused as:
  // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,
  //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered
  //    the edit is reset - so we want to keep it rendered.
  // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,
  //    otherwise the user can range select and drag (with focus cell going out of the viewport)
  //    and then ctrl+c, nothing will happen if cell is removed from dom.
  // c) if detail record of master detail, as users complained that the context of detail rows
  //    was getting lost when detail row out of view. eg user expands to show detail row,
  //    then manipulates the detail panel (eg sorts the detail grid), then context is lost
  //    after detail panel is scrolled out of / into view.
  doNotUnVirtualiseRow(e) {
    const r = e.getRowNode(), n = this.focusService.isRowNodeFocused(r), s = e.isEditing(), a = r.detail;
    return n || s || a ? !!this.paginationProxy.isRowPresent(r) : !1;
  }
  createRowCon(e, t, i) {
    const r = this.cachedRowCtrls ? this.cachedRowCtrls.getRow(e) : null;
    if (r)
      return r;
    const n = this.gridOptionsService.is("suppressAnimationFrame"), s = i && !n && !this.printLayout;
    return new Gn(e, this.beans, t, s, this.printLayout);
  }
  getRenderedNodes() {
    const e = this.rowCtrlsByRowIndex;
    return Object.keys(e).map((t) => e[t].getRowNode());
  }
  getRowByPosition(e) {
    let t;
    const { rowIndex: i } = e;
    switch (e.rowPinned) {
      case "top":
        t = this.topRowCtrls[i];
        break;
      case "bottom":
        t = this.bottomRowCtrls[i];
        break;
      default:
        t = this.rowCtrlsByRowIndex[i], t || (t = this.getStickyTopRowCtrls().find((r) => r.getRowNode().rowIndex === i) || null);
        break;
    }
    return t;
  }
  getRowNode(e) {
    switch (e.rowPinned) {
      case "top":
        return this.pinnedRowModel.getPinnedTopRowData()[e.rowIndex];
      case "bottom":
        return this.pinnedRowModel.getPinnedBottomRowData()[e.rowIndex];
      default:
        return this.rowModel.getRow(e.rowIndex);
    }
  }
  // returns true if any row between startIndex and endIndex is rendered. used by
  // SSRM or IRM, as they don't want to purge visible blocks from cache.
  isRangeInRenderedViewport(e, t) {
    if (e == null || t == null)
      return !1;
    const r = e > this.lastRenderedRow;
    return !(t < this.firstRenderedRow) && !r;
  }
};
Xn([
  S("animationFrameService")
], Ir.prototype, "animationFrameService", void 0);
Xn([
  S("paginationProxy")
], Ir.prototype, "paginationProxy", void 0);
Xn([
  S("columnModel")
], Ir.prototype, "columnModel", void 0);
Xn([
  S("pinnedRowModel")
], Ir.prototype, "pinnedRowModel", void 0);
Xn([
  S("rowModel")
], Ir.prototype, "rowModel", void 0);
Xn([
  S("focusService")
], Ir.prototype, "focusService", void 0);
Xn([
  S("beans")
], Ir.prototype, "beans", void 0);
Xn([
  S("rowContainerHeightService")
], Ir.prototype, "rowContainerHeightService", void 0);
Xn([
  S("ctrlsService")
], Ir.prototype, "ctrlsService", void 0);
Xn([
  B
], Ir.prototype, "postConstruct", null);
Ir = Xn([
  q("rowRenderer")
], Ir);
class EN {
  constructor(e) {
    this.entriesMap = {}, this.entriesList = [], this.maxCount = e;
  }
  addRow(e) {
    if (this.entriesMap[e.getRowNode().id] = e, this.entriesList.push(e), e.setCached(!0), this.entriesList.length > this.maxCount) {
      const t = this.entriesList[0];
      t.destroyFirstPass(), t.destroySecondPass(), this.removeFromCache(t);
    }
  }
  getRow(e) {
    if (e == null || e.id == null)
      return null;
    const t = this.entriesMap[e.id];
    return t ? (this.removeFromCache(t), t.setCached(!1), t.getRowNode() != e ? null : t) : null;
  }
  removeFromCache(e) {
    const t = e.getRowNode().id;
    delete this.entriesMap[t], Ni(this.entriesList, e);
  }
  getEntries() {
    return this.entriesList;
  }
}
var Cx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let _g = class extends H {
  formatValue(e, t, i, r, n = !0) {
    let s = null, a;
    const l = e.getColDef();
    if (r ? a = r : n && (a = l.valueFormatter), a) {
      const c = {
        value: i,
        node: t,
        data: t ? t.data : null,
        colDef: l,
        column: e,
        api: this.gridOptionsService.api,
        columnApi: this.gridOptionsService.columnApi,
        context: this.gridOptionsService.context
      };
      typeof a == "function" ? s = a(c) : s = this.expressionService.evaluate(a, c);
    } else if (l.refData)
      return l.refData[i] || "";
    return s == null && Array.isArray(i) && (s = i.join(", ")), s;
  }
};
Cx([
  S("expressionService")
], _g.prototype, "expressionService", void 0);
_g = Cx([
  q("valueFormatterService")
], _g);
var wb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let $h = class extends H {
  init() {
    this.setPinnedTopRowData(this.gridOptionsService.get("pinnedTopRowData")), this.setPinnedBottomRowData(this.gridOptionsService.get("pinnedBottomRowData"));
  }
  isEmpty(e) {
    const t = e === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
    return br(t);
  }
  isRowsToRender(e) {
    return !this.isEmpty(e);
  }
  getRowAtPixel(e, t) {
    const i = t === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
    if (br(i))
      return 0;
    for (let r = 0; r < i.length; r++) {
      const n = i[r];
      if (n.rowTop + n.rowHeight - 1 >= e)
        return r;
    }
    return i.length - 1;
  }
  setPinnedTopRowData(e) {
    this.pinnedTopRows = this.createNodesFromData(e, !0);
    const t = {
      type: w.EVENT_PINNED_ROW_DATA_CHANGED
    };
    this.eventService.dispatchEvent(t);
  }
  setPinnedBottomRowData(e) {
    this.pinnedBottomRows = this.createNodesFromData(e, !1);
    const t = {
      type: w.EVENT_PINNED_ROW_DATA_CHANGED
    };
    this.eventService.dispatchEvent(t);
  }
  createNodesFromData(e, t) {
    const i = [];
    if (e) {
      let r = 0;
      e.forEach((n, s) => {
        const a = new re(this.beans);
        a.data = n;
        const l = t ? re.ID_PREFIX_TOP_PINNED : re.ID_PREFIX_BOTTOM_PINNED;
        a.id = l + s, a.rowPinned = t ? "top" : "bottom", a.setRowTop(r), a.setRowHeight(this.gridOptionsService.getRowHeightForNode(a).height), a.setRowIndex(s), r += a.rowHeight, i.push(a);
      });
    }
    return i;
  }
  getPinnedTopRowData() {
    return this.pinnedTopRows;
  }
  getPinnedBottomRowData() {
    return this.pinnedBottomRows;
  }
  getPinnedTopTotalHeight() {
    return this.getTotalHeight(this.pinnedTopRows);
  }
  getPinnedTopRowCount() {
    return this.pinnedTopRows ? this.pinnedTopRows.length : 0;
  }
  getPinnedBottomRowCount() {
    return this.pinnedBottomRows ? this.pinnedBottomRows.length : 0;
  }
  getPinnedTopRow(e) {
    return this.pinnedTopRows[e];
  }
  getPinnedBottomRow(e) {
    return this.pinnedBottomRows[e];
  }
  forEachPinnedTopRow(e) {
    br(this.pinnedTopRows) || this.pinnedTopRows.forEach(e);
  }
  forEachPinnedBottomRow(e) {
    br(this.pinnedBottomRows) || this.pinnedBottomRows.forEach(e);
  }
  getPinnedBottomTotalHeight() {
    return this.getTotalHeight(this.pinnedBottomRows);
  }
  getTotalHeight(e) {
    if (!e || e.length === 0)
      return 0;
    const t = at(e);
    return t.rowTop + t.rowHeight;
  }
};
wb([
  S("beans")
], $h.prototype, "beans", void 0);
wb([
  B
], $h.prototype, "init", null);
$h = wb([
  q("pinnedRowModel")
], $h);
var tr;
(function(o) {
  o.Applied = "Applied", o.StoreNotFound = "StoreNotFound", o.StoreLoading = "StoreLoading", o.StoreWaitingToLoad = "StoreWaitingToLoad", o.StoreLoadingFailed = "StoreLoadingFailed", o.StoreWrongType = "StoreWrongType", o.Cancelled = "Cancelled";
})(tr || (tr = {}));
class dm {
  constructor(e, t) {
    this.active = !0, this.nodeIdsToColumns = {}, this.mapToItems = {}, this.keepingColumns = e, this.pathRoot = {
      rowNode: t,
      children: null
    }, this.mapToItems[t.id] = this.pathRoot;
  }
  // can be set inactive by:
  // a) ClientSideRowModel, if no transactions or
  // b) PivotService, if secondary columns changed
  setInactive() {
    this.active = !1;
  }
  isActive() {
    return this.active;
  }
  depthFirstSearchChangedPath(e, t) {
    if (e.children)
      for (let i = 0; i < e.children.length; i++)
        this.depthFirstSearchChangedPath(e.children[i], t);
    t(e.rowNode);
  }
  depthFirstSearchEverything(e, t, i) {
    if (e.childrenAfterGroup)
      for (let r = 0; r < e.childrenAfterGroup.length; r++) {
        const n = e.childrenAfterGroup[r];
        n.childrenAfterGroup ? this.depthFirstSearchEverything(e.childrenAfterGroup[r], t, i) : i && t(n);
      }
    t(e);
  }
  // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback
  // will be called for child nodes in addition to parent nodes.
  forEachChangedNodeDepthFirst(e, t = !1, i = !1) {
    this.active && !i ? this.depthFirstSearchChangedPath(this.pathRoot, e) : this.depthFirstSearchEverything(this.pathRoot.rowNode, e, t);
  }
  executeFromRootNode(e) {
    e(this.pathRoot.rowNode);
  }
  createPathItems(e) {
    let t = e, i = 0;
    for (; !this.mapToItems[t.id]; ) {
      const r = {
        rowNode: t,
        children: null
      };
      this.mapToItems[t.id] = r, i++, t = t.parent;
    }
    return i;
  }
  populateColumnsMap(e, t) {
    if (!this.keepingColumns || !t)
      return;
    let i = e;
    for (; i; )
      this.nodeIdsToColumns[i.id] || (this.nodeIdsToColumns[i.id] = {}), t.forEach((r) => this.nodeIdsToColumns[i.id][r.getId()] = !0), i = i.parent;
  }
  linkPathItems(e, t) {
    let i = e;
    for (let r = 0; r < t; r++) {
      const n = this.mapToItems[i.id], s = this.mapToItems[i.parent.id];
      s.children || (s.children = []), s.children.push(n), i = i.parent;
    }
  }
  // called by
  // 1) change detection (provides cols) and
  // 2) groupStage if doing transaction update (doesn't provide cols)
  addParentNode(e, t) {
    if (!e || e.isRowPinned())
      return;
    const i = this.createPathItems(e);
    this.linkPathItems(e, i), this.populateColumnsMap(e, t);
  }
  canSkip(e) {
    return this.active && !this.mapToItems[e.id];
  }
  getValueColumnsForNode(e, t) {
    if (!this.keepingColumns)
      return t;
    const i = this.nodeIdsToColumns[e.id];
    return t.filter((n) => i[n.getId()]);
  }
  getNotValueColumnsForNode(e, t) {
    if (!this.keepingColumns)
      return null;
    const i = this.nodeIdsToColumns[e.id];
    return t.filter((n) => !i[n.getId()]);
  }
}
class Gt extends H {
  constructor(e) {
    super(), this.state = Gt.STATE_WAITING_TO_LOAD, this.version = 0, this.id = e;
  }
  getId() {
    return this.id;
  }
  load() {
    this.state = Gt.STATE_LOADING, this.loadFromDatasource();
  }
  getVersion() {
    return this.version;
  }
  setStateWaitingToLoad() {
    this.version++, this.state = Gt.STATE_WAITING_TO_LOAD;
  }
  getState() {
    return this.state;
  }
  pageLoadFailed(e) {
    this.isRequestMostRecentAndLive(e) && (this.state = Gt.STATE_FAILED, this.processServerFail()), this.dispatchLoadCompleted(!1);
  }
  success(e, t) {
    this.successCommon(e, t);
  }
  pageLoaded(e, t, i) {
    this.successCommon(e, { rowData: t, rowCount: i });
  }
  isRequestMostRecentAndLive(e) {
    const t = e === this.version, i = this.isAlive();
    return t && i;
  }
  successCommon(e, t) {
    this.dispatchLoadCompleted(), this.isRequestMostRecentAndLive(e) && (this.state = Gt.STATE_LOADED, this.processServerResult(t));
  }
  dispatchLoadCompleted(e = !0) {
    const t = {
      type: Gt.EVENT_LOAD_COMPLETE,
      success: e,
      block: this
    };
    this.dispatchEvent(t);
  }
}
Gt.EVENT_LOAD_COMPLETE = "loadComplete";
Gt.STATE_WAITING_TO_LOAD = "needsLoading";
Gt.STATE_LOADING = "loading";
Gt.STATE_LOADED = "loaded";
Gt.STATE_FAILED = "failed";
var um = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, RN = function(o, e) {
  return function(t, i) {
    e(t, i, o);
  };
}, hg;
let Es = hg = class extends H {
  constructor() {
    super(...arguments), this.activeBlockLoadsCount = 0, this.blocks = [], this.active = !0;
  }
  postConstruct() {
    this.maxConcurrentRequests = this.getMaxConcurrentDatasourceRequests();
    const e = this.gridOptionsService.getNum("blockLoadDebounceMillis");
    e && e > 0 && (this.checkBlockToLoadDebounce = x.debounce(this.performCheckBlocksToLoad.bind(this), e));
  }
  setBeans(e) {
    this.logger = e.create("RowNodeBlockLoader");
  }
  getMaxConcurrentDatasourceRequests() {
    const e = this.gridOptionsService.getNum("maxConcurrentDatasourceRequests");
    if (e == null)
      return 2;
    if (!(e <= 0))
      return e;
  }
  addBlock(e) {
    this.blocks.push(e), e.addEventListener(Gt.EVENT_LOAD_COMPLETE, this.loadComplete.bind(this)), this.checkBlockToLoad();
  }
  removeBlock(e) {
    x.removeFromArray(this.blocks, e);
  }
  destroy() {
    super.destroy(), this.active = !1;
  }
  loadComplete() {
    this.activeBlockLoadsCount--, this.checkBlockToLoad(), this.dispatchEvent({ type: hg.BLOCK_LOADED_EVENT }), this.activeBlockLoadsCount == 0 && this.dispatchEvent({ type: hg.BLOCK_LOADER_FINISHED_EVENT });
  }
  checkBlockToLoad() {
    this.checkBlockToLoadDebounce ? this.checkBlockToLoadDebounce() : this.performCheckBlocksToLoad();
  }
  performCheckBlocksToLoad() {
    if (!this.active)
      return;
    if (this.printCacheStatus(), this.maxConcurrentRequests != null && this.activeBlockLoadsCount >= this.maxConcurrentRequests) {
      this.logger.log("checkBlockToLoad: max loads exceeded");
      return;
    }
    const e = this.getAvailableLoadingCount(), t = this.blocks.filter((i) => i.getState() === Gt.STATE_WAITING_TO_LOAD).slice(0, e);
    this.registerLoads(t.length), t.forEach((i) => i.load()), this.printCacheStatus();
  }
  getBlockState() {
    if (this.gridOptionsService.isRowModelType("serverSide"))
      return this.rowModel.getBlockStates();
    const e = {};
    return this.blocks.forEach((t) => {
      const { id: i, state: r } = t.getBlockStateJson();
      e[i] = r;
    }), e;
  }
  printCacheStatus() {
    this.logger.isLogging() && this.logger.log(`printCacheStatus: activePageLoadsCount = ${this.activeBlockLoadsCount}, blocks = ${JSON.stringify(this.getBlockState())}`);
  }
  isLoading() {
    return this.activeBlockLoadsCount > 0;
  }
  registerLoads(e) {
    this.activeBlockLoadsCount += e;
  }
  getAvailableLoadingCount() {
    return this.maxConcurrentRequests !== void 0 ? this.maxConcurrentRequests - this.activeBlockLoadsCount : void 0;
  }
};
Es.BLOCK_LOADED_EVENT = "blockLoaded";
Es.BLOCK_LOADER_FINISHED_EVENT = "blockLoaderFinished";
um([
  S("rowModel")
], Es.prototype, "rowModel", void 0);
um([
  B
], Es.prototype, "postConstruct", null);
um([
  RN(0, qi("loggerFactory"))
], Es.prototype, "setBeans", null);
Es = hg = um([
  q("rowNodeBlockLoader")
], Es);
var Eb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let zh = class extends H {
  constructor() {
    super(...arguments), this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = 0, this.pixelOffset = 0, this.masterRowCount = 0;
  }
  postConstruct() {
    this.active = this.gridOptionsService.is("pagination"), this.paginateChildRows = this.isPaginateChildRows(), this.addManagedListener(this.eventService, w.EVENT_MODEL_UPDATED, this.onModelUpdated.bind(this)), this.addManagedPropertyListener("pagination", this.onPaginationPageSizeChanged.bind(this)), this.addManagedPropertyListener("paginationPageSize", this.onPaginationPageSizeChanged.bind(this)), this.onModelUpdated();
  }
  ensureRowHeightsValid(e, t, i, r) {
    const n = this.rowModel.ensureRowHeightsValid(e, t, this.getPageFirstRow(), this.getPageLastRow());
    return n && this.calculatePages(), n;
  }
  isPaginateChildRows() {
    return this.gridOptionsService.is("groupRemoveSingleChildren") || this.gridOptionsService.is("groupRemoveLowestSingleChildren") ? !0 : this.gridOptionsService.is("paginateChildRows");
  }
  onModelUpdated(e) {
    this.calculatePages();
    const t = {
      type: w.EVENT_PAGINATION_CHANGED,
      animate: e ? e.animate : !1,
      newData: e ? e.newData : !1,
      newPage: e ? e.newPage : !1,
      keepRenderedRows: e ? e.keepRenderedRows : !1
    };
    this.eventService.dispatchEvent(t);
  }
  onPaginationPageSizeChanged() {
    this.active = this.gridOptionsService.is("pagination"), this.calculatePages();
    const e = {
      type: w.EVENT_PAGINATION_CHANGED,
      animate: !1,
      newData: !1,
      newPage: !1,
      // important to keep rendered rows, otherwise every time grid is resized,
      // we would destroy all the rows.
      keepRenderedRows: !0
    };
    this.eventService.dispatchEvent(e);
  }
  goToPage(e) {
    if (!this.active || this.currentPage === e || typeof this.currentPage != "number")
      return;
    this.currentPage = e;
    const t = {
      type: w.EVENT_MODEL_UPDATED,
      animate: !1,
      keepRenderedRows: !1,
      newData: !1,
      newPage: !0
    };
    this.onModelUpdated(t);
  }
  getPixelOffset() {
    return this.pixelOffset;
  }
  getRow(e) {
    return this.rowModel.getRow(e);
  }
  getRowNode(e) {
    return this.rowModel.getRowNode(e);
  }
  getRowIndexAtPixel(e) {
    return this.rowModel.getRowIndexAtPixel(e);
  }
  getCurrentPageHeight() {
    return Se(this.topRowBounds) || Se(this.bottomRowBounds) ? 0 : Math.max(this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight - this.topRowBounds.rowTop, 0);
  }
  getCurrentPagePixelRange() {
    const e = this.topRowBounds ? this.topRowBounds.rowTop : 0, t = this.bottomRowBounds ? this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight : 0;
    return { pageFirstPixel: e, pageLastPixel: t };
  }
  isRowPresent(e) {
    return this.rowModel.isRowPresent(e) ? e.rowIndex >= this.topDisplayedRowIndex && e.rowIndex <= this.bottomDisplayedRowIndex : !1;
  }
  isEmpty() {
    return this.rowModel.isEmpty();
  }
  isRowsToRender() {
    return this.rowModel.isRowsToRender();
  }
  forEachNode(e) {
    return this.rowModel.forEachNode(e);
  }
  forEachNodeOnPage(e) {
    const t = this.getPageFirstRow(), i = this.getPageLastRow();
    for (let r = t; r <= i; r++) {
      const n = this.getRow(r);
      n && e(n);
    }
  }
  getType() {
    return this.rowModel.getType();
  }
  getRowBounds(e) {
    const t = this.rowModel.getRowBounds(e);
    return t.rowIndex = e, t;
  }
  getPageFirstRow() {
    return this.topRowBounds ? this.topRowBounds.rowIndex : -1;
  }
  getPageLastRow() {
    return this.bottomRowBounds ? this.bottomRowBounds.rowIndex : -1;
  }
  getRowCount() {
    return this.rowModel.getRowCount();
  }
  getPageForIndex(e) {
    return Math.floor(e / this.pageSize);
  }
  goToPageWithIndex(e) {
    if (!this.active)
      return;
    const t = this.getPageForIndex(e);
    this.goToPage(t);
  }
  isRowInPage(e) {
    return this.active ? this.getPageForIndex(e.rowIndex) === this.currentPage : !0;
  }
  isLastPageFound() {
    return this.rowModel.isLastRowIndexKnown();
  }
  getCurrentPage() {
    return this.currentPage;
  }
  goToNextPage() {
    this.goToPage(this.currentPage + 1);
  }
  goToPreviousPage() {
    this.goToPage(this.currentPage - 1);
  }
  goToFirstPage() {
    this.goToPage(0);
  }
  goToLastPage() {
    const e = this.rowModel.getRowCount(), t = Math.floor(e / this.pageSize);
    this.goToPage(t);
  }
  getPageSize() {
    return this.pageSize;
  }
  getTotalPages() {
    return this.totalPages;
  }
  setPageSize() {
    this.pageSize = this.gridOptionsService.getNum("paginationPageSize"), (this.pageSize == null || this.pageSize < 1) && (this.pageSize = 100);
  }
  calculatePages() {
    this.active ? (this.setPageSize(), this.paginateChildRows ? this.calculatePagesAllRows() : this.calculatePagesMasterRowsOnly()) : this.calculatedPagesNotActive(), this.topRowBounds = this.rowModel.getRowBounds(this.topDisplayedRowIndex), this.topRowBounds && (this.topRowBounds.rowIndex = this.topDisplayedRowIndex), this.bottomRowBounds = this.rowModel.getRowBounds(this.bottomDisplayedRowIndex), this.bottomRowBounds && (this.bottomRowBounds.rowIndex = this.bottomDisplayedRowIndex), this.setPixelOffset(z(this.topRowBounds) ? this.topRowBounds.rowTop : 0);
  }
  setPixelOffset(e) {
    this.pixelOffset !== e && (this.pixelOffset = e, this.eventService.dispatchEvent({ type: w.EVENT_PAGINATION_PIXEL_OFFSET_CHANGED }));
  }
  setZeroRows() {
    this.masterRowCount = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = -1, this.currentPage = 0, this.totalPages = 0;
  }
  adjustCurrentPageIfInvalid() {
    this.currentPage >= this.totalPages && (this.currentPage = this.totalPages - 1), (!isFinite(this.currentPage) || isNaN(this.currentPage) || this.currentPage < 0) && (this.currentPage = 0);
  }
  calculatePagesMasterRowsOnly() {
    if (this.masterRowCount = this.rowModel.getTopLevelRowCount(), this.masterRowCount <= 0) {
      this.setZeroRows();
      return;
    }
    const e = this.masterRowCount - 1;
    this.totalPages = Math.floor(e / this.pageSize) + 1, this.adjustCurrentPageIfInvalid();
    const t = this.pageSize * this.currentPage;
    let i = this.pageSize * (this.currentPage + 1) - 1;
    if (i > e && (i = e), this.topDisplayedRowIndex = this.rowModel.getTopLevelRowDisplayedIndex(t), i === e)
      this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
    else {
      const r = this.rowModel.getTopLevelRowDisplayedIndex(i + 1);
      this.bottomDisplayedRowIndex = r - 1;
    }
  }
  getMasterRowCount() {
    return this.masterRowCount;
  }
  calculatePagesAllRows() {
    if (this.masterRowCount = this.rowModel.getRowCount(), this.masterRowCount === 0) {
      this.setZeroRows();
      return;
    }
    const e = this.masterRowCount - 1;
    this.totalPages = Math.floor(e / this.pageSize) + 1, this.adjustCurrentPageIfInvalid(), this.topDisplayedRowIndex = this.pageSize * this.currentPage, this.bottomDisplayedRowIndex = this.pageSize * (this.currentPage + 1) - 1, this.bottomDisplayedRowIndex > e && (this.bottomDisplayedRowIndex = e);
  }
  calculatedPagesNotActive() {
    this.pageSize = this.rowModel.getRowCount(), this.totalPages = 1, this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
  }
};
Eb([
  S("rowModel")
], zh.prototype, "rowModel", void 0);
Eb([
  B
], zh.prototype, "postConstruct", null);
zh = Eb([
  q("paginationProxy")
], zh);
var Sx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Ig = class extends H {
  processAllCellClasses(e, t, i, r) {
    this.processClassRules(e.cellClassRules, t, i, r), this.processStaticCellClasses(e, t, i);
  }
  processClassRules(e, t, i, r) {
    if (e == null)
      return;
    const n = Object.keys(e), s = {}, a = {};
    for (let l = 0; l < n.length; l++) {
      const c = n[l], d = e[c];
      let u;
      typeof d == "string" ? u = this.expressionService.evaluate(d, t) : typeof d == "function" && (u = d(t)), c.split(" ").forEach((h) => {
        h == null || h.trim() == "" || (u ? s[h] = !0 : a[h] = !0);
      });
    }
    r && Object.keys(a).forEach(r), Object.keys(s).forEach(i);
  }
  getStaticCellClasses(e, t) {
    const { cellClass: i } = e;
    if (!i)
      return [];
    let r;
    return typeof i == "function" ? r = i(t) : r = i, typeof r == "string" && (r = [r]), r || [];
  }
  processStaticCellClasses(e, t, i) {
    this.getStaticCellClasses(e, t).forEach((n) => {
      i(n);
    });
  }
};
Sx([
  S("expressionService")
], Ig.prototype, "expressionService", void 0);
Ig = Sx([
  q("stylingService")
], Ig);
class Rb extends rr {
  constructor(e) {
    super(e, "ag-toggle-button");
  }
  setValue(e, t) {
    return super.setValue(e, t), this.addOrRemoveCssClass("ag-selected", this.getValue()), this;
  }
}
class TN extends Nn {
  constructor(e) {
    super(e, "ag-text-area", null, "textarea");
  }
  setValue(e, t) {
    const i = super.setValue(e, t);
    return this.eInput.value = e, i;
  }
  setCols(e) {
    return this.eInput.cols = e, this;
  }
  setRows(e) {
    return this.eInput.rows = e, this;
  }
}
class xN extends Na {
  constructor(e) {
    super(e, "ag-date-field", "date");
  }
  postConstruct() {
    super.postConstruct(), this.addManagedListener(this.eInput, "wheel", this.onWheel.bind(this));
    const e = fn();
    this.addManagedListener(this.eInput, "mousedown", () => {
      this.isDisabled() || e || this.eInput.focus();
    }), this.eInput.step = "any";
  }
  onWheel(e) {
    document.activeElement === this.eInput && e.preventDefault();
  }
  setMin(e) {
    var t;
    const i = e instanceof Date ? (t = cn(e != null ? e : null, !1)) !== null && t !== void 0 ? t : void 0 : e;
    return this.min === i ? this : (this.min = i, da(this.eInput, "min", i), this);
  }
  setMax(e) {
    var t;
    const i = e instanceof Date ? (t = cn(e != null ? e : null, !1)) !== null && t !== void 0 ? t : void 0 : e;
    return this.max === i ? this : (this.max = i, da(this.eInput, "max", i), this);
  }
  setStep(e) {
    return this.step === e ? this : (this.step = e, da(this.eInput, "step", e), this);
  }
  getDate() {
    var e;
    if (this.eInput.validity.valid)
      return (e = Vn(this.getValue())) !== null && e !== void 0 ? e : void 0;
  }
  setDate(e, t) {
    this.setValue(cn(e != null ? e : null, !1), t);
  }
}
class DN extends Nn {
  constructor(e) {
    super(e, "ag-range-field", "range");
  }
  postConstruct() {
    super.postConstruct();
    const { min: e, max: t, step: i } = this.config;
    e != null && this.setMinValue(e), t != null && this.setMaxValue(t), this.setStep(i || 1);
  }
  addInputListeners() {
    this.addManagedListener(this.eInput, "input", (e) => {
      const t = e.target.value;
      this.setValue(t);
    });
  }
  setMinValue(e) {
    return this.min = e, this.eInput.setAttribute("min", e.toString()), this;
  }
  setMaxValue(e) {
    return this.max = e, this.eInput.setAttribute("max", e.toString()), this;
  }
  setStep(e) {
    return this.eInput.setAttribute("step", e.toString()), this;
  }
  setValue(e, t) {
    this.min != null && (e = Math.max(parseFloat(e), this.min).toString()), this.max != null && (e = Math.min(parseFloat(e), this.max).toString());
    const i = super.setValue(e, t);
    return this.eInput.value = e, i;
  }
}
var hm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class mi extends Wv {
  constructor(e) {
    super(e, mi.TEMPLATE), this.labelAlignment = "top";
  }
  init() {
    this.eSlider.addCssClass("ag-slider-field");
  }
  onValueChange(e) {
    const t = ir.EVENT_CHANGED;
    return this.addManagedListener(this.eText, t, () => {
      const i = parseFloat(this.eText.getValue());
      this.eSlider.setValue(i.toString(), !0), e(i || 0);
    }), this.addManagedListener(this.eSlider, t, () => {
      const i = this.eSlider.getValue();
      this.eText.setValue(i, !0), e(parseFloat(i));
    }), this;
  }
  setSliderWidth(e) {
    return this.eSlider.setWidth(e), this;
  }
  setTextFieldWidth(e) {
    return this.eText.setWidth(e), this;
  }
  setMinValue(e) {
    return this.eSlider.setMinValue(e), this.eText.setMin(e), this;
  }
  setMaxValue(e) {
    return this.eSlider.setMaxValue(e), this.eText.setMax(e), this;
  }
  getValue() {
    return this.eText.getValue();
  }
  setValue(e) {
    return this.getValue() === e ? this : (this.eText.setValue(e, !0), this.eSlider.setValue(e, !0), this.dispatchEvent({ type: ir.EVENT_CHANGED }), this);
  }
  setStep(e) {
    return this.eSlider.setStep(e), this.eText.setStep(e), this;
  }
}
mi.TEMPLATE = `<div class="ag-slider">
            <label ref="eLabel"></label>
            <div class="ag-wrapper ag-slider-wrapper">
                <ag-input-range ref="eSlider"></ag-input-range>
                <ag-input-number-field ref="eText"></ag-input-number-field>
            </div>
        </div>`;
hm([
  L("eLabel")
], mi.prototype, "eLabel", void 0);
hm([
  L("eSlider")
], mi.prototype, "eSlider", void 0);
hm([
  L("eText")
], mi.prototype, "eText", void 0);
hm([
  B
], mi.prototype, "init", null);
var Ha = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Tt extends X {
  constructor(e = {}) {
    super(Tt.getTemplate(e)), this.suppressEnabledCheckbox = !0, this.suppressOpenCloseIcons = !1;
    const { title: t, enabled: i, items: r, suppressEnabledCheckbox: n, suppressOpenCloseIcons: s } = e;
    this.title = t, this.cssIdentifier = e.cssIdentifier || "default", this.enabled = i != null ? i : !0, this.items = r || [], this.alignItems = e.alignItems || "center", n != null && (this.suppressEnabledCheckbox = n), s != null && (this.suppressOpenCloseIcons = s);
  }
  static getTemplate(e) {
    const t = e.cssIdentifier || "default", i = e.direction || "vertical";
    return (
      /* html */
      `<div class="ag-group ag-${t}-group" role="presentation">
            <div class="ag-group-title-bar ag-${t}-group-title-bar ag-unselectable" ref="eTitleBar" role="button">
                <span class="ag-group-title-bar-icon ag-${t}-group-title-bar-icon" ref="eGroupOpenedIcon" role="presentation"></span>
                <span class="ag-group-title-bar-icon ag-${t}-group-title-bar-icon" ref="eGroupClosedIcon" role="presentation"></span>
                <span ref="eTitle" class="ag-group-title ag-${t}-group-title"></span>
            </div>
            <div ref="eToolbar" class="ag-group-toolbar ag-${t}-group-toolbar">
                <ag-checkbox ref="cbGroupEnabled"></ag-checkbox>
            </div>
            <div ref="eContainer" class="ag-group-container ag-group-container-${i} ag-${t}-group-container"></div>
        </div>`
    );
  }
  postConstruct() {
    if (this.items.length) {
      const t = this.items;
      this.items = [], this.addItems(t);
    }
    const e = this.localeService.getLocaleTextFunc();
    this.cbGroupEnabled.setLabel(e("enabled", "Enabled")), this.title && this.setTitle(this.title), this.enabled && this.setEnabled(this.enabled), this.setAlignItems(this.alignItems), this.hideEnabledCheckbox(this.suppressEnabledCheckbox), this.hideOpenCloseIcons(this.suppressOpenCloseIcons), this.setupExpandContract(), this.refreshAriaStatus(), this.refreshChildDisplay();
  }
  setupExpandContract() {
    this.eGroupClosedIcon.appendChild(tn("columnSelectClosed", this.gridOptionsService, null)), this.eGroupOpenedIcon.appendChild(tn("columnSelectOpen", this.gridOptionsService, null)), this.addManagedListener(this.eTitleBar, "click", () => this.toggleGroupExpand()), this.addManagedListener(this.eTitleBar, "keydown", (e) => {
      switch (e.key) {
        case V.ENTER:
        case V.SPACE:
          e.preventDefault(), this.toggleGroupExpand();
          break;
        case V.RIGHT:
        case V.LEFT:
          e.preventDefault(), this.toggleGroupExpand(e.key === V.RIGHT);
          break;
      }
    });
  }
  refreshAriaStatus() {
    this.suppressOpenCloseIcons || Ln(this.eTitleBar, this.expanded);
  }
  refreshChildDisplay() {
    const e = !this.suppressOpenCloseIcons;
    Ke(this.eToolbar, this.expanded && !this.suppressEnabledCheckbox), Ke(this.eGroupOpenedIcon, e && this.expanded), Ke(this.eGroupClosedIcon, e && !this.expanded);
  }
  isExpanded() {
    return this.expanded;
  }
  setAlignItems(e) {
    this.alignItems !== e && this.removeCssClass(`ag-group-item-alignment-${this.alignItems}`), this.alignItems = e;
    const t = `ag-group-item-alignment-${this.alignItems}`;
    return this.addCssClass(t), this;
  }
  toggleGroupExpand(e) {
    return this.suppressOpenCloseIcons ? (this.expanded = !0, this.refreshChildDisplay(), Ke(this.eContainer, !0), this) : (e = e != null ? e : !this.expanded, this.expanded === e ? this : (this.expanded = e, this.refreshAriaStatus(), this.refreshChildDisplay(), Ke(this.eContainer, e), this.dispatchEvent({ type: this.expanded ? Tt.EVENT_EXPANDED : Tt.EVENT_COLLAPSED }), this));
  }
  addItems(e) {
    e.forEach((t) => this.addItem(t));
  }
  addItem(e) {
    const t = this.eContainer, i = e instanceof X ? e.getGui() : e;
    i.classList.add("ag-group-item", `ag-${this.cssIdentifier}-group-item`), t.appendChild(i), this.items.push(i);
  }
  hideItem(e, t) {
    const i = this.items[t];
    Ke(i, !e);
  }
  setTitle(e) {
    return this.eTitle.innerText = e, this;
  }
  addCssClassToTitleBar(e) {
    this.eTitleBar.classList.add(e);
  }
  setEnabled(e, t) {
    return this.enabled = e, this.refreshDisabledStyles(), this.toggleGroupExpand(e), t || this.cbGroupEnabled.setValue(e), this;
  }
  isEnabled() {
    return this.enabled;
  }
  onEnableChange(e) {
    return this.cbGroupEnabled.onValueChange((t) => {
      this.setEnabled(t, !0), e(t);
    }), this;
  }
  hideEnabledCheckbox(e) {
    return this.suppressEnabledCheckbox = e, this.refreshChildDisplay(), this.refreshDisabledStyles(), this;
  }
  hideOpenCloseIcons(e) {
    return this.suppressOpenCloseIcons = e, e && this.toggleGroupExpand(!0), this;
  }
  refreshDisabledStyles() {
    this.addOrRemoveCssClass("ag-disabled", !this.enabled), this.suppressEnabledCheckbox && !this.enabled ? (this.eTitleBar.classList.add("ag-disabled-group-title-bar"), this.eTitleBar.removeAttribute("tabindex")) : (this.eTitleBar.classList.remove("ag-disabled-group-title-bar"), this.eTitleBar.setAttribute("tabindex", "0")), this.eContainer.classList.toggle("ag-disabled-group-container", !this.enabled);
  }
}
Tt.EVENT_EXPANDED = "expanded";
Tt.EVENT_COLLAPSED = "collapsed";
Ha([
  L("eTitleBar")
], Tt.prototype, "eTitleBar", void 0);
Ha([
  L("eGroupOpenedIcon")
], Tt.prototype, "eGroupOpenedIcon", void 0);
Ha([
  L("eGroupClosedIcon")
], Tt.prototype, "eGroupClosedIcon", void 0);
Ha([
  L("eToolbar")
], Tt.prototype, "eToolbar", void 0);
Ha([
  L("cbGroupEnabled")
], Tt.prototype, "cbGroupEnabled", void 0);
Ha([
  L("eTitle")
], Tt.prototype, "eTitle", void 0);
Ha([
  L("eContainer")
], Tt.prototype, "eContainer", void 0);
Ha([
  B
], Tt.prototype, "postConstruct", null);
class mu extends X {
  initialiseTabGuard(e) {
    this.eTopGuard = this.createTabGuard("top"), this.eBottomGuard = this.createTabGuard("bottom"), this.eFocusableElement = this.getFocusableElement();
    const t = [this.eTopGuard, this.eBottomGuard], i = {
      setTabIndex: (r) => {
        t.forEach((n) => r != null ? n.setAttribute("tabindex", r) : n.removeAttribute("tabindex"));
      }
    };
    this.addTabGuards(this.eTopGuard, this.eBottomGuard), this.tabGuardCtrl = this.createManagedBean(new Cb({
      comp: i,
      eTopGuard: this.eTopGuard,
      eBottomGuard: this.eBottomGuard,
      eFocusableElement: this.eFocusableElement,
      onFocusIn: e.onFocusIn,
      onFocusOut: e.onFocusOut,
      focusInnerElement: e.focusInnerElement,
      handleKeyDown: e.handleKeyDown,
      onTabKeyDown: e.onTabKeyDown,
      shouldStopEventPropagation: e.shouldStopEventPropagation
    }));
  }
  createTabGuard(e) {
    const t = document.createElement("div"), i = e === "top" ? Rd.TAB_GUARD_TOP : Rd.TAB_GUARD_BOTTOM;
    return t.classList.add(Rd.TAB_GUARD, i), ci(t, "presentation"), t;
  }
  addTabGuards(e, t) {
    this.eFocusableElement.insertAdjacentElement("afterbegin", e), this.eFocusableElement.insertAdjacentElement("beforeend", t);
  }
  removeAllChildrenExceptTabGuards() {
    const e = [this.eTopGuard, this.eBottomGuard];
    Or(this.getFocusableElement()), this.addTabGuards(...e);
  }
  forceFocusOutOfContainer(e = !1) {
    this.tabGuardCtrl.forceFocusOutOfContainer(e);
  }
  appendChild(e, t) {
    Dp(e) || (e = e.getGui());
    const { eBottomGuard: i } = this;
    i ? i.insertAdjacentElement("beforebegin", e) : super.appendChild(e, t);
  }
}
var bx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Ro extends mu {
  constructor(e = 1) {
    super(
      /* html */
      '<div class="ag-menu-list" role="tree"></div>'
    ), this.level = e, this.menuItems = [];
  }
  postConstruct() {
    this.initialiseTabGuard({
      onTabKeyDown: (e) => this.onTabKeyDown(e),
      handleKeyDown: (e) => this.handleKeyDown(e)
    });
  }
  onTabKeyDown(e) {
    const t = this.getParentComponent(), i = t && t.getGui();
    i && i.classList.contains("ag-focus-managed") || e.preventDefault(), e.shiftKey && this.closeIfIsChild(e);
  }
  handleKeyDown(e) {
    switch (e.key) {
      case V.UP:
      case V.RIGHT:
      case V.DOWN:
      case V.LEFT:
        e.preventDefault(), this.handleNavKey(e.key);
        break;
      case V.ESCAPE:
        const t = this.findTopMenu();
        t && this.focusService.focusInto(t.getGui());
        break;
    }
  }
  clearActiveItem() {
    this.activeMenuItem && (this.activeMenuItem.deactivate(), this.activeMenuItem = null);
  }
  addMenuItems(e) {
    e != null && e.forEach((t) => {
      t === "separator" ? this.addSeparator() : typeof t == "string" ? console.warn(`AG Grid: unrecognised menu item ${t}`) : this.addItem(t);
    });
  }
  addItem(e) {
    const t = this.createManagedBean(new _t(Object.assign(Object.assign({}, e), { isAnotherSubMenuOpen: () => this.menuItems.some((i) => i.isSubMenuOpen()) })));
    t.setParentComponent(this), hT(t.getGui(), this.level), this.menuItems.push(t), this.appendChild(t.getGui()), this.addManagedListener(t, _t.EVENT_MENU_ITEM_SELECTED, (i) => {
      this.dispatchEvent(i);
    }), this.addManagedListener(t, _t.EVENT_MENU_ITEM_ACTIVATED, (i) => {
      this.activeMenuItem && this.activeMenuItem !== i.menuItem && this.activeMenuItem.deactivate(), this.activeMenuItem = i.menuItem;
    });
  }
  activateFirstItem() {
    const e = this.menuItems.filter((t) => !t.isDisabled())[0];
    e && e.activate();
  }
  addSeparator() {
    const e = (
      /* html */
      `
            <div class="ag-menu-separator" aria-hidden="true">
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
                <div class="ag-menu-separator-part"></div>
            </div>`
    );
    this.appendChild(Si(e));
  }
  findTopMenu() {
    let e = this.getParentComponent();
    if (!e && this instanceof Ro)
      return this;
    for (; ; ) {
      const t = e && e.getParentComponent && e.getParentComponent();
      if (!t || !(t instanceof Ro || t instanceof _t))
        break;
      e = t;
    }
    return e instanceof Ro ? e : void 0;
  }
  handleNavKey(e) {
    switch (e) {
      case V.UP:
      case V.DOWN:
        const i = this.findNextItem(e === V.UP);
        i && i !== this.activeMenuItem && i.activate();
        return;
    }
    const t = this.gridOptionsService.is("enableRtl") ? V.RIGHT : V.LEFT;
    e === t ? this.closeIfIsChild() : this.openChild();
  }
  closeIfIsChild(e) {
    const t = this.getParentComponent();
    t && t instanceof _t && (e && e.preventDefault(), t.closeSubMenu(), t.getGui().focus());
  }
  openChild() {
    this.activeMenuItem && this.activeMenuItem.openSubMenu(!0);
  }
  findNextItem(e) {
    const t = this.menuItems.filter((n) => !n.isDisabled());
    if (!t.length)
      return;
    if (!this.activeMenuItem)
      return e ? at(t) : t[0];
    e && t.reverse();
    let i, r = !1;
    for (let n = 0; n < t.length; n++) {
      const s = t[n];
      if (!r) {
        s === this.activeMenuItem && (r = !0);
        continue;
      }
      i = s;
      break;
    }
    return i || this.activeMenuItem;
  }
  destroy() {
    this.clearActiveItem(), super.destroy();
  }
}
bx([
  S("focusService")
], Ro.prototype, "focusService", void 0);
bx([
  B
], Ro.prototype, "postConstruct", null);
var ON = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class wx extends mu {
  constructor(e) {
    super(), this.wrappedComponent = e, this.setTemplateFromElement(e.getGui());
  }
  postConstruct() {
    this.initialiseTabGuard({
      onTabKeyDown: (e) => this.onTabKeyDown(e),
      handleKeyDown: (e) => this.handleKeyDown(e)
    });
  }
  handleKeyDown(e) {
    e.key === V.ESCAPE && this.closePanel();
  }
  onTabKeyDown(e) {
    e.defaultPrevented || (this.closePanel(), e.preventDefault());
  }
  closePanel() {
    const e = this.parentComponent;
    e.closeSubMenu(), setTimeout(() => e.getGui().focus(), 0);
  }
}
ON([
  B
], wx.prototype, "postConstruct", null);
var Ex = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class _t extends X {
  constructor(e) {
    super(), this.params = e, this.isActive = !1, this.subMenuIsOpen = !1, this.setTemplate(
      /* html */
      `<div class="${this.getClassName()}" tabindex="-1" role="treeitem"></div>`
    );
  }
  init() {
    this.addIcon(), this.addName(), this.addShortcut(), this.addSubMenu(), this.addTooltip();
    const e = this.getGui();
    this.params.disabled ? (this.addCssClass(this.getClassName("disabled")), RS(e, !0)) : (this.addGuiEventListener("click", (t) => this.onItemSelected(t)), this.addGuiEventListener("keydown", (t) => {
      (t.key === V.ENTER || t.key === V.SPACE) && (t.preventDefault(), this.onItemSelected(t));
    }), this.addGuiEventListener("mousedown", (t) => {
      t.stopPropagation(), t.preventDefault();
    }), this.addGuiEventListener("mouseenter", () => this.onMouseEnter()), this.addGuiEventListener("mouseleave", () => this.onMouseLeave())), this.params.cssClasses && this.params.cssClasses.forEach((t) => this.addCssClass(t));
  }
  isDisabled() {
    return !!this.params.disabled;
  }
  openSubMenu(e = !1) {
    if (this.closeSubMenu(), !this.params.subMenu)
      return;
    const t = Si(
      /* html */
      '<div class="ag-menu" role="presentation"></div>'
    );
    let i;
    if (this.params.subMenu instanceof Array) {
      const l = aT(this.getGui()), c = isNaN(l) ? 1 : l + 1, d = this.createBean(new Ro(c));
      d.setParentComponent(this), d.addMenuItems(this.params.subMenu), t.appendChild(d.getGui()), this.addManagedListener(d, _t.EVENT_MENU_ITEM_SELECTED, (u) => this.dispatchEvent(u)), d.addGuiEventListener("mouseenter", () => this.cancelDeactivate()), i = () => this.destroyBean(d), e && setTimeout(() => d.activateFirstItem(), 0);
    } else {
      const { subMenu: l } = this.params, c = this.createBean(new wx(l));
      c.setParentComponent(this);
      const d = c.getGui(), u = "mouseenter", h = () => this.cancelDeactivate();
      d.addEventListener(u, h), i = () => d.removeEventListener(u, h), t.appendChild(d), l.afterGuiAttached && setTimeout(() => l.afterGuiAttached(), 0);
    }
    const r = this.getGui(), n = this.popupService.positionPopupForMenu.bind(this.popupService, { eventSource: r, ePopup: t }), s = this.localeService.getLocaleTextFunc(), a = this.popupService.addPopup({
      modal: !0,
      eChild: t,
      positionCallback: n,
      anchorToElement: r,
      ariaLabel: s("ariaLabelSubMenu", "SubMenu")
    });
    this.subMenuIsOpen = !0, Ln(r, !0), this.hideSubMenu = () => {
      a && a.hideFunc(), this.subMenuIsOpen = !1, Ln(r, !1), i();
    };
  }
  closeSubMenu() {
    this.hideSubMenu && (this.hideSubMenu(), this.hideSubMenu = null, Ln(this.getGui(), !1));
  }
  isSubMenuOpen() {
    return this.subMenuIsOpen;
  }
  activate(e) {
    this.cancelActivate(), !this.params.disabled && (this.isActive = !0, this.addCssClass(this.getClassName("active")), this.getGui().focus(), e && this.params.subMenu && window.setTimeout(() => {
      this.isAlive() && this.isActive && this.openSubMenu();
    }, 300), this.onItemActivated());
  }
  deactivate() {
    this.cancelDeactivate(), this.removeCssClass(this.getClassName("active")), this.isActive = !1, this.subMenuIsOpen && this.hideSubMenu();
  }
  addIcon() {
    if (!this.params.checked && !this.params.icon && this.params.isCompact)
      return;
    const e = Si(
      /* html */
      `<span ref="eIcon" class="${this.getClassName("part")} ${this.getClassName("icon")}" role="presentation"></span>`
    );
    this.params.checked ? e.appendChild(Vt("check", this.gridOptionsService)) : this.params.icon && (Dp(this.params.icon) ? e.appendChild(this.params.icon) : typeof this.params.icon == "string" ? e.innerHTML = this.params.icon : console.warn("AG Grid: menu item icon must be DOM node or string")), this.getGui().appendChild(e);
  }
  addName() {
    if (!this.params.name && this.params.isCompact)
      return;
    const e = Si(
      /* html */
      `<span ref="eName" class="${this.getClassName("part")} ${this.getClassName("text")}">${this.params.name || ""}</span>`
    );
    this.getGui().appendChild(e);
  }
  addTooltip() {
    this.params.tooltip && (this.tooltip = this.params.tooltip, this.gridOptionsService.is("enableBrowserTooltips") ? this.getGui().setAttribute("title", this.tooltip) : this.createManagedBean(new ws(this)));
  }
  getTooltipParams() {
    return {
      location: "menu",
      value: this.tooltip
    };
  }
  addShortcut() {
    if (!this.params.shortcut && this.params.isCompact)
      return;
    const e = Si(
      /* html */
      `<span ref="eShortcut" class="${this.getClassName("part")} ${this.getClassName("shortcut")}">${this.params.shortcut || ""}</span>`
    );
    this.getGui().appendChild(e);
  }
  addSubMenu() {
    if (!this.params.subMenu && this.params.isCompact)
      return;
    const e = Si(
      /* html */
      `<span ref="ePopupPointer" class="${this.getClassName("part")} ${this.getClassName("popup-pointer")}"></span>`
    ), t = this.getGui();
    if (this.params.subMenu) {
      const i = this.gridOptionsService.is("enableRtl") ? "smallLeft" : "smallRight";
      Ln(t, !1), e.appendChild(Vt(i, this.gridOptionsService));
    }
    t.appendChild(e);
  }
  onItemSelected(e) {
    if (this.params.action ? this.params.action() : this.openSubMenu(e && e.type === "keydown"), this.params.subMenu && !this.params.action)
      return;
    const t = {
      type: _t.EVENT_MENU_ITEM_SELECTED,
      action: this.params.action,
      checked: this.params.checked,
      cssClasses: this.params.cssClasses,
      disabled: this.params.disabled,
      icon: this.params.icon,
      name: this.params.name,
      shortcut: this.params.shortcut,
      subMenu: this.params.subMenu,
      tooltip: this.params.tooltip,
      event: e
    };
    this.dispatchEvent(t);
  }
  onItemActivated() {
    const e = {
      type: _t.EVENT_MENU_ITEM_ACTIVATED,
      menuItem: this
    };
    this.dispatchEvent(e);
  }
  cancelActivate() {
    this.activateTimeoutId && (window.clearTimeout(this.activateTimeoutId), this.activateTimeoutId = 0);
  }
  cancelDeactivate() {
    this.deactivateTimeoutId && (window.clearTimeout(this.deactivateTimeoutId), this.deactivateTimeoutId = 0);
  }
  onMouseEnter() {
    this.cancelDeactivate(), this.params.isAnotherSubMenuOpen() ? this.activateTimeoutId = window.setTimeout(() => this.activate(!0), _t.ACTIVATION_DELAY) : this.activate(!0);
  }
  onMouseLeave() {
    this.cancelActivate(), this.isSubMenuOpen() ? this.deactivateTimeoutId = window.setTimeout(() => this.deactivate(), _t.ACTIVATION_DELAY) : this.deactivate();
  }
  getClassName(e) {
    const t = this.params.isCompact ? "ag-compact-menu-option" : "ag-menu-option";
    return e ? `${t}-${e}` : t;
  }
}
_t.EVENT_MENU_ITEM_SELECTED = "menuItemSelected";
_t.EVENT_MENU_ITEM_ACTIVATED = "menuItemActivated";
_t.ACTIVATION_DELAY = 80;
Ex([
  S("popupService")
], _t.prototype, "popupService", void 0);
Ex([
  B
], _t.prototype, "init", null);
var tf = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class gn extends X {
  constructor(e) {
    super(gn.getTemplate(e)), this.closable = !0, this.config = e;
  }
  static getTemplate(e) {
    const t = e && e.cssIdentifier || "default";
    return (
      /* html */
      `<div class="ag-panel ag-${t}-panel" tabindex="-1">
            <div ref="eTitleBar" class="ag-panel-title-bar ag-${t}-panel-title-bar ag-unselectable">
                <span ref="eTitle" class="ag-panel-title-bar-title ag-${t}-panel-title-bar-title"></span>
                <div ref="eTitleBarButtons" class="ag-panel-title-bar-buttons ag-${t}-panel-title-bar-buttons"></div>
            </div>
            <div ref="eContentWrapper" class="ag-panel-content-wrapper ag-${t}-panel-content-wrapper"></div>
        </div>`
    );
  }
  postConstruct() {
    const { component: e, closable: t, hideTitleBar: i, title: r, minWidth: n = 250, width: s, minHeight: a = 250, height: l, centered: c, popup: d, x: u, y: h } = this.config;
    this.positionableFeature = new ec(this.getGui(), {
      minWidth: n,
      width: s,
      minHeight: a,
      height: l,
      centered: c,
      x: u,
      y: h,
      popup: d,
      calculateTopBuffer: () => this.positionableFeature.getHeight() - this.getBodyHeight()
    }), this.createManagedBean(this.positionableFeature);
    const p = this.getGui();
    e && this.setBodyComponent(e), i ? Ke(this.eTitleBar, !1) : (r && this.setTitle(r), this.setClosable(t != null ? t : this.closable)), this.addManagedListener(this.eTitleBar, "mousedown", (f) => {
      const g = this.gridOptionsService.getDocument();
      if (p.contains(f.relatedTarget) || p.contains(g.activeElement) || this.eTitleBarButtons.contains(f.target)) {
        f.preventDefault();
        return;
      }
      const v = this.eContentWrapper.querySelector("button, [href], input, select, textarea, [tabindex]");
      v && v.focus();
    }), !(d && this.positionableFeature.isPositioned()) && (this.renderComponent && this.renderComponent(), this.positionableFeature.initialisePosition(), this.eContentWrapper.style.height = "0");
  }
  renderComponent() {
    const e = this.getGui();
    e.focus(), this.close = () => {
      e.parentElement.removeChild(e), this.destroy();
    };
  }
  getHeight() {
    return this.positionableFeature.getHeight();
  }
  setHeight(e) {
    this.positionableFeature.setHeight(e);
  }
  getWidth() {
    return this.positionableFeature.getWidth();
  }
  setWidth(e) {
    this.positionableFeature.setWidth(e);
  }
  setClosable(e) {
    if (e !== this.closable && (this.closable = e), e) {
      const t = this.closeButtonComp = new X(gn.CLOSE_BTN_TEMPLATE);
      this.getContext().createBean(t);
      const i = t.getGui(), r = Vt("close", this.gridOptionsService);
      r.classList.add("ag-panel-title-bar-button-icon"), i.appendChild(r), this.addTitleBarButton(t), t.addManagedListener(i, "click", this.onBtClose.bind(this));
    } else if (this.closeButtonComp) {
      const t = this.closeButtonComp.getGui();
      t.parentElement.removeChild(t), this.closeButtonComp = this.destroyBean(this.closeButtonComp);
    }
  }
  setBodyComponent(e) {
    e.setParentComponent(this), this.eContentWrapper.appendChild(e.getGui());
  }
  addTitleBarButton(e, t) {
    const i = this.eTitleBarButtons, r = i.children, n = r.length;
    t == null && (t = n), t = Math.max(0, Math.min(t, n)), e.addCssClass("ag-panel-title-bar-button");
    const s = e.getGui();
    t === 0 ? i.insertAdjacentElement("afterbegin", s) : t === n ? i.insertAdjacentElement("beforeend", s) : r[t - 1].insertAdjacentElement("afterend", s), e.setParentComponent(this);
  }
  getBodyHeight() {
    return Tp(this.eContentWrapper);
  }
  getBodyWidth() {
    return Bv(this.eContentWrapper);
  }
  setTitle(e) {
    this.eTitle.innerText = e;
  }
  // called when user hits the 'x' in the top right
  onBtClose() {
    this.close();
  }
  destroy() {
    this.closeButtonComp && (this.closeButtonComp = this.destroyBean(this.closeButtonComp));
    const e = this.getGui();
    e && e.offsetParent && this.close(), super.destroy();
  }
}
gn.CLOSE_BTN_TEMPLATE = '<div class="ag-button"></div>';
tf([
  L("eContentWrapper")
], gn.prototype, "eContentWrapper", void 0);
tf([
  L("eTitleBar")
], gn.prototype, "eTitleBar", void 0);
tf([
  L("eTitleBarButtons")
], gn.prototype, "eTitleBarButtons", void 0);
tf([
  L("eTitle")
], gn.prototype, "eTitle", void 0);
tf([
  B
], gn.prototype, "postConstruct", null);
var PN = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Kh extends gn {
  constructor(e) {
    super(Object.assign(Object.assign({}, e), { popup: !0 })), this.isMaximizable = !1, this.isMaximized = !1, this.maximizeListeners = [], this.resizeListenerDestroy = null, this.lastPosition = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
  postConstruct() {
    const e = this.getGui(), { movable: t, resizable: i, maximizable: r } = this.config;
    this.addCssClass("ag-dialog"), super.postConstruct(), this.addManagedListener(e, "focusin", (n) => {
      e.contains(n.relatedTarget) || this.popupService.bringPopupToFront(e);
    }), t && this.setMovable(t), r && this.setMaximizable(r), i && this.setResizable(i);
  }
  renderComponent() {
    const e = this.getGui(), { alwaysOnTop: t, modal: i, title: r } = this.config, n = this.localeService.getLocaleTextFunc(), s = this.popupService.addPopup({
      modal: i,
      eChild: e,
      closeOnEsc: !0,
      closedCallback: this.destroy.bind(this),
      alwaysOnTop: t,
      ariaLabel: r || n("ariaLabelDialog", "Dialog")
    });
    s && (this.close = s.hideFunc);
  }
  toggleMaximize() {
    const e = this.positionableFeature.getPosition();
    if (this.isMaximized) {
      const { x: t, y: i, width: r, height: n } = this.lastPosition;
      this.setWidth(r), this.setHeight(n), this.positionableFeature.offsetElement(t, i);
    } else
      this.lastPosition.width = this.getWidth(), this.lastPosition.height = this.getHeight(), this.lastPosition.x = e.x, this.lastPosition.y = e.y, this.positionableFeature.offsetElement(0, 0), this.setHeight("100%"), this.setWidth("100%");
    this.isMaximized = !this.isMaximized, this.refreshMaximizeIcon();
  }
  refreshMaximizeIcon() {
    Ke(this.maximizeIcon, !this.isMaximized), Ke(this.minimizeIcon, this.isMaximized);
  }
  clearMaximizebleListeners() {
    this.maximizeListeners.length && (this.maximizeListeners.forEach((e) => e()), this.maximizeListeners.length = 0), this.resizeListenerDestroy && (this.resizeListenerDestroy(), this.resizeListenerDestroy = null);
  }
  destroy() {
    this.maximizeButtonComp = this.destroyBean(this.maximizeButtonComp), this.clearMaximizebleListeners(), super.destroy();
  }
  setResizable(e) {
    this.positionableFeature.setResizable(e);
  }
  setMovable(e) {
    this.positionableFeature.setMovable(e, this.eTitleBar);
  }
  setMaximizable(e) {
    if (!e) {
      this.clearMaximizebleListeners(), this.maximizeButtonComp && (this.destroyBean(this.maximizeButtonComp), this.maximizeButtonComp = this.maximizeIcon = this.minimizeIcon = void 0);
      return;
    }
    const t = this.eTitleBar;
    if (!t || e === this.isMaximizable)
      return;
    const i = this.buildMaximizeAndMinimizeElements();
    this.refreshMaximizeIcon(), i.addManagedListener(i.getGui(), "click", this.toggleMaximize.bind(this)), this.addTitleBarButton(i, 0), this.maximizeListeners.push(this.addManagedListener(t, "dblclick", this.toggleMaximize.bind(this))), this.resizeListenerDestroy = this.addManagedListener(this, "resize", () => {
      this.isMaximized = !1, this.refreshMaximizeIcon();
    });
  }
  buildMaximizeAndMinimizeElements() {
    const e = this.maximizeButtonComp = this.createBean(new X(
      /* html */
      '<div class="ag-dialog-button"></span>'
    )), t = e.getGui();
    return this.maximizeIcon = Vt("maximize", this.gridOptionsService), t.appendChild(this.maximizeIcon), this.maximizeIcon.classList.add("ag-panel-title-bar-button-icon"), this.minimizeIcon = Vt("minimize", this.gridOptionsService), t.appendChild(this.minimizeIcon), this.minimizeIcon.classList.add("ag-panel-title-bar-button-icon"), e;
  }
}
PN([
  S("popupService")
], Kh.prototype, "popupService", void 0);
var rf = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, PC, Qs;
(function(o) {
  o[o.vertical = 0] = "vertical", o[o.horizontal = 1] = "horizontal";
})(Qs || (Qs = {}));
let AN = 0, va = PC = class extends H {
  constructor() {
    super(...arguments), this.popupList = [];
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridCtrl = e.gridCtrl, this.addManagedListener(this.gridCtrl, w.EVENT_KEYBOARD_FOCUS, () => {
        this.popupList.forEach((t) => t.element.classList.add(Ht.AG_KEYBOARD_FOCUS));
      }), this.addManagedListener(this.gridCtrl, w.EVENT_MOUSE_FOCUS, () => {
        this.popupList.forEach((t) => t.element.classList.remove(Ht.AG_KEYBOARD_FOCUS));
      });
    });
  }
  getPopupParent() {
    const e = this.gridOptionsService.get("popupParent");
    return e || this.gridCtrl.getGui();
  }
  positionPopupForMenu(e) {
    const t = e.eventSource.getBoundingClientRect(), i = this.getParentRect(), r = this.keepXYWithinBounds(e.ePopup, t.top - i.top, Qs.vertical), n = e.ePopup.clientWidth > 0 ? e.ePopup.clientWidth : 200;
    e.ePopup.style.minWidth = `${n}px`;
    const a = i.right - i.left - n;
    let l;
    this.gridOptionsService.is("enableRtl") ? (l = d(), l < 0 && (l = c()), l > a && (l = 0)) : (l = c(), l > a && (l = d()), l < 0 && (l = 0)), e.ePopup.style.left = `${l}px`, e.ePopup.style.top = `${r}px`;
    function c() {
      return t.right - i.left - 2;
    }
    function d() {
      return t.left - i.left - n;
    }
  }
  positionPopupUnderMouseEvent(e) {
    const { ePopup: t, nudgeX: i, nudgeY: r, skipObserver: n } = e;
    this.positionPopup({
      ePopup: t,
      nudgeX: i,
      nudgeY: r,
      keepWithinBounds: !0,
      skipObserver: n,
      updatePosition: () => this.calculatePointerAlign(e.mouseEvent),
      postProcessCallback: () => this.callPostProcessPopup(e.type, e.ePopup, null, e.mouseEvent, e.column, e.rowNode)
    });
  }
  calculatePointerAlign(e) {
    const t = this.getParentRect();
    return {
      x: e.clientX - t.left,
      y: e.clientY - t.top
    };
  }
  positionPopupByComponent(e) {
    const t = e.eventSource.getBoundingClientRect(), i = e.alignSide || "left", r = e.position || "over", n = this.getParentRect(), s = () => {
      let a = t.left - n.left;
      i === "right" && (a -= e.ePopup.offsetWidth - t.width);
      const l = r === "over" ? t.top - n.top : t.top - n.top + t.height;
      return { x: a, y: l };
    };
    this.positionPopup({
      ePopup: e.ePopup,
      nudgeX: e.nudgeX,
      nudgeY: e.nudgeY,
      keepWithinBounds: e.keepWithinBounds,
      updatePosition: s,
      postProcessCallback: () => this.callPostProcessPopup(e.type, e.ePopup, e.eventSource, null, e.column, e.rowNode)
    });
  }
  callPostProcessPopup(e, t, i, r, n, s) {
    const a = this.gridOptionsService.getCallback("postProcessPopup");
    a && a({
      column: n,
      rowNode: s,
      ePopup: t,
      type: e,
      eventSource: i,
      mouseEvent: r
    });
  }
  positionPopup(e) {
    const { ePopup: t, keepWithinBounds: i, nudgeX: r, nudgeY: n, skipObserver: s, updatePosition: a } = e, l = { width: 0, height: 0 }, c = (d = !1) => {
      let { x: u, y: h } = a();
      d && t.clientWidth === l.width && t.clientHeight === l.height || (l.width = t.clientWidth, l.height = t.clientHeight, r && (u += r), n && (h += n), i && (u = this.keepXYWithinBounds(t, u, Qs.horizontal), h = this.keepXYWithinBounds(t, h, Qs.vertical)), t.style.left = `${u}px`, t.style.top = `${h}px`, e.postProcessCallback && e.postProcessCallback());
    };
    if (c(), !s) {
      const d = this.resizeObserverService.observeResize(t, () => c(!0));
      setTimeout(() => d(), PC.WAIT_FOR_POPUP_CONTENT_RESIZE);
    }
  }
  getActivePopups() {
    return this.popupList.map((e) => e.element);
  }
  getPopupList() {
    return this.popupList;
  }
  getParentRect() {
    const e = this.gridOptionsService.getDocument();
    let t = this.getPopupParent();
    return t === e.body ? t = e.documentElement : getComputedStyle(t).position === "static" && (t = t.offsetParent), NS(t);
  }
  keepXYWithinBounds(e, t, i) {
    const r = i === Qs.vertical, n = r ? "clientHeight" : "clientWidth", s = r ? "top" : "left", a = r ? "offsetHeight" : "offsetWidth", l = r ? "scrollTop" : "scrollLeft", c = this.gridOptionsService.getDocument(), d = c.documentElement, u = this.getPopupParent(), h = u.getBoundingClientRect(), p = c.documentElement.getBoundingClientRect(), f = u === c.body, g = e[a];
    let y = f ? (r ? LS : Hv)(d) + d[l] : u[n];
    f && (y -= Math.abs(p[s] - h[s]));
    const m = y - g;
    return Math.min(Math.max(t, 0), Math.abs(m));
  }
  addPopup(e) {
    const t = this.gridOptionsService.getDocument(), { eChild: i, ariaLabel: r, alwaysOnTop: n, positionCallback: s, anchorToElement: a } = e;
    if (!t)
      return console.warn("AG Grid: could not find the document, document is empty"), { hideFunc: () => {
      } };
    const l = this.popupList.findIndex((u) => u.element === i);
    if (l !== -1)
      return { hideFunc: this.popupList[l].hideFunc };
    this.initialisePopupPosition(i);
    const c = this.createPopupWrapper(i, r, !!n), d = this.addEventListenersToPopup(Object.assign(Object.assign({}, e), { wrapperEl: c }));
    return s && s(), this.addPopupToPopupList(i, c, d, a), {
      hideFunc: d
    };
  }
  initialisePopupPosition(e) {
    const i = this.getPopupParent().getBoundingClientRect();
    z(e.style.top) || (e.style.top = `${i.top * -1}px`), z(e.style.left) || (e.style.left = `${i.left * -1}px`);
  }
  createPopupWrapper(e, t, i) {
    const r = this.getPopupParent(), n = document.createElement("div"), { allThemes: s } = this.environment.getTheme();
    return s.length && n.classList.add(...s), n.classList.add("ag-popup"), e.classList.add(this.gridOptionsService.is("enableRtl") ? "ag-rtl" : "ag-ltr", "ag-popup-child"), e.hasAttribute("role") || ci(e, "dialog"), Ia(e, t), this.focusService.isKeyboardMode() && e.classList.add(Ht.AG_KEYBOARD_FOCUS), n.appendChild(e), r.appendChild(n), i ? this.setAlwaysOnTop(e, !0) : this.bringPopupToFront(e), n;
  }
  addEventListenersToPopup(e) {
    const t = this.gridOptionsService.getDocument(), i = this.getPopupParent(), { wrapperEl: r, eChild: n, click: s, closedCallback: a, afterGuiAttached: l, closeOnEsc: c, modal: d } = e;
    let u = !1;
    const h = (v) => {
      if (!r.contains(t.activeElement))
        return;
      v.key === V.ESCAPE && g({ keyboardEvent: v });
    }, p = (v) => g({ mouseEvent: v }), f = (v) => g({ touchEvent: v }), g = (v = {}) => {
      const { mouseEvent: y, touchEvent: m, keyboardEvent: C } = v;
      // we don't hide popup if the event was on the child, or any
      // children of this child
      this.isEventFromCurrentPopup({ mouseEvent: y, touchEvent: m }, n) || // if the event to close is actually the open event, then ignore it
      this.isEventSameChainAsOriginalEvent({ originalMouseEvent: s, mouseEvent: y, touchEvent: m }) || // this method should only be called once. the client can have different
      // paths, each one wanting to close, so this method may be called multiple times.
      u || (u = !0, i.removeChild(r), t.removeEventListener("keydown", h), t.removeEventListener("mousedown", p), t.removeEventListener("touchstart", f), t.removeEventListener("contextmenu", p), this.eventService.removeEventListener(w.EVENT_DRAG_STARTED, p), a && a(y || m || C), this.removePopupFromPopupList(n));
    };
    return l && l({ hidePopup: g }), window.setTimeout(() => {
      c && t.addEventListener("keydown", h), d && (t.addEventListener("mousedown", p), this.eventService.addEventListener(w.EVENT_DRAG_STARTED, p), t.addEventListener("touchstart", f), t.addEventListener("contextmenu", p));
    }, 0), g;
  }
  addPopupToPopupList(e, t, i, r) {
    this.popupList.push({
      element: e,
      wrapper: t,
      hideFunc: i,
      instanceId: AN++,
      isAnchored: !!r
    }), r && this.setPopupPositionRelatedToElement(e, r);
  }
  setPopupPositionRelatedToElement(e, t) {
    const i = this.popupList.find((n) => n.element === e);
    if (!i || (i.stopAnchoringPromise && i.stopAnchoringPromise.then((n) => n && n()), i.stopAnchoringPromise = void 0, i.isAnchored = !1, !t))
      return;
    const r = this.keepPopupPositionedRelativeTo({
      element: t,
      ePopup: e,
      hidePopup: i.hideFunc
    });
    return i.stopAnchoringPromise = r, i.isAnchored = !0, r;
  }
  removePopupFromPopupList(e) {
    this.setPopupPositionRelatedToElement(e, null), this.popupList = this.popupList.filter((t) => t.element !== e);
  }
  keepPopupPositionedRelativeTo(e) {
    const t = this.getPopupParent(), i = t.getBoundingClientRect(), { element: r, ePopup: n } = e, s = r.getBoundingClientRect(), a = i.top - s.top, l = i.left - s.left;
    let c = a, d = l;
    const u = n.style.top, h = parseInt(u.substring(0, u.length - 1), 10), p = n.style.left, f = parseInt(p.substring(0, p.length - 1), 10);
    return new Qe((g) => {
      this.getFrameworkOverrides().setInterval(() => {
        const v = t.getBoundingClientRect(), y = r.getBoundingClientRect();
        if (y.top == 0 && y.left == 0 && y.height == 0 && y.width == 0) {
          e.hidePopup();
          return;
        }
        const C = v.top - y.top;
        if (C != c) {
          const E = this.keepXYWithinBounds(n, h + a - C, Qs.vertical);
          n.style.top = `${E}px`;
        }
        c = C;
        const R = v.left - y.left;
        if (R != d) {
          const E = this.keepXYWithinBounds(n, f + l - R, Qs.horizontal);
          n.style.left = `${E}px`;
        }
        d = R;
      }, 200).then((v) => {
        g(() => {
          v != null && window.clearInterval(v);
        });
      });
    });
  }
  hasAnchoredPopup() {
    return this.popupList.some((e) => e.isAnchored);
  }
  isEventFromCurrentPopup(e, t) {
    const { mouseEvent: i, touchEvent: r } = e, n = i || r;
    if (!n)
      return !1;
    const s = this.popupList.findIndex((a) => a.element === t);
    if (s === -1)
      return !1;
    for (let a = s; a < this.popupList.length; a++) {
      const l = this.popupList[a];
      if (Og(l.element, n))
        return !0;
    }
    return this.isElementWithinCustomPopup(n.target);
  }
  isElementWithinCustomPopup(e) {
    const t = this.gridOptionsService.getDocument();
    for (; e && e !== t.body; ) {
      if (e.classList.contains("ag-custom-component-popup") || e.parentElement === null)
        return !0;
      e = e.parentElement;
    }
    return !1;
  }
  // in some browsers, the context menu event can be fired before the click event, which means
  // the context menu event could open the popup, but then the click event closes it straight away.
  isEventSameChainAsOriginalEvent(e) {
    const { originalMouseEvent: t, mouseEvent: i, touchEvent: r } = e;
    let n = null;
    if (i ? n = i : r && (n = r.touches[0]), n && t) {
      const s = i ? i.screenX : 0, a = i ? i.screenY : 0, l = Math.abs(t.screenX - s) < 5, c = Math.abs(t.screenY - a) < 5;
      if (l && c)
        return !0;
    }
    return !1;
  }
  getWrapper(e) {
    for (; !e.classList.contains("ag-popup") && e.parentElement; )
      e = e.parentElement;
    return e.classList.contains("ag-popup") ? e : null;
  }
  setAlwaysOnTop(e, t) {
    const i = this.getWrapper(e);
    i && (i.classList.toggle("ag-always-on-top", !!t), t && this.bringPopupToFront(i));
  }
  bringPopupToFront(e) {
    const t = this.getPopupParent(), i = Array.prototype.slice.call(t.querySelectorAll(".ag-popup")), r = i.length, n = Array.prototype.slice.call(t.querySelectorAll(".ag-popup.ag-always-on-top")), s = n.length, a = this.getWrapper(e);
    if (!a || r <= 1 || !t.contains(e))
      return;
    const l = i.indexOf(a), c = a.querySelectorAll("div"), d = [];
    for (c.forEach((h) => {
      h.scrollTop !== 0 && d.push([h, h.scrollTop]);
    }), s ? a.classList.contains("ag-always-on-top") ? l !== r - 1 && at(n).insertAdjacentElement("afterend", a) : l !== r - s - 1 && n[0].insertAdjacentElement("beforebegin", a) : l !== r - 1 && at(i).insertAdjacentElement("afterend", a); d.length; ) {
      const h = d.pop();
      h[0].scrollTop = h[1];
    }
    const u = {
      type: "popupToFront",
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      eWrapper: a
    };
    this.eventService.dispatchEvent(u);
  }
};
va.WAIT_FOR_POPUP_CONTENT_RESIZE = 200;
rf([
  S("focusService")
], va.prototype, "focusService", void 0);
rf([
  S("ctrlsService")
], va.prototype, "ctrlsService", void 0);
rf([
  S("resizeObserverService")
], va.prototype, "resizeObserverService", void 0);
rf([
  B
], va.prototype, "postConstruct", null);
va = PC = rf([
  q("popupService")
], va);
var Tb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Ls extends mu {
  constructor(e = "default", t = "listbox", i) {
    super(Ls.getTemplate(e)), this.cssIdentifier = e, this.ariaRole = t, this.listName = i, this.renderedRows = /* @__PURE__ */ new Map(), this.rowHeight = 20;
  }
  postConstruct() {
    this.addScrollListener(), this.rowHeight = this.getItemHeight(), this.addResizeObserver(), this.initialiseTabGuard({
      onFocusIn: (e) => this.onFocusIn(e),
      onFocusOut: (e) => this.onFocusOut(e),
      focusInnerElement: (e) => this.focusInnerElement(e),
      onTabKeyDown: (e) => this.onTabKeyDown(e),
      handleKeyDown: (e) => this.handleKeyDown(e)
    }), this.setAriaProperties(), this.addManagedListener(this.eventService, w.EVENT_GRID_STYLES_CHANGED, this.onGridStylesChanged.bind(this));
  }
  onGridStylesChanged() {
    this.rowHeight = this.getItemHeight(), this.refresh();
  }
  setAriaProperties() {
    const t = this.localeService.getLocaleTextFunc()("ariaDefaultListName", this.listName || "List"), i = this.eContainer;
    ci(i, this.ariaRole), Ia(i, t);
  }
  addResizeObserver() {
    const e = () => this.drawVirtualRows(), t = this.resizeObserverService.observeResize(this.getGui(), e);
    this.addDestroyFunc(t);
  }
  focusInnerElement(e) {
    this.focusRow(e ? this.model.getRowCount() - 1 : 0);
  }
  onFocusIn(e) {
    const t = e.target;
    return t.classList.contains("ag-virtual-list-item") && (this.lastFocusedRowIndex = lT(t) - 1), !1;
  }
  onFocusOut(e) {
    return this.getFocusableElement().contains(e.relatedTarget) || (this.lastFocusedRowIndex = null), !1;
  }
  handleKeyDown(e) {
    switch (e.key) {
      case V.UP:
      case V.DOWN:
        this.navigate(e.key === V.UP) && e.preventDefault();
        break;
    }
  }
  onTabKeyDown(e) {
    this.navigate(e.shiftKey) ? e.preventDefault() : (Ss(e), this.forceFocusOutOfContainer(e.shiftKey));
  }
  navigate(e) {
    if (this.lastFocusedRowIndex == null)
      return !1;
    const t = this.lastFocusedRowIndex + (e ? -1 : 1);
    return t < 0 || t >= this.model.getRowCount() ? !1 : (this.focusRow(t), !0);
  }
  getLastFocusedRow() {
    return this.lastFocusedRowIndex;
  }
  focusRow(e) {
    this.ensureIndexVisible(e), window.setTimeout(() => {
      if (!this.isAlive())
        return;
      const t = this.renderedRows.get(e);
      t && t.eDiv.focus();
    }, 10);
  }
  getComponentAt(e) {
    const t = this.renderedRows.get(e);
    return t && t.rowComponent;
  }
  forEachRenderedRow(e) {
    this.renderedRows.forEach((t, i) => e(t.rowComponent, i));
  }
  static getTemplate(e) {
    return (
      /* html */
      `
            <div class="ag-virtual-list-viewport ag-${e}-virtual-list-viewport" role="presentation">
                <div class="ag-virtual-list-container ag-${e}-virtual-list-container" ref="eContainer"></div>
            </div>`
    );
  }
  getItemHeight() {
    return this.environment.getListItemHeight();
  }
  ensureIndexVisible(e) {
    const t = this.model.getRowCount();
    if (typeof e != "number" || e < 0 || e >= t) {
      console.warn("AG Grid: invalid row index for ensureIndexVisible: " + e);
      return;
    }
    const i = e * this.rowHeight, r = i + this.rowHeight, n = this.getGui(), s = n.scrollTop, a = n.offsetHeight, l = s + a, c = s > i, d = l < r;
    if (c)
      n.scrollTop = i;
    else if (d) {
      const u = r - a;
      n.scrollTop = u;
    }
  }
  setComponentCreator(e) {
    this.componentCreator = e;
  }
  setComponentUpdater(e) {
    this.componentUpdater = e;
  }
  getRowHeight() {
    return this.rowHeight;
  }
  getScrollTop() {
    return this.getGui().scrollTop;
  }
  setRowHeight(e) {
    this.rowHeight = e, this.refresh();
  }
  refresh(e) {
    if (this.model == null || !this.isAlive())
      return;
    const t = this.model.getRowCount();
    this.eContainer.style.height = `${t * this.rowHeight}px`, yS(() => this.eContainer.clientHeight >= t * this.rowHeight, () => {
      this.isAlive() && (this.canSoftRefresh(e) ? this.drawVirtualRows(!0) : (this.clearVirtualRows(), this.drawVirtualRows()));
    });
  }
  canSoftRefresh(e) {
    return !!(e && this.renderedRows.size && typeof this.model.areRowsEqual == "function" && this.componentUpdater);
  }
  clearVirtualRows() {
    this.renderedRows.forEach((e, t) => this.removeRow(t));
  }
  drawVirtualRows(e) {
    if (!this.isAlive())
      return;
    const t = this.getGui(), i = t.scrollTop, r = i + t.offsetHeight, n = Math.floor(i / this.rowHeight), s = Math.floor(r / this.rowHeight);
    this.ensureRowsRendered(n, s, e);
  }
  ensureRowsRendered(e, t, i) {
    this.renderedRows.forEach((r, n) => {
      (n < e || n > t) && n !== this.lastFocusedRowIndex && this.removeRow(n);
    }), i && this.refreshRows();
    for (let r = e; r <= t; r++)
      this.renderedRows.has(r) || r < this.model.getRowCount() && this.insertRow(r);
  }
  insertRow(e) {
    const t = this.model.getRow(e), i = document.createElement("div");
    if (i.classList.add("ag-virtual-list-item", `ag-${this.cssIdentifier}-virtual-list-item`), ci(i, this.ariaRole === "tree" ? "treeitem" : "option"), TS(i, this.model.getRowCount()), xS(i, e + 1), i.setAttribute("tabindex", "-1"), typeof this.model.isRowSelected == "function") {
      const n = this.model.isRowSelected(e);
      _d(i, !!n), ST(i, n);
    }
    i.style.height = `${this.rowHeight}px`, i.style.top = `${this.rowHeight * e}px`;
    const r = this.componentCreator(t, i);
    r.addGuiEventListener("focusin", () => this.lastFocusedRowIndex = e), i.appendChild(r.getGui()), this.renderedRows.has(e - 1) ? this.renderedRows.get(e - 1).eDiv.insertAdjacentElement("afterend", i) : this.renderedRows.has(e + 1) ? this.renderedRows.get(e + 1).eDiv.insertAdjacentElement("beforebegin", i) : this.eContainer.appendChild(i), this.renderedRows.set(e, { rowComponent: r, eDiv: i, value: t });
  }
  removeRow(e) {
    const t = this.renderedRows.get(e);
    this.eContainer.removeChild(t.eDiv), this.destroyBean(t.rowComponent), this.renderedRows.delete(e);
  }
  refreshRows() {
    const e = this.model.getRowCount();
    this.renderedRows.forEach((t, i) => {
      var r, n;
      if (i >= e)
        this.removeRow(i);
      else {
        const s = this.model.getRow(i);
        !((n = (r = this.model).areRowsEqual) === null || n === void 0) && n.call(r, t.value, s) ? this.componentUpdater(s, t.rowComponent) : this.removeRow(i);
      }
    });
  }
  addScrollListener() {
    this.addGuiEventListener("scroll", () => this.drawVirtualRows(), { passive: !0 });
  }
  setModel(e) {
    this.model = e;
  }
  destroy() {
    this.isAlive() && (this.clearVirtualRows(), super.destroy());
  }
}
Tb([
  S("resizeObserverService")
], Ls.prototype, "resizeObserverService", void 0);
Tb([
  L("eContainer")
], Ls.prototype, "eContainer", void 0);
Tb([
  B
], Ls.prototype, "postConstruct", null);
const MN = ["mouseover", "mouseout", "mouseenter", "mouseleave", "mousemove"], _N = ["touchstart", "touchend", "touchmove", "touchcancel"];
class Rx {
  constructor() {
    this.renderingEngine = "vanilla", this.isOutsideAngular = (e) => ln(MN, e);
  }
  // for Vanilla JS, we use simple timeout
  setTimeout(e, t) {
    window.setTimeout(e, t);
  }
  setInterval(e, t) {
    return new Qe((i) => {
      i(window.setInterval(e, t));
    });
  }
  // for Vanilla JS, we just add the event to the element
  addEventListener(e, t, i, r) {
    const n = ln(_N, t);
    e.addEventListener(t, i, { capture: !!r, passive: n });
  }
  // for Vanilla JS, we just execute the listener
  dispatchEvent(e, t, i = !1) {
    t();
  }
  frameworkComponent(e) {
    return null;
  }
  isFrameworkComponent(e) {
    return !1;
  }
}
var yu = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let ma = class extends H {
  // returns null if no cell to focus on, ie at the end of the grid
  getNextCellToFocus(e, t, i = !1) {
    return i ? this.getNextCellToFocusWithCtrlPressed(e, t) : this.getNextCellToFocusWithoutCtrlPressed(e, t);
  }
  getNextCellToFocusWithCtrlPressed(e, t) {
    const i = e === V.UP, r = e === V.DOWN, n = e === V.LEFT;
    let s, a;
    if (i || r)
      a = i ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow(), s = t.column;
    else {
      const l = this.columnModel.getAllDisplayedColumns(), c = this.gridOptionsService.is("enableRtl");
      a = t.rowIndex, s = n !== c ? l[0] : at(l);
    }
    return {
      rowIndex: a,
      rowPinned: null,
      column: s
    };
  }
  getNextCellToFocusWithoutCtrlPressed(e, t) {
    let i = t, r = !1;
    for (; !r; ) {
      switch (e) {
        case V.UP:
          i = this.getCellAbove(i);
          break;
        case V.DOWN:
          i = this.getCellBelow(i);
          break;
        case V.RIGHT:
          this.gridOptionsService.is("enableRtl") ? i = this.getCellToLeft(i) : i = this.getCellToRight(i);
          break;
        case V.LEFT:
          this.gridOptionsService.is("enableRtl") ? i = this.getCellToRight(i) : i = this.getCellToLeft(i);
          break;
        default:
          i = null, console.warn("AG Grid: unknown key for navigation " + e);
          break;
      }
      i ? r = this.isCellGoodToFocusOn(i) : r = !0;
    }
    return i;
  }
  isCellGoodToFocusOn(e) {
    const t = e.column;
    let i;
    switch (e.rowPinned) {
      case "top":
        i = this.pinnedRowModel.getPinnedTopRow(e.rowIndex);
        break;
      case "bottom":
        i = this.pinnedRowModel.getPinnedBottomRow(e.rowIndex);
        break;
      default:
        i = this.rowModel.getRow(e.rowIndex);
        break;
    }
    return i ? !t.isSuppressNavigable(i) : !1;
  }
  getCellToLeft(e) {
    if (!e)
      return null;
    const t = this.columnModel.getDisplayedColBefore(e.column);
    return t ? {
      rowIndex: e.rowIndex,
      column: t,
      rowPinned: e.rowPinned
    } : null;
  }
  getCellToRight(e) {
    if (!e)
      return null;
    const t = this.columnModel.getDisplayedColAfter(e.column);
    return t ? {
      rowIndex: e.rowIndex,
      column: t,
      rowPinned: e.rowPinned
    } : null;
  }
  getRowBelow(e) {
    const t = e.rowIndex, i = e.rowPinned;
    if (this.isLastRowInContainer(e))
      switch (i) {
        case "bottom":
          return null;
        case "top":
          return this.rowModel.isRowsToRender() ? { rowIndex: this.paginationProxy.getPageFirstRow(), rowPinned: null } : this.pinnedRowModel.isRowsToRender("bottom") ? { rowIndex: 0, rowPinned: "bottom" } : null;
        default:
          return this.pinnedRowModel.isRowsToRender("bottom") ? { rowIndex: 0, rowPinned: "bottom" } : null;
      }
    const r = this.rowModel.getRow(e.rowIndex), n = this.getNextStickyPosition(r);
    return n || { rowIndex: t + 1, rowPinned: i };
  }
  getNextStickyPosition(e, t) {
    if (!this.gridOptionsService.isGroupRowsSticky() || !e || !e.sticky)
      return;
    const i = [...this.rowRenderer.getStickyTopRowCtrls()].sort((a, l) => a.getRowNode().rowIndex - l.getRowNode().rowIndex), r = t ? -1 : 1, n = i.findIndex((a) => a.getRowNode().rowIndex === e.rowIndex), s = i[n + r];
    if (s)
      return { rowIndex: s.getRowNode().rowIndex, rowPinned: null };
  }
  getCellBelow(e) {
    if (!e)
      return null;
    const t = this.getRowBelow(e);
    return t ? {
      rowIndex: t.rowIndex,
      column: e.column,
      rowPinned: t.rowPinned
    } : null;
  }
  isLastRowInContainer(e) {
    const t = e.rowPinned, i = e.rowIndex;
    return t === "top" ? this.pinnedRowModel.getPinnedTopRowData().length - 1 <= i : t === "bottom" ? this.pinnedRowModel.getPinnedBottomRowData().length - 1 <= i : this.paginationProxy.getPageLastRow() <= i;
  }
  getRowAbove(e) {
    const t = e.rowIndex, i = e.rowPinned;
    if (i ? t === 0 : t === this.paginationProxy.getPageFirstRow())
      return i === "top" ? null : i ? this.rowModel.isRowsToRender() ? this.getLastBodyCell() : this.pinnedRowModel.isRowsToRender("top") ? this.getLastFloatingTopRow() : null : this.pinnedRowModel.isRowsToRender("top") ? this.getLastFloatingTopRow() : null;
    const n = this.rowModel.getRow(e.rowIndex), s = this.getNextStickyPosition(n, !0);
    return s || { rowIndex: t - 1, rowPinned: i };
  }
  getCellAbove(e) {
    if (!e)
      return null;
    const t = this.getRowAbove({ rowIndex: e.rowIndex, rowPinned: e.rowPinned });
    return t ? {
      rowIndex: t.rowIndex,
      column: e.column,
      rowPinned: t.rowPinned
    } : null;
  }
  getLastBodyCell() {
    return { rowIndex: this.paginationProxy.getPageLastRow(), rowPinned: null };
  }
  getLastFloatingTopRow() {
    return { rowIndex: this.pinnedRowModel.getPinnedTopRowData().length - 1, rowPinned: "top" };
  }
  getNextTabbedCell(e, t) {
    return t ? this.getNextTabbedCellBackwards(e) : this.getNextTabbedCellForwards(e);
  }
  getNextTabbedCellForwards(e) {
    const t = this.columnModel.getAllDisplayedColumns();
    let i = e.rowIndex, r = e.rowPinned, n = this.columnModel.getDisplayedColAfter(e.column);
    if (!n) {
      n = t[0];
      const s = this.getRowBelow(e);
      if (Se(s) || !s.rowPinned && !this.paginationProxy.isRowInPage(s))
        return null;
      i = s ? s.rowIndex : null, r = s ? s.rowPinned : null;
    }
    return { rowIndex: i, column: n, rowPinned: r };
  }
  getNextTabbedCellBackwards(e) {
    const t = this.columnModel.getAllDisplayedColumns();
    let i = e.rowIndex, r = e.rowPinned, n = this.columnModel.getDisplayedColBefore(e.column);
    if (!n) {
      n = at(t);
      const s = this.getRowAbove({ rowIndex: e.rowIndex, rowPinned: e.rowPinned });
      if (Se(s) || !s.rowPinned && !this.paginationProxy.isRowInPage(s))
        return null;
      i = s ? s.rowIndex : null, r = s ? s.rowPinned : null;
    }
    return { rowIndex: i, column: n, rowPinned: r };
  }
};
yu([
  S("columnModel")
], ma.prototype, "columnModel", void 0);
yu([
  S("rowModel")
], ma.prototype, "rowModel", void 0);
yu([
  S("rowRenderer")
], ma.prototype, "rowRenderer", void 0);
yu([
  S("pinnedRowModel")
], ma.prototype, "pinnedRowModel", void 0);
yu([
  S("paginationProxy")
], ma.prototype, "paginationProxy", void 0);
ma = yu([
  q("cellNavigationService")
], ma);
var nf = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, IN = function(o, e) {
  return function(t, i) {
    e(t, i, o);
  };
};
let kl = class extends H {
  constructor() {
    super(...arguments), this.consuming = !1;
  }
  setBeans(e) {
    this.logger = e.create("AlignedGridsService");
  }
  init() {
    this.addManagedListener(this.eventService, w.EVENT_COLUMN_MOVED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_VISIBLE, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PINNED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_GROUP_OPENED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_RESIZED, this.fireColumnEvent.bind(this)), this.addManagedListener(this.eventService, w.EVENT_BODY_SCROLL, this.fireScrollEvent.bind(this));
  }
  // common logic across all the fire methods
  fireEvent(e) {
    if (this.consuming)
      return;
    const t = this.gridOptionsService.get("alignedGrids");
    t && t.forEach((i) => {
      if (i.api) {
        const r = i.api.__getAlignedGridService();
        e(r);
      }
    });
  }
  // common logic across all consume methods. very little common logic, however extracting
  // guarantees consistency across the methods.
  onEvent(e) {
    this.consuming = !0, e(), this.consuming = !1;
  }
  fireColumnEvent(e) {
    this.fireEvent((t) => {
      t.onColumnEvent(e);
    });
  }
  fireScrollEvent(e) {
    e.direction === "horizontal" && this.fireEvent((t) => {
      t.onScrollEvent(e);
    });
  }
  onScrollEvent(e) {
    this.onEvent(() => {
      this.ctrlsService.getGridBodyCtrl().getScrollFeature().setHorizontalScrollPosition(e.left, !0);
    });
  }
  getMasterColumns(e) {
    const t = [];
    return e.columns ? e.columns.forEach((i) => {
      t.push(i);
    }) : e.column && t.push(e.column), t;
  }
  getColumnIds(e) {
    const t = [];
    return e.columns ? e.columns.forEach((i) => {
      t.push(i.getColId());
    }) : e.column && t.push(e.column.getColId()), t;
  }
  onColumnEvent(e) {
    this.onEvent(() => {
      switch (e.type) {
        case w.EVENT_COLUMN_MOVED:
        case w.EVENT_COLUMN_VISIBLE:
        case w.EVENT_COLUMN_PINNED:
        case w.EVENT_COLUMN_RESIZED:
          const t = e;
          this.processColumnEvent(t);
          break;
        case w.EVENT_COLUMN_GROUP_OPENED:
          const i = e;
          this.processGroupOpenedEvent(i);
          break;
        case w.EVENT_COLUMN_PIVOT_CHANGED:
          console.warn("AG Grid: pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid.");
          break;
      }
    });
  }
  processGroupOpenedEvent(e) {
    const t = e.columnGroup;
    let i = null;
    if (t) {
      const r = t.getGroupId();
      i = this.columnModel.getProvidedColumnGroup(r);
    }
    t && !i || (this.logger.log("onColumnEvent-> processing " + e + " expanded = " + t.isExpanded()), this.columnModel.setColumnGroupOpened(i, t.isExpanded(), "alignedGridChanged"));
  }
  processColumnEvent(e) {
    var t;
    const i = e.column;
    let r = null;
    if (i && (r = this.columnModel.getPrimaryColumn(i.getColId())), i && !r)
      return;
    const n = this.getMasterColumns(e);
    switch (e.type) {
      case w.EVENT_COLUMN_MOVED:
        {
          const u = e, p = e.columnApi.getColumnState().map((f) => ({ colId: f.colId }));
          this.columnModel.applyColumnState({ state: p, applyOrder: !0 }, "alignedGridChanged"), this.logger.log(`onColumnEvent-> processing ${e.type} toIndex = ${u.toIndex}`);
        }
        break;
      case w.EVENT_COLUMN_VISIBLE:
        {
          const u = e, p = e.columnApi.getColumnState().map((f) => ({ colId: f.colId, hide: f.hide }));
          this.columnModel.applyColumnState({ state: p }, "alignedGridChanged"), this.logger.log(`onColumnEvent-> processing ${e.type} visible = ${u.visible}`);
        }
        break;
      case w.EVENT_COLUMN_PINNED:
        {
          const u = e, p = e.columnApi.getColumnState().map((f) => ({ colId: f.colId, pinned: f.pinned }));
          this.columnModel.applyColumnState({ state: p }, "alignedGridChanged"), this.logger.log(`onColumnEvent-> processing ${e.type} pinned = ${u.pinned}`);
        }
        break;
      case w.EVENT_COLUMN_RESIZED:
        const c = e, d = {};
        n.forEach((u) => {
          this.logger.log(`onColumnEvent-> processing ${e.type} actualWidth = ${u.getActualWidth()}`), d[u.getId()] = { key: u.getColId(), newWidth: u.getActualWidth() };
        }), (t = c.flexColumns) === null || t === void 0 || t.forEach((u) => {
          d[u.getId()] && delete d[u.getId()];
        }), this.columnModel.setColumnWidths(Object.values(d), !1, c.finished, "alignedGridChanged");
        break;
    }
    const a = this.ctrlsService.getGridBodyCtrl().isVerticalScrollShowing(), l = this.gridOptionsService.get("alignedGrids");
    l && l.forEach((c) => {
      c.api && c.api.setAlwaysShowVerticalScroll(a);
    });
  }
};
nf([
  S("columnModel")
], kl.prototype, "columnModel", void 0);
nf([
  S("ctrlsService")
], kl.prototype, "ctrlsService", void 0);
nf([
  IN(0, qi("loggerFactory"))
], kl.prototype, "setBeans", null);
nf([
  B
], kl.prototype, "init", null);
kl = nf([
  q("alignedGridsService")
], kl);
var of = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, FN = function(o, e) {
  return function(t, i) {
    e(t, i, o);
  };
};
let Vl = class extends H {
  setBeans(e) {
    this.logger = e.create("selectionService"), this.reset();
  }
  init() {
    this.groupSelectsChildren = this.gridOptionsService.is("groupSelectsChildren"), this.addManagedPropertyListener("groupSelectsChildren", (e) => this.groupSelectsChildren = e.currentValue), this.rowSelection = this.gridOptionsService.get("rowSelection"), this.addManagedPropertyListener("rowSelection", (e) => this.rowSelection = e.currentValue), this.addManagedListener(this.eventService, w.EVENT_ROW_SELECTED, this.onRowSelected.bind(this));
  }
  isMultiselect() {
    return this.rowSelection === "multiple";
  }
  setNodesSelected(e) {
    var t;
    if (e.nodes.length === 0)
      return 0;
    const { newValue: i, clearSelection: r, suppressFinishActions: n, rangeSelect: s, event: a, source: l = "api" } = e;
    if (e.nodes.length > 1 && !this.isMultiselect())
      return console.warn("AG Grid: cannot multi select while rowSelection='single'"), 0;
    const c = this.groupSelectsChildren && e.groupSelectsFiltered === !0, d = e.nodes.map((h) => h.footer ? h.sibling : h);
    if (s) {
      if (e.nodes.length > 1)
        return console.warn("AG Grid: cannot range select while selecting multiple rows"), 0;
      const h = this.getLastSelectedNode();
      if (h) {
        const p = d[0];
        if (h !== p && this.isMultiselect()) {
          const g = this.selectRange(p, h, e.newValue, l);
          return this.setLastSelectedNode(p), g;
        }
      }
    }
    let u = 0;
    for (let h = 0; h < d.length; h++) {
      const p = d[h];
      c && p.group || p.selectThisNode(i, e.event, l) && u++, this.groupSelectsChildren && (!((t = p.childrenAfterGroup) === null || t === void 0) && t.length) && (u += this.selectChildren(p, i, c, l));
    }
    if (!n) {
      if (i && (r || !this.isMultiselect()) && (u += this.clearOtherNodes(d[0], l)), u > 0) {
        this.updateGroupsFromChildrenSelections(l);
        const p = {
          type: w.EVENT_SELECTION_CHANGED,
          source: l
        };
        this.eventService.dispatchEvent(p);
      }
      i && this.setLastSelectedNode(d[d.length - 1]);
    }
    return u;
  }
  // selects all rows between this node and the last selected node (or the top if this is the first selection).
  // not to be mixed up with 'cell range selection' where you drag the mouse, this is row range selection, by
  // holding down 'shift'.
  selectRange(e, t, i = !0, r) {
    const n = this.rowModel.getNodesInRangeForSelection(e, t);
    let s = 0;
    n.forEach((l) => {
      if (l.group && this.groupSelectsChildren || i === !1 && e === l)
        return;
      l.selectThisNode(i, void 0, r) && s++;
    }), this.updateGroupsFromChildrenSelections(r);
    const a = {
      type: w.EVENT_SELECTION_CHANGED,
      source: r
    };
    return this.eventService.dispatchEvent(a), s;
  }
  selectChildren(e, t, i, r) {
    const n = i ? e.childrenAfterAggFilter : e.childrenAfterGroup;
    return x.missing(n) ? 0 : this.setNodesSelected({
      newValue: t,
      clearSelection: !1,
      suppressFinishActions: !0,
      groupSelectsFiltered: i,
      source: r,
      nodes: n
    });
  }
  setLastSelectedNode(e) {
    this.lastSelectedNode = e;
  }
  getLastSelectedNode() {
    return this.lastSelectedNode;
  }
  getSelectedNodes() {
    const e = [];
    return Ct(this.selectedNodes, (t, i) => {
      i && e.push(i);
    }), e;
  }
  getSelectedRows() {
    const e = [];
    return Ct(this.selectedNodes, (t, i) => {
      i && i.data && e.push(i.data);
    }), e;
  }
  getSelectionCount() {
    return Object.values(this.selectedNodes).length;
  }
  /**
   * This method is used by the CSRM to remove groups which are being disposed of,
   * events do not need fired in this case
   */
  filterFromSelection(e) {
    const t = {};
    Object.entries(this.selectedNodes).forEach(([i, r]) => {
      r && e(r) && (t[i] = r);
    }), this.selectedNodes = t;
  }
  // should only be called if groupSelectsChildren=true
  updateGroupsFromChildrenSelections(e, t) {
    if (!this.groupSelectsChildren || this.rowModel.getType() !== "clientSide")
      return !1;
    const r = this.rowModel.getRootNode();
    t || (t = new dm(!0, r), t.setInactive());
    let n = !1;
    return t.forEachChangedNodeDepthFirst((s) => {
      if (s !== r) {
        const a = s.calculateSelectedFromChildren();
        n = s.selectThisNode(a === null ? !1 : a, void 0, e) || n;
      }
    }), n;
  }
  clearOtherNodes(e, t) {
    const i = {};
    let r = 0;
    return Ct(this.selectedNodes, (n, s) => {
      if (s && s.id !== e.id) {
        const a = this.selectedNodes[s.id];
        r += a.setSelectedParams({
          newValue: !1,
          clearSelection: !1,
          suppressFinishActions: !0,
          source: t
        }), this.groupSelectsChildren && s.parent && (i[s.parent.id] = s.parent);
      }
    }), Ct(i, (n, s) => {
      const a = s.calculateSelectedFromChildren();
      s.selectThisNode(a === null ? !1 : a, void 0, t);
    }), r;
  }
  onRowSelected(e) {
    const t = e.node;
    this.groupSelectsChildren && t.group || (t.isSelected() ? this.selectedNodes[t.id] = t : delete this.selectedNodes[t.id]);
  }
  syncInRowNode(e, t) {
    this.syncInOldRowNode(e, t), this.syncInNewRowNode(e);
  }
  // if the id has changed for the node, then this means the rowNode
  // is getting used for a different data item, which breaks
  // our selectedNodes, as the node now is mapped by the old id
  // which is inconsistent. so to keep the old node as selected,
  // we swap in the clone (with the old id and old data). this means
  // the oldNode is effectively a daemon we keep a reference to,
  // so if client calls api.getSelectedNodes(), it gets the daemon
  // in the result. when the client un-selects, the reference to the
  // daemon is removed. the daemon, because it's an oldNode, is not
  // used by the grid for rendering, it's a copy of what the node used
  // to be like before the id was changed.
  syncInOldRowNode(e, t) {
    if (z(t) && e.id !== t.id && t) {
      const r = t.id;
      this.selectedNodes[r] == e && (this.selectedNodes[t.id] = t);
    }
  }
  syncInNewRowNode(e) {
    z(this.selectedNodes[e.id]) ? (e.setSelectedInitialValue(!0), this.selectedNodes[e.id] = e) : e.setSelectedInitialValue(!1);
  }
  reset() {
    this.logger.log("reset"), this.selectedNodes = {}, this.lastSelectedNode = null;
  }
  // returns a list of all nodes at 'best cost' - a feature to be used
  // with groups / trees. if a group has all it's children selected,
  // then the group appears in the result, but not the children.
  // Designed for use with 'children' as the group selection type,
  // where groups don't actually appear in the selection normally.
  getBestCostNodeSelection() {
    if (this.rowModel.getType() !== "clientSide")
      return;
    const t = this.rowModel.getTopLevelNodes();
    if (t === null)
      return;
    const i = [];
    function r(n) {
      for (let s = 0, a = n.length; s < a; s++) {
        const l = n[s];
        if (l.isSelected())
          i.push(l);
        else {
          const c = l;
          c.group && c.children && r(c.children);
        }
      }
    }
    return r(t), i;
  }
  isEmpty() {
    let e = 0;
    return Ct(this.selectedNodes, (t, i) => {
      i && e++;
    }), e === 0;
  }
  deselectAllRowNodes(e) {
    const t = (l) => l.selectThisNode(!1, void 0, r), i = this.rowModel.getType() === "clientSide", { source: r, justFiltered: n, justCurrentPage: s } = e;
    if (s || n) {
      if (!i) {
        console.error("AG Grid: selecting just filtered only works when gridOptions.rowModelType='clientSide'");
        return;
      }
      this.getNodesToSelect(n, s).forEach(t);
    } else
      Ct(this.selectedNodes, (l, c) => {
        c && t(c);
      }), this.reset();
    i && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections(r);
    const a = {
      type: w.EVENT_SELECTION_CHANGED,
      source: r
    };
    this.eventService.dispatchEvent(a);
  }
  getSelectAllState(e, t) {
    let i = 0, r = 0;
    const n = (s) => {
      this.groupSelectsChildren && s.group || (s.isSelected() ? i++ : s.selectable && r++);
    };
    return this.getNodesToSelect(e, t).forEach(n), i === 0 && r === 0 ? !1 : i > 0 && r > 0 ? null : i > 0;
  }
  /**
   * @param justFiltered whether to just include nodes which have passed the filter
   * @param justCurrentPage whether to just include nodes on the current page
   * @returns all nodes including unselectable nodes which are the target of this selection attempt
   */
  getNodesToSelect(e = !1, t = !1) {
    if (this.rowModel.getType() !== "clientSide")
      throw new Error(`selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`);
    const i = [];
    if (t)
      return this.paginationProxy.forEachNodeOnPage((n) => {
        if (!n.group) {
          i.push(n);
          return;
        }
        if (!n.expanded) {
          const s = (a) => {
            var l;
            i.push(a), !((l = a.childrenAfterFilter) === null || l === void 0) && l.length && a.childrenAfterFilter.forEach(s);
          };
          s(n);
          return;
        }
        this.groupSelectsChildren || i.push(n);
      }), i;
    const r = this.rowModel;
    return e ? (r.forEachNodeAfterFilter((n) => {
      i.push(n);
    }), i) : (r.forEachNode((n) => {
      i.push(n);
    }), i);
  }
  selectAllRowNodes(e) {
    if (this.rowModel.getType() !== "clientSide")
      throw new Error(`selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`);
    const { source: t, justFiltered: i, justCurrentPage: r } = e, n = (a) => a.selectThisNode(!0, void 0, t);
    this.getNodesToSelect(i, r).forEach(n), this.rowModel.getType() === "clientSide" && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections(t);
    const s = {
      type: w.EVENT_SELECTION_CHANGED,
      source: t
    };
    this.eventService.dispatchEvent(s);
  }
  // Used by SSRM
  getServerSideSelectionState() {
    return null;
  }
  setServerSideSelectionState(e) {
  }
};
of([
  S("rowModel")
], Vl.prototype, "rowModel", void 0);
of([
  S("paginationProxy")
], Vl.prototype, "paginationProxy", void 0);
of([
  FN(0, qi("loggerFactory"))
], Vl.prototype, "setBeans", null);
of([
  B
], Vl.prototype, "init", null);
Vl = of([
  q("selectionService")
], Vl);
var xb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Yh = class {
  /**
   * Gets the grid to size the columns to the specified width in pixels, e.g. `sizeColumnsToFit(900)`.
   * To have the grid fit the columns to the grid's width, use the Grid API `gridApi.sizeColumnsToFit()` instead.
   * If inferring cell data types with custom column types and row data is provided asynchronously,
   * the column sizing will happen asynchronously when row data is added.
   * To always perform this synchronously, set `cellDataType = false` on the default column definition.
   */
  sizeColumnsToFit(e) {
    typeof e == "undefined" && console.error("AG Grid: missing parameter to columnApi.sizeColumnsToFit(gridWidth)"), this.columnModel.sizeColumnsToFit(e, "api");
  }
  /** Call this if you want to open or close a column group. */
  setColumnGroupOpened(e, t) {
    this.columnModel.setColumnGroupOpened(e, t, "api");
  }
  /** Returns the column group with the given name. */
  getColumnGroup(e, t) {
    return this.columnModel.getColumnGroup(e, t);
  }
  /** Returns the provided column group with the given name. */
  getProvidedColumnGroup(e) {
    return this.columnModel.getProvidedColumnGroup(e);
  }
  /** Returns the display name for a column. Useful if you are doing your own header rendering and want the grid to work out if `headerValueGetter` is used, or if you are doing your own column management GUI, to know what to show as the column name. */
  getDisplayNameForColumn(e, t) {
    return this.columnModel.getDisplayNameForColumn(e, t) || "";
  }
  /** Returns the display name for a column group (when grouping columns). */
  getDisplayNameForColumnGroup(e, t) {
    return this.columnModel.getDisplayNameForColumnGroup(e, t) || "";
  }
  /** Returns the column with the given `colKey`, which can either be the `colId` (a string) or the `colDef` (an object). */
  getColumn(e) {
    return this.columnModel.getPrimaryColumn(e);
  }
  /** Returns all the columns, regardless of visible or not. */
  getColumns() {
    return this.columnModel.getAllPrimaryColumns();
  }
  /** Applies the state of the columns from a previous state. Returns `false` if one or more columns could not be found. */
  applyColumnState(e) {
    return this.columnModel.applyColumnState(e, "api");
  }
  /** Gets the state of the columns. Typically used when saving column state. */
  getColumnState() {
    return this.columnModel.getColumnState();
  }
  /** Sets the state back to match the originally provided column definitions. */
  resetColumnState() {
    this.columnModel.resetColumnState("api");
  }
  /** Gets the state of the column groups. Typically used when saving column group state. */
  getColumnGroupState() {
    return this.columnModel.getColumnGroupState();
  }
  /** Sets the state of the column group state from a previous state. */
  setColumnGroupState(e) {
    this.columnModel.setColumnGroupState(e, "api");
  }
  /** Sets the state back to match the originally provided column definitions. */
  resetColumnGroupState() {
    this.columnModel.resetColumnGroupState("api");
  }
  /** Returns `true` if pinning left or right, otherwise `false`. */
  isPinning() {
    return this.columnModel.isPinningLeft() || this.columnModel.isPinningRight();
  }
  /** Returns `true` if pinning left, otherwise `false`. */
  isPinningLeft() {
    return this.columnModel.isPinningLeft();
  }
  /** Returns `true` if pinning right, otherwise `false`. */
  isPinningRight() {
    return this.columnModel.isPinningRight();
  }
  /** Returns the column to the right of the provided column, taking into consideration open / closed column groups and visible columns. This is useful if you need to know what column is beside yours e.g. if implementing your own cell navigation. */
  getDisplayedColAfter(e) {
    return this.columnModel.getDisplayedColAfter(e);
  }
  /** Same as `getVisibleColAfter` except gives column to the left. */
  getDisplayedColBefore(e) {
    return this.columnModel.getDisplayedColBefore(e);
  }
  /** Sets the visibility of a column. Key can be the column ID or `Column` object. */
  setColumnVisible(e, t) {
    this.columnModel.setColumnVisible(e, t, "api");
  }
  /** Same as `setColumnVisible`, but provide a list of column keys. */
  setColumnsVisible(e, t) {
    this.columnModel.setColumnsVisible(e, t, "api");
  }
  /** Sets the column pinned / unpinned. Key can be the column ID, field, `ColDef` object or `Column` object. */
  setColumnPinned(e, t) {
    this.columnModel.setColumnPinned(e, t, "api");
  }
  /** Same as `setColumnPinned`, but provide a list of column keys. */
  setColumnsPinned(e, t) {
    this.columnModel.setColumnsPinned(e, t, "api");
  }
  /**
   * Returns all the grid columns, same as `getColumns()`, except
   *
   *  a) it has the order of the columns that are presented in the grid
   *
   *  b) it's after the 'pivot' step, so if pivoting, has the value columns for the pivot.
   */
  getAllGridColumns() {
    return this.columnModel.getAllGridColumns();
  }
  /** Same as `getAllDisplayedColumns` but just for the pinned left portion of the grid. */
  getDisplayedLeftColumns() {
    return this.columnModel.getDisplayedLeftColumns();
  }
  /** Same as `getAllDisplayedColumns` but just for the center portion of the grid. */
  getDisplayedCenterColumns() {
    return this.columnModel.getDisplayedCenterColumns();
  }
  /** Same as `getAllDisplayedColumns` but just for the pinned right portion of the grid. */
  getDisplayedRightColumns() {
    return this.columnModel.getDisplayedRightColumns();
  }
  /** Returns all columns currently displayed (e.g. are visible and if in a group, the group is showing the columns) for the pinned left, centre and pinned right portions of the grid. */
  getAllDisplayedColumns() {
    return this.columnModel.getAllDisplayedColumns();
  }
  /** Same as `getAllGridColumns()`, except only returns rendered columns, i.e. columns that are not within the viewport and therefore not rendered, due to column virtualisation, are not displayed. */
  getAllDisplayedVirtualColumns() {
    return this.columnModel.getViewportColumns();
  }
  /** Moves a column to `toIndex`. The column is first removed, then added at the `toIndex` location, thus index locations will change to the right of the column after the removal. */
  moveColumn(e, t) {
    this.columnModel.moveColumn(e, t, "api");
  }
  /** Same as `moveColumn` but works on index locations. */
  moveColumnByIndex(e, t) {
    this.columnModel.moveColumnByIndex(e, t, "api");
  }
  /** Same as `moveColumn` but works on list. */
  moveColumns(e, t) {
    this.columnModel.moveColumns(e, t, "api");
  }
  /** Move the column to a new position in the row grouping order. */
  moveRowGroupColumn(e, t) {
    this.columnModel.moveRowGroupColumn(e, t);
  }
  /** Sets the agg function for a column. `aggFunc` can be one of the built-in aggregations or a custom aggregation by name or direct function. */
  setColumnAggFunc(e, t) {
    this.columnModel.setColumnAggFunc(e, t);
  }
  /** Sets the column width on a single column. The finished flag gets included in the resulting event and not used internally by the grid. The finished flag is intended for dragging, where a dragging action will produce many `columnWidth` events, so the consumer of events knows when it receives the last event in a stream. The finished parameter is optional, and defaults to `true`. */
  setColumnWidth(e, t, i = !0, r) {
    this.columnModel.setColumnWidths([{ key: e, newWidth: t }], !1, i, r);
  }
  /** Sets the column widths on multiple columns. This method offers better performance than calling `setColumnWidth` multiple times. The finished flag gets included in the resulting event and not used internally by the grid. The finished flag is intended for dragging, where a dragging action will produce many `columnWidth` events, so the consumer of events knows when it receives the last event in a stream. The finished parameter is optional, and defaults to `true`. */
  setColumnWidths(e, t = !0, i) {
    this.columnModel.setColumnWidths(e, !1, t, i);
  }
  /** Set the pivot mode. */
  setPivotMode(e) {
    this.columnModel.setPivotMode(e);
  }
  /** Get the pivot mode. */
  isPivotMode() {
    return this.columnModel.isPivotMode();
  }
  /** Returns the pivot result column for the given `pivotKeys` and `valueColId`. Useful to then call operations on the pivot column. */
  getPivotResultColumn(e, t) {
    return this.columnModel.getSecondaryPivotColumn(e, t);
  }
  /** Set the value columns to the provided list of columns. */
  setValueColumns(e) {
    this.columnModel.setValueColumns(e, "api");
  }
  /** Get a list of the existing value columns. */
  getValueColumns() {
    return this.columnModel.getValueColumns();
  }
  /** Remove the given column from the existing set of value columns. */
  removeValueColumn(e) {
    this.columnModel.removeValueColumn(e, "api");
  }
  /** Like `removeValueColumn` but remove the given list of columns from the existing set of value columns. */
  removeValueColumns(e) {
    this.columnModel.removeValueColumns(e, "api");
  }
  /** Add the given column to the set of existing value columns. */
  addValueColumn(e) {
    this.columnModel.addValueColumn(e, "api");
  }
  /** Like `addValueColumn` but add the given list of columns to the existing set of value columns. */
  addValueColumns(e) {
    this.columnModel.addValueColumns(e, "api");
  }
  /** Set the row group columns. */
  setRowGroupColumns(e) {
    this.columnModel.setRowGroupColumns(e, "api");
  }
  /** Remove a column from the row groups. */
  removeRowGroupColumn(e) {
    this.columnModel.removeRowGroupColumn(e, "api");
  }
  /** Same as `removeRowGroupColumn` but provide a list of columns. */
  removeRowGroupColumns(e) {
    this.columnModel.removeRowGroupColumns(e, "api");
  }
  /** Add a column to the row groups. */
  addRowGroupColumn(e) {
    this.columnModel.addRowGroupColumn(e, "api");
  }
  /** Same as `addRowGroupColumn` but provide a list of columns. */
  addRowGroupColumns(e) {
    this.columnModel.addRowGroupColumns(e, "api");
  }
  /** Get row group columns. */
  getRowGroupColumns() {
    return this.columnModel.getRowGroupColumns();
  }
  /** Set the pivot columns. */
  setPivotColumns(e) {
    this.columnModel.setPivotColumns(e, "api");
  }
  /** Remove a pivot column. */
  removePivotColumn(e) {
    this.columnModel.removePivotColumn(e, "api");
  }
  /** Same as `removePivotColumn` but provide a list of columns. */
  removePivotColumns(e) {
    this.columnModel.removePivotColumns(e, "api");
  }
  /** Add a pivot column. */
  addPivotColumn(e) {
    this.columnModel.addPivotColumn(e, "api");
  }
  /** Same as `addPivotColumn` but provide a list of columns. */
  addPivotColumns(e) {
    this.columnModel.addPivotColumns(e, "api");
  }
  /** Get the pivot columns. */
  getPivotColumns() {
    return this.columnModel.getPivotColumns();
  }
  /** Same as `getAllDisplayedColumnGroups` but just for the pinned left portion of the grid. */
  getLeftDisplayedColumnGroups() {
    return this.columnModel.getDisplayedTreeLeft();
  }
  /** Same as `getAllDisplayedColumnGroups` but just for the center portion of the grid. */
  getCenterDisplayedColumnGroups() {
    return this.columnModel.getDisplayedTreeCentre();
  }
  /** Same as `getAllDisplayedColumnGroups` but just for the pinned right portion of the grid. */
  getRightDisplayedColumnGroups() {
    return this.columnModel.getDisplayedTreeRight();
  }
  /** Returns all 'root' column headers. If you are not grouping columns, these return the columns. If you are grouping, these return the top level groups - you can navigate down through each one to get the other lower level headers and finally the columns at the bottom. */
  getAllDisplayedColumnGroups() {
    return this.columnModel.getAllDisplayedTrees();
  }
  /**
   * Auto-sizes a column based on its contents. If inferring cell data types with custom column types and row data is provided asynchronously,
   * the column sizing will happen asynchronously when row data is added. To always perform this synchronously,
   * set `cellDataType = false` on the default column definition.
   */
  autoSizeColumn(e, t) {
    return this.columnModel.autoSizeColumn(e, t, "api");
  }
  /**
   * Same as `autoSizeColumn`, but provide a list of column keys. If inferring cell data types with custom column types
   * and row data is provided asynchronously, the column sizing will happen asynchronously when row data is added.
   * To always perform this synchronously, set `cellDataType = false` on the default column definition.
   */
  autoSizeColumns(e, t) {
    this.columnModel.autoSizeColumns({ columns: e, skipHeader: t });
  }
  /**
   * Calls `autoSizeColumns` on all displayed columns. If inferring cell data types with custom column types
   * and row data is provided asynchronously, the column sizing will happen asynchronously when row data is added.
   * To always perform this synchronously, set `cellDataType = false` on the default column definition.
   */
  autoSizeAllColumns(e) {
    this.columnModel.autoSizeAllColumns(e, "api");
  }
  /** Set the pivot result columns. */
  setPivotResultColumns(e) {
    this.columnModel.setSecondaryColumns(e, "api");
  }
  /** Returns the grid's pivot result columns. */
  getPivotResultColumns() {
    return this.columnModel.getSecondaryColumns();
  }
  cleanDownReferencesToAvoidMemoryLeakInCaseApplicationIsKeepingReferenceToDestroyedGrid() {
    setTimeout(x.removeAllReferences.bind(window, this, "Column API"), 100);
  }
  /** @deprecated v28 Use `getColumns` instead */
  getAllColumns() {
    return rn("28.0", "getAllColumns", "getColumns"), this.getColumns();
  }
  /** @deprecated v28 Use `getColumns` instead. */
  getPrimaryColumns() {
    return rn("28.0", "getPrimaryColumns", "getColumns"), this.getColumns();
  }
  /** @deprecated v28 Use `getPivotResultColumns` instead. */
  getSecondaryColumns() {
    return rn("28.0", "getSecondaryColumns", "getPivotResultColumns"), this.getPivotResultColumns();
  }
  /** @deprecated v28 Use `setPivotResultColumns` instead. */
  setSecondaryColumns(e) {
    rn("28.0", "setSecondaryColumns", "setPivotResultColumns"), this.setPivotResultColumns(e);
  }
  /** @deprecated v28 Use `getPivotResultColumn` instead */
  getSecondaryPivotColumn(e, t) {
    return rn("28.0", "getSecondaryPivotColumn", "getPivotResultColumn"), this.getPivotResultColumn(e, t);
  }
};
xb([
  S("columnModel")
], Yh.prototype, "columnModel", void 0);
xb([
  dt
], Yh.prototype, "cleanDownReferencesToAvoidMemoryLeakInCaseApplicationIsKeepingReferenceToDestroyedGrid", null);
Yh = xb([
  q("columnApi")
], Yh);
var Cu = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let ya = class extends H {
  constructor() {
    super(...arguments), this.initialised = !1, this.isSsrm = !1;
  }
  init() {
    this.isSsrm = this.gridOptionsService.isRowModelType("serverSide"), this.cellExpressions = this.gridOptionsService.is("enableCellExpressions"), this.isTreeData = this.gridOptionsService.is("treeData"), this.initialised = !0, this.eventService.addEventListener(w.EVENT_CELL_VALUE_CHANGED, (e) => this.callColumnCellValueChangedHandler(e), this.gridOptionsService.useAsyncEvents()), this.addManagedPropertyListener("treeData", (e) => this.isTreeData = e.currentValue);
  }
  getValue(e, t, i = !1, r = !1) {
    if (this.initialised || this.init(), !t)
      return;
    const n = e.getColDef(), s = n.field, a = e.getColId(), l = t.data;
    let c;
    const d = t.groupData && t.groupData[a] !== void 0, u = !r && t.aggData && t.aggData[a] !== void 0, h = this.isSsrm && r && !!e.getColDef().aggFunc, p = this.isSsrm && t.footer && t.field && (e.getColDef().showRowGroup === !0 || e.getColDef().showRowGroup === t.field);
    if (i && n.filterValueGetter ? c = this.executeFilterValueGetter(n.filterValueGetter, l, e, t) : this.isTreeData && u ? c = t.aggData[a] : this.isTreeData && n.valueGetter ? c = this.executeValueGetter(n.valueGetter, l, e, t) : this.isTreeData && s && l ? c = bd(l, s, e.isFieldContainsDots()) : d ? c = t.groupData[a] : u ? c = t.aggData[a] : n.valueGetter ? c = this.executeValueGetter(n.valueGetter, l, e, t) : p ? c = bd(l, t.field, e.isFieldContainsDots()) : s && l && !h && (c = bd(l, s, e.isFieldContainsDots())), this.cellExpressions && typeof c == "string" && c.indexOf("=") === 0) {
      const f = c.substring(1);
      c = this.executeValueGetter(f, l, e, t);
    }
    if (c == null) {
      const f = this.getOpenedGroup(t, e);
      if (f != null)
        return f;
    }
    return c;
  }
  getOpenedGroup(e, t) {
    if (!this.gridOptionsService.is("showOpenedGroup") || !t.getColDef().showRowGroup)
      return;
    const r = t.getColDef().showRowGroup;
    let n = e.parent;
    for (; n != null; ) {
      if (n.rowGroupColumn && (r === !0 || r === n.rowGroupColumn.getColId()))
        return n.key;
      n = n.parent;
    }
  }
  /**
   * Sets the value of a GridCell
   * @param rowNode The `RowNode` to be updated
   * @param colKey The `Column` to be updated
   * @param newValue The new value to be set
   * @param eventSource The event source
   * @returns `True` if the value has been updated, otherwise`False`.
   */
  setValue(e, t, i, r) {
    const n = this.columnModel.getPrimaryColumn(t);
    if (!e || !n)
      return !1;
    Se(e.data) && (e.data = {});
    const { field: s, valueSetter: a } = n.getColDef();
    if (Se(s) && Se(a))
      return console.warn("AG Grid: you need either field or valueSetter set on colDef for editing to work"), !1;
    if (!this.dataTypeService.checkType(n, i))
      return console.warn("AG Grid: Data type of the new value does not match the cell data type of the column"), !1;
    const l = {
      node: e,
      data: e.data,
      oldValue: this.getValue(n, e),
      newValue: i,
      colDef: n.getColDef(),
      column: n,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context
    };
    l.newValue = i;
    let c;
    if (z(a) ? typeof a == "function" ? c = a(l) : c = this.expressionService.evaluate(a, l) : c = this.setValueUsingField(e.data, s, i, n.isFieldContainsDots()), c === void 0 && (c = !0), !c)
      return !1;
    e.resetQuickFilterAggregateText(), this.valueCache.onDataChanged(), l.newValue = this.getValue(n, e);
    const d = {
      type: w.EVENT_CELL_VALUE_CHANGED,
      event: null,
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: l.column,
      api: l.api,
      columnApi: l.columnApi,
      colDef: l.colDef,
      context: l.context,
      data: e.data,
      node: e,
      oldValue: l.oldValue,
      newValue: l.newValue,
      value: l.newValue,
      source: r
    };
    return this.eventService.dispatchEvent(d), !0;
  }
  callColumnCellValueChangedHandler(e) {
    const t = e.colDef.onCellValueChanged;
    typeof t == "function" && t({
      node: e.node,
      data: e.data,
      oldValue: e.oldValue,
      newValue: e.newValue,
      colDef: e.colDef,
      column: e.column,
      api: e.api,
      columnApi: e.columnApi,
      context: e.context
    });
  }
  setValueUsingField(e, t, i, r) {
    if (!t)
      return !1;
    let n = !1;
    if (!r)
      n = e[t] == i, n || (e[t] = i);
    else {
      const s = t.split(".");
      let a = e;
      for (; s.length > 0 && a; ) {
        const l = s.shift();
        s.length === 0 ? (n = a[l] == i, n || (a[l] = i)) : a = a[l];
      }
    }
    return !n;
  }
  executeFilterValueGetter(e, t, i, r) {
    const n = {
      data: t,
      node: r,
      column: i,
      colDef: i.getColDef(),
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context,
      getValue: this.getValueCallback.bind(this, r)
    };
    return typeof e == "function" ? e(n) : this.expressionService.evaluate(e, n);
  }
  executeValueGetter(e, t, i, r) {
    const n = i.getColId(), s = this.valueCache.getValue(r, n);
    if (s !== void 0)
      return s;
    const a = {
      data: t,
      node: r,
      column: i,
      colDef: i.getColDef(),
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context,
      getValue: this.getValueCallback.bind(this, r)
    };
    let l;
    return typeof e == "function" ? l = e(a) : l = this.expressionService.evaluate(e, a), this.valueCache.setValue(r, n, l), l;
  }
  getValueCallback(e, t) {
    const i = this.columnModel.getPrimaryColumn(t);
    return i ? this.getValue(i, e) : null;
  }
  // used by row grouping and pivot, to get key for a row. col can be a pivot col or a row grouping col
  getKeyForNode(e, t) {
    const i = this.getValue(e, t), r = e.getColDef().keyCreator;
    let n = i;
    if (r) {
      const s = {
        value: i,
        colDef: e.getColDef(),
        column: e,
        node: t,
        data: t.data,
        api: this.gridOptionsService.api,
        columnApi: this.gridOptionsService.columnApi,
        context: this.gridOptionsService.context
      };
      n = r(s);
    }
    return typeof n == "string" || n == null || (n = String(n), n === "[object Object]" && tt(() => {
      console.warn("AG Grid: a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (se AG Grid docs) or b) to toString() on the object to return a key");
    }, "getKeyForNode - warn about [object,object]")), n;
  }
};
Cu([
  S("expressionService")
], ya.prototype, "expressionService", void 0);
Cu([
  S("columnModel")
], ya.prototype, "columnModel", void 0);
Cu([
  S("valueCache")
], ya.prototype, "valueCache", void 0);
Cu([
  S("dataTypeService")
], ya.prototype, "dataTypeService", void 0);
Cu([
  B
], ya.prototype, "init", null);
ya = Cu([
  q("valueService")
], ya);
var Tx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, LN = function(o, e) {
  return function(t, i) {
    e(t, i, o);
  };
};
let Fg = class extends H {
  constructor() {
    super(...arguments), this.expressionToFunctionCache = {};
  }
  setBeans(e) {
    this.logger = e.create("ExpressionService");
  }
  evaluate(e, t) {
    if (typeof e == "string")
      return this.evaluateExpression(e, t);
    console.error("AG Grid: value should be either a string or a function", e);
  }
  evaluateExpression(e, t) {
    try {
      return this.createExpressionFunction(e)(t.value, t.context, t.oldValue, t.newValue, t.value, t.node, t.data, t.colDef, t.rowIndex, t.api, t.columnApi, t.getValue, t.column, t.columnGroup);
    } catch (i) {
      return console.log("Processing of the expression failed"), console.log("Expression = " + e), console.log("Params =", t), console.log("Exception = " + i), null;
    }
  }
  createExpressionFunction(e) {
    if (this.expressionToFunctionCache[e])
      return this.expressionToFunctionCache[e];
    const t = this.createFunctionBody(e), i = new Function("x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, columnApi, getValue, column, columnGroup", t);
    return this.expressionToFunctionCache[e] = i, i;
  }
  createFunctionBody(e) {
    return e.indexOf("return") >= 0 ? e : "return " + e + ";";
  }
};
Tx([
  LN(0, qi("loggerFactory"))
], Fg.prototype, "setBeans", null);
Fg = Tx([
  q("expressionService")
], Fg);
var NN = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let AC = class extends H {
  constructor() {
    super(...arguments), this.templateCache = {}, this.waitingCallbacks = {};
  }
  // returns the template if it is loaded, or null if it is not loaded
  // but will call the callback when it is loaded
  getTemplate(e, t) {
    const i = this.templateCache[e];
    if (i)
      return i;
    let r = this.waitingCallbacks[e];
    const n = this;
    if (!r) {
      r = [], this.waitingCallbacks[e] = r;
      const s = new XMLHttpRequest();
      s.onload = function() {
        n.handleHttpResult(this, e);
      }, s.open("GET", e), s.send();
    }
    return t && r.push(t), null;
  }
  handleHttpResult(e, t) {
    if (e.status !== 200 || e.response === null) {
      console.warn(`AG Grid: Unable to get template error ${e.status} - ${t}`);
      return;
    }
    this.templateCache[t] = e.response || e.responseText;
    const i = this.waitingCallbacks[t];
    for (let r = 0; r < i.length; r++) {
      const n = i[r];
      n();
    }
  }
};
AC = NN([
  q("templateService")
], AC);
var xx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, GN = function(o, e) {
  return function(t, i) {
    e(t, i, o);
  };
};
let Lg = class extends H {
  setBeans(e) {
    this.logging = e.is("debug");
  }
  create(e) {
    return new MC(e, this.isLogging.bind(this));
  }
  isLogging() {
    return this.logging;
  }
};
xx([
  GN(0, qi("gridOptionsService"))
], Lg.prototype, "setBeans", null);
Lg = xx([
  q("loggerFactory")
], Lg);
let MC = class {
  constructor(e, t) {
    this.name = e, this.isLoggingFunc = t;
  }
  isLogging() {
    return this.isLoggingFunc();
  }
  log(e) {
    this.isLoggingFunc() && console.log("AG Grid." + this.name + ": " + e);
  }
};
var Su = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class lc extends H {
  setComp(e, t, i) {
    this.view = e, this.eGridHostDiv = t, this.eGui = i, this.eGui.setAttribute("grid-id", this.context.getGridId()), this.dragAndDropService.addDropTarget({
      getContainer: () => this.eGui,
      isInterestedIn: (n) => n === Dt.HeaderCell || n === Dt.ToolPanel,
      getIconName: () => Te.ICON_NOT_ALLOWED
    }), this.mouseEventService.stampTopLevelGridCompWithGridInstance(t), this.createManagedBean(new Yv(this.view)), this.addRtlSupport(), this.addManagedListener(this, w.EVENT_KEYBOARD_FOCUS, () => {
      this.view.addOrRemoveKeyboardFocusClass(!0);
    }), this.addManagedListener(this, w.EVENT_MOUSE_FOCUS, () => {
      this.view.addOrRemoveKeyboardFocusClass(!1);
    });
    const r = this.resizeObserverService.observeResize(this.eGridHostDiv, this.onGridSizeChanged.bind(this));
    this.addDestroyFunc(() => r()), this.ctrlsService.registerGridCtrl(this);
  }
  isDetailGrid() {
    var e;
    const t = this.focusService.findTabbableParent(this.getGui());
    return ((e = t == null ? void 0 : t.getAttribute("row-id")) === null || e === void 0 ? void 0 : e.startsWith("detail")) || !1;
  }
  showDropZones() {
    return Z.__isRegistered(Q.RowGroupingModule, this.context.getGridId());
  }
  showSideBar() {
    return Z.__isRegistered(Q.SideBarModule, this.context.getGridId());
  }
  showStatusBar() {
    return Z.__isRegistered(Q.StatusBarModule, this.context.getGridId());
  }
  showWatermark() {
    return Z.__isRegistered(Q.EnterpriseCoreModule, this.context.getGridId());
  }
  onGridSizeChanged() {
    const e = {
      type: w.EVENT_GRID_SIZE_CHANGED,
      clientWidth: this.eGridHostDiv.clientWidth,
      clientHeight: this.eGridHostDiv.clientHeight
    };
    this.eventService.dispatchEvent(e);
  }
  addRtlSupport() {
    const e = this.gridOptionsService.is("enableRtl") ? "ag-rtl" : "ag-ltr";
    this.view.setRtlClass(e);
  }
  destroyGridUi() {
    this.view.destroyGridUi();
  }
  getGui() {
    return this.eGui;
  }
  setResizeCursor(e) {
    this.view.setCursor(e ? "ew-resize" : null);
  }
  disableUserSelect(e) {
    this.view.setUserSelect(e ? "none" : null);
  }
  focusNextInnerContainer(e) {
    const t = this.gridOptionsService.getDocument(), i = this.view.getFocusableContainers(), n = i.findIndex((s) => s.contains(t.activeElement)) + (e ? -1 : 1);
    return n <= 0 || n >= i.length ? !1 : this.focusService.focusInto(i[n]);
  }
  focusInnerElement(e) {
    const t = this.view.getFocusableContainers(), i = this.columnModel.getAllDisplayedColumns();
    if (e) {
      if (t.length > 1)
        return this.focusService.focusInto(at(t), !0);
      const r = at(i);
      if (this.focusService.focusGridView(r, !0))
        return !0;
    }
    return this.gridOptionsService.getNum("headerHeight") === 0 ? this.focusService.focusGridView(i[0]) : this.focusService.focusFirstHeader();
  }
  forceFocusOutOfContainer(e = !1) {
    this.view.forceFocusOutOfContainer(e);
  }
}
Su([
  S("focusService")
], lc.prototype, "focusService", void 0);
Su([
  S("resizeObserverService")
], lc.prototype, "resizeObserverService", void 0);
Su([
  S("columnModel")
], lc.prototype, "columnModel", void 0);
Su([
  S("ctrlsService")
], lc.prototype, "ctrlsService", void 0);
Su([
  S("mouseEventService")
], lc.prototype, "mouseEventService", void 0);
Su([
  S("dragAndDropService")
], lc.prototype, "dragAndDropService", void 0);
var sf = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class bu extends mu {
  constructor(e) {
    super(), this.eGridDiv = e;
  }
  postConstruct() {
    this.logger = this.loggerFactory.create("GridComp");
    const e = {
      destroyGridUi: () => this.destroyBean(this),
      setRtlClass: (i) => this.addCssClass(i),
      addOrRemoveKeyboardFocusClass: (i) => this.addOrRemoveCssClass(Ht.AG_KEYBOARD_FOCUS, i),
      forceFocusOutOfContainer: this.forceFocusOutOfContainer.bind(this),
      updateLayoutClasses: this.updateLayoutClasses.bind(this),
      getFocusableContainers: this.getFocusableContainers.bind(this),
      setUserSelect: (i) => {
        this.getGui().style.userSelect = i != null ? i : "", this.getGui().style.webkitUserSelect = i != null ? i : "";
      },
      setCursor: (i) => {
        this.getGui().style.cursor = i != null ? i : "";
      }
    };
    this.ctrl = this.createManagedBean(new lc());
    const t = this.createTemplate();
    this.setTemplate(t), this.ctrl.setComp(e, this.eGridDiv, this.getGui()), this.insertGridIntoDom(), this.initialiseTabGuard({
      // we want to override the default behaviour to do nothing for onTabKeyDown
      onTabKeyDown: () => {
      },
      focusInnerElement: (i) => this.ctrl.focusInnerElement(i)
    });
  }
  insertGridIntoDom() {
    const e = this.getGui();
    this.eGridDiv.appendChild(e), this.addDestroyFunc(() => {
      this.eGridDiv.removeChild(e), this.logger.log("Grid removed from DOM");
    });
  }
  updateLayoutClasses(e, t) {
    const i = this.eRootWrapperBody.classList;
    i.toggle(zt.AUTO_HEIGHT, t.autoHeight), i.toggle(zt.NORMAL, t.normal), i.toggle(zt.PRINT, t.print), this.addOrRemoveCssClass(zt.AUTO_HEIGHT, t.autoHeight), this.addOrRemoveCssClass(zt.NORMAL, t.normal), this.addOrRemoveCssClass(zt.PRINT, t.print);
  }
  createTemplate() {
    const e = this.ctrl.showDropZones() ? "<ag-grid-header-drop-zones></ag-grid-header-drop-zones>" : "", t = this.ctrl.showSideBar() ? '<ag-side-bar ref="sideBar"></ag-side-bar>' : "", i = this.ctrl.showStatusBar() ? '<ag-status-bar ref="statusBar"></ag-status-bar>' : "", r = this.ctrl.showWatermark() ? "<ag-watermark></ag-watermark>" : "";
    return (
      /* html */
      `<div class="ag-root-wrapper" role="presentation">
                ${e}
                <div class="ag-root-wrapper-body" ref="rootWrapperBody" role="presentation">
                    <ag-grid-body ref="gridBody"></ag-grid-body>
                    ${t}
                </div>
                ${i}
                <ag-pagination></ag-pagination>
                ${r}
            </div>`
    );
  }
  getFocusableElement() {
    return this.eRootWrapperBody;
  }
  getFocusableContainers() {
    const e = [
      this.gridBodyComp.getGui()
    ];
    return this.sideBarComp && e.push(this.sideBarComp.getGui()), e.filter((t) => Ms(t));
  }
}
sf([
  S("loggerFactory")
], bu.prototype, "loggerFactory", void 0);
sf([
  L("gridBody")
], bu.prototype, "gridBodyComp", void 0);
sf([
  L("sideBar")
], bu.prototype, "sideBarComp", void 0);
sf([
  L("rootWrapperBody")
], bu.prototype, "eRootWrapperBody", void 0);
sf([
  B
], bu.prototype, "postConstruct", null);
var Dx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, pg;
let Xh = pg = class extends H {
  progressSort(e, t, i) {
    const r = this.getNextSortDirection(e);
    this.setSortForColumn(e, r, t, i);
  }
  setSortForColumn(e, t, i, r) {
    t !== "asc" && t !== "desc" && (t = null);
    const n = this.gridOptionsService.isColumnsSortingCoupledToGroup();
    let s = [e];
    if (n && e.getColDef().showRowGroup) {
      const l = this.columnModel.getSourceColumnsForGroupColumn(e), c = l == null ? void 0 : l.filter((d) => d.getColDef().sortable);
      c && (s = [e, ...c]);
    }
    s.forEach((l) => l.setSort(t, r)), (i || this.gridOptionsService.is("alwaysMultiSort")) && !this.gridOptionsService.is("suppressMultiSort") || this.clearSortBarTheseColumns(s, r), this.updateSortIndex(e), this.dispatchSortChangedEvents(r);
  }
  updateSortIndex(e) {
    const t = this.gridOptionsService.isColumnsSortingCoupledToGroup(), i = this.columnModel.getGroupDisplayColumnForGroup(e.getId()), r = t && i || e, n = this.getColumnsWithSortingOrdered();
    this.columnModel.getPrimaryAndSecondaryAndAutoColumns().forEach((l) => l.setSortIndex(null));
    const s = n.filter((l) => l !== r);
    (r.getSort() ? [...s, r] : s).forEach((l, c) => l.setSortIndex(c));
  }
  // gets called by API, so if data changes, use can call this, which will end up
  // working out the sort order again of the rows.
  onSortChanged(e) {
    this.dispatchSortChangedEvents(e);
  }
  isSortActive() {
    const t = this.columnModel.getPrimaryAndSecondaryAndAutoColumns().filter((i) => !!i.getSort());
    return t && t.length > 0;
  }
  dispatchSortChangedEvents(e) {
    const t = {
      type: w.EVENT_SORT_CHANGED,
      source: e
    };
    this.eventService.dispatchEvent(t);
  }
  clearSortBarTheseColumns(e, t) {
    this.columnModel.getPrimaryAndSecondaryAndAutoColumns().forEach((i) => {
      e.includes(i) || i.setSort(void 0, t);
    });
  }
  getNextSortDirection(e) {
    let t;
    if (e.getColDef().sortingOrder ? t = e.getColDef().sortingOrder : this.gridOptionsService.get("sortingOrder") ? t = this.gridOptionsService.get("sortingOrder") : t = pg.DEFAULT_SORTING_ORDER, !Array.isArray(t) || t.length <= 0)
      return console.warn(`AG Grid: sortingOrder must be an array with at least one element, currently it's ${t}`), null;
    const i = t.indexOf(e.getSort()), r = i < 0, n = i == t.length - 1;
    let s;
    return r || n ? s = t[0] : s = t[i + 1], pg.DEFAULT_SORTING_ORDER.indexOf(s) < 0 ? (console.warn("AG Grid: invalid sort type " + s), null) : s;
  }
  /**
   * @param includeRedundantColumns whether to include non-grouped, non-secondary, non-aggregated columns when pivot active
   * @returns a map of sort indexes for every sorted column, if groups sort primaries then they will have equivalent indices
   */
  getIndexedSortMap() {
    let e = this.columnModel.getPrimaryAndSecondaryAndAutoColumns().filter((s) => !!s.getSort());
    if (this.columnModel.isPivotMode()) {
      const s = this.gridOptionsService.isColumnsSortingCoupledToGroup();
      e = e.filter((a) => {
        const l = !!a.getAggFunc(), c = !a.isPrimary(), d = s ? this.columnModel.getGroupDisplayColumnForGroup(a.getId()) : a.getColDef().showRowGroup;
        return l || c || d;
      });
    }
    const t = this.columnModel.getRowGroupColumns().filter((s) => !!s.getSort()), i = this.gridOptionsService.isColumnsSortingCoupledToGroup() && !!t.length;
    i && (e = [
      ...new Set(
        // if linked sorting, replace all columns with the display group column for index purposes, and ensure uniqueness
        e.map((s) => {
          var a;
          return (a = this.columnModel.getGroupDisplayColumnForGroup(s.getId())) !== null && a !== void 0 ? a : s;
        })
      )
    ]);
    const r = {};
    e.forEach((s, a) => r[s.getId()] = a), e.sort((s, a) => {
      const l = s.getSortIndex(), c = a.getSortIndex();
      if (l != null && c != null)
        return l - c;
      if (l == null && c == null) {
        const d = r[s.getId()], u = r[a.getId()];
        return d > u ? 1 : -1;
      } else
        return c == null ? -1 : 1;
    });
    const n = /* @__PURE__ */ new Map();
    return e.forEach((s, a) => n.set(s, a)), i && t.forEach((s) => {
      const a = this.columnModel.getGroupDisplayColumnForGroup(s.getId());
      n.set(s, n.get(a));
    }), n;
  }
  getColumnsWithSortingOrdered() {
    return [...this.getIndexedSortMap().entries()].sort(([e, t], [i, r]) => t - r).map(([e]) => e);
  }
  // used by server side row models, to sent sort to server
  getSortModel() {
    return this.getColumnsWithSortingOrdered().map((e) => ({
      sort: e.getSort(),
      colId: e.getId()
    }));
  }
  getSortOptions() {
    return this.getColumnsWithSortingOrdered().map((e) => ({
      sort: e.getSort(),
      column: e
    }));
  }
  canColumnDisplayMixedSort(e) {
    const t = this.gridOptionsService.isColumnsSortingCoupledToGroup(), i = !!e.getColDef().showRowGroup;
    return t && i;
  }
  getDisplaySortForColumn(e) {
    const t = this.columnModel.getSourceColumnsForGroupColumn(e);
    if (!this.canColumnDisplayMixedSort(e) || !(t != null && t.length))
      return e.getSort();
    const r = !!e.getColDef().field ? [e, ...t] : t, n = r[0].getSort();
    return r.every((a) => a.getSort() == n) ? n : "mixed";
  }
  getDisplaySortIndexForColumn(e) {
    return this.getIndexedSortMap().get(e);
  }
};
Xh.DEFAULT_SORTING_ORDER = ["asc", "desc", null];
Dx([
  S("columnModel")
], Xh.prototype, "columnModel", void 0);
Xh = pg = Dx([
  q("sortController")
], Xh);
var kN = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let _C = class extends H {
  setMouseOver(e) {
    this.selectedColumns = e;
    const t = {
      type: w.EVENT_COLUMN_HOVER_CHANGED
    };
    this.eventService.dispatchEvent(t);
  }
  clearMouseOver() {
    this.selectedColumns = null;
    const e = {
      type: w.EVENT_COLUMN_HOVER_CHANGED
    };
    this.eventService.dispatchEvent(e);
  }
  isHovered(e) {
    return !!this.selectedColumns && this.selectedColumns.indexOf(e) >= 0;
  }
};
_C = kN([
  q("columnHoverService")
], _C);
var Db = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let qh = class extends H {
  constructor() {
    super(...arguments), this.executeNextFuncs = [], this.executeLaterFuncs = [], this.active = !1, this.animationThreadCount = 0;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => this.gridBodyCtrl = e.gridBodyCtrl);
  }
  isActive() {
    return this.active;
  }
  start() {
    this.active || this.gridOptionsService.is("suppressColumnMoveAnimation") || this.gridOptionsService.is("enableRtl") || (this.ensureAnimationCssClassPresent(), this.active = !0);
  }
  finish() {
    this.active && (this.flush(), this.active = !1);
  }
  executeNextVMTurn(e) {
    this.active ? this.executeNextFuncs.push(e) : e();
  }
  executeLaterVMTurn(e) {
    this.active ? this.executeLaterFuncs.push(e) : e();
  }
  ensureAnimationCssClassPresent() {
    this.animationThreadCount++;
    const e = this.animationThreadCount;
    this.gridBodyCtrl.setColumnMovingCss(!0), this.executeLaterFuncs.push(() => {
      this.animationThreadCount === e && this.gridBodyCtrl.setColumnMovingCss(!1);
    });
  }
  flush() {
    const e = this.executeNextFuncs;
    this.executeNextFuncs = [];
    const t = this.executeLaterFuncs;
    this.executeLaterFuncs = [], !(e.length === 0 && t.length === 0) && (window.setTimeout(() => e.forEach((i) => i()), 0), window.setTimeout(() => t.forEach((i) => i()), 300));
  }
};
Db([
  S("ctrlsService")
], qh.prototype, "ctrlsService", void 0);
Db([
  B
], qh.prototype, "postConstruct", null);
qh = Db([
  q("columnAnimationService")
], qh);
var Ob = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Zh = class extends H {
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.centerRowContainerCon = e.centerRowContainerCtrl, this.addManagedListener(this.eventService, w.EVENT_BODY_HEIGHT_CHANGED, this.checkPageSize.bind(this)), this.addManagedListener(this.eventService, w.EVENT_SCROLL_VISIBILITY_CHANGED, this.checkPageSize.bind(this)), this.checkPageSize();
    });
  }
  notActive() {
    return !this.gridOptionsService.is("paginationAutoPageSize") || this.centerRowContainerCon == null;
  }
  checkPageSize() {
    if (this.notActive())
      return;
    const e = this.centerRowContainerCon.getViewportSizeFeature().getBodyHeight();
    if (e > 0) {
      const t = () => {
        const i = this.gridOptionsService.getRowHeightAsNumber(), r = Math.floor(e / i);
        this.gridOptionsService.set("paginationPageSize", r);
      };
      this.isBodyRendered ? Co(() => t(), 50)() : (t(), this.isBodyRendered = !0);
    } else
      this.isBodyRendered = !1;
  }
};
Ob([
  S("ctrlsService")
], Zh.prototype, "ctrlsService", void 0);
Ob([
  B
], Zh.prototype, "postConstruct", null);
Zh = Ob([
  q("paginationAutoPageSizeService")
], Zh);
var Ox = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Ng = class extends H {
  constructor() {
    super(...arguments), this.cacheVersion = 0;
  }
  init() {
    this.active = this.gridOptionsService.is("valueCache"), this.neverExpires = this.gridOptionsService.is("valueCacheNeverExpires");
  }
  onDataChanged() {
    this.neverExpires || this.expire();
  }
  expire() {
    this.cacheVersion++;
  }
  setValue(e, t, i) {
    this.active && (e.__cacheVersion !== this.cacheVersion && (e.__cacheVersion = this.cacheVersion, e.__cacheData = {}), e.__cacheData[t] = i);
  }
  getValue(e, t) {
    if (!(!this.active || e.__cacheVersion !== this.cacheVersion))
      return e.__cacheData[t];
  }
};
Ox([
  B
], Ng.prototype, "init", null);
Ng = Ox([
  q("valueCache")
], Ng);
var pm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const VN = "paste";
let kd = class extends H {
  init() {
    this.rowModel.getType() === "clientSide" && (this.clientSideRowModel = this.rowModel), this.addManagedListener(this.eventService, w.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged.bind(this));
  }
  onCellValueChanged(e) {
    e.source !== VN && this.doChangeDetection(e.node, e.column);
  }
  doChangeDetection(e, t) {
    if (this.gridOptionsService.is("suppressChangeDetection"))
      return;
    const i = [e];
    if (this.clientSideRowModel && !e.isRowPinned()) {
      const r = this.gridOptionsService.is("aggregateOnlyChangedColumns"), n = new dm(r, this.clientSideRowModel.getRootNode());
      n.addParentNode(e.parent, [t]), this.clientSideRowModel.doAggregate(n), n.forEachChangedNodeDepthFirst((s) => {
        i.push(s);
      });
    }
    this.rowRenderer.refreshCells({ rowNodes: i });
  }
};
pm([
  S("rowModel")
], kd.prototype, "rowModel", void 0);
pm([
  S("rowRenderer")
], kd.prototype, "rowRenderer", void 0);
pm([
  B
], kd.prototype, "init", null);
kd = pm([
  q("changeDetectionService")
], kd);
var Px = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Gg = class extends H {
  adaptFunction(e, t) {
    const i = this.componentMetadataProvider.retrieve(e);
    return i && i.functionAdapter ? i.functionAdapter(t) : null;
  }
  adaptCellRendererFunction(e) {
    class t {
      refresh(r) {
        return !1;
      }
      getGui() {
        return this.eGui;
      }
      init(r) {
        const n = e(r), s = typeof n;
        if (s === "string" || s === "number" || s === "boolean") {
          this.eGui = Si("<span>" + n + "</span>");
          return;
        }
        if (n == null) {
          this.eGui = Si("<span></span>");
          return;
        }
        this.eGui = n;
      }
    }
    return t;
  }
  doesImplementIComponent(e) {
    return e ? e.prototype && "getGui" in e.prototype : !1;
  }
};
Px([
  S("componentMetadataProvider")
], Gg.prototype, "componentMetadataProvider", void 0);
Gg = Px([
  q("agComponentUtils")
], Gg);
var Pb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Qh = class extends H {
  postConstruct() {
    this.componentMetaData = {
      dateComponent: {
        mandatoryMethodList: ["getDate", "setDate"],
        optionalMethodList: ["afterGuiAttached", "setInputPlaceholder", "setInputAriaLabel"]
      },
      detailCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      headerComponent: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      headerGroupComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      loadingCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      loadingOverlayComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      noRowsOverlayComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      floatingFilterComponent: {
        mandatoryMethodList: ["onParentModelChanged"],
        optionalMethodList: ["afterGuiAttached"]
      },
      floatingFilterWrapperComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      cellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      cellEditor: {
        mandatoryMethodList: ["getValue"],
        optionalMethodList: ["isPopup", "isCancelBeforeStart", "isCancelAfterEnd", "getPopupPosition", "focusIn", "focusOut", "afterGuiAttached"]
      },
      innerRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      fullWidthCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      groupRowRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      filter: {
        mandatoryMethodList: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
        optionalMethodList: ["afterGuiAttached", "afterGuiDetached", "onNewRowsLoaded", "getModelAsString", "onFloatingFilterChanged", "onAnyFilterChanged"]
      },
      filterComponent: {
        mandatoryMethodList: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
        optionalMethodList: ["afterGuiAttached", "afterGuiDetached", "onNewRowsLoaded", "getModelAsString", "onFloatingFilterChanged", "onAnyFilterChanged"]
      },
      statusPanel: {
        mandatoryMethodList: [],
        optionalMethodList: ["afterGuiAttached"]
      },
      toolPanel: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "afterGuiAttached"]
      },
      tooltipComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      }
    };
  }
  retrieve(e) {
    return this.componentMetaData[e];
  }
};
Pb([
  S("agComponentUtils")
], Qh.prototype, "agComponentUtils", void 0);
Pb([
  B
], Qh.prototype, "postConstruct", null);
Qh = Pb([
  q("componentMetadataProvider")
], Qh);
var Ab = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const BN = 25, Jw = 10, Ry = 8, HN = 4, Ty = 4, xy = 6, WN = {
  // this item is required for custom themes
  "ag-theme-custom": {
    headerHeight: 25,
    headerCellMinWidth: 24,
    listItemHeight: HN * 5,
    rowHeight: 25,
    chartMenuPanelWidth: 220
  },
  "ag-theme-material": {
    headerHeight: Ry * 7,
    headerCellMinWidth: 48,
    listItemHeight: Ry * 4,
    rowHeight: Ry * 6,
    chartMenuPanelWidth: 240
  },
  "ag-theme-balham": {
    headerHeight: Ty * 8,
    headerCellMinWidth: 24,
    listItemHeight: Ty * 6,
    rowHeight: Ty * 7,
    chartMenuPanelWidth: 220
  },
  "ag-theme-alpine": {
    headerHeight: xy * 8,
    headerCellMinWidth: 36,
    listItemHeight: xy * 4,
    rowHeight: xy * 7,
    chartMenuPanelWidth: 240
  }
}, e0 = {
  headerHeight: ["ag-header-row"],
  headerCellMinWidth: ["ag-header-cell"],
  listItemHeight: ["ag-virtual-list-item"],
  rowHeight: ["ag-row"],
  chartMenuPanelWidth: ["ag-chart-docked-container"]
};
let Jh = class extends H {
  constructor() {
    super(...arguments), this.calculatedSizes = {};
  }
  postConstruct() {
    var e;
    const t = (e = this.getTheme().el) !== null && e !== void 0 ? e : this.eGridDiv;
    this.mutationObserver = new MutationObserver(() => {
      this.calculatedSizes = {}, this.fireGridStylesChangedEvent();
    }), this.mutationObserver.observe(t || this.eGridDiv, {
      attributes: !0,
      attributeFilter: ["class"]
    });
  }
  fireGridStylesChangedEvent() {
    const e = {
      type: w.EVENT_GRID_STYLES_CHANGED
    };
    this.eventService.dispatchEvent(e);
  }
  getSassVariable(e) {
    const { themeFamily: t, el: i } = this.getTheme();
    if (!t || t.indexOf("ag-theme") !== 0)
      return;
    this.calculatedSizes || (this.calculatedSizes = {}), this.calculatedSizes[t] || (this.calculatedSizes[t] = {});
    const r = this.calculatedSizes[t][e];
    return r != null ? r : (this.calculatedSizes[t][e] = this.calculateValueForSassProperty(e, t, i), this.calculatedSizes[t][e]);
  }
  calculateValueForSassProperty(e, t, i) {
    const r = "ag-theme-" + (t.match("material") ? "material" : t.match("balham") ? "balham" : t.match("alpine") ? "alpine" : "custom"), n = WN[r][e], s = this.gridOptionsService.getDocument();
    if (i || (i = this.eGridDiv), !e0[e])
      return n;
    const a = e0[e], l = s.createElement("div"), c = Array.from(i.classList);
    l.classList.add(t, ...c), l.style.position = "absolute";
    const d = a.reduce((h, p) => {
      const f = s.createElement("div");
      return f.style.position = "static", f.classList.add(p), h.appendChild(f), f;
    }, l);
    let u = 0;
    if (s.body) {
      s.body.appendChild(l);
      const h = e.toLowerCase().indexOf("height") !== -1 ? "height" : "width";
      u = parseInt(window.getComputedStyle(d)[h], 10), s.body.removeChild(l);
    }
    return u || n;
  }
  isThemeDark() {
    const { theme: e } = this.getTheme();
    return !!e && e.indexOf("dark") >= 0;
  }
  chartMenuPanelWidth() {
    return this.getSassVariable("chartMenuPanelWidth");
  }
  getTheme() {
    const e = /\bag-(material|(?:theme-([\w\-]*)))\b/g;
    let t = this.eGridDiv, i = null, r = [];
    for (; t; )
      if (i = e.exec(t.className), !i)
        t = t.parentElement || void 0;
      else {
        const s = t.className.match(e);
        s && (r = s);
        break;
      }
    if (!i)
      return { allThemes: r };
    const n = i[0];
    return { theme: n, el: t, themeFamily: n.replace(/-dark$/, ""), allThemes: r };
  }
  getFromTheme(e, t) {
    var i;
    return (i = this.getSassVariable(t)) !== null && i !== void 0 ? i : e;
  }
  getDefaultRowHeight() {
    return this.getFromTheme(BN, "rowHeight");
  }
  getListItemHeight() {
    return this.getFromTheme(20, "listItemHeight");
  }
  setRowHeightVariable(e) {
    const t = this.eGridDiv.style.getPropertyValue("--ag-line-height").trim(), i = `${e}px`;
    t != i && this.eGridDiv.style.setProperty("--ag-line-height", i);
  }
  getMinColWidth() {
    const e = this.getFromTheme(null, "headerCellMinWidth");
    return z(e) ? Math.max(e, Jw) : Jw;
  }
  destroy() {
    this.calculatedSizes = null, this.mutationObserver && this.mutationObserver.disconnect(), super.destroy();
  }
};
Ab([
  S("eGridDiv")
], Jh.prototype, "eGridDiv", void 0);
Ab([
  B
], Jh.prototype, "postConstruct", null);
Jh = Ab([
  q("environment")
], Jh);
var fm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, jN = function(o, e) {
  return function(t, i) {
    e(t, i, o);
  };
};
let Vd = class extends H {
  constructor() {
    super(...arguments), this.scrollY = 0, this.uiBodyHeight = 0;
  }
  agWire(e) {
    this.logger = e.create("RowContainerHeightService");
  }
  postConstruct() {
    this.addManagedListener(this.eventService, w.EVENT_BODY_HEIGHT_CHANGED, this.updateOffset.bind(this)), this.maxDivHeight = bT(), this.logger.log("maxDivHeight = " + this.maxDivHeight);
  }
  isStretching() {
    return this.stretching;
  }
  getDivStretchOffset() {
    return this.divStretchOffset;
  }
  updateOffset() {
    if (!this.stretching)
      return;
    const t = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition().top, i = this.getUiBodyHeight();
    (t !== this.scrollY || i !== this.uiBodyHeight) && (this.scrollY = t, this.uiBodyHeight = i, this.calculateOffset());
  }
  calculateOffset() {
    this.setUiContainerHeight(this.maxDivHeight), this.pixelsToShave = this.modelHeight - this.uiContainerHeight, this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
    const e = this.scrollY / this.maxScrollY, t = e * this.pixelsToShave;
    this.logger.log(`Div Stretch Offset = ${t} (${this.pixelsToShave} * ${e})`), this.setDivStretchOffset(t);
  }
  setUiContainerHeight(e) {
    e !== this.uiContainerHeight && (this.uiContainerHeight = e, this.eventService.dispatchEvent({ type: w.EVENT_ROW_CONTAINER_HEIGHT_CHANGED }));
  }
  clearOffset() {
    this.setUiContainerHeight(this.modelHeight), this.pixelsToShave = 0, this.setDivStretchOffset(0);
  }
  setDivStretchOffset(e) {
    const t = typeof e == "number" ? Math.floor(e) : null;
    this.divStretchOffset !== t && (this.divStretchOffset = t, this.eventService.dispatchEvent({ type: w.EVENT_HEIGHT_SCALE_CHANGED }));
  }
  setModelHeight(e) {
    this.modelHeight = e, this.stretching = e != null && this.maxDivHeight > 0 && e > this.maxDivHeight, this.stretching ? this.calculateOffset() : this.clearOffset();
  }
  getUiContainerHeight() {
    return this.uiContainerHeight;
  }
  getRealPixelPosition(e) {
    return e - this.divStretchOffset;
  }
  getUiBodyHeight() {
    const t = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition();
    return t.bottom - t.top;
  }
  getScrollPositionForPixel(e) {
    if (this.pixelsToShave <= 0)
      return e;
    const t = this.modelHeight - this.getUiBodyHeight(), i = e / t;
    return this.maxScrollY * i;
  }
};
fm([
  S("ctrlsService")
], Vd.prototype, "ctrlsService", void 0);
fm([
  jN(0, qi("loggerFactory"))
], Vd.prototype, "agWire", null);
fm([
  B
], Vd.prototype, "postConstruct", null);
Vd = fm([
  q("rowContainerHeightService")
], Vd);
var Ax = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let kg = class extends H {
  init() {
    this.groupSelectsChildren = this.gridOptionsService.is("groupSelectsChildren"), this.isRowSelectableFunc = this.gridOptionsService.get("isRowSelectable");
  }
  updateSelectableAfterGrouping(e) {
    if (this.isRowSelectableFunc) {
      const t = (i) => i.childrenAfterGroup;
      this.recurseDown(e.childrenAfterGroup, t);
    }
  }
  recurseDown(e, t) {
    e && e.forEach((i) => {
      if (!i.group)
        return;
      i.hasChildren() && this.recurseDown(t(i), t);
      let r;
      if (this.groupSelectsChildren) {
        const n = (t(i) || []).find((s) => s.selectable === !0);
        r = z(n);
      } else
        r = this.isRowSelectableFunc ? this.isRowSelectableFunc(i) : !1;
      i.setRowSelectable(r);
    });
  }
};
Ax([
  B
], kg.prototype, "init", null);
kg = Ax([
  q("selectableService")
], kg);
var wn = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Wr extends X {
  constructor() {
    super(), this.previousAndFirstButtonsDisabled = !1, this.nextButtonDisabled = !1, this.lastButtonDisabled = !1, this.areListenersSetup = !1;
  }
  postConstruct() {
    const e = this.gridOptionsService.is("enableRtl");
    this.setTemplate(this.getTemplate());
    const { btFirst: t, btPrevious: i, btNext: r, btLast: n } = this;
    this.activateTabIndex([t, i, r, n]), t.insertAdjacentElement("afterbegin", Vt(e ? "last" : "first", this.gridOptionsService)), i.insertAdjacentElement("afterbegin", Vt(e ? "next" : "previous", this.gridOptionsService)), r.insertAdjacentElement("afterbegin", Vt(e ? "previous" : "next", this.gridOptionsService)), n.insertAdjacentElement("afterbegin", Vt(e ? "first" : "last", this.gridOptionsService)), this.addManagedPropertyListener("pagination", this.onPaginationChanged.bind(this)), this.addManagedPropertyListener("suppressPaginationPanel", this.onPaginationChanged.bind(this)), this.onPaginationChanged();
  }
  onPaginationChanged() {
    const t = this.gridOptionsService.is("pagination") && !this.gridOptionsService.is("suppressPaginationPanel");
    this.setDisplayed(t), t && (this.setupListeners(), this.enableOrDisableButtons(), this.updateRowLabels(), this.setCurrentPageLabel(), this.setTotalLabels());
  }
  setupListeners() {
    this.areListenersSetup || (this.addManagedListener(this.eventService, w.EVENT_PAGINATION_CHANGED, this.onPaginationChanged.bind(this)), [
      { el: this.btFirst, fn: this.onBtFirst.bind(this) },
      { el: this.btPrevious, fn: this.onBtPrevious.bind(this) },
      { el: this.btNext, fn: this.onBtNext.bind(this) },
      { el: this.btLast, fn: this.onBtLast.bind(this) }
    ].forEach((e) => {
      const { el: t, fn: i } = e;
      this.addManagedListener(t, "click", i), this.addManagedListener(t, "keydown", (r) => {
        (r.key === V.ENTER || r.key === V.SPACE) && (r.preventDefault(), i());
      });
    }), this.areListenersSetup = !0);
  }
  onBtFirst() {
    this.previousAndFirstButtonsDisabled || this.paginationProxy.goToFirstPage();
  }
  setCurrentPageLabel() {
    const e = this.paginationProxy.getTotalPages() > 0, t = this.paginationProxy.getCurrentPage(), i = e ? t + 1 : 0;
    this.lbCurrent.innerHTML = this.formatNumber(i);
  }
  formatNumber(e) {
    const t = this.gridOptionsService.getCallback("paginationNumberFormatter");
    if (t)
      return t({ value: e });
    const i = this.localeService.getLocaleTextFunc(), r = i("thousandSeparator", ","), n = i("decimalSeparator", ".");
    return _S(e, r, n);
  }
  getTemplate() {
    const e = this.localeService.getLocaleTextFunc(), t = e("page", "Page"), i = e("to", "to"), r = e("of", "of"), n = e("firstPage", "First Page"), s = e("previousPage", "Previous Page"), a = e("nextPage", "Next Page"), l = e("lastPage", "Last Page"), c = this.getCompId();
    return (
      /* html */
      `<div class="ag-paging-panel ag-unselectable" id="ag-${c}">
                <span class="ag-paging-row-summary-panel" role="status">
                    <span id="ag-${c}-first-row" ref="lbFirstRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${c}-to">${i}</span>
                    <span id="ag-${c}-last-row" ref="lbLastRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${c}-of">${r}</span>
                    <span id="ag-${c}-row-count" ref="lbRecordCount" class="ag-paging-row-summary-panel-number"></span>
                </span>
                <span class="ag-paging-page-summary-panel" role="presentation">
                    <div ref="btFirst" class="ag-button ag-paging-button" role="button" aria-label="${n}"></div>
                    <div ref="btPrevious" class="ag-button ag-paging-button" role="button" aria-label="${s}"></div>
                    <span class="ag-paging-description" role="status">
                        <span id="ag-${c}-start-page">${t}</span>
                        <span id="ag-${c}-start-page-number" ref="lbCurrent" class="ag-paging-number"></span>
                        <span id="ag-${c}-of-page">${r}</span>
                        <span id="ag-${c}-of-page-number" ref="lbTotal" class="ag-paging-number"></span>
                    </span>
                    <div ref="btNext" class="ag-button ag-paging-button" role="button" aria-label="${a}"></div>
                    <div ref="btLast" class="ag-button ag-paging-button" role="button" aria-label="${l}"></div>
                </span>
            </div>`
    );
  }
  onBtNext() {
    this.nextButtonDisabled || this.paginationProxy.goToNextPage();
  }
  onBtPrevious() {
    this.previousAndFirstButtonsDisabled || this.paginationProxy.goToPreviousPage();
  }
  onBtLast() {
    this.lastButtonDisabled || this.paginationProxy.goToLastPage();
  }
  enableOrDisableButtons() {
    const e = this.paginationProxy.getCurrentPage(), t = this.paginationProxy.isLastPageFound(), i = this.paginationProxy.getTotalPages();
    this.previousAndFirstButtonsDisabled = e === 0, this.toggleButtonDisabled(this.btFirst, this.previousAndFirstButtonsDisabled), this.toggleButtonDisabled(this.btPrevious, this.previousAndFirstButtonsDisabled);
    const r = this.isZeroPagesToDisplay(), n = t && e === i - 1;
    this.nextButtonDisabled = n || r, this.lastButtonDisabled = !t || r || e === i - 1, this.toggleButtonDisabled(this.btNext, this.nextButtonDisabled), this.toggleButtonDisabled(this.btLast, this.lastButtonDisabled);
  }
  toggleButtonDisabled(e, t) {
    RS(e, t), e.classList.toggle("ag-disabled", t);
  }
  updateRowLabels() {
    const e = this.paginationProxy.getCurrentPage(), t = this.paginationProxy.getPageSize(), i = this.paginationProxy.isLastPageFound(), r = this.paginationProxy.isLastPageFound() ? this.paginationProxy.getMasterRowCount() : null;
    let n, s;
    if (this.isZeroPagesToDisplay() ? n = s = 0 : (n = t * e + 1, s = n + t - 1, i && s > r && (s = r)), this.lbFirstRowOnPage.innerHTML = this.formatNumber(n), this.rowNodeBlockLoader.isLoading()) {
      const a = this.localeService.getLocaleTextFunc();
      this.lbLastRowOnPage.innerHTML = a("pageLastRowUnknown", "?");
    } else
      this.lbLastRowOnPage.innerHTML = this.formatNumber(s);
  }
  isZeroPagesToDisplay() {
    const e = this.paginationProxy.isLastPageFound(), t = this.paginationProxy.getTotalPages();
    return e && t === 0;
  }
  setTotalLabels() {
    const e = this.paginationProxy.isLastPageFound(), t = this.paginationProxy.getTotalPages(), i = e ? this.paginationProxy.getMasterRowCount() : null;
    if (i === 1) {
      const r = this.paginationProxy.getRow(0);
      if (r && r.group && !(r.groupData || r.aggData)) {
        this.setTotalLabelsToZero();
        return;
      }
    }
    if (e)
      this.lbTotal.innerHTML = this.formatNumber(t), this.lbRecordCount.innerHTML = this.formatNumber(i);
    else {
      const r = this.localeService.getLocaleTextFunc()("more", "more");
      this.lbTotal.innerHTML = r, this.lbRecordCount.innerHTML = r;
    }
  }
  setTotalLabelsToZero() {
    this.lbFirstRowOnPage.innerHTML = this.formatNumber(0), this.lbCurrent.innerHTML = this.formatNumber(0), this.lbLastRowOnPage.innerHTML = this.formatNumber(0), this.lbTotal.innerHTML = this.formatNumber(0), this.lbRecordCount.innerHTML = this.formatNumber(0);
  }
}
wn([
  S("paginationProxy")
], Wr.prototype, "paginationProxy", void 0);
wn([
  S("rowNodeBlockLoader")
], Wr.prototype, "rowNodeBlockLoader", void 0);
wn([
  L("btFirst")
], Wr.prototype, "btFirst", void 0);
wn([
  L("btPrevious")
], Wr.prototype, "btPrevious", void 0);
wn([
  L("btNext")
], Wr.prototype, "btNext", void 0);
wn([
  L("btLast")
], Wr.prototype, "btLast", void 0);
wn([
  L("lbRecordCount")
], Wr.prototype, "lbRecordCount", void 0);
wn([
  L("lbFirstRowOnPage")
], Wr.prototype, "lbFirstRowOnPage", void 0);
wn([
  L("lbLastRowOnPage")
], Wr.prototype, "lbLastRowOnPage", void 0);
wn([
  L("lbCurrent")
], Wr.prototype, "lbCurrent", void 0);
wn([
  L("lbTotal")
], Wr.prototype, "lbTotal", void 0);
wn([
  B
], Wr.prototype, "postConstruct", null);
var wu = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, dd;
(function(o) {
  o[o.Loading = 0] = "Loading", o[o.NoRows = 1] = "NoRows";
})(dd || (dd = {}));
class Bo extends X {
  constructor() {
    super(Bo.TEMPLATE), this.inProgress = !1, this.destroyRequested = !1, this.manuallyDisplayed = !1;
  }
  updateLayoutClasses(e, t) {
    const i = this.eOverlayWrapper.classList;
    i.toggle(zt.AUTO_HEIGHT, t.autoHeight), i.toggle(zt.NORMAL, t.normal), i.toggle(zt.PRINT, t.print);
  }
  postConstruct() {
    this.createManagedBean(new Yv(this)), this.setDisplayed(!1, { skipAriaHidden: !0 }), this.addManagedListener(this.eventService, w.EVENT_ROW_DATA_UPDATED, this.onRowDataUpdated.bind(this)), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this)), this.gridOptionsService.isRowModelType("clientSide") && !this.gridOptionsService.get("rowData") && this.showLoadingOverlay(), this.gridApi.registerOverlayWrapperComp(this);
  }
  setWrapperTypeClass(e) {
    const t = this.eOverlayWrapper.classList;
    t.toggle("ag-overlay-loading-wrapper", e === dd.Loading), t.toggle("ag-overlay-no-rows-wrapper", e === dd.NoRows);
  }
  showLoadingOverlay() {
    if (this.gridOptionsService.is("suppressLoadingOverlay"))
      return;
    const e = {}, i = this.userComponentFactory.getLoadingOverlayCompDetails(e).newAgStackInstance();
    this.showOverlay(i, dd.Loading);
  }
  showNoRowsOverlay() {
    if (this.gridOptionsService.is("suppressNoRowsOverlay"))
      return;
    const e = {}, i = this.userComponentFactory.getNoRowsOverlayCompDetails(e).newAgStackInstance();
    this.showOverlay(i, dd.NoRows);
  }
  showOverlay(e, t) {
    this.inProgress || (this.setWrapperTypeClass(t), this.destroyActiveOverlay(), this.inProgress = !0, e && e.then((i) => {
      this.inProgress = !1, this.eOverlayWrapper.appendChild(i.getGui()), this.activeOverlay = i, this.destroyRequested && (this.destroyRequested = !1, this.destroyActiveOverlay());
    }), this.manuallyDisplayed = this.columnModel.isReady() && !this.paginationProxy.isEmpty(), this.setDisplayed(!0, { skipAriaHidden: !0 }));
  }
  destroyActiveOverlay() {
    if (this.inProgress) {
      this.destroyRequested = !0;
      return;
    }
    this.activeOverlay && (this.activeOverlay = this.getContext().destroyBean(this.activeOverlay), Or(this.eOverlayWrapper));
  }
  hideOverlay() {
    this.manuallyDisplayed = !1, this.destroyActiveOverlay(), this.setDisplayed(!1, { skipAriaHidden: !0 });
  }
  destroy() {
    this.destroyActiveOverlay(), super.destroy();
  }
  showOrHideOverlay() {
    const e = this.paginationProxy.isEmpty(), t = this.gridOptionsService.is("suppressNoRowsOverlay");
    e && !t ? this.showNoRowsOverlay() : this.hideOverlay();
  }
  onRowDataUpdated() {
    this.showOrHideOverlay();
  }
  onNewColumnsLoaded() {
    this.columnModel.isReady() && !this.paginationProxy.isEmpty() && !this.manuallyDisplayed && this.hideOverlay();
  }
}
Bo.TEMPLATE = `
        <div class="ag-overlay" aria-hidden="true">
            <div class="ag-overlay-panel">
                <div class="ag-overlay-wrapper" ref="eOverlayWrapper"></div>
            </div>
        </div>`;
wu([
  S("userComponentFactory")
], Bo.prototype, "userComponentFactory", void 0);
wu([
  S("paginationProxy")
], Bo.prototype, "paginationProxy", void 0);
wu([
  S("gridApi")
], Bo.prototype, "gridApi", void 0);
wu([
  S("columnModel")
], Bo.prototype, "columnModel", void 0);
wu([
  L("eOverlayWrapper")
], Bo.prototype, "eOverlayWrapper", void 0);
wu([
  B
], Bo.prototype, "postConstruct", null);
var gm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Bd = class extends H {
  getFirstRow() {
    let e = 0, t;
    return this.pinnedRowModel.getPinnedTopRowCount() ? t = "top" : this.rowModel.getRowCount() ? (t = null, e = this.paginationProxy.getPageFirstRow()) : this.pinnedRowModel.getPinnedBottomRowCount() && (t = "bottom"), t === void 0 ? null : { rowIndex: e, rowPinned: t };
  }
  getLastRow() {
    let e, t = null;
    const i = this.pinnedRowModel.getPinnedBottomRowCount(), r = this.pinnedRowModel.getPinnedTopRowCount();
    return i ? (t = "bottom", e = i - 1) : this.rowModel.getRowCount() ? (t = null, e = this.paginationProxy.getPageLastRow()) : r && (t = "top", e = r - 1), e === void 0 ? null : { rowIndex: e, rowPinned: t };
  }
  getRowNode(e) {
    switch (e.rowPinned) {
      case "top":
        return this.pinnedRowModel.getPinnedTopRowData()[e.rowIndex];
      case "bottom":
        return this.pinnedRowModel.getPinnedBottomRowData()[e.rowIndex];
      default:
        return this.rowModel.getRow(e.rowIndex);
    }
  }
  sameRow(e, t) {
    return !e && !t ? !0 : e && !t || !e && t ? !1 : e.rowIndex === t.rowIndex && e.rowPinned == t.rowPinned;
  }
  // tests if this row selection is before the other row selection
  before(e, t) {
    switch (e.rowPinned) {
      case "top":
        if (t.rowPinned !== "top")
          return !0;
        break;
      case "bottom":
        if (t.rowPinned !== "bottom")
          return !1;
        break;
      default:
        if (z(t.rowPinned))
          return t.rowPinned !== "top";
        break;
    }
    return e.rowIndex < t.rowIndex;
  }
  rowMax(e) {
    let t;
    return e.forEach((i) => {
      (t === void 0 || this.before(t, i)) && (t = i);
    }), t;
  }
  rowMin(e) {
    let t;
    return e.forEach((i) => {
      (t === void 0 || this.before(i, t)) && (t = i);
    }), t;
  }
};
gm([
  S("rowModel")
], Bd.prototype, "rowModel", void 0);
gm([
  S("pinnedRowModel")
], Bd.prototype, "pinnedRowModel", void 0);
gm([
  S("paginationProxy")
], Bd.prototype, "paginationProxy", void 0);
Bd = gm([
  q("rowPositionUtils")
], Bd);
var UN = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let IC = class extends H {
  createId(e) {
    const { rowIndex: t, rowPinned: i, column: r } = e;
    return this.createIdFromValues({ rowIndex: t, column: r, rowPinned: i });
  }
  createIdFromValues(e) {
    const { rowIndex: t, rowPinned: i, column: r } = e;
    return `${t}.${i == null ? "null" : i}.${r.getId()}`;
  }
  equals(e, t) {
    const i = e.column === t.column, r = e.rowPinned === t.rowPinned, n = e.rowIndex === t.rowIndex;
    return i && r && n;
  }
};
IC = UN([
  q("cellPositionUtils")
], IC);
class gh {
  constructor(e) {
    this.cellValueChanges = e;
  }
}
class Dy extends gh {
  constructor(e, t, i, r) {
    super(e), this.initialRange = t, this.finalRange = i, this.ranges = r;
  }
}
class ep {
  constructor(e) {
    this.actionStack = [], this.maxStackSize = e || ep.DEFAULT_STACK_SIZE, this.actionStack = new Array(this.maxStackSize);
  }
  pop() {
    return this.actionStack.pop();
  }
  push(e) {
    e.cellValueChanges && e.cellValueChanges.length > 0 && (this.actionStack.length === this.maxStackSize && this.actionStack.shift(), this.actionStack.push(e));
  }
  clear() {
    this.actionStack = [];
  }
  getCurrentStackSize() {
    return this.actionStack.length;
  }
}
ep.DEFAULT_STACK_SIZE = 10;
var Ho = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let vn = class extends H {
  constructor() {
    super(...arguments), this.cellValueChanges = [], this.activeCellEdit = null, this.activeRowEdit = null, this.isPasting = !1, this.isRangeInAction = !1, this.onCellValueChanged = (e) => {
      const t = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned }, i = this.activeCellEdit !== null && this.cellPositionUtils.equals(this.activeCellEdit, t), r = this.activeRowEdit !== null && this.rowPositionUtils.sameRow(this.activeRowEdit, t);
      if (!(i || r || this.isPasting || this.isRangeInAction))
        return;
      const { rowPinned: s, rowIndex: a, column: l, oldValue: c, value: d } = e, u = {
        rowPinned: s,
        rowIndex: a,
        columnId: l.getColId(),
        newValue: d,
        oldValue: c
      };
      this.cellValueChanges.push(u);
    }, this.clearStacks = () => {
      this.undoStack.clear(), this.redoStack.clear();
    };
  }
  init() {
    if (!this.gridOptionsService.is("undoRedoCellEditing"))
      return;
    const e = this.gridOptionsService.getNum("undoRedoCellEditingLimit");
    e <= 0 || (this.undoStack = new ep(e), this.redoStack = new ep(e), this.addRowEditingListeners(), this.addCellEditingListeners(), this.addPasteListeners(), this.addFillListeners(), this.addCellKeyListeners(), this.addManagedListener(this.eventService, w.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged), this.addManagedListener(this.eventService, w.EVENT_MODEL_UPDATED, (t) => {
      t.keepUndoRedoStack || this.clearStacks();
    }), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.clearStacks), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, this.clearStacks), this.addManagedListener(this.eventService, w.EVENT_COLUMN_GROUP_OPENED, this.clearStacks), this.addManagedListener(this.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, this.clearStacks), this.addManagedListener(this.eventService, w.EVENT_COLUMN_MOVED, this.clearStacks), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PINNED, this.clearStacks), this.addManagedListener(this.eventService, w.EVENT_COLUMN_VISIBLE, this.clearStacks), this.addManagedListener(this.eventService, w.EVENT_ROW_DRAG_END, this.clearStacks), this.ctrlsService.whenReady(() => {
      this.gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();
    }));
  }
  getCurrentUndoStackSize() {
    return this.undoStack ? this.undoStack.getCurrentStackSize() : 0;
  }
  getCurrentRedoStackSize() {
    return this.redoStack ? this.redoStack.getCurrentStackSize() : 0;
  }
  undo(e) {
    const t = {
      type: w.EVENT_UNDO_STARTED,
      source: e
    };
    this.eventService.dispatchEvent(t);
    const i = this.undoRedo(this.undoStack, this.redoStack, "initialRange", "oldValue", "undo"), r = {
      type: w.EVENT_UNDO_ENDED,
      source: e,
      operationPerformed: i
    };
    this.eventService.dispatchEvent(r);
  }
  redo(e) {
    const t = {
      type: w.EVENT_REDO_STARTED,
      source: e
    };
    this.eventService.dispatchEvent(t);
    const i = this.undoRedo(this.redoStack, this.undoStack, "finalRange", "newValue", "redo"), r = {
      type: w.EVENT_REDO_ENDED,
      source: e,
      operationPerformed: i
    };
    this.eventService.dispatchEvent(r);
  }
  undoRedo(e, t, i, r, n) {
    if (!e)
      return !1;
    const s = e.pop();
    return !s || !s.cellValueChanges ? !1 : (this.processAction(s, (a) => a[r], n), s instanceof Dy ? this.processRange(s.ranges || [s[i]]) : this.processCell(s.cellValueChanges), t.push(s), !0);
  }
  processAction(e, t, i) {
    e.cellValueChanges.forEach((r) => {
      const { rowIndex: n, rowPinned: s, columnId: a } = r, l = { rowIndex: n, rowPinned: s }, c = this.getRowNode(l);
      c.displayed && c.setDataValue(a, t(r), i);
    });
  }
  processRange(e) {
    let t;
    this.rangeService.removeAllCellRanges(!0), e.forEach((i, r) => {
      if (!i)
        return;
      const n = i.startRow, s = i.endRow;
      r === e.length - 1 && (t = {
        rowPinned: n.rowPinned,
        rowIndex: n.rowIndex,
        columnId: i.startColumn.getColId()
      }, this.setLastFocusedCell(t));
      const a = {
        rowStartIndex: n.rowIndex,
        rowStartPinned: n.rowPinned,
        rowEndIndex: s.rowIndex,
        rowEndPinned: s.rowPinned,
        columnStart: i.startColumn,
        columns: i.columns
      };
      this.rangeService.addCellRange(a);
    });
  }
  processCell(e) {
    const t = e[0], { rowIndex: i, rowPinned: r } = t, n = { rowIndex: i, rowPinned: r }, s = this.getRowNode(n), a = {
      rowPinned: t.rowPinned,
      rowIndex: s.rowIndex,
      columnId: t.columnId
    };
    this.setLastFocusedCell(a, !!this.rangeService);
  }
  setLastFocusedCell(e, t) {
    const { rowIndex: i, columnId: r, rowPinned: n } = e, s = this.gridBodyCtrl.getScrollFeature(), a = this.columnModel.getGridColumn(r);
    if (!a)
      return;
    s.ensureIndexVisible(i), s.ensureColumnVisible(a);
    const l = { rowIndex: i, column: a, rowPinned: n };
    this.focusService.setFocusedCell(Object.assign(Object.assign({}, l), { forceBrowserFocus: !0 })), t && this.rangeService.setRangeToCell(l);
  }
  addRowEditingListeners() {
    this.addManagedListener(this.eventService, w.EVENT_ROW_EDITING_STARTED, (e) => {
      this.activeRowEdit = { rowIndex: e.rowIndex, rowPinned: e.rowPinned };
    }), this.addManagedListener(this.eventService, w.EVENT_ROW_EDITING_STOPPED, () => {
      const e = new gh(this.cellValueChanges);
      this.pushActionsToUndoStack(e), this.activeRowEdit = null;
    });
  }
  addCellEditingListeners() {
    this.addManagedListener(this.eventService, w.EVENT_CELL_EDITING_STARTED, (e) => {
      this.activeCellEdit = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned };
    }), this.addManagedListener(this.eventService, w.EVENT_CELL_EDITING_STOPPED, (e) => {
      if (this.activeCellEdit = null, e.valueChanged && !this.activeRowEdit && !this.isPasting && !this.isRangeInAction) {
        const i = new gh(this.cellValueChanges);
        this.pushActionsToUndoStack(i);
      }
    });
  }
  addPasteListeners() {
    this.addManagedListener(this.eventService, w.EVENT_PASTE_START, () => {
      this.isPasting = !0;
    }), this.addManagedListener(this.eventService, w.EVENT_PASTE_END, () => {
      const e = new gh(this.cellValueChanges);
      this.pushActionsToUndoStack(e), this.isPasting = !1;
    });
  }
  addFillListeners() {
    this.addManagedListener(this.eventService, w.EVENT_FILL_START, () => {
      this.isRangeInAction = !0;
    }), this.addManagedListener(this.eventService, w.EVENT_FILL_END, (e) => {
      const t = new Dy(this.cellValueChanges, e.initialRange, e.finalRange);
      this.pushActionsToUndoStack(t), this.isRangeInAction = !1;
    });
  }
  addCellKeyListeners() {
    this.addManagedListener(this.eventService, w.EVENT_KEY_SHORTCUT_CHANGED_CELL_START, () => {
      this.isRangeInAction = !0;
    }), this.addManagedListener(this.eventService, w.EVENT_KEY_SHORTCUT_CHANGED_CELL_END, () => {
      let e;
      this.rangeService && this.gridOptionsService.isEnableRangeSelection() ? e = new Dy(this.cellValueChanges, void 0, void 0, [...this.rangeService.getCellRanges()]) : e = new gh(this.cellValueChanges), this.pushActionsToUndoStack(e), this.isRangeInAction = !1;
    });
  }
  pushActionsToUndoStack(e) {
    this.undoStack.push(e), this.cellValueChanges = [], this.redoStack.clear();
  }
  getRowNode(e) {
    switch (e.rowPinned) {
      case "top":
        return this.pinnedRowModel.getPinnedTopRowData()[e.rowIndex];
      case "bottom":
        return this.pinnedRowModel.getPinnedBottomRowData()[e.rowIndex];
      default:
        return this.rowModel.getRow(e.rowIndex);
    }
  }
};
Ho([
  S("focusService")
], vn.prototype, "focusService", void 0);
Ho([
  S("ctrlsService")
], vn.prototype, "ctrlsService", void 0);
Ho([
  S("rowModel")
], vn.prototype, "rowModel", void 0);
Ho([
  S("pinnedRowModel")
], vn.prototype, "pinnedRowModel", void 0);
Ho([
  S("cellPositionUtils")
], vn.prototype, "cellPositionUtils", void 0);
Ho([
  S("rowPositionUtils")
], vn.prototype, "rowPositionUtils", void 0);
Ho([
  S("columnModel")
], vn.prototype, "columnModel", void 0);
Ho([
  Ve("rangeService")
], vn.prototype, "rangeService", void 0);
Ho([
  B
], vn.prototype, "init", null);
vn = Ho([
  q("undoRedoService")
], vn);
var Mb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let tp = class extends H {
  findHeader(e, t) {
    let i, r, n;
    if (e.column instanceof pt ? (r = `getDisplayedGroup${t}`, i = this.columnModel[r](e.column)) : (n = `getDisplayedCol${t}`, i = this.columnModel[n](e.column)), !i)
      return;
    let { headerRowIndex: s } = e;
    if (this.getHeaderRowType(s) === bi.COLUMN_GROUP) {
      const l = i;
      if (l.isPadding() && this.isAnyChildSpanningHeaderHeight(l)) {
        const { nextFocusColumn: c, nextRow: d } = this.getColumnVisibleChild(l, s, t);
        c && (i = c, s = d);
      }
    }
    return {
      column: i,
      headerRowIndex: s
    };
  }
  isAnyChildSpanningHeaderHeight(e) {
    return e ? e.getLeafColumns().some((t) => t.isSpanHeaderHeight()) : !1;
  }
  getColumnVisibleParent(e, t) {
    const i = this.getHeaderRowType(t), r = i === bi.FLOATING_FILTER, n = i === bi.COLUMN;
    let s = r ? e : e.getParent(), a = t - 1;
    if (n && this.isAnyChildSpanningHeaderHeight(e.getParent())) {
      for (; s && s.isPadding(); )
        s = s.getParent(), a--;
      a < 0 && (s = e, a = t);
    }
    return { nextFocusColumn: s, nextRow: a };
  }
  getColumnVisibleChild(e, t, i = "After") {
    const r = this.getHeaderRowType(t);
    let n = e, s = t + 1;
    if (r === bi.COLUMN_GROUP) {
      const a = e.getLeafColumns(), l = i === "After" ? a[0] : at(a);
      if (this.isAnyChildSpanningHeaderHeight(l.getParent())) {
        n = l;
        let c = l.getParent();
        for (; c && c !== e; )
          c = c.getParent(), s++;
      } else
        n = e.getDisplayedChildren()[0];
    }
    return { nextFocusColumn: n, nextRow: s };
  }
  getHeaderRowType(e) {
    const t = this.ctrlsService.getHeaderRowContainerCtrl();
    if (t)
      return t.getRowType(e);
  }
  findColAtEdgeForHeaderRow(e, t) {
    const i = this.columnModel.getAllDisplayedColumns(), r = i[t === "start" ? 0 : i.length - 1];
    if (!r)
      return;
    const s = this.ctrlsService.getHeaderRowContainerCtrl(r.getPinned()).getRowType(e);
    if (s == bi.COLUMN_GROUP) {
      const a = this.columnModel.getColumnGroupAtLevel(r, e);
      return {
        headerRowIndex: e,
        column: a
      };
    }
    return {
      // if type==null, means the header level didn't exist
      headerRowIndex: s == null ? -1 : e,
      column: r
    };
  }
};
Mb([
  S("columnModel")
], tp.prototype, "columnModel", void 0);
Mb([
  S("ctrlsService")
], tp.prototype, "ctrlsService", void 0);
tp = Mb([
  q("headerPositionUtils")
], tp);
var $N = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let FC = class {
  buildColumnDefs(e, t, i) {
    const r = [], n = {};
    return e.forEach((s) => {
      const a = this.createDefFromColumn(s, t, i);
      let l = !0, c = a, d = s.getOriginalParent(), u = null;
      for (; d; ) {
        let h = null;
        if (d.isPadding()) {
          d = d.getOriginalParent();
          continue;
        }
        const p = n[d.getGroupId()];
        if (p) {
          p.children.push(c), l = !1;
          break;
        }
        if (h = this.createDefFromGroup(d), h && (h.children = [c], n[h.groupId] = h, c = h, d = d.getOriginalParent()), d != null && u === d) {
          l = !1;
          break;
        }
        u = d;
      }
      l && r.push(c);
    }), r;
  }
  createDefFromGroup(e) {
    const t = Tg(e.getColGroupDef(), ["children"]);
    return t && (t.groupId = e.getGroupId()), t;
  }
  createDefFromColumn(e, t, i) {
    const r = Tg(e.getColDef());
    return r.colId = e.getColId(), r.width = e.getActualWidth(), r.rowGroup = e.isRowGroupActive(), r.rowGroupIndex = e.isRowGroupActive() ? t.indexOf(e) : null, r.pivot = e.isPivotActive(), r.pivotIndex = e.isPivotActive() ? i.indexOf(e) : null, r.aggFunc = e.isValueActive() ? e.getAggFunc() : null, r.hide = e.isVisible() ? void 0 : !0, r.pinned = e.isPinned() ? e.getPinned() : null, r.sort = e.getSort() ? e.getSort() : null, r.sortIndex = e.getSortIndex() != null ? e.getSortIndex() : null, r;
  }
};
FC = $N([
  q("columnDefFactory")
], FC);
var _b = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let ip = class {
  getInitialRowClasses(e) {
    const t = [];
    return z(e.extraCssClass) && t.push(e.extraCssClass), t.push("ag-row"), t.push(e.rowFocused ? "ag-row-focus" : "ag-row-no-focus"), e.fadeRowIn && t.push("ag-opacity-zero"), t.push(e.rowIsEven ? "ag-row-even" : "ag-row-odd"), e.rowNode.isRowPinned() && t.push("ag-row-pinned"), e.rowNode.isSelected() && t.push("ag-row-selected"), e.rowNode.footer && t.push("ag-row-footer"), t.push("ag-row-level-" + e.rowLevel), e.rowNode.stub && t.push("ag-row-loading"), e.fullWidthRow && t.push("ag-full-width-row"), e.expandable && (t.push("ag-row-group"), t.push(e.rowNode.expanded ? "ag-row-group-expanded" : "ag-row-group-contracted")), e.rowNode.dragging && t.push("ag-row-dragging"), mC(t, this.processClassesFromGridOptions(e.rowNode)), mC(t, this.preProcessRowClassRules(e.rowNode)), t.push(e.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute"), e.firstRowOnPage && t.push("ag-row-first"), e.lastRowOnPage && t.push("ag-row-last"), e.fullWidthRow && (e.pinned === "left" && t.push("ag-cell-last-left-pinned"), e.pinned === "right" && t.push("ag-cell-first-right-pinned")), t;
  }
  processClassesFromGridOptions(e) {
    const t = [], i = (s) => {
      typeof s == "string" ? t.push(s) : Array.isArray(s) && s.forEach((a) => t.push(a));
    }, r = this.gridOptionsService.get("rowClass");
    if (r) {
      if (typeof r == "function")
        return console.warn("AG Grid: rowClass should not be a function, please use getRowClass instead"), [];
      i(r);
    }
    const n = this.gridOptionsService.getCallback("getRowClass");
    if (n) {
      const s = {
        data: e.data,
        node: e,
        rowIndex: e.rowIndex
      }, a = n(s);
      i(a);
    }
    return t;
  }
  preProcessRowClassRules(e) {
    const t = [];
    return this.processRowClassRules(e, (i) => {
      t.push(i);
    }, (i) => {
    }), t;
  }
  processRowClassRules(e, t, i) {
    const r = {
      data: e.data,
      node: e,
      rowIndex: e.rowIndex,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context
    };
    this.stylingService.processClassRules(this.gridOptionsService.get("rowClassRules"), r, t, i);
  }
  calculateRowLevel(e) {
    return e.group ? e.level : e.parent ? e.parent.level + 1 : 0;
  }
};
_b([
  S("stylingService")
], ip.prototype, "stylingService", void 0);
_b([
  S("gridOptionsService")
], ip.prototype, "gridOptionsService", void 0);
ip = _b([
  q("rowCssClassCalculator")
], ip);
var vm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Hd = class extends H {
  init() {
    this.isAccentedSort = this.gridOptionsService.is("accentedSort"), this.primaryColumnsSortGroups = this.gridOptionsService.isColumnsSortingCoupledToGroup(), this.addManagedPropertyListener("accentedSort", (e) => this.isAccentedSort = e.currentValue), this.addManagedPropertyListener("autoGroupColumnDef", () => this.primaryColumnsSortGroups = this.gridOptionsService.isColumnsSortingCoupledToGroup());
  }
  doFullSort(e, t) {
    const i = (n, s) => ({ currentPos: s, rowNode: n }), r = e.map(i);
    return r.sort(this.compareRowNodes.bind(this, t)), r.map((n) => n.rowNode);
  }
  compareRowNodes(e, t, i) {
    const r = t.rowNode, n = i.rowNode;
    for (let s = 0, a = e.length; s < a; s++) {
      const l = e[s], c = l.sort === "desc", d = this.getValue(r, l.column), u = this.getValue(n, l.column);
      let h;
      const p = this.getComparator(l, r);
      if (p ? h = p(d, u, r, n, c) : h = x.defaultComparator(d, u, this.isAccentedSort), !isNaN(h) && h !== 0)
        return l.sort === "asc" ? h : h * -1;
    }
    return t.currentPos - i.currentPos;
  }
  getComparator(e, t) {
    const i = e.column, r = i.getColDef().comparator;
    if (r != null)
      return r;
    if (!i.getColDef().showRowGroup)
      return;
    const n = !t.group && i.getColDef().field;
    if (!n)
      return;
    const s = this.columnModel.getPrimaryColumn(n);
    if (s)
      return s.getColDef().comparator;
  }
  getValue(e, t) {
    var i, r;
    if (!this.primaryColumnsSortGroups)
      return this.valueService.getValue(t, e, !1, !1);
    if (e.rowGroupColumn === t) {
      if (this.gridOptionsService.isGroupUseEntireRow(this.columnModel.isPivotActive())) {
        if (t.getColDef().keyCreator)
          return e.key;
        const c = (i = e.allLeafChildren) === null || i === void 0 ? void 0 : i[0];
        return c ? this.valueService.getValue(t, c, !1, !1) : void 0;
      }
      const a = this.columnModel.getGroupDisplayColumnForGroup(t.getId());
      return a ? (r = e.groupData) === null || r === void 0 ? void 0 : r[a.getId()] : void 0;
    }
    if (!(e.group && t.getColDef().showRowGroup))
      return this.valueService.getValue(t, e, !1, !1);
  }
};
vm([
  S("valueService")
], Hd.prototype, "valueService", void 0);
vm([
  S("columnModel")
], Hd.prototype, "columnModel", void 0);
vm([
  B
], Hd.prototype, "init", null);
Hd = vm([
  q("rowNodeSorter")
], Hd);
var zN = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, LC;
let Vg = LC = class extends H {
  constructor() {
    super(...arguments), this.ready = !1, this.readyCallbacks = [];
  }
  checkReady() {
    if (this.ready = this.gridCtrl != null && this.gridBodyCtrl != null && this.centerRowContainerCtrl != null && this.leftRowContainerCtrl != null && this.rightRowContainerCtrl != null && this.bottomCenterRowContainerCtrl != null && this.bottomLeftRowContainerCtrl != null && this.bottomRightRowContainerCtrl != null && this.topCenterRowContainerCtrl != null && this.topLeftRowContainerCtrl != null && this.topRightRowContainerCtrl != null && this.stickyTopCenterRowContainerCtrl != null && this.stickyTopLeftRowContainerCtrl != null && this.stickyTopRightRowContainerCtrl != null && this.centerHeaderRowContainerCtrl != null && this.leftHeaderRowContainerCtrl != null && this.rightHeaderRowContainerCtrl != null && this.fakeHScrollComp != null && this.fakeVScrollComp != null && this.gridHeaderCtrl != null, this.ready) {
      const e = this.createReadyParams();
      this.readyCallbacks.forEach((t) => t(e)), this.readyCallbacks.length = 0;
    }
  }
  whenReady(e) {
    this.ready ? e(this.createReadyParams()) : this.readyCallbacks.push(e);
  }
  createReadyParams() {
    return {
      centerRowContainerCtrl: this.centerRowContainerCtrl,
      leftRowContainerCtrl: this.leftRowContainerCtrl,
      rightRowContainerCtrl: this.rightRowContainerCtrl,
      bottomCenterRowContainerCtrl: this.bottomCenterRowContainerCtrl,
      bottomLeftRowContainerCtrl: this.bottomLeftRowContainerCtrl,
      bottomRightRowContainerCtrl: this.bottomRightRowContainerCtrl,
      topCenterRowContainerCtrl: this.topCenterRowContainerCtrl,
      topLeftRowContainerCtrl: this.topLeftRowContainerCtrl,
      topRightRowContainerCtrl: this.topRightRowContainerCtrl,
      stickyTopCenterRowContainerCtrl: this.stickyTopCenterRowContainerCtrl,
      stickyTopLeftRowContainerCtrl: this.stickyTopLeftRowContainerCtrl,
      stickyTopRightRowContainerCtrl: this.stickyTopRightRowContainerCtrl,
      centerHeaderRowContainerCtrl: this.centerHeaderRowContainerCtrl,
      leftHeaderRowContainerCtrl: this.leftHeaderRowContainerCtrl,
      rightHeaderRowContainerCtrl: this.rightHeaderRowContainerCtrl,
      fakeHScrollComp: this.fakeHScrollComp,
      fakeVScrollComp: this.fakeVScrollComp,
      gridBodyCtrl: this.gridBodyCtrl,
      gridCtrl: this.gridCtrl,
      gridHeaderCtrl: this.gridHeaderCtrl
    };
  }
  registerFakeHScrollComp(e) {
    this.fakeHScrollComp = e, this.checkReady();
  }
  registerFakeVScrollComp(e) {
    this.fakeVScrollComp = e, this.checkReady();
  }
  registerGridHeaderCtrl(e) {
    this.gridHeaderCtrl = e, this.checkReady();
  }
  registerCenterRowContainerCtrl(e) {
    this.centerRowContainerCtrl = e, this.checkReady();
  }
  registerLeftRowContainerCtrl(e) {
    this.leftRowContainerCtrl = e, this.checkReady();
  }
  registerRightRowContainerCtrl(e) {
    this.rightRowContainerCtrl = e, this.checkReady();
  }
  registerTopCenterRowContainerCtrl(e) {
    this.topCenterRowContainerCtrl = e, this.checkReady();
  }
  registerTopLeftRowContainerCon(e) {
    this.topLeftRowContainerCtrl = e, this.checkReady();
  }
  registerTopRightRowContainerCtrl(e) {
    this.topRightRowContainerCtrl = e, this.checkReady();
  }
  registerStickyTopCenterRowContainerCtrl(e) {
    this.stickyTopCenterRowContainerCtrl = e, this.checkReady();
  }
  registerStickyTopLeftRowContainerCon(e) {
    this.stickyTopLeftRowContainerCtrl = e, this.checkReady();
  }
  registerStickyTopRightRowContainerCtrl(e) {
    this.stickyTopRightRowContainerCtrl = e, this.checkReady();
  }
  registerBottomCenterRowContainerCtrl(e) {
    this.bottomCenterRowContainerCtrl = e, this.checkReady();
  }
  registerBottomLeftRowContainerCtrl(e) {
    this.bottomLeftRowContainerCtrl = e, this.checkReady();
  }
  registerBottomRightRowContainerCtrl(e) {
    this.bottomRightRowContainerCtrl = e, this.checkReady();
  }
  registerHeaderContainer(e, t) {
    switch (t) {
      case "left":
        this.leftHeaderRowContainerCtrl = e;
        break;
      case "right":
        this.rightHeaderRowContainerCtrl = e;
        break;
      default:
        this.centerHeaderRowContainerCtrl = e;
        break;
    }
    this.checkReady();
  }
  registerGridBodyCtrl(e) {
    this.gridBodyCtrl = e, this.checkReady();
  }
  registerGridCtrl(e) {
    this.gridCtrl = e, this.checkReady();
  }
  getFakeHScrollComp() {
    return this.fakeHScrollComp;
  }
  getFakeVScrollComp() {
    return this.fakeVScrollComp;
  }
  getGridHeaderCtrl() {
    return this.gridHeaderCtrl;
  }
  getGridCtrl() {
    return this.gridCtrl;
  }
  getCenterRowContainerCtrl() {
    return this.centerRowContainerCtrl;
  }
  getTopCenterRowContainerCtrl() {
    return this.topCenterRowContainerCtrl;
  }
  getBottomCenterRowContainerCtrl() {
    return this.bottomCenterRowContainerCtrl;
  }
  getStickyTopCenterRowContainerCtrl() {
    return this.stickyTopCenterRowContainerCtrl;
  }
  getGridBodyCtrl() {
    return this.gridBodyCtrl;
  }
  getHeaderRowContainerCtrls() {
    return [this.leftHeaderRowContainerCtrl, this.rightHeaderRowContainerCtrl, this.centerHeaderRowContainerCtrl];
  }
  getHeaderRowContainerCtrl(e) {
    switch (e) {
      case "left":
        return this.leftHeaderRowContainerCtrl;
      case "right":
        return this.rightHeaderRowContainerCtrl;
      default:
        return this.centerHeaderRowContainerCtrl;
    }
  }
};
Vg.NAME = "ctrlsService";
Vg = LC = zN([
  q(LC.NAME)
], Vg);
var KN = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let NC = class extends H {
  constructor() {
    super(...arguments), this.registry = {};
  }
  register(e) {
    this.registry[e.controllerName] = e.controllerClass;
  }
  getInstance(e) {
    const t = this.registry[e];
    if (t != null)
      return new t();
  }
};
NC = KN([
  q("ctrlsFactory")
], NC);
var af = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class cc extends X {
  constructor(e, t) {
    super(e), this.direction = t, this.hideTimeout = null;
  }
  postConstruct() {
    this.addManagedListener(this.eventService, w.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this)), this.onScrollVisibilityChanged(), this.addOrRemoveCssClass("ag-apple-scrollbar", MS() || Fa());
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.invisibleScrollbar = wd(), this.invisibleScrollbar && (this.hideAndShowInvisibleScrollAsNeeded(), this.addActiveListenerToggles()));
  }
  addActiveListenerToggles() {
    const e = ["mouseenter", "mousedown", "touchstart"], t = ["mouseleave", "touchend"], i = this.getGui();
    e.forEach((r) => this.addManagedListener(i, r, () => this.addOrRemoveCssClass("ag-scrollbar-active", !0))), t.forEach((r) => this.addManagedListener(i, r, () => this.addOrRemoveCssClass("ag-scrollbar-active", !1)));
  }
  onScrollVisibilityChanged() {
    this.invisibleScrollbar === void 0 && this.initialiseInvisibleScrollbar(), this.animationFrameService.requestAnimationFrame(() => this.setScrollVisible());
  }
  hideAndShowInvisibleScrollAsNeeded() {
    this.addManagedListener(this.eventService, w.EVENT_BODY_SCROLL, (e) => {
      e.direction === this.direction && (this.hideTimeout !== null && (window.clearTimeout(this.hideTimeout), this.hideTimeout = null), this.addOrRemoveCssClass("ag-scrollbar-scrolling", !0));
    }), this.addManagedListener(this.eventService, w.EVENT_BODY_SCROLL_END, () => {
      this.hideTimeout = window.setTimeout(() => {
        this.addOrRemoveCssClass("ag-scrollbar-scrolling", !1), this.hideTimeout = null;
      }, 400);
    });
  }
  attemptSettingScrollPosition(e) {
    const t = this.getViewport();
    yS(() => Ms(t), () => this.setScrollPosition(e), 100);
  }
  getViewport() {
    return this.eViewport;
  }
  getContainer() {
    return this.eContainer;
  }
  onScrollCallback(e) {
    this.addManagedListener(this.getViewport(), "scroll", e);
  }
}
af([
  L("eViewport")
], cc.prototype, "eViewport", void 0);
af([
  L("eContainer")
], cc.prototype, "eContainer", void 0);
af([
  S("scrollVisibleService")
], cc.prototype, "scrollVisibleService", void 0);
af([
  S("ctrlsService")
], cc.prototype, "ctrlsService", void 0);
af([
  S("animationFrameService")
], cc.prototype, "animationFrameService", void 0);
var lf = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Ns extends cc {
  constructor() {
    super(Ns.TEMPLATE, "horizontal");
  }
  postConstruct() {
    super.postConstruct();
    const e = this.setFakeHScrollSpacerWidths.bind(this);
    this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_CHANGED, e), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, e), this.addManagedListener(this.eventService, w.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this)), this.addManagedPropertyListener("domLayout", e), this.ctrlsService.registerFakeHScrollComp(this), this.createManagedBean(new hu((t) => this.eContainer.style.width = `${t}px`));
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.enableRtl = this.gridOptionsService.is("enableRtl"), super.initialiseInvisibleScrollbar(), this.invisibleScrollbar && this.refreshCompBottom());
  }
  onPinnedRowDataChanged() {
    this.refreshCompBottom();
  }
  refreshCompBottom() {
    if (!this.invisibleScrollbar)
      return;
    const e = this.pinnedRowModel.getPinnedBottomTotalHeight();
    this.getGui().style.bottom = `${e}px`;
  }
  onScrollVisibilityChanged() {
    super.onScrollVisibilityChanged(), this.setFakeHScrollSpacerWidths();
  }
  setFakeHScrollSpacerWidths() {
    const e = this.scrollVisibleService.isVerticalScrollShowing();
    let t = this.columnModel.getDisplayedColumnsRightWidth();
    const i = !this.enableRtl && e, r = this.gridOptionsService.getScrollbarWidth();
    i && (t += r), dn(this.eRightSpacer, t), this.eRightSpacer.classList.toggle("ag-scroller-corner", t <= r);
    let n = this.columnModel.getDisplayedColumnsLeftWidth();
    this.enableRtl && e && (n += r), dn(this.eLeftSpacer, n), this.eLeftSpacer.classList.toggle("ag-scroller-corner", n <= r);
  }
  setScrollVisible() {
    const e = this.scrollVisibleService.isHorizontalScrollShowing(), t = this.invisibleScrollbar, i = this.gridOptionsService.is("suppressHorizontalScroll"), r = e && this.gridOptionsService.getScrollbarWidth() || 0, s = i ? 0 : r === 0 && t ? 16 : r;
    this.addOrRemoveCssClass("ag-scrollbar-invisible", t), Pl(this.getGui(), s), Pl(this.eViewport, s), Pl(this.eContainer, s), this.setDisplayed(e, { skipAriaHidden: !0 });
  }
  getScrollPosition() {
    return Vh(this.getViewport(), this.enableRtl);
  }
  setScrollPosition(e) {
    Ms(this.getViewport()) || this.attemptSettingScrollPosition(e), Bh(this.getViewport(), e, this.enableRtl);
  }
}
Ns.TEMPLATE = `<div class="ag-body-horizontal-scroll" aria-hidden="true">
            <div class="ag-horizontal-left-spacer" ref="eLeftSpacer"></div>
            <div class="ag-body-horizontal-scroll-viewport" ref="eViewport">
                <div class="ag-body-horizontal-scroll-container" ref="eContainer"></div>
            </div>
            <div class="ag-horizontal-right-spacer" ref="eRightSpacer"></div>
        </div>`;
lf([
  L("eLeftSpacer")
], Ns.prototype, "eLeftSpacer", void 0);
lf([
  L("eRightSpacer")
], Ns.prototype, "eRightSpacer", void 0);
lf([
  S("columnModel")
], Ns.prototype, "columnModel", void 0);
lf([
  S("pinnedRowModel")
], Ns.prototype, "pinnedRowModel", void 0);
lf([
  B
], Ns.prototype, "postConstruct", null);
var Ib = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let rp = class extends H {
  postConstruct() {
    const e = this.checkContainerWidths.bind(this);
    this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_CHANGED, e), this.addManagedListener(this.eventService, w.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, e), this.addManagedPropertyListener("domLayout", e);
  }
  checkContainerWidths() {
    const e = this.gridOptionsService.isDomLayout("print"), t = e ? 0 : this.columnModel.getDisplayedColumnsLeftWidth(), i = e ? 0 : this.columnModel.getDisplayedColumnsRightWidth();
    t != this.leftWidth && (this.leftWidth = t, this.eventService.dispatchEvent({ type: w.EVENT_LEFT_PINNED_WIDTH_CHANGED })), i != this.rightWidth && (this.rightWidth = i, this.eventService.dispatchEvent({ type: w.EVENT_RIGHT_PINNED_WIDTH_CHANGED }));
  }
  getPinnedRightWidth() {
    return this.rightWidth;
  }
  getPinnedLeftWidth() {
    return this.leftWidth;
  }
};
Ib([
  S("columnModel")
], rp.prototype, "columnModel", void 0);
Ib([
  B
], rp.prototype, "postConstruct", null);
rp = Ib([
  q("pinnedWidthService")
], rp);
var mm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Wd = class extends H {
  constructor() {
    super(...arguments), this.events = [];
  }
  postConstruct() {
    this.rowModel.getType() == "clientSide" && (this.clientSideRowModel = this.rowModel);
  }
  // because the user can call rowNode.setExpanded() many times in one VM turn,
  // we throttle the calls to ClientSideRowModel using animationFrameService. this means for 100
  // row nodes getting expanded, we only update the CSRM once, and then we fire all events after
  // CSRM has updated.
  //
  // if we did not do this, then the user could call setExpanded on 100+ rows, causing the grid
  // to re-render 100+ times, which would be a performance lag.
  //
  // we use animationFrameService
  // rather than _.debounce() so this will get done if anyone flushes the animationFrameService
  // (eg user calls api.ensureRowVisible(), which in turn flushes ).
  dispatchExpanded(e) {
    if (this.clientSideRowModel == null) {
      this.eventService.dispatchEvent(e);
      return;
    }
    this.events.push(e);
    const t = () => {
      this.clientSideRowModel && this.clientSideRowModel.onRowGroupOpened(), this.events.forEach((i) => this.eventService.dispatchEvent(i)), this.events = [];
    };
    this.dispatchExpandedDebounced == null && (this.dispatchExpandedDebounced = this.animationFrameService.debounce(t)), this.dispatchExpandedDebounced();
  }
};
mm([
  S("animationFrameService")
], Wd.prototype, "animationFrameService", void 0);
mm([
  S("rowModel")
], Wd.prototype, "rowModel", void 0);
mm([
  B
], Wd.prototype, "postConstruct", null);
Wd = mm([
  q("rowNodeEventThrottle")
], Wd);
var Wa = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, t0 = function(o, e) {
  return function(t, i) {
    e(t, i, o);
  };
};
function YN(o) {
  if (typeof o == "number")
    return o;
  if (typeof o == "string")
    return parseInt(o, 10);
}
function i0(o) {
  return o === !0 || o === "true";
}
let Po = class {
  constructor() {
    this.destroyed = !1, this.domDataKey = "__AG_" + Math.random().toString(), this.propertyEventService = new _r();
  }
  // This is quicker then having code call gridOptionsService.get('context')
  get context() {
    return this.gridOptions.context;
  }
  agWire(e, t) {
    this.gridOptions.api = e, this.gridOptions.columnApi = t, this.api = e, this.columnApi = t;
  }
  init() {
    this.gridOptionLookup = /* @__PURE__ */ new Set([...ke.ALL_PROPERTIES, ...ke.EVENT_CALLBACKS]);
    const e = !this.is("suppressAsyncEvents");
    this.eventService.addGlobalListener(this.globalEventHandler.bind(this), e), this.getScrollbarWidth();
  }
  destroy() {
    this.gridOptions.api = null, this.gridOptions.columnApi = null, this.destroyed = !0;
  }
  /**
   * Is the given GridOption property set to true.
   * @param property GridOption property that has the type `boolean | undefined`
   */
  is(e) {
    return i0(this.gridOptions[e]);
  }
  /**
   * Get the raw value of the GridOptions property provided.
   * @param property
   */
  get(e) {
    return this.gridOptions[e];
  }
  /**
   * Get the GridOption property as a number, raw value is returned via a toNumber coercion function.
   * @param property GridOption property that has the type `number | undefined`
   */
  getNum(e) {
    return YN(this.gridOptions[e]);
  }
  /**
   * Get the GridOption callback but wrapped so that the common params of api,columnApi and context are automatically applied to the params.
   * @param property GridOption callback properties based on the fact that this property has a callback with params extending AgGridCommon
   */
  getCallback(e) {
    return this.mergeGridCommonParams(this.gridOptions[e]);
  }
  /**
   * Returns `true` if a value has been specified for this GridOption.
   * @param property GridOption property
   */
  exists(e) {
    return z(this.gridOptions[e]);
  }
  /**
  * Wrap the user callback and attach the api, columnApi and context to the params object on the way through.
  * @param callback User provided callback
  * @returns Wrapped callback where the params object not require api, columnApi and context
  */
  mergeGridCommonParams(e) {
    return e && ((i) => {
      const r = i;
      return r.api = this.api, r.columnApi = this.columnApi, r.context = this.context, e(r);
    });
  }
  /**
   *
   * @param key - key of the GridOption property to update
   * @param newValue - new value for this property
   * @param force - force the property change Event to be fired even if the value has not changed
   * @param eventParams - additional params to merge into the property changed event
   */
  set(e, t, i = !1, r = {}) {
    if (this.gridOptionLookup.has(e)) {
      const n = this.gridOptions[e];
      if (i || n !== t) {
        this.gridOptions[e] = t;
        const s = Object.assign({ type: e, currentValue: t, previousValue: n }, r);
        this.propertyEventService.dispatchEvent(s);
      }
    }
  }
  addEventListener(e, t) {
    this.propertyEventService.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.propertyEventService.removeEventListener(e, t);
  }
  // responsible for calling the onXXX functions on gridOptions
  globalEventHandler(e, t) {
    if (this.destroyed)
      return;
    const i = ke.getCallbackForEvent(e);
    typeof this.gridOptions[i] == "function" && this.gridOptions[i](t);
  }
  // *************** Helper methods ************************** //
  // Methods to share common GridOptions related logic that goes above accessing a single property
  getGridId() {
    return this.api.getGridId();
  }
  // the user might be using some non-standard scrollbar, eg a scrollbar that has zero
  // width and overlays (like the Safari scrollbar, but presented in Chrome). so we
  // allow the user to provide the scroll width before we work it out.
  getScrollbarWidth() {
    if (this.scrollbarWidth == null) {
      const t = typeof this.gridOptions.scrollbarWidth == "number" && this.gridOptions.scrollbarWidth >= 0 ? this.gridOptions.scrollbarWidth : RT();
      t != null && (this.scrollbarWidth = t, this.eventService.dispatchEvent({
        type: w.EVENT_SCROLLBAR_WIDTH_CHANGED
      }));
    }
    return this.scrollbarWidth;
  }
  isRowModelType(e) {
    return this.gridOptions.rowModelType === e || e === "clientSide" && Se(this.gridOptions.rowModelType);
  }
  isDomLayout(e) {
    var t;
    return ((t = this.gridOptions.domLayout) !== null && t !== void 0 ? t : "normal") === e;
  }
  isRowSelection() {
    return this.gridOptions.rowSelection === "single" || this.gridOptions.rowSelection === "multiple";
  }
  useAsyncEvents() {
    return !this.is("suppressAsyncEvents");
  }
  isGetRowHeightFunction() {
    return typeof this.gridOptions.getRowHeight == "function";
  }
  getRowHeightForNode(e, t = !1, i) {
    if (i == null && (i = this.environment.getDefaultRowHeight()), this.isGetRowHeightFunction()) {
      if (t)
        return { height: i, estimated: !0 };
      const n = {
        node: e,
        data: e.data
      }, s = this.getCallback("getRowHeight")(n);
      if (this.isNumeric(s))
        return s === 0 && tt(() => console.warn("AG Grid: The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead."), "invalidRowHeight"), { height: Math.max(1, s), estimated: !1 };
    }
    return e.detail && this.is("masterDetail") ? this.getMasterDetailRowHeight() : { height: this.gridOptions.rowHeight && this.isNumeric(this.gridOptions.rowHeight) ? this.gridOptions.rowHeight : i, estimated: !1 };
  }
  getMasterDetailRowHeight() {
    return this.is("detailRowAutoHeight") ? { height: 1, estimated: !1 } : this.isNumeric(this.gridOptions.detailRowHeight) ? { height: this.gridOptions.detailRowHeight, estimated: !1 } : { height: 300, estimated: !1 };
  }
  // we don't allow dynamic row height for virtual paging
  getRowHeightAsNumber() {
    if (!this.gridOptions.rowHeight || Se(this.gridOptions.rowHeight))
      return this.environment.getDefaultRowHeight();
    const e = this.gridOptions.rowHeight;
    return e && this.isNumeric(e) ? (this.environment.setRowHeightVariable(e), e) : (console.warn("AG Grid row height must be a number if not using standard row model"), this.environment.getDefaultRowHeight());
  }
  isNumeric(e) {
    return !isNaN(e) && typeof e == "number" && isFinite(e);
  }
  getDomDataKey() {
    return this.domDataKey;
  }
  // returns the dom data, or undefined if not found
  getDomData(e, t) {
    const i = e[this.getDomDataKey()];
    return i ? i[t] : void 0;
  }
  setDomData(e, t, i) {
    const r = this.getDomDataKey();
    let n = e[r];
    Se(n) && (n = {}, e[r] = n), n[t] = i;
  }
  getDocument() {
    let e = null;
    return this.gridOptions.getDocument && z(this.gridOptions.getDocument) ? e = this.gridOptions.getDocument() : this.eGridDiv && (e = this.eGridDiv.ownerDocument), e && z(e) ? e : document;
  }
  getWindow() {
    return this.getDocument().defaultView || window;
  }
  getRootNode() {
    return this.eGridDiv.getRootNode();
  }
  getAsyncTransactionWaitMillis() {
    return z(this.gridOptions.asyncTransactionWaitMillis) ? this.gridOptions.asyncTransactionWaitMillis : 50;
  }
  isAnimateRows() {
    return this.is("ensureDomOrder") ? !1 : this.is("animateRows");
  }
  isGroupRowsSticky() {
    return !(this.is("suppressGroupRowsSticky") || this.is("paginateChildRows") || this.is("groupHideOpenParents"));
  }
  isTreeData() {
    return this.is("treeData") && Z.__assertRegistered(Q.RowGroupingModule, "Tree Data", this.api.getGridId());
  }
  isMasterDetail() {
    return this.is("masterDetail") && Z.__assertRegistered(Q.MasterDetailModule, "masterDetail", this.api.getGridId());
  }
  isEnableRangeSelection() {
    return this.is("enableRangeSelection") && Z.__isRegistered(Q.RangeSelectionModule, this.api.getGridId());
  }
  isColumnsSortingCoupledToGroup() {
    const e = this.gridOptions.autoGroupColumnDef;
    return this.isRowModelType("clientSide") && !(e != null && e.comparator) && !this.isTreeData();
  }
  getGroupAggFiltering() {
    const e = this.gridOptions.groupAggFiltering;
    if (typeof e == "function")
      return this.getCallback("groupAggFiltering");
    if (i0(e))
      return () => !0;
  }
  isGroupMultiAutoColumn() {
    return this.gridOptions.groupDisplayType ? yC("multipleColumns", this.gridOptions.groupDisplayType) : this.is("groupHideOpenParents");
  }
  isGroupUseEntireRow(e) {
    return e ? !1 : this.gridOptions.groupDisplayType ? yC("groupRows", this.gridOptions.groupDisplayType) : !1;
  }
};
Wa([
  S("gridOptions")
], Po.prototype, "gridOptions", void 0);
Wa([
  S("eventService")
], Po.prototype, "eventService", void 0);
Wa([
  S("environment")
], Po.prototype, "environment", void 0);
Wa([
  S("eGridDiv")
], Po.prototype, "eGridDiv", void 0);
Wa([
  t0(0, qi("gridApi")),
  t0(1, qi("columnApi"))
], Po.prototype, "agWire", null);
Wa([
  B
], Po.prototype, "init", null);
Wa([
  dt
], Po.prototype, "destroy", null);
Po = Wa([
  q("gridOptionsService")
], Po);
var XN = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let GC = class extends H {
  getLocaleTextFunc() {
    const e = this.gridOptionsService.getCallback("getLocaleText");
    if (e)
      return (i, r, n) => e({
        key: i,
        defaultValue: r,
        variableValues: n
      });
    const t = this.gridOptionsService.get("localeText");
    return (i, r, n) => {
      let s = t && t[i];
      if (s && n && n.length) {
        let a = 0;
        for (; !(a >= n.length || s.indexOf("${variable}") === -1); )
          s = s.replace("${variable}", n[a++]);
      }
      return s != null ? s : r;
    };
  }
};
GC = XN([
  q("localeService")
], GC);
var qN = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class cf extends cc {
  constructor() {
    super(cf.TEMPLATE, "vertical");
  }
  postConstruct() {
    super.postConstruct(), this.createManagedBean(new Zv(this.eContainer)), this.ctrlsService.registerFakeVScrollComp(this), this.addManagedListener(this.eventService, w.EVENT_ROW_CONTAINER_HEIGHT_CHANGED, this.onRowContainerHeightChanged.bind(this));
  }
  setScrollVisible() {
    const e = this.scrollVisibleService.isVerticalScrollShowing(), t = this.invisibleScrollbar, i = e && this.gridOptionsService.getScrollbarWidth() || 0, r = i === 0 && t ? 16 : i;
    this.addOrRemoveCssClass("ag-scrollbar-invisible", t), dn(this.getGui(), r), dn(this.eViewport, r), dn(this.eContainer, r), this.setDisplayed(e, { skipAriaHidden: !0 });
  }
  onRowContainerHeightChanged() {
    const t = this.ctrlsService.getGridBodyCtrl().getBodyViewportElement();
    this.eViewport.scrollTop != t.scrollTop && (this.eViewport.scrollTop = t.scrollTop);
  }
  getScrollPosition() {
    return this.getViewport().scrollTop;
  }
  setScrollPosition(e) {
    Ms(this.getViewport()) || this.attemptSettingScrollPosition(e), this.getViewport().scrollTop = e;
  }
}
cf.TEMPLATE = `<div class="ag-body-vertical-scroll" aria-hidden="true">
            <div class="ag-body-vertical-scroll-viewport" ref="eViewport">
                <div class="ag-body-vertical-scroll-container" ref="eContainer"></div>
            </div>
        </div>`;
qN([
  B
], cf.prototype, "postConstruct", null);
var dc = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const r0 = {
  january: "January",
  february: "February",
  march: "March",
  april: "April",
  may: "May",
  june: "June",
  july: "July",
  august: "August",
  september: "September",
  october: "October",
  november: "November",
  december: "December"
}, n0 = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
let Rs = class extends H {
  constructor() {
    super(...arguments), this.dataTypeDefinitions = {}, this.isWaitingForRowData = !1, this.isColumnTypeOverrideInDataTypeDefinitions = !1, this.columnStateUpdatesPendingInference = {}, this.columnStateUpdateListenerDestroyFuncs = [];
  }
  init() {
    this.groupHideOpenParents = this.gridOptionsService.is("groupHideOpenParents"), this.addManagedPropertyListener("groupHideOpenParents", () => {
      this.groupHideOpenParents = this.gridOptionsService.is("groupHideOpenParents");
    }), this.processDataTypeDefinitions(), this.addManagedPropertyListener("dataTypeDefinitions", () => {
      this.processDataTypeDefinitions(), this.columnModel.recreateColumnDefs("gridOptionsChanged");
    });
  }
  processDataTypeDefinitions() {
    var e;
    const t = this.getDefaultDataTypes();
    this.dataTypeDefinitions = {}, Object.entries(t).forEach(([r, n]) => {
      this.dataTypeDefinitions[r] = Object.assign(Object.assign({}, n), { groupSafeValueFormatter: this.createGroupSafeValueFormatter(n) });
    });
    const i = (e = this.gridOptionsService.get("dataTypeDefinitions")) !== null && e !== void 0 ? e : {};
    this.dataTypeMatchers = {}, Object.entries(i).forEach(([r, n]) => {
      const s = this.processDataTypeDefinition(n, i, [r], t);
      s && (this.dataTypeDefinitions[r] = s, n.dataTypeMatcher && (this.dataTypeMatchers[r] = n.dataTypeMatcher));
    }), this.checkObjectValueHandlers(t), ["dateString", "text", "number", "boolean", "date"].forEach((r) => {
      const n = this.dataTypeMatchers[r];
      n && delete this.dataTypeMatchers[r], this.dataTypeMatchers[r] = n != null ? n : t[r].dataTypeMatcher;
    });
  }
  mergeDataTypeDefinitions(e, t) {
    const i = Object.assign(Object.assign({}, e), t);
    return e.columnTypes && t.columnTypes && t.appendColumnTypes && (i.columnTypes = [
      ...this.convertColumnTypes(e.columnTypes),
      ...this.convertColumnTypes(t.columnTypes)
    ]), i;
  }
  processDataTypeDefinition(e, t, i, r) {
    let n;
    const s = e.extendsDataType;
    if (e.columnTypes && (this.isColumnTypeOverrideInDataTypeDefinitions = !0), e.extendsDataType === e.baseDataType) {
      const a = r[s];
      if (!this.validateDataTypeDefinition(e, a, s))
        return;
      n = this.mergeDataTypeDefinitions(a, e);
    } else {
      if (i.includes(s)) {
        tt(() => console.warn('AG Grid: Data type definition hierarchies (via the "extendsDataType" property) cannot contain circular references.'), "dataTypeExtendsCircularRef");
        return;
      }
      const a = t[s];
      if (!this.validateDataTypeDefinition(e, a, s))
        return;
      const l = this.processDataTypeDefinition(a, t, [...i, s], r);
      if (!l)
        return;
      n = this.mergeDataTypeDefinitions(l, e);
    }
    return Object.assign(Object.assign({}, n), { groupSafeValueFormatter: this.createGroupSafeValueFormatter(n) });
  }
  validateDataTypeDefinition(e, t, i) {
    return t ? t.baseDataType !== e.baseDataType ? (tt(() => console.warn('AG Grid: The "baseDataType" property of a data type definition must match that of its parent.'), "dataTypeBaseTypesMatch"), !1) : !0 : (tt(() => console.warn(`AG Grid: The data type definition ${i} does not exist.`), "dataTypeDefMissing" + i), !1);
  }
  createGroupSafeValueFormatter(e) {
    if (e.valueFormatter)
      return (t) => {
        var i, r;
        if (!((i = t.node) === null || i === void 0) && i.group) {
          const n = t.column.getAggFunc();
          if (n) {
            if (n === "first" || n === "last")
              return e.valueFormatter(t);
            if (e.baseDataType === "number" && n !== "count") {
              if (typeof t.value == "number")
                return e.valueFormatter(t);
              if (typeof t.value == "object") {
                if (!t.value)
                  return;
                if ("toNumber" in t.value)
                  return e.valueFormatter(Object.assign(Object.assign({}, t), { value: t.value.toNumber() }));
                if ("value" in t.value)
                  return e.valueFormatter(Object.assign(Object.assign({}, t), { value: t.value.value }));
              }
            }
          }
          return;
        } else if (this.groupHideOpenParents && t.column.isRowGroupActive())
          return typeof t.value != "string" || !((r = e.dataTypeMatcher) === null || r === void 0) && r.call(e, t.value) ? e.valueFormatter(t) : void 0;
        return e.valueFormatter(t);
      };
  }
  updateColDefAndGetDataTypeDefinitionColumnType(e, t, i) {
    let { cellDataType: r } = t;
    const { field: n } = t;
    if (r === void 0 && (r = e.cellDataType), (r == null || r === !0) && (r = this.canInferCellDataType(e, t) ? this.inferCellDataType(n, i) : !1), !r) {
      e.cellDataType = !1;
      return;
    }
    const s = this.dataTypeDefinitions[r];
    if (!s) {
      tt(() => console.warn(`AG Grid: Missing data type definition - "${r}"`), "dataTypeMissing" + r);
      return;
    }
    return e.cellDataType = r, s.groupSafeValueFormatter && (e.valueFormatter = s.groupSafeValueFormatter), s.valueParser && (e.valueParser = s.valueParser), s.suppressDefaultProperties || this.setColDefPropertiesForBaseDataType(e, s, i), s.columnTypes;
  }
  updateColDefAndGetColumnType(e, t, i) {
    var r, n;
    const s = this.updateColDefAndGetDataTypeDefinitionColumnType(e, t, i), a = (n = (r = t.type) !== null && r !== void 0 ? r : s) !== null && n !== void 0 ? n : e.type;
    return e.type = a, a ? this.convertColumnTypes(a) : void 0;
  }
  addColumnListeners(e) {
    if (!this.isWaitingForRowData)
      return;
    const t = this.columnStateUpdatesPendingInference[e.getColId()];
    if (!t)
      return;
    const i = (r) => {
      t.add(r.key);
    };
    e.addEventListener(me.EVENT_STATE_UPDATED, i), this.columnStateUpdateListenerDestroyFuncs.push(() => e.removeEventListener(me.EVENT_STATE_UPDATED, i));
  }
  canInferCellDataType(e, t) {
    var i;
    if (this.rowModel.getType() !== "clientSide")
      return !1;
    const r = { cellRenderer: !0, valueGetter: !0, valueParser: !0, refData: !0 };
    if (this.doColDefPropsPreventInference(t, r))
      return !1;
    const n = t.type === null ? e.type : t.type;
    if (n) {
      const s = (i = this.gridOptionsService.get("columnTypes")) !== null && i !== void 0 ? i : {};
      if (this.convertColumnTypes(n).some((l) => {
        const c = s[l.trim()];
        return c && this.doColDefPropsPreventInference(c, r);
      }))
        return !1;
    }
    return !this.doColDefPropsPreventInference(e, r);
  }
  doColDefPropsPreventInference(e, t) {
    return [
      ["cellRenderer", "agSparklineCellRenderer"],
      ["valueGetter", void 0],
      ["valueParser", void 0],
      ["refData", void 0]
    ].some(([i, r]) => this.doesColDefPropPreventInference(e, t, i, r));
  }
  doesColDefPropPreventInference(e, t, i, r) {
    if (!t[i])
      return !1;
    const n = e[i];
    return n === null ? (t[i] = !1, !1) : r === void 0 ? !!n : n === r;
  }
  inferCellDataType(e, t) {
    var i;
    if (!e)
      return;
    let r;
    const n = this.getInitialData();
    if (n) {
      const a = e.indexOf(".") >= 0 && !this.gridOptionsService.is("suppressFieldDotNotation");
      r = bd(n, e, a);
    } else
      this.initWaitForRowData(t);
    if (r == null)
      return;
    const [s] = (i = Object.entries(this.dataTypeMatchers).find(([a, l]) => l(r))) !== null && i !== void 0 ? i : ["object"];
    return s;
  }
  getInitialData() {
    const e = this.gridOptionsService.get("rowData");
    if (e != null && e.length)
      return e[0];
    if (this.initialData)
      return this.initialData;
    {
      const t = this.rowModel.getRootNode().allLeafChildren;
      if (t != null && t.length)
        return t[0].data;
    }
    return null;
  }
  initWaitForRowData(e) {
    if (this.columnStateUpdatesPendingInference[e] = /* @__PURE__ */ new Set(), this.isWaitingForRowData)
      return;
    this.isWaitingForRowData = !0;
    const t = this.isColumnTypeOverrideInDataTypeDefinitions;
    t && this.columnModel.queueResizeOperations();
    const i = this.addManagedListener(this.eventService, w.EVENT_ROW_DATA_UPDATE_STARTED, (r) => {
      const { firstRowData: n } = r;
      n && (i == null || i(), this.isWaitingForRowData = !1, this.processColumnsPendingInference(n, t), this.columnStateUpdatesPendingInference = {}, t && this.columnModel.processResizeOperations());
    });
  }
  processColumnsPendingInference(e, t) {
    this.initialData = e;
    const i = [];
    this.columnStateUpdateListenerDestroyFuncs.forEach((s) => s()), this.columnStateUpdateListenerDestroyFuncs = [];
    const r = {}, n = {};
    Object.entries(this.columnStateUpdatesPendingInference).forEach(([s, a]) => {
      const l = this.columnModel.getGridColumn(s);
      if (!l)
        return;
      const c = l.getColDef();
      if (!this.columnModel.resetColumnDefIntoColumn(l))
        return;
      const d = l.getColDef();
      if (t && d.type && d.type !== c.type) {
        const u = this.getUpdatedColumnState(l, a);
        u.rowGroup && u.rowGroupIndex == null && (r[s] = u), u.pivot && u.pivotIndex == null && (n[s] = u), i.push(u);
      }
    }), t && i.push(...this.columnModel.generateColumnStateForRowGroupAndPivotIndexes(r, n)), i.length && this.columnModel.applyColumnState({ state: i }, "cellDataTypeInferred"), this.initialData = null;
  }
  getUpdatedColumnState(e, t) {
    const i = this.columnModel.getColumnStateFromColDef(e);
    return t.forEach((r) => {
      delete i[r], r === "rowGroup" ? delete i.rowGroupIndex : r === "pivot" && delete i.pivotIndex;
    }), i;
  }
  checkObjectValueHandlers(e) {
    const t = this.dataTypeDefinitions.object, i = e.object;
    this.hasObjectValueParser = t.valueParser !== i.valueParser, this.hasObjectValueFormatter = t.valueFormatter !== i.valueFormatter;
  }
  convertColumnTypes(e) {
    let t = [];
    return e instanceof Array ? e.some((r) => typeof r != "string") ? console.warn("AG Grid: if colDef.type is supplied an array it should be of type 'string[]'") : t = e : typeof e == "string" ? t = e.split(",") : console.warn("AG Grid: colDef.type should be of type 'string' | 'string[]'"), t;
  }
  getDateStringTypeDefinition() {
    return this.dataTypeDefinitions.dateString;
  }
  getDateParserFunction() {
    return this.getDateStringTypeDefinition().dateParser;
  }
  getDateFormatterFunction() {
    return this.getDateStringTypeDefinition().dateFormatter;
  }
  checkType(e, t) {
    var i;
    const r = e.getColDef();
    if (!r.cellDataType || t == null)
      return !0;
    const n = (i = this.dataTypeDefinitions[r.cellDataType]) === null || i === void 0 ? void 0 : i.dataTypeMatcher;
    return n ? n(t) : !0;
  }
  validateColDef(e) {
    e.cellDataType === "object" && (e.valueFormatter === this.dataTypeDefinitions.object.groupSafeValueFormatter && !this.hasObjectValueFormatter && tt(() => console.warn('AG Grid: Cell data type is "object" but no value formatter has been provided. Please either provide an object data type definition with a value formatter, or set "colDef.valueFormatter"'), "dataTypeObjectValueFormatter"), e.editable && e.valueParser === this.dataTypeDefinitions.object.valueParser && !this.hasObjectValueParser && tt(() => console.warn('AG Grid: Cell data type is "object" but no value parser has been provided. Please either provide an object data type definition with a value parser, or set "colDef.valueParser"'), "dataTypeObjectValueParser"));
  }
  setColDefPropertiesForBaseDataType(e, t, i) {
    const r = (l, c, d) => {
      let u = l.getColDef().valueFormatter;
      return u === t.groupSafeValueFormatter && (u = t.valueFormatter), this.valueFormatterService.formatValue(l, c, d, u);
    }, n = Z.__isRegistered(Q.SetFilterModule, this.context.getGridId()), s = this.localeService.getLocaleTextFunc(), a = (l) => {
      const { filterParams: c } = e;
      e.filterParams = typeof c == "object" ? Object.assign(Object.assign({}, c), l) : l;
    };
    switch (e.useValueFormatterForExport = !0, e.useValueParserForImport = !0, t.baseDataType) {
      case "number": {
        e.cellEditor = "agNumberCellEditor", n && a({
          comparator: (l, c) => {
            const d = l == null ? 0 : parseInt(l), u = c == null ? 0 : parseInt(c);
            return d === u ? 0 : d > u ? 1 : -1;
          }
        });
        break;
      }
      case "boolean": {
        e.cellEditor = "agCheckboxCellEditor", e.cellRenderer = "agCheckboxCellRenderer", e.suppressKeyboardEvent = (l) => !!l.colDef.editable && l.event.key === V.SPACE, a(n ? {
          valueFormatter: (l) => z(l.value) ? s(String(l.value), l.value ? "True" : "False") : s("blanks", "(Blanks)")
        } : {
          maxNumConditions: 1,
          filterOptions: [
            "empty",
            {
              displayKey: "true",
              displayName: "True",
              predicate: (l, c) => c,
              numberOfInputs: 0
            },
            {
              displayKey: "false",
              displayName: "False",
              predicate: (l, c) => c === !1,
              numberOfInputs: 0
            }
          ]
        });
        break;
      }
      case "date": {
        e.cellEditor = "agDateCellEditor", e.keyCreator = (l) => r(l.column, l.node, l.value), n && a({
          valueFormatter: (l) => {
            const c = r(l.column, l.node, l.value);
            return z(c) ? c : s("blanks", "(Blanks)");
          },
          treeList: !0,
          treeListFormatter: (l, c) => {
            if (c === 1 && l != null) {
              const d = n0[Number(l) - 1];
              return s(d, r0[d]);
            }
            return l != null ? l : s("blanks", "(Blanks)");
          }
        });
        break;
      }
      case "dateString": {
        e.cellEditor = "agDateStringCellEditor", e.keyCreator = (c) => r(c.column, c.node, c.value);
        const l = this.getDateParserFunction();
        a(n ? {
          valueFormatter: (c) => {
            const d = r(c.column, c.node, c.value);
            return z(d) ? d : s("blanks", "(Blanks)");
          },
          treeList: !0,
          treeListPathGetter: (c) => {
            const d = l(c != null ? c : void 0);
            return d ? [String(d.getFullYear()), String(d.getMonth() + 1), String(d.getDate())] : null;
          },
          treeListFormatter: (c, d) => {
            if (d === 1 && c != null) {
              const u = n0[Number(c) - 1];
              return s(u, r0[u]);
            }
            return c != null ? c : s("blanks", "(Blanks)");
          }
        } : {
          comparator: (c, d) => {
            const u = l(d);
            return d == null || u < c ? -1 : u > c ? 1 : 0;
          }
        });
        break;
      }
      case "object": {
        e.cellEditorParams = {
          useFormatter: !0
        }, e.comparator = (l, c) => {
          const d = this.columnModel.getPrimaryColumn(i), u = d == null ? void 0 : d.getColDef();
          if (!d || !u)
            return 0;
          const h = l == null ? "" : r(d, null, l), p = c == null ? "" : r(d, null, c);
          return h === p ? 0 : h > p ? 1 : -1;
        }, e.keyCreator = (l) => r(l.column, l.node, l.value), n ? a({
          valueFormatter: (l) => {
            const c = r(l.column, l.node, l.value);
            return z(c) ? c : s("blanks", "(Blanks)");
          }
        }) : e.filterValueGetter = (l) => r(l.column, l.node, this.valueService.getValue(l.column, l.node));
        break;
      }
    }
  }
  getDefaultDataTypes() {
    const e = (i) => !!i.match("^\\d{4}-\\d{2}-\\d{2}$"), t = this.localeService.getLocaleTextFunc();
    return {
      number: {
        baseDataType: "number",
        valueParser: (i) => i.newValue === "" ? null : Number(i.newValue),
        valueFormatter: (i) => i.value == null ? "" : typeof i.value != "number" || isNaN(i.value) ? t("invalidNumber", "Invalid Number") : String(i.value),
        dataTypeMatcher: (i) => typeof i == "number"
      },
      text: {
        baseDataType: "text",
        valueParser: (i) => i.newValue === "" ? null : Lh(i.newValue),
        dataTypeMatcher: (i) => typeof i == "string"
      },
      boolean: {
        baseDataType: "boolean",
        valueParser: (i) => i.newValue === "" ? null : String(i.newValue).toLowerCase() === "true",
        valueFormatter: (i) => i.value == null ? "" : String(i.value),
        dataTypeMatcher: (i) => typeof i == "boolean"
      },
      date: {
        baseDataType: "date",
        valueParser: (i) => Vn(i.newValue == null ? null : String(i.newValue)),
        valueFormatter: (i) => {
          var r;
          return i.value == null ? "" : !(i.value instanceof Date) || isNaN(i.value.getTime()) ? t("invalidDate", "Invalid Date") : (r = cn(i.value, !1)) !== null && r !== void 0 ? r : "";
        },
        dataTypeMatcher: (i) => i instanceof Date
      },
      dateString: {
        baseDataType: "dateString",
        dateParser: (i) => {
          var r;
          return (r = Vn(i)) !== null && r !== void 0 ? r : void 0;
        },
        dateFormatter: (i) => {
          var r;
          return (r = cn(i != null ? i : null, !1)) !== null && r !== void 0 ? r : void 0;
        },
        valueParser: (i) => e(String(i.newValue)) ? i.newValue : null,
        valueFormatter: (i) => e(String(i.value)) ? i.value : "",
        dataTypeMatcher: (i) => typeof i == "string" && e(i)
      },
      object: {
        baseDataType: "object",
        valueParser: () => null,
        valueFormatter: (i) => {
          var r;
          return (r = Lh(i.value)) !== null && r !== void 0 ? r : "";
        }
      }
    };
  }
};
dc([
  S("rowModel")
], Rs.prototype, "rowModel", void 0);
dc([
  S("columnModel")
], Rs.prototype, "columnModel", void 0);
dc([
  S("columnUtils")
], Rs.prototype, "columnUtils", void 0);
dc([
  S("valueService")
], Rs.prototype, "valueService", void 0);
dc([
  S("valueFormatterService")
], Rs.prototype, "valueFormatterService", void 0);
dc([
  B
], Rs.prototype, "init", null);
Rs = dc([
  q("dataTypeService")
], Rs);
var Mx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Bg = class extends H {
  parseValue(e, t, i, r) {
    const n = e.getColDef(), s = {
      node: t,
      data: t == null ? void 0 : t.data,
      oldValue: r,
      newValue: i,
      colDef: n,
      column: e,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context
    }, a = n.valueParser;
    return z(a) ? typeof a == "function" ? a(s) : this.expressionService.evaluate(a, s) : i;
  }
};
Mx([
  S("expressionService")
], Bg.prototype, "expressionService", void 0);
Bg = Mx([
  q("valueParserService")
], Bg);
class _x {
  constructor(e, t, i) {
    if (!t) {
      console.error("AG Grid: no gridOptions provided to the grid");
      return;
    }
    this.gridOptions = t, new QN().create(e, t, (r) => {
      const n = new bu(e);
      r.createBean(n);
    }, void 0, i);
  }
  destroy() {
    this.gridOptions && this.gridOptions.api && this.gridOptions.api.destroy();
  }
}
let ZN = 1;
class QN {
  create(e, t, i, r, n) {
    var s;
    const a = !!t.debug, l = (s = t.gridId) !== null && s !== void 0 ? s : String(ZN++), c = this.getRegisteredModules(n, l), d = this.createBeansList(t.rowModelType, c, l), u = this.createProvidedBeans(e, t, n);
    if (!d)
      return;
    const h = {
      providedBeanInstances: u,
      beanClasses: d,
      debug: a,
      gridId: l
    }, p = new MC("AG Grid", () => t.debug), f = new MC("Context", () => h.debug), g = new FI(h, f), v = g.getBean("beans");
    this.registerModuleUserComponents(v, c), this.registerStackComponents(v, c), this.registerControllers(v, c), i(g), v.ctrlsService.whenReady(() => {
      this.setColumnsAndData(v), this.dispatchGridReadyEvent(v);
      const y = Z.__isRegistered(Q.EnterpriseCoreModule, l);
      p.log(`initialised successfully, enterprise = ${y}`);
    }), r && r(g);
  }
  registerControllers(e, t) {
    t.forEach((i) => {
      i.controllers && i.controllers.forEach((r) => e.ctrlsFactory.register(r));
    });
  }
  registerStackComponents(e, t) {
    const i = this.createAgStackComponentsList(t);
    e.agStackComponentsRegistry.setupComponents(i);
  }
  getRegisteredModules(e, t) {
    const i = e ? e.modules : null, r = Z.__getRegisteredModules(t), n = [], s = {}, a = (l, c, d) => {
      ((h) => {
        s[h.moduleName] || (s[h.moduleName] = !0, n.push(h), Z.__register(h, l, d));
      })(c), c.dependantModules && c.dependantModules.forEach((h) => a(l, h, d));
    };
    return i && i.forEach((l) => a(!0, l, t)), r && r.forEach((l) => a(!Z.__isPackageBased(), l, void 0)), n;
  }
  registerModuleUserComponents(e, t) {
    this.extractModuleEntity(t, (r) => r.userComponents ? r.userComponents : []).forEach((r) => {
      e.userComponentRegistry.registerDefaultComponent(r.componentName, r.componentClass);
    });
  }
  createProvidedBeans(e, t, i) {
    let r = i ? i.frameworkOverrides : null;
    Se(r) && (r = new Rx());
    const n = {
      gridOptions: t,
      eGridDiv: e,
      globalEventListener: i ? i.globalEventListener : null,
      frameworkOverrides: r
    };
    return i && i.providedBeanInstances && Object.assign(n, i.providedBeanInstances), n;
  }
  createAgStackComponentsList(e) {
    let t = [
      { componentName: "AgCheckbox", componentClass: rr },
      { componentName: "AgRadioButton", componentClass: ZS },
      { componentName: "AgToggleButton", componentClass: Rb },
      { componentName: "AgInputTextField", componentClass: Na },
      { componentName: "AgInputTextArea", componentClass: TN },
      { componentName: "AgInputNumberField", componentClass: eb },
      { componentName: "AgInputDateField", componentClass: xN },
      { componentName: "AgInputRange", componentClass: DN },
      { componentName: "AgSelect", componentClass: zn },
      { componentName: "AgSlider", componentClass: mi },
      { componentName: "AgGridBody", componentClass: Kn },
      { componentName: "AgHeaderRoot", componentClass: Zp },
      { componentName: "AgSortIndicator", componentClass: Gr },
      { componentName: "AgPagination", componentClass: Wr },
      { componentName: "AgOverlayWrapper", componentClass: Bo },
      { componentName: "AgGroupComponent", componentClass: Tt },
      { componentName: "AgPanel", componentClass: gn },
      { componentName: "AgDialog", componentClass: Kh },
      { componentName: "AgRowContainer", componentClass: sc },
      { componentName: "AgFakeHorizontalScroll", componentClass: Ns },
      { componentName: "AgFakeVerticalScroll", componentClass: cf }
    ];
    const i = this.extractModuleEntity(e, (r) => r.agStackComponents ? r.agStackComponents : []);
    return t = t.concat(i), t;
  }
  createBeansList(e = "clientSide", t, i) {
    const r = t.filter((c) => !c.rowModel || c.rowModel === e), n = {
      clientSide: Q.ClientSideRowModelModule,
      infinite: Q.InfiniteRowModelModule,
      serverSide: Q.ServerSideRowModelModule,
      viewport: Q.ViewportRowModelModule
    };
    if (!n[e]) {
      console.error("AG Grid: could not find row model for rowModelType = " + e);
      return;
    }
    if (!Z.__assertRegistered(n[e], `rowModelType = '${e}'`, i))
      return;
    const s = [
      Oe,
      Bd,
      IC,
      tp,
      Zh,
      Ye,
      Hh,
      Gg,
      Qh,
      OC,
      fa,
      Vd,
      Uh,
      GC,
      Md,
      $h,
      Wh,
      SC,
      _r,
      Po,
      va,
      Vl,
      Oo,
      ti,
      Ll,
      zh,
      Ir,
      Fg,
      Ad,
      AC,
      kl,
      Bi,
      Ng,
      ya,
      Lg,
      CC,
      Gl,
      Nl,
      Te,
      Yh,
      Ht,
      Nd,
      Jh,
      ma,
      _g,
      Ig,
      jh,
      Xh,
      _C,
      qh,
      kg,
      Gh,
      kd,
      Gd,
      vn,
      bC,
      FC,
      ip,
      Es,
      Hd,
      Vg,
      rp,
      Wd,
      NC,
      Rs,
      Bg
    ], a = this.extractModuleEntity(r, (c) => c.beans ? c.beans : []);
    s.push(...a);
    const l = [];
    return s.forEach((c) => {
      l.indexOf(c) < 0 && l.push(c);
    }), l;
  }
  extractModuleEntity(e, t) {
    return [].concat(...e.map(t));
  }
  setColumnsAndData(e) {
    const t = e.gridOptionsService.get("columnDefs");
    e.columnModel.setColumnDefs(t || [], "gridInitializing"), e.rowModel.start();
  }
  dispatchGridReadyEvent(e) {
    const t = {
      type: w.EVENT_GRID_READY
    };
    e.eventService.dispatchEvent(t);
  }
}
class JN {
  wrap(e, t, i = [], r) {
    const n = this.createWrapper(e, r);
    return t.forEach((s) => {
      this.createMethod(n, s, !0);
    }), i.forEach((s) => {
      this.createMethod(n, s, !1);
    }), n;
  }
  unwrap(e) {
    return e;
  }
  createMethod(e, t, i) {
    e.addMethod(t, this.createMethodProxy(e, t, i));
  }
  createMethodProxy(e, t, i) {
    return function() {
      return e.hasMethod(t) ? e.callMethod(t, arguments) : (i && console.warn("AG Grid: Framework component is missing the method " + t + "()"), null);
    };
  }
}
const eG = {
  columnGroup: [
    "column",
    "stackedColumn",
    "normalizedColumn"
  ],
  barGroup: [
    "bar",
    "stackedBar",
    "normalizedBar"
  ],
  pieGroup: [
    "pie",
    "doughnut"
  ],
  lineGroup: [
    "line"
  ],
  scatterGroup: [
    "scatter",
    "bubble"
  ],
  areaGroup: [
    "area",
    "stackedArea",
    "normalizedArea"
  ],
  histogramGroup: [
    "histogram"
  ],
  combinationGroup: [
    "columnLineCombo",
    "areaColumnCombo",
    "customCombo"
  ]
}, Oy = [
  "chartSettings",
  "chartData",
  "chartFormat"
], o0 = [
  "chartUnlink",
  "chartLink",
  "chartDownload"
], fg = {
  settings: "chartSettings",
  data: "chartData",
  format: "chartFormat"
};
var s0;
(function(o) {
  o.InsideBase = "insideBase", o.InsideEnd = "insideEnd", o.Center = "center", o.OutsideEnd = "outsideEnd";
})(s0 || (s0 = {}));
/**
 * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue
 * @version v30.0.5
 * @link https://www.ag-grid.com/
 * @license MIT
 */
const Eu = typeof global == "undefined" ? {} : global;
Eu.HTMLElement = typeof HTMLElement == "undefined" ? {} : HTMLElement;
Eu.HTMLButtonElement = typeof HTMLButtonElement == "undefined" ? {} : HTMLButtonElement;
Eu.HTMLSelectElement = typeof HTMLSelectElement == "undefined" ? {} : HTMLSelectElement;
Eu.HTMLInputElement = typeof HTMLInputElement == "undefined" ? {} : HTMLInputElement;
Eu.Node = typeof Node == "undefined" ? {} : Node;
Eu.MouseEvent = typeof MouseEvent == "undefined" ? {} : MouseEvent;
class ra {
  constructor(e, t, i, r, n, s) {
    this.nextId = 0, this.allNodesMap = {}, this.rootNode = e, this.gridOptionsService = t, this.eventService = i, this.columnModel = r, this.beans = s, this.selectionService = n, this.rootNode.group = !0, this.rootNode.level = -1, this.rootNode.id = ra.ROOT_NODE_ID, this.rootNode.allLeafChildren = [], this.rootNode.childrenAfterGroup = [], this.rootNode.childrenAfterSort = [], this.rootNode.childrenAfterAggFilter = [], this.rootNode.childrenAfterFilter = [], this.postConstruct();
  }
  // @PostConstruct - this is not a bean, so postConstruct called by constructor
  postConstruct() {
    this.suppressParentsInRowNodes = this.gridOptionsService.is("suppressParentsInRowNodes"), this.isRowMasterFunc = this.gridOptionsService.get("isRowMaster"), this.doingTreeData = this.gridOptionsService.isTreeData(), this.doingMasterDetail = this.gridOptionsService.isMasterDetail();
  }
  getCopyOfNodesMap() {
    return x.cloneObject(this.allNodesMap);
  }
  getRowNode(e) {
    return this.allNodesMap[e];
  }
  setRowData(e) {
    if (typeof e == "string") {
      console.warn("AG Grid: rowData must be an array, however you passed in a string. If you are loading JSON, make sure you convert the JSON string to JavaScript objects first");
      return;
    }
    this.dispatchRowDataUpdateStartedEvent(e);
    const t = this.rootNode, i = this.rootNode.sibling;
    t.childrenAfterFilter = null, t.childrenAfterGroup = null, t.childrenAfterAggFilter = null, t.childrenAfterSort = null, t.childrenMapped = null, t.updateHasChildren(), this.nextId = 0, this.allNodesMap = {}, e ? t.allLeafChildren = e.map((r) => this.createNode(r, this.rootNode, ra.TOP_LEVEL)) : (t.allLeafChildren = [], t.childrenAfterGroup = []), i && (i.childrenAfterFilter = t.childrenAfterFilter, i.childrenAfterGroup = t.childrenAfterGroup, i.childrenAfterAggFilter = t.childrenAfterAggFilter, i.childrenAfterSort = t.childrenAfterSort, i.childrenMapped = t.childrenMapped, i.allLeafChildren = t.allLeafChildren);
  }
  updateRowData(e, t) {
    this.dispatchRowDataUpdateStartedEvent(e.add);
    const i = {
      remove: [],
      update: [],
      add: []
    }, r = [];
    return this.executeRemove(e, i, r), this.executeUpdate(e, i, r), this.executeAdd(e, i), this.updateSelection(r, "rowDataChanged"), t && x.sortRowNodesByOrder(this.rootNode.allLeafChildren, t), i;
  }
  dispatchRowDataUpdateStartedEvent(e) {
    const t = {
      type: w.EVENT_ROW_DATA_UPDATE_STARTED,
      firstRowData: e != null && e.length ? e[0] : null
    };
    this.eventService.dispatchEvent(t);
  }
  updateSelection(e, t) {
    const i = e.length > 0;
    if (i && this.selectionService.setNodesSelected({
      newValue: !1,
      nodes: e,
      suppressFinishActions: !0,
      source: t
    }), this.selectionService.updateGroupsFromChildrenSelections(t), i) {
      const r = {
        type: w.EVENT_SELECTION_CHANGED,
        source: t
      };
      this.eventService.dispatchEvent(r);
    }
  }
  executeAdd(e, t) {
    var i;
    const { add: r, addIndex: n } = e;
    if (x.missingOrEmpty(r))
      return;
    const s = r.map((a) => this.createNode(a, this.rootNode, ra.TOP_LEVEL));
    if (typeof n == "number" && n >= 0) {
      const { allLeafChildren: a } = this.rootNode, l = a.length;
      let c = n;
      if (this.doingTreeData && n > 0 && l > 0) {
        for (let h = 0; h < l; h++)
          if (((i = a[h]) === null || i === void 0 ? void 0 : i.rowIndex) == n - 1) {
            c = h + 1;
            break;
          }
      }
      const d = a.slice(0, c), u = a.slice(c, a.length);
      this.rootNode.allLeafChildren = [...d, ...s, ...u];
    } else
      this.rootNode.allLeafChildren = [...this.rootNode.allLeafChildren, ...s];
    this.rootNode.sibling && (this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren), t.add = s;
  }
  executeRemove(e, t, i) {
    const { remove: r } = e;
    if (x.missingOrEmpty(r))
      return;
    const n = {};
    r.forEach((s) => {
      const a = this.lookupRowNode(s);
      a && (a.isSelected() && i.push(a), a.clearRowTopAndRowIndex(), n[a.id] = !0, delete this.allNodesMap[a.id], t.remove.push(a));
    }), this.rootNode.allLeafChildren = this.rootNode.allLeafChildren.filter((s) => !n[s.id]), this.rootNode.sibling && (this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren);
  }
  executeUpdate(e, t, i) {
    const { update: r } = e;
    x.missingOrEmpty(r) || r.forEach((n) => {
      const s = this.lookupRowNode(n);
      s && (s.updateData(n), !s.selectable && s.isSelected() && i.push(s), this.setMasterForRow(s, n, ra.TOP_LEVEL, !1), t.update.push(s));
    });
  }
  lookupRowNode(e) {
    const t = this.gridOptionsService.getCallback("getRowId");
    let i;
    if (t) {
      const r = t({ data: e, level: 0 });
      if (i = this.allNodesMap[r], !i)
        return console.error(`AG Grid: could not find row id=${r}, data item was not found for this id`), null;
    } else if (i = this.rootNode.allLeafChildren.find((r) => r.data === e), !i)
      return console.error("AG Grid: could not find data item as object was not found", e), console.error("Consider using getRowId to help the Grid find matching row data"), null;
    return i || null;
  }
  createNode(e, t, i) {
    const r = new re(this.beans);
    return r.group = !1, this.setMasterForRow(r, e, i, !0), t && !this.suppressParentsInRowNodes && (r.parent = t), r.level = i, r.setDataAndId(e, this.nextId.toString()), this.allNodesMap[r.id] && console.warn(`AG Grid: duplicate node id '${r.id}' detected from getRowId callback, this could cause issues in your grid.`), this.allNodesMap[r.id] = r, this.nextId++, r;
  }
  setMasterForRow(e, t, i, r) {
    if (this.doingTreeData)
      e.setMaster(!1), r && (e.expanded = !1);
    else if (this.doingMasterDetail ? this.isRowMasterFunc ? e.setMaster(this.isRowMasterFunc(t)) : e.setMaster(!0) : e.setMaster(!1), r) {
      const n = this.columnModel.getRowGroupColumns(), s = n ? n.length : 0, a = i + s;
      e.expanded = e.master ? this.isExpanded(a) : !1;
    }
  }
  isExpanded(e) {
    const t = this.gridOptionsService.getNum("groupDefaultExpanded");
    return t === -1 ? !0 : e < t;
  }
}
ra.TOP_LEVEL = 0;
ra.ROOT_NODE_ID = "ROOT_NODE_ID";
var lr = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, uo;
(function(o) {
  o[o.Normal = 0] = "Normal", o[o.AfterFilter = 1] = "AfterFilter", o[o.AfterFilterAndSort = 2] = "AfterFilterAndSort", o[o.PivotNodes = 3] = "PivotNodes";
})(uo || (uo = {}));
let Hi = class extends H {
  constructor() {
    super(...arguments), this.onRowHeightChanged_debounced = x.debounce(this.onRowHeightChanged.bind(this), 100), this.rowsToDisplay = [];
  }
  init() {
    const e = this.refreshModel.bind(this, { step: ot.EVERYTHING }), t = !this.gridOptionsService.is("suppressAnimationFrame"), i = this.refreshModel.bind(this, {
      step: ot.EVERYTHING,
      afterColumnsChanged: !0,
      keepRenderedRows: !0,
      animate: t
    });
    this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, i), this.addManagedListener(this.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, e), this.addManagedListener(this.eventService, w.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, { step: ot.PIVOT })), this.addManagedListener(this.eventService, w.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_SORT_CHANGED, this.onSortChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_MODE_CHANGED, e), this.addManagedListener(this.eventService, w.EVENT_GRID_STYLES_CHANGED, this.onGridStylesChanges.bind(this));
    const r = this.refreshModel.bind(this, {
      step: ot.MAP,
      keepRenderedRows: !0,
      animate: t
    });
    this.addManagedPropertyListener("groupRemoveSingleChildren", r), this.addManagedPropertyListener("groupRemoveLowestSingleChildren", r), this.rootNode = new re(this.beans), this.nodeManager = new ra(this.rootNode, this.gridOptionsService, this.eventService, this.columnModel, this.selectionService, this.beans);
  }
  start() {
    const e = this.gridOptionsService.get("rowData");
    e && this.setRowData(e);
  }
  ensureRowHeightsValid(e, t, i, r) {
    let n, s = !1;
    do {
      n = !1;
      const a = this.getRowIndexAtPixel(e), l = this.getRowIndexAtPixel(t), c = Math.max(a, i), d = Math.min(l, r);
      for (let u = c; u <= d; u++) {
        const h = this.getRow(u);
        if (h.rowHeightEstimated) {
          const p = this.gridOptionsService.getRowHeightForNode(h);
          h.setRowHeight(p.height), n = !0, s = !0;
        }
      }
      n && this.setRowTopAndRowIndex();
    } while (n);
    return s;
  }
  setRowTopAndRowIndex() {
    const e = this.environment.getDefaultRowHeight();
    let t = 0;
    const i = /* @__PURE__ */ new Set(), r = this.gridOptionsService.isDomLayout("normal");
    for (let n = 0; n < this.rowsToDisplay.length; n++) {
      const s = this.rowsToDisplay[n];
      if (s.id != null && i.add(s.id), s.rowHeight == null) {
        const a = this.gridOptionsService.getRowHeightForNode(s, r, e);
        s.setRowHeight(a.height, a.estimated);
      }
      s.setRowTop(t), s.setRowIndex(n), t += s.rowHeight;
    }
    return i;
  }
  clearRowTopAndRowIndex(e, t) {
    const i = e.isActive(), r = (s) => {
      s && s.id != null && !t.has(s.id) && s.clearRowTopAndRowIndex();
    }, n = (s) => {
      if (r(s), r(s.detailNode), r(s.sibling), s.hasChildren() && s.childrenAfterGroup) {
        const a = s.level == -1;
        i && !a && !s.expanded || s.childrenAfterGroup.forEach(n);
      }
    };
    n(this.rootNode);
  }
  // returns false if row was moved, otherwise true
  ensureRowsAtPixel(e, t, i = 0) {
    const r = this.getRowIndexAtPixel(t), n = this.getRow(r), s = !this.gridOptionsService.is("suppressAnimationFrame");
    return n === e[0] ? !1 : (e.forEach((a) => {
      x.removeFromArray(this.rootNode.allLeafChildren, a);
    }), e.forEach((a, l) => {
      x.insertIntoArray(this.rootNode.allLeafChildren, a, Math.max(r + i, 0) + l);
    }), this.refreshModel({
      step: ot.EVERYTHING,
      keepRenderedRows: !0,
      keepEditingRows: !0,
      animate: s
    }), !0);
  }
  highlightRowAtPixel(e, t) {
    const i = t != null ? this.getRowIndexAtPixel(t) : null, r = i != null ? this.getRow(i) : null;
    if (!r || !e || r === e || t == null) {
      this.lastHighlightedRow && (this.lastHighlightedRow.setHighlighted(null), this.lastHighlightedRow = null);
      return;
    }
    const n = this.getHighlightPosition(t, r);
    this.lastHighlightedRow && this.lastHighlightedRow !== r && (this.lastHighlightedRow.setHighlighted(null), this.lastHighlightedRow = null), r.setHighlighted(n), this.lastHighlightedRow = r;
  }
  getHighlightPosition(e, t) {
    if (!t) {
      const n = this.getRowIndexAtPixel(e);
      if (t = this.getRow(n || 0), !t)
        return ms.Below;
    }
    const { rowTop: i, rowHeight: r } = t;
    return e - i < r / 2 ? ms.Above : ms.Below;
  }
  getLastHighlightedRowNode() {
    return this.lastHighlightedRow;
  }
  isLastRowIndexKnown() {
    return !0;
  }
  getRowCount() {
    return this.rowsToDisplay ? this.rowsToDisplay.length : 0;
  }
  getTopLevelRowCount() {
    if (this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode)
      return 1;
    const t = this.rootNode.childrenAfterAggFilter;
    return t ? t.length : 0;
  }
  getTopLevelRowDisplayedIndex(e) {
    if (this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode)
      return e;
    let i = this.rootNode.childrenAfterSort[e];
    if (this.gridOptionsService.is("groupHideOpenParents"))
      for (; i.expanded && i.childrenAfterSort && i.childrenAfterSort.length > 0; )
        i = i.childrenAfterSort[0];
    return i.rowIndex;
  }
  getRowBounds(e) {
    if (x.missing(this.rowsToDisplay))
      return null;
    const t = this.rowsToDisplay[e];
    return t ? {
      rowTop: t.rowTop,
      rowHeight: t.rowHeight
    } : null;
  }
  onRowGroupOpened() {
    const e = this.gridOptionsService.isAnimateRows();
    this.refreshModel({ step: ot.MAP, keepRenderedRows: !0, animate: e });
  }
  onFilterChanged(e) {
    if (e.afterDataChange)
      return;
    const t = this.gridOptionsService.isAnimateRows(), r = e.columns.length === 0 || e.columns.some((n) => n.isPrimary()) ? ot.FILTER : ot.FILTER_AGGREGATES;
    this.refreshModel({ step: r, keepRenderedRows: !0, animate: t });
  }
  onSortChanged() {
    const e = this.gridOptionsService.isAnimateRows();
    this.refreshModel({ step: ot.SORT, keepRenderedRows: !0, animate: e, keepEditingRows: !0 });
  }
  getType() {
    return "clientSide";
  }
  onValueChanged() {
    this.columnModel.isPivotActive() ? this.refreshModel({ step: ot.PIVOT }) : this.refreshModel({ step: ot.AGGREGATE });
  }
  createChangePath(e) {
    const t = x.missingOrEmpty(e), i = new dm(!1, this.rootNode);
    return (t || this.gridOptionsService.isTreeData()) && i.setInactive(), i;
  }
  isSuppressModelUpdateAfterUpdateTransaction(e) {
    if (!this.gridOptionsService.is("suppressModelUpdateAfterUpdateTransaction") || e.rowNodeTransactions == null)
      return !1;
    const t = e.rowNodeTransactions.filter((r) => r.add != null && r.add.length > 0 || r.remove != null && r.remove.length > 0);
    return t == null || t.length == 0;
  }
  buildRefreshModelParams(e) {
    let t = ot.EVERYTHING;
    const i = {
      everything: ot.EVERYTHING,
      group: ot.EVERYTHING,
      filter: ot.FILTER,
      map: ot.MAP,
      aggregate: ot.AGGREGATE,
      sort: ot.SORT,
      pivot: ot.PIVOT
    };
    if (x.exists(e) && (t = i[e]), x.missing(t)) {
      console.error(`AG Grid: invalid step ${e}, available steps are ${Object.keys(i).join(", ")}`);
      return;
    }
    const r = !this.gridOptionsService.is("suppressAnimationFrame");
    return {
      step: t,
      keepRenderedRows: !0,
      keepEditingRows: !0,
      animate: r
    };
  }
  refreshModel(e) {
    let t = typeof e == "object" && "step" in e ? e : this.buildRefreshModelParams(e);
    if (!t || this.isSuppressModelUpdateAfterUpdateTransaction(t))
      return;
    const i = this.createChangePath(t.rowNodeTransactions);
    switch (t.step) {
      case ot.EVERYTHING:
        this.doRowGrouping(t.groupState, t.rowNodeTransactions, t.rowNodeOrder, i, !!t.afterColumnsChanged);
      case ot.FILTER:
        this.doFilter(i);
      case ot.PIVOT:
        this.doPivot(i);
      case ot.AGGREGATE:
        this.doAggregate(i);
      case ot.FILTER_AGGREGATES:
        this.doFilterAggregates(i);
      case ot.SORT:
        this.doSort(t.rowNodeTransactions, i);
      case ot.MAP:
        this.doRowsToDisplay();
    }
    const r = this.setRowTopAndRowIndex();
    this.clearRowTopAndRowIndex(i, r);
    const n = {
      type: w.EVENT_MODEL_UPDATED,
      animate: t.animate,
      keepRenderedRows: t.keepRenderedRows,
      newData: t.newData,
      newPage: !1,
      keepUndoRedoStack: t.keepUndoRedoStack
    };
    this.eventService.dispatchEvent(n);
  }
  isEmpty() {
    const e = x.missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;
    return x.missing(this.rootNode) || e || !this.columnModel.isReady();
  }
  isRowsToRender() {
    return x.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;
  }
  getNodesInRangeForSelection(e, t) {
    let i = !t, r = !1;
    const n = [], s = this.gridOptionsService.is("groupSelectsChildren");
    return this.forEachNodeAfterFilterAndSort((a) => {
      if (r)
        return;
      if (i && (a === t || a === e) && (r = !0, a.group && s)) {
        n.push(...a.allLeafChildren);
        return;
      }
      if (!i) {
        if (a !== t && a !== e)
          return;
        i = !0;
      }
      if (!a.group || !s) {
        n.push(a);
        return;
      }
    }), n;
  }
  setDatasource(e) {
    console.error("AG Grid: should never call setDatasource on clientSideRowController");
  }
  getTopLevelNodes() {
    return this.rootNode ? this.rootNode.childrenAfterGroup : null;
  }
  getRootNode() {
    return this.rootNode;
  }
  getRow(e) {
    return this.rowsToDisplay[e];
  }
  isRowPresent(e) {
    return this.rowsToDisplay.indexOf(e) >= 0;
  }
  getRowIndexAtPixel(e) {
    if (this.isEmpty() || this.rowsToDisplay.length === 0)
      return -1;
    let t = 0, i = this.rowsToDisplay.length - 1;
    if (e <= 0)
      return 0;
    if (x.last(this.rowsToDisplay).rowTop <= e)
      return this.rowsToDisplay.length - 1;
    let n = -1, s = -1;
    for (; ; ) {
      const a = Math.floor((t + i) / 2), l = this.rowsToDisplay[a];
      if (this.isRowInPixel(l, e) || (l.rowTop < e ? t = a + 1 : l.rowTop > e && (i = a - 1), n === t && s === i))
        return a;
      n = t, s = i;
    }
  }
  isRowInPixel(e, t) {
    const i = e.rowTop, r = e.rowTop + e.rowHeight;
    return i <= t && r > t;
  }
  forEachLeafNode(e) {
    this.rootNode.allLeafChildren && this.rootNode.allLeafChildren.forEach((t, i) => e(t, i));
  }
  forEachNode(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterGroup || []],
      callback: e,
      recursionType: uo.Normal,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachNodeAfterFilter(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterAggFilter || []],
      callback: e,
      recursionType: uo.AfterFilter,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachNodeAfterFilterAndSort(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterSort || []],
      callback: e,
      recursionType: uo.AfterFilterAndSort,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachPivotNode(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [this.rootNode],
      callback: e,
      recursionType: uo.PivotNodes,
      index: 0,
      includeFooterNodes: t
    });
  }
  // iterates through each item in memory, and calls the callback function
  // nodes - the rowNodes to traverse
  // callback - the user provided callback
  // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc
  // index - works similar to the index in forEach in javascript's array function
  recursivelyWalkNodesAndCallback(e) {
    var t;
    const { nodes: i, callback: r, recursionType: n, includeFooterNodes: s } = e;
    let { index: a } = e;
    const l = i[0];
    s && (!((t = l == null ? void 0 : l.parent) === null || t === void 0) && t.sibling) && i.push(l.parent.sibling);
    for (let c = 0; c < i.length; c++) {
      const d = i[c];
      if (r(d, a++), d.hasChildren() && !d.footer) {
        let u = null;
        switch (n) {
          case uo.Normal:
            u = d.childrenAfterGroup;
            break;
          case uo.AfterFilter:
            u = d.childrenAfterAggFilter;
            break;
          case uo.AfterFilterAndSort:
            u = d.childrenAfterSort;
            break;
          case uo.PivotNodes:
            u = d.leafGroup ? null : d.childrenAfterSort;
            break;
        }
        u && (a = this.recursivelyWalkNodesAndCallback({
          nodes: [...u],
          callback: r,
          recursionType: n,
          index: a,
          includeFooterNodes: s
        }));
      }
    }
    return a;
  }
  // it's possible to recompute the aggregate without doing the other parts
  // + api.refreshClientSideRowModel('aggregate')
  doAggregate(e) {
    this.aggregationStage && this.aggregationStage.execute({ rowNode: this.rootNode, changedPath: e });
  }
  doFilterAggregates(e) {
    this.filterAggregatesStage ? this.filterAggregatesStage.execute({ rowNode: this.rootNode, changedPath: e }) : this.rootNode.childrenAfterAggFilter = this.rootNode.childrenAfterFilter;
  }
  // + gridApi.expandAll()
  // + gridApi.collapseAll()
  expandOrCollapseAll(e) {
    const t = this.gridOptionsService.isTreeData(), i = this.columnModel.isPivotActive(), r = (a) => {
      a && a.forEach((l) => {
        const c = () => {
          l.expanded = e, r(l.childrenAfterGroup);
        };
        if (t) {
          x.exists(l.childrenAfterGroup) && c();
          return;
        }
        if (i) {
          !l.leafGroup && c();
          return;
        }
        l.group && c();
      });
    };
    this.rootNode && r(this.rootNode.childrenAfterGroup), this.refreshModel({ step: ot.MAP });
    const n = e ? "expandAll" : "collapseAll", s = {
      type: w.EVENT_EXPAND_COLLAPSE_ALL,
      source: n
    };
    this.eventService.dispatchEvent(s);
  }
  doSort(e, t) {
    this.sortStage.execute({
      rowNode: this.rootNode,
      rowNodeTransactions: e,
      changedPath: t
    });
  }
  doRowGrouping(e, t, i, r, n) {
    if (this.groupStage) {
      if (t ? this.groupStage.execute({
        rowNode: this.rootNode,
        rowNodeTransactions: t,
        rowNodeOrder: i,
        changedPath: r
      }) : (this.groupStage.execute({
        rowNode: this.rootNode,
        changedPath: r,
        afterColumnsChanged: n
      }), this.restoreGroupState(e)), this.gridOptionsService.is("groupSelectsChildren") && this.selectionService.updateGroupsFromChildrenSelections("rowGroupChanged", r)) {
        const a = {
          type: w.EVENT_SELECTION_CHANGED,
          source: "rowGroupChanged"
        };
        this.eventService.dispatchEvent(a);
      }
    } else
      this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren, this.rootNode.sibling && (this.rootNode.sibling.childrenAfterGroup = this.rootNode.childrenAfterGroup), this.rootNode.updateHasChildren();
  }
  restoreGroupState(e) {
    e && x.traverseNodesWithKey(this.rootNode.childrenAfterGroup, (t, i) => {
      typeof e[i] == "boolean" && (t.expanded = e[i]);
    });
  }
  doFilter(e) {
    this.filterStage.execute({ rowNode: this.rootNode, changedPath: e });
  }
  doPivot(e) {
    this.pivotStage && this.pivotStage.execute({ rowNode: this.rootNode, changedPath: e });
  }
  getGroupState() {
    if (!this.rootNode.childrenAfterGroup || !this.gridOptionsService.is("rememberGroupStateWhenNewData"))
      return null;
    const e = {};
    return x.traverseNodesWithKey(this.rootNode.childrenAfterGroup, (t, i) => e[i] = t.expanded), e;
  }
  getCopyOfNodesMap() {
    return this.nodeManager.getCopyOfNodesMap();
  }
  getRowNode(e) {
    if (typeof e == "string" && e.indexOf(re.ID_PREFIX_ROW_GROUP) == 0) {
      let i;
      return this.forEachNode((r) => {
        r.id === e && (i = r);
      }), i;
    }
    return this.nodeManager.getRowNode(e);
  }
  // rows: the rows to put into the model
  setRowData(e) {
    const t = this.getGroupState();
    this.nodeManager.setRowData(e), this.selectionService.reset(), this.filterManager.onNewRowsLoaded("rowDataUpdated");
    const i = {
      type: w.EVENT_ROW_DATA_UPDATED
    };
    this.eventService.dispatchEvent(i), this.refreshModel({
      step: ot.EVERYTHING,
      groupState: t,
      newData: !0
    });
  }
  batchUpdateRowData(e, t) {
    if (this.applyAsyncTransactionsTimeout == null) {
      this.rowDataTransactionBatch = [];
      const i = this.gridOptionsService.getAsyncTransactionWaitMillis();
      this.applyAsyncTransactionsTimeout = window.setTimeout(() => {
        this.executeBatchUpdateRowData();
      }, i);
    }
    this.rowDataTransactionBatch.push({ rowDataTransaction: e, callback: t });
  }
  flushAsyncTransactions() {
    this.applyAsyncTransactionsTimeout != null && (clearTimeout(this.applyAsyncTransactionsTimeout), this.executeBatchUpdateRowData());
  }
  executeBatchUpdateRowData() {
    this.valueCache.onDataChanged();
    const e = [], t = [];
    let i = !1;
    if (this.rowDataTransactionBatch && this.rowDataTransactionBatch.forEach((r) => {
      const n = this.nodeManager.updateRowData(r.rowDataTransaction, void 0);
      t.push(n), r.callback && e.push(r.callback.bind(null, n)), typeof r.rowDataTransaction.addIndex == "number" && (i = !0);
    }), this.commonUpdateRowData(t, void 0, i), e.length > 0 && window.setTimeout(() => {
      e.forEach((r) => r());
    }, 0), t.length > 0) {
      const r = {
        type: w.EVENT_ASYNC_TRANSACTIONS_FLUSHED,
        results: t
      };
      this.eventService.dispatchEvent(r);
    }
    this.rowDataTransactionBatch = null, this.applyAsyncTransactionsTimeout = void 0;
  }
  updateRowData(e, t) {
    this.valueCache.onDataChanged();
    const i = this.nodeManager.updateRowData(e, t), r = typeof e.addIndex == "number";
    return this.commonUpdateRowData([i], t, r), i;
  }
  createRowNodeOrder() {
    if (this.gridOptionsService.is("suppressMaintainUnsortedOrder"))
      return;
    const t = {};
    if (this.rootNode && this.rootNode.allLeafChildren)
      for (let i = 0; i < this.rootNode.allLeafChildren.length; i++) {
        const r = this.rootNode.allLeafChildren[i];
        t[r.id] = i;
      }
    return t;
  }
  // common to updateRowData and batchUpdateRowData
  commonUpdateRowData(e, t, i) {
    const r = !this.gridOptionsService.is("suppressAnimationFrame");
    i && (t = this.createRowNodeOrder()), this.refreshModel({
      step: ot.EVERYTHING,
      rowNodeTransactions: e,
      rowNodeOrder: t,
      keepRenderedRows: !0,
      keepEditingRows: !0,
      animate: r
    }), this.filterManager.onNewRowsLoaded("rowDataUpdated");
    const n = {
      type: w.EVENT_ROW_DATA_UPDATED
    };
    this.eventService.dispatchEvent(n);
  }
  doRowsToDisplay() {
    this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode });
  }
  onRowHeightChanged() {
    this.refreshModel({ step: ot.MAP, keepRenderedRows: !0, keepEditingRows: !0, keepUndoRedoStack: !0 });
  }
  /** This method is debounced. It is used for row auto-height. If we don't debounce,
   * then the Row Models will end up recalculating each row position
   * for each row height change and result in the Row Renderer laying out rows.
   * This is particularly bad if using print layout, and showing eg 1,000 rows,
   * each row will change it's height, causing Row Model to update 1,000 times.
   */
  onRowHeightChangedDebounced() {
    this.onRowHeightChanged_debounced();
  }
  resetRowHeights() {
    const e = this.resetRowHeightsForAllRowNodes();
    this.rootNode.setRowHeight(this.rootNode.rowHeight, !0), e && this.onRowHeightChanged();
  }
  resetRowHeightsForAllRowNodes() {
    let e = !1;
    return this.forEachNode((t) => {
      t.setRowHeight(t.rowHeight, !0);
      const i = t.detailNode;
      i && i.setRowHeight(i.rowHeight, !0), e = !0;
    }), e;
  }
  onGridStylesChanges() {
    this.columnModel.isAutoRowHeightActive() || this.resetRowHeights();
  }
};
lr([
  S("columnModel")
], Hi.prototype, "columnModel", void 0);
lr([
  S("selectionService")
], Hi.prototype, "selectionService", void 0);
lr([
  S("filterManager")
], Hi.prototype, "filterManager", void 0);
lr([
  S("valueCache")
], Hi.prototype, "valueCache", void 0);
lr([
  S("beans")
], Hi.prototype, "beans", void 0);
lr([
  S("filterStage")
], Hi.prototype, "filterStage", void 0);
lr([
  S("sortStage")
], Hi.prototype, "sortStage", void 0);
lr([
  S("flattenStage")
], Hi.prototype, "flattenStage", void 0);
lr([
  Ve("groupStage")
], Hi.prototype, "groupStage", void 0);
lr([
  Ve("aggregationStage")
], Hi.prototype, "aggregationStage", void 0);
lr([
  Ve("pivotStage")
], Hi.prototype, "pivotStage", void 0);
lr([
  Ve("filterAggregatesStage")
], Hi.prototype, "filterAggregatesStage", void 0);
lr([
  B
], Hi.prototype, "init", null);
Hi = lr([
  q("rowModel")
], Hi);
var Ix = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Hg = class extends H {
  execute(e) {
    const { changedPath: t } = e;
    this.filterService.filter(t);
  }
};
Ix([
  S("filterService")
], Hg.prototype, "filterService", void 0);
Hg = Ix([
  q("filterStage")
], Hg);
var ym = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let jd = class extends H {
  execute(e) {
    const t = this.sortController.getSortOptions(), i = x.exists(t) && t.length > 0, r = i && x.exists(e.rowNodeTransactions) && this.gridOptionsService.is("deltaSort"), n = t.some((s) => !!this.columnModel.getGroupDisplayColumnForGroup(s.column.getId()));
    this.sortService.sort(t, i, r, e.rowNodeTransactions, e.changedPath, n);
  }
};
ym([
  S("sortService")
], jd.prototype, "sortService", void 0);
ym([
  S("sortController")
], jd.prototype, "sortController", void 0);
ym([
  S("columnModel")
], jd.prototype, "columnModel", void 0);
jd = ym([
  q("sortStage")
], jd);
var Fb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let np = class extends H {
  execute(e) {
    const t = e.rowNode, i = [], r = { value: 0 }, n = this.columnModel.isPivotMode(), s = n && t.leafGroup, a = s ? [t] : t.childrenAfterSort;
    this.recursivelyAddToRowsToDisplay(a, i, r, n, 0);
    const l = i.length > 0;
    return !s && l && this.gridOptionsService.is("groupIncludeTotalFooter") && (t.createFooter(), this.addRowNodeToRowsToDisplay(t.sibling, i, r, 0)), i;
  }
  recursivelyAddToRowsToDisplay(e, t, i, r, n) {
    if (x.missingOrEmpty(e))
      return;
    const s = this.gridOptionsService.is("groupHideOpenParents"), a = this.gridOptionsService.is("groupRemoveSingleChildren"), l = !a && this.gridOptionsService.is("groupRemoveLowestSingleChildren");
    for (let c = 0; c < e.length; c++) {
      const d = e[c], u = d.hasChildren(), h = r && !u, p = a && u && d.childrenAfterGroup.length === 1, f = l && u && d.leafGroup && d.childrenAfterGroup.length === 1, g = r && d.leafGroup, v = s && d.expanded && !d.master && !g;
      if (!h && !v && !p && !f && this.addRowNodeToRowsToDisplay(d, t, i, n), !(r && d.leafGroup)) {
        if (u) {
          const m = p || f;
          if (d.expanded || m) {
            const C = m ? n : n + 1;
            this.recursivelyAddToRowsToDisplay(d.childrenAfterSort, t, i, r, C), this.gridOptionsService.is("groupIncludeFooter") && this.addRowNodeToRowsToDisplay(d.sibling, t, i, C);
          }
        } else if (d.master && d.expanded) {
          const m = this.createDetailNode(d);
          this.addRowNodeToRowsToDisplay(m, t, i, n);
        }
      }
    }
  }
  // duplicated method, it's also in floatingRowModel
  addRowNodeToRowsToDisplay(e, t, i, r) {
    const n = this.gridOptionsService.isGroupMultiAutoColumn();
    t.push(e), e.setUiLevel(n ? 0 : r);
  }
  createDetailNode(e) {
    if (x.exists(e.detailNode))
      return e.detailNode;
    const t = new re(this.beans);
    return t.detail = !0, t.selectable = !1, t.parent = e, x.exists(e.id) && (t.id = "detail_" + e.id), t.data = e.data, t.level = e.level + 1, e.detailNode = t, t;
  }
};
Fb([
  S("columnModel")
], np.prototype, "columnModel", void 0);
Fb([
  S("beans")
], np.prototype, "beans", void 0);
np = Fb([
  q("flattenStage")
], np);
var Cm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Ud = class extends H {
  init() {
    this.postSortFunc = this.gridOptionsService.getCallback("postSortRows");
  }
  sort(e, t, i, r, n, s) {
    const a = this.gridOptionsService.is("groupMaintainOrder"), l = this.columnModel.getAllGridColumns().some((h) => h.isRowGroupActive());
    let c = {};
    i && r && (c = this.calculateDirtyNodes(r));
    const d = this.columnModel.isPivotMode(), u = (h) => {
      this.pullDownGroupDataForHideOpenParents(h.childrenAfterAggFilter, !0);
      const p = d && h.leafGroup;
      if (a && l && !h.leafGroup && !s) {
        const g = h.childrenAfterAggFilter.slice(0);
        if (h.childrenAfterSort) {
          const v = {};
          h.childrenAfterSort.forEach((y, m) => {
            v[y.id] = m;
          }), g.sort((y, m) => {
            var C, R;
            return ((C = v[y.id]) !== null && C !== void 0 ? C : 0) - ((R = v[m.id]) !== null && R !== void 0 ? R : 0);
          });
        }
        h.childrenAfterSort = g;
      } else
        !t || p ? h.childrenAfterSort = h.childrenAfterAggFilter.slice(0) : i ? h.childrenAfterSort = this.doDeltaSort(h, c, n, e) : h.childrenAfterSort = this.rowNodeSorter.doFullSort(h.childrenAfterAggFilter, e);
      if (h.sibling && (h.sibling.childrenAfterSort = h.childrenAfterSort), this.updateChildIndexes(h), this.postSortFunc) {
        const g = { nodes: h.childrenAfterSort };
        this.postSortFunc(g);
      }
    };
    n && n.forEachChangedNodeDepthFirst(u), this.updateGroupDataForHideOpenParents(n);
  }
  calculateDirtyNodes(e) {
    const t = {}, i = (r) => {
      r && r.forEach((n) => t[n.id] = !0);
    };
    return e && e.forEach((r) => {
      i(r.add), i(r.update), i(r.remove);
    }), t;
  }
  doDeltaSort(e, t, i, r) {
    const n = e.childrenAfterAggFilter, s = e.childrenAfterSort;
    if (!s)
      return this.rowNodeSorter.doFullSort(n, r);
    const a = {}, l = [];
    n.forEach((h) => {
      t[h.id] || !i.canSkip(h) ? l.push(h) : a[h.id] = !0;
    });
    const c = s.filter((h) => a[h.id]), d = (h, p) => ({ currentPos: p, rowNode: h }), u = l.map(d).sort((h, p) => this.rowNodeSorter.compareRowNodes(r, h, p));
    return this.mergeSortedArrays(r, u, c.map(d)).map(({ rowNode: h }) => h);
  }
  // Merge two sorted arrays into each other
  mergeSortedArrays(e, t, i) {
    const r = [];
    let n = 0, s = 0;
    for (; n < t.length && s < i.length; )
      this.rowNodeSorter.compareRowNodes(e, t[n], i[s]) < 0 ? r.push(t[n++]) : r.push(i[s++]);
    for (; n < t.length; )
      r.push(t[n++]);
    for (; s < i.length; )
      r.push(i[s++]);
    return r;
  }
  updateChildIndexes(e) {
    if (x.missing(e.childrenAfterSort))
      return;
    const t = e.childrenAfterSort;
    for (let i = 0; i < t.length; i++) {
      const r = t[i], n = i === 0, s = i === e.childrenAfterSort.length - 1;
      r.setFirstChild(n), r.setLastChild(s), r.setChildIndex(i);
    }
  }
  updateGroupDataForHideOpenParents(e) {
    if (!this.gridOptionsService.is("groupHideOpenParents"))
      return;
    if (this.gridOptionsService.isTreeData()) {
      const i = "AG Grid: The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them (as opposed to Row Grouping, which only has Aggregated Values at the group level).";
      return x.doOnce(() => console.warn(i), "sortService.hideOpenParentsWithTreeData"), !1;
    }
    const t = (i) => {
      this.pullDownGroupDataForHideOpenParents(i.childrenAfterSort, !1), i.childrenAfterSort.forEach((r) => {
        r.hasChildren() && t(r);
      });
    };
    e && e.executeFromRootNode((i) => t(i));
  }
  pullDownGroupDataForHideOpenParents(e, t) {
    !this.gridOptionsService.is("groupHideOpenParents") || x.missing(e) || e.forEach((i) => {
      this.columnModel.getGroupDisplayColumns().forEach((n) => {
        const s = n.getColDef().showRowGroup;
        if (typeof s != "string") {
          console.error("AG Grid: groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup");
          return;
        }
        const a = s, l = this.columnModel.getPrimaryColumn(a);
        if (l !== i.rowGroupColumn)
          if (t)
            i.setGroupValue(n.getId(), void 0);
          else {
            const d = i.getFirstChildOfFirstChild(l);
            d && i.setGroupValue(n.getId(), d.key);
          }
      });
    });
  }
};
Cm([
  S("columnModel")
], Ud.prototype, "columnModel", void 0);
Cm([
  S("rowNodeSorter")
], Ud.prototype, "rowNodeSorter", void 0);
Cm([
  B
], Ud.prototype, "init", null);
Ud = Cm([
  q("sortService")
], Ud);
var Fx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Wg = class extends H {
  filter(e) {
    const t = this.filterManager.isColumnFilterPresent() || this.filterManager.isQuickFilterPresent() || this.filterManager.isExternalFilterPresent();
    this.filterNodes(t, e);
  }
  filterNodes(e, t) {
    const i = (r, n) => {
      r.hasChildren() && e && !n ? r.childrenAfterFilter = r.childrenAfterGroup.filter((s) => {
        const a = s.childrenAfterFilter && s.childrenAfterFilter.length > 0, l = s.data && this.filterManager.doesRowPassFilter({ rowNode: s });
        return a || l;
      }) : r.childrenAfterFilter = r.childrenAfterGroup, r.sibling && (r.sibling.childrenAfterFilter = r.childrenAfterFilter);
    };
    if (this.doingTreeDataFiltering()) {
      const r = (s, a) => {
        if (s.childrenAfterGroup)
          for (let l = 0; l < s.childrenAfterGroup.length; l++) {
            const c = s.childrenAfterGroup[l], d = a || this.filterManager.doesRowPassFilter({ rowNode: c });
            c.childrenAfterGroup ? r(s.childrenAfterGroup[l], d) : i(c, d);
          }
        i(s, a);
      }, n = (s) => r(s, !1);
      t.executeFromRootNode(n);
    } else {
      const r = (n) => i(n, !1);
      t.forEachChangedNodeDepthFirst(r, !0);
    }
  }
  doingTreeDataFiltering() {
    return this.gridOptionsService.isTreeData() && !this.gridOptionsService.is("excludeChildrenWhenTreeDataFiltering");
  }
};
Fx([
  S("filterManager")
], Wg.prototype, "filterManager", void 0);
Wg = Fx([
  q("filterService")
], Wg);
var Sm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let $d = class extends H {
  postConstruct() {
    this.rowModel.getType() === "clientSide" && (this.clientSideRowModel = this.rowModel);
  }
  isActive() {
    const e = this.gridOptionsService.exists("getRowId");
    return this.gridOptionsService.is("resetRowDataOnUpdate") ? !1 : e;
  }
  setRowData(e) {
    const t = this.createTransactionForRowData(e);
    if (!t)
      return;
    const [i, r] = t;
    this.clientSideRowModel.updateRowData(i, r);
  }
  // converts the setRowData() command to a transaction
  createTransactionForRowData(e) {
    if (x.missing(this.clientSideRowModel)) {
      console.error("AG Grid: ImmutableService only works with ClientSideRowModel");
      return;
    }
    const t = this.gridOptionsService.getCallback("getRowId");
    if (t == null) {
      console.error("AG Grid: ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!");
      return;
    }
    const i = {
      remove: [],
      update: [],
      add: []
    }, r = this.clientSideRowModel.getCopyOfNodesMap(), s = this.gridOptionsService.is("suppressMaintainUnsortedOrder") ? void 0 : {};
    return x.exists(e) && e.forEach((a, l) => {
      const c = t({ data: a, level: 0 }), d = r[c];
      s && (s[c] = l), d ? (d.data !== a && i.update.push(a), r[c] = void 0) : i.add.push(a);
    }), x.iterateObject(r, (a, l) => {
      l && i.remove.push(l.data);
    }), [i, s];
  }
};
Sm([
  S("rowModel")
], $d.prototype, "rowModel", void 0);
Sm([
  S("rowRenderer")
], $d.prototype, "rowRenderer", void 0);
Sm([
  B
], $d.prototype, "postConstruct", null);
$d = Sm([
  q("immutableService")
], $d);
const tG = "30.0.5", iG = {
  version: tG,
  moduleName: Q.ClientSideRowModelModule,
  rowModel: "clientSide",
  beans: [Hi, Hg, jd, np, Ud, Wg, $d]
};
var Lb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class op extends Gt {
  constructor(e, t, i) {
    super(e), this.parentCache = t, this.params = i, this.startRow = e * i.blockSize, this.endRow = this.startRow + i.blockSize;
  }
  postConstruct() {
    this.createRowNodes();
  }
  getBlockStateJson() {
    return {
      id: "" + this.getId(),
      state: {
        blockNumber: this.getId(),
        startRow: this.getStartRow(),
        endRow: this.getEndRow(),
        pageStatus: this.getState()
      }
    };
  }
  setDataAndId(e, t, i) {
    x.exists(t) ? e.setDataAndId(t, i.toString()) : e.setDataAndId(void 0, void 0);
  }
  loadFromDatasource() {
    const e = this.createLoadParams();
    if (x.missing(this.params.datasource.getRows)) {
      console.warn("AG Grid: datasource is missing getRows method");
      return;
    }
    window.setTimeout(() => {
      this.params.datasource.getRows(e);
    }, 0);
  }
  processServerFail() {
  }
  createLoadParams() {
    return {
      startRow: this.getStartRow(),
      endRow: this.getEndRow(),
      successCallback: this.pageLoaded.bind(this, this.getVersion()),
      failCallback: this.pageLoadFailed.bind(this, this.getVersion()),
      sortModel: this.params.sortModel,
      filterModel: this.params.filterModel,
      context: this.gridOptionsService.context
    };
  }
  forEachNode(e, t, i) {
    this.rowNodes.forEach((r, n) => {
      this.startRow + n < i && e(r, t.next());
    });
  }
  getLastAccessed() {
    return this.lastAccessed;
  }
  getRow(e, t = !1) {
    t || (this.lastAccessed = this.params.lastAccessedSequence.next());
    const i = e - this.startRow;
    return this.rowNodes[i];
  }
  getStartRow() {
    return this.startRow;
  }
  getEndRow() {
    return this.endRow;
  }
  // creates empty row nodes, data is missing as not loaded yet
  createRowNodes() {
    this.rowNodes = [];
    for (let e = 0; e < this.params.blockSize; e++) {
      const t = this.startRow + e, i = new re(this.beans);
      i.setRowHeight(this.params.rowHeight), i.uiLevel = 0, i.setRowIndex(t), i.setRowTop(this.params.rowHeight * t), this.rowNodes.push(i);
    }
  }
  processServerResult(e) {
    this.rowNodes.forEach((i, r) => {
      const n = e.rowData ? e.rowData[r] : void 0;
      !i.id && i.alreadyRendered && n && (this.rowNodes[r] = new re(this.beans), this.rowNodes[r].setRowIndex(i.rowIndex), this.rowNodes[r].setRowTop(i.rowTop), i.clearRowTopAndRowIndex()), this.setDataAndId(this.rowNodes[r], n, this.startRow + r);
    });
    const t = e.rowCount != null && e.rowCount >= 0 ? e.rowCount : void 0;
    this.parentCache.pageLoaded(this, t);
  }
  destroyRowNodes() {
    this.rowNodes.forEach((e) => {
      e.clearRowTopAndRowIndex();
    });
  }
}
Lb([
  S("beans")
], op.prototype, "beans", void 0);
Lb([
  B
], op.prototype, "postConstruct", null);
Lb([
  dt
], op.prototype, "destroyRowNodes", null);
var bm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, rG = function(o, e) {
  return function(t, i) {
    e(t, i, o);
  };
};
class ja extends H {
  constructor(e) {
    super(), this.lastRowIndexKnown = !1, this.blocks = {}, this.blockCount = 0, this.rowCount = e.initialRowCount, this.params = e;
  }
  setBeans(e) {
    this.logger = e.create("InfiniteCache");
  }
  // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,
  // it will want new pages in the cache as it asks for rows. only when we are inserting /
  // removing rows via the api is dontCreatePage set, where we move rows between the pages.
  getRow(e, t = !1) {
    const i = Math.floor(e / this.params.blockSize);
    let r = this.blocks[i];
    if (!r) {
      if (t)
        return;
      r = this.createBlock(i);
    }
    return r.getRow(e);
  }
  createBlock(e) {
    const t = this.createBean(new op(e, this, this.params));
    return this.blocks[t.getId()] = t, this.blockCount++, this.purgeBlocksIfNeeded(t), this.params.rowNodeBlockLoader.addBlock(t), t;
  }
  // we have this on infinite row model only, not server side row model,
  // because for server side, it would leave the children in inconsistent
  // state - eg if a node had children, but after the refresh it had data
  // for a different row, then the children would be with the wrong row node.
  refreshCache() {
    if (this.blockCount == 0) {
      this.purgeCache();
      return;
    }
    this.getBlocksInOrder().forEach((t) => t.setStateWaitingToLoad()), this.params.rowNodeBlockLoader.checkBlockToLoad();
  }
  destroyAllBlocks() {
    this.getBlocksInOrder().forEach((e) => this.destroyBlock(e));
  }
  getRowCount() {
    return this.rowCount;
  }
  isLastRowIndexKnown() {
    return this.lastRowIndexKnown;
  }
  // block calls this, when page loaded
  pageLoaded(e, t) {
    this.isAlive() && (this.logger.log(`onPageLoaded: page = ${e.getId()}, lastRow = ${t}`), this.checkRowCount(e, t), this.onCacheUpdated());
  }
  purgeBlocksIfNeeded(e) {
    const t = this.getBlocksInOrder().filter((a) => a != e), i = (a, l) => l.getLastAccessed() - a.getLastAccessed();
    t.sort(i);
    const r = this.params.maxBlocksInCache > 0, n = r ? this.params.maxBlocksInCache - 1 : null, s = ja.MAX_EMPTY_BLOCKS_TO_KEEP - 1;
    t.forEach((a, l) => {
      const c = a.getState() === op.STATE_WAITING_TO_LOAD && l >= s, d = r ? l >= n : !1;
      if (c || d) {
        if (this.isBlockCurrentlyDisplayed(a) || this.isBlockFocused(a))
          return;
        this.removeBlockFromCache(a);
      }
    });
  }
  isBlockFocused(e) {
    const t = this.focusService.getFocusCellToUseAfterRefresh();
    if (!t || t.rowPinned != null)
      return !1;
    const i = e.getStartRow(), r = e.getEndRow();
    return t.rowIndex >= i && t.rowIndex < r;
  }
  isBlockCurrentlyDisplayed(e) {
    const t = e.getStartRow(), i = e.getEndRow() - 1;
    return this.rowRenderer.isRangeInRenderedViewport(t, i);
  }
  removeBlockFromCache(e) {
    e && this.destroyBlock(e);
  }
  checkRowCount(e, t) {
    if (typeof t == "number" && t >= 0)
      this.rowCount = t, this.lastRowIndexKnown = !0;
    else if (!this.lastRowIndexKnown) {
      const r = (e.getId() + 1) * this.params.blockSize + this.params.overflowSize;
      this.rowCount < r && (this.rowCount = r);
    }
  }
  setRowCount(e, t) {
    this.rowCount = e, x.exists(t) && (this.lastRowIndexKnown = t), this.lastRowIndexKnown || this.rowCount % this.params.blockSize === 0 && this.rowCount++, this.onCacheUpdated();
  }
  forEachNodeDeep(e) {
    const t = new Ei();
    this.getBlocksInOrder().forEach((i) => i.forEachNode(e, t, this.rowCount));
  }
  getBlocksInOrder() {
    const e = (i, r) => i.getId() - r.getId();
    return x.getAllValuesInObject(this.blocks).sort(e);
  }
  destroyBlock(e) {
    delete this.blocks[e.getId()], this.destroyBean(e), this.blockCount--, this.params.rowNodeBlockLoader.removeBlock(e);
  }
  // gets called 1) row count changed 2) cache purged 3) items inserted
  onCacheUpdated() {
    if (this.isAlive()) {
      this.destroyAllBlocksPastVirtualRowCount();
      const e = {
        type: w.EVENT_STORE_UPDATED
      };
      this.eventService.dispatchEvent(e);
    }
  }
  destroyAllBlocksPastVirtualRowCount() {
    const e = [];
    this.getBlocksInOrder().forEach((t) => {
      t.getId() * this.params.blockSize >= this.rowCount && e.push(t);
    }), e.length > 0 && e.forEach((t) => this.destroyBlock(t));
  }
  purgeCache() {
    this.getBlocksInOrder().forEach((e) => this.removeBlockFromCache(e)), this.lastRowIndexKnown = !1, this.rowCount === 0 && (this.rowCount = this.params.initialRowCount), this.onCacheUpdated();
  }
  getRowNodesInRange(e, t) {
    const i = [];
    let r = -1, n = !1;
    const s = new Ei();
    x.missing(e) && (n = !0);
    let a = !1;
    return this.getBlocksInOrder().forEach((c) => {
      if (!a) {
        if (n && r + 1 !== c.getId()) {
          a = !0;
          return;
        }
        r = c.getId(), c.forEachNode((d) => {
          const u = d === e || d === t;
          (n || u) && i.push(d), u && (n = !n);
        }, s, this.rowCount);
      }
    }), a || n ? [] : i;
  }
}
ja.MAX_EMPTY_BLOCKS_TO_KEEP = 2;
bm([
  S("rowRenderer")
], ja.prototype, "rowRenderer", void 0);
bm([
  S("focusService")
], ja.prototype, "focusService", void 0);
bm([
  rG(0, qi("loggerFactory"))
], ja.prototype, "setBeans", null);
bm([
  dt
], ja.prototype, "destroyAllBlocks", null);
var Ua = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Ao = class extends H {
  getRowBounds(e) {
    return {
      rowHeight: this.rowHeight,
      rowTop: this.rowHeight * e
    };
  }
  // we don't implement as lazy row heights is not supported in this row model
  ensureRowHeightsValid(e, t, i, r) {
    return !1;
  }
  init() {
    this.gridOptionsService.isRowModelType("infinite") && (this.rowHeight = this.gridOptionsService.getRowHeightAsNumber(), this.addEventListeners(), this.addDestroyFunc(() => this.destroyCache()), this.verifyProps());
  }
  verifyProps() {
    if (this.gridOptionsService.exists("initialGroupOrderComparator")) {
      const e = "AG Grid: initialGroupOrderComparator cannot be used with Infinite Row Model. If using Infinite Row Model, then sorting is done on the server side, nothing to do with the client.";
      x.doOnce(() => console.warn(e), "IRM.InitialGroupOrderComparator");
    }
  }
  start() {
    this.setDatasource(this.gridOptionsService.get("datasource"));
  }
  destroyDatasource() {
    this.datasource && (this.getContext().destroyBean(this.datasource), this.rowRenderer.datasourceChanged(), this.datasource = null);
  }
  addEventListeners() {
    this.addManagedListener(this.eventService, w.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_SORT_CHANGED, this.onSortChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverything.bind(this)), this.addManagedListener(this.eventService, w.EVENT_STORE_UPDATED, this.onCacheUpdated.bind(this));
  }
  onFilterChanged() {
    this.reset();
  }
  onSortChanged() {
    this.reset();
  }
  onColumnEverything() {
    let e;
    this.cacheParams ? e = this.isSortModelDifferent() : e = !0, e && this.reset();
  }
  isSortModelDifferent() {
    return !x.jsonEquals(this.cacheParams.sortModel, this.sortController.getSortModel());
  }
  getType() {
    return "infinite";
  }
  setDatasource(e) {
    this.destroyDatasource(), this.datasource = e, e && this.reset();
  }
  isEmpty() {
    return !this.infiniteCache;
  }
  isRowsToRender() {
    return !!this.infiniteCache;
  }
  getNodesInRangeForSelection(e, t) {
    return this.infiniteCache ? this.infiniteCache.getRowNodesInRange(e, t) : [];
  }
  reset() {
    if (!this.datasource)
      return;
    this.gridOptionsService.getCallback("getRowId") != null || this.selectionService.reset(), this.resetCache();
    const i = this.createModelUpdatedEvent();
    this.eventService.dispatchEvent(i);
  }
  createModelUpdatedEvent() {
    return {
      type: w.EVENT_MODEL_UPDATED,
      // not sure if these should all be false - noticed if after implementing,
      // maybe they should be true?
      newPage: !1,
      newData: !1,
      keepRenderedRows: !0,
      animate: !1
    };
  }
  resetCache() {
    this.destroyCache(), this.cacheParams = {
      // the user provided datasource
      datasource: this.datasource,
      // sort and filter model
      filterModel: this.filterManager.getFilterModel(),
      sortModel: this.sortController.getSortModel(),
      rowNodeBlockLoader: this.rowNodeBlockLoader,
      // properties - this way we take a snapshot of them, so if user changes any, they will be
      // used next time we create a new cache, which is generally after a filter or sort change,
      // or a new datasource is set
      initialRowCount: this.defaultIfInvalid(this.gridOptionsService.getNum("infiniteInitialRowCount"), 1),
      maxBlocksInCache: this.gridOptionsService.getNum("maxBlocksInCache"),
      rowHeight: this.gridOptionsService.getRowHeightAsNumber(),
      // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past
      // the current page and request first row of next page
      overflowSize: this.defaultIfInvalid(this.gridOptionsService.getNum("cacheOverflowSize"), 1),
      // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the
      // server for one page at a time. so the default if not specified is 100.
      blockSize: this.defaultIfInvalid(this.gridOptionsService.getNum("cacheBlockSize"), 100),
      // the cache could create this, however it is also used by the pages, so handy to create it
      // here as the settings are also passed to the pages
      lastAccessedSequence: new Ei()
    }, this.infiniteCache = this.createBean(new ja(this.cacheParams));
  }
  defaultIfInvalid(e, t) {
    return e > 0 ? e : t;
  }
  destroyCache() {
    this.infiniteCache && (this.infiniteCache = this.destroyBean(this.infiniteCache));
  }
  onCacheUpdated() {
    const e = this.createModelUpdatedEvent();
    this.eventService.dispatchEvent(e);
  }
  getRow(e) {
    if (this.infiniteCache && !(e >= this.infiniteCache.getRowCount()))
      return this.infiniteCache.getRow(e);
  }
  getRowNode(e) {
    let t;
    return this.forEachNode((i) => {
      i.id === e && (t = i);
    }), t;
  }
  forEachNode(e) {
    this.infiniteCache && this.infiniteCache.forEachNodeDeep(e);
  }
  getTopLevelRowCount() {
    return this.getRowCount();
  }
  getTopLevelRowDisplayedIndex(e) {
    return e;
  }
  getRowIndexAtPixel(e) {
    if (this.rowHeight !== 0) {
      const t = Math.floor(e / this.rowHeight), i = this.getRowCount() - 1;
      return t > i ? i : t;
    }
    return 0;
  }
  getRowCount() {
    return this.infiniteCache ? this.infiniteCache.getRowCount() : 0;
  }
  isRowPresent(e) {
    return !!this.getRowNode(e.id);
  }
  refreshCache() {
    this.infiniteCache && this.infiniteCache.refreshCache();
  }
  purgeCache() {
    this.infiniteCache && this.infiniteCache.purgeCache();
  }
  // for iRowModel
  isLastRowIndexKnown() {
    return this.infiniteCache ? this.infiniteCache.isLastRowIndexKnown() : !1;
  }
  setRowCount(e, t) {
    this.infiniteCache && this.infiniteCache.setRowCount(e, t);
  }
};
Ua([
  S("filterManager")
], Ao.prototype, "filterManager", void 0);
Ua([
  S("sortController")
], Ao.prototype, "sortController", void 0);
Ua([
  S("selectionService")
], Ao.prototype, "selectionService", void 0);
Ua([
  S("rowRenderer")
], Ao.prototype, "rowRenderer", void 0);
Ua([
  S("rowNodeBlockLoader")
], Ao.prototype, "rowNodeBlockLoader", void 0);
Ua([
  B
], Ao.prototype, "init", null);
Ua([
  dt
], Ao.prototype, "destroyDatasource", null);
Ao = Ua([
  q("rowModel")
], Ao);
const nG = "30.0.5", oG = {
  version: nG,
  moduleName: Q.InfiniteRowModelModule,
  rowModel: "infinite",
  beans: [Ao]
};
class Lx {
  setBeans(e) {
    this.beans = e;
  }
  getFileName(e) {
    const t = this.getDefaultFileExtension();
    return (e == null || !e.length) && (e = this.getDefaultFileName()), e.indexOf(".") === -1 ? `${e}.${t}` : e;
  }
  getData(e) {
    const t = this.createSerializingSession(e);
    return this.beans.gridSerializer.serialize(t, e);
  }
}
class Nx {
  constructor(e) {
    this.groupColumns = [];
    const { columnModel: t, valueService: i, gridOptionsService: r, valueFormatterService: n, valueParserService: s, processCellCallback: a, processHeaderCallback: l, processGroupHeaderCallback: c, processRowGroupCallback: d } = e;
    this.columnModel = t, this.valueService = i, this.gridOptionsService = r, this.valueFormatterService = n, this.valueParserService = s, this.processCellCallback = a, this.processHeaderCallback = l, this.processGroupHeaderCallback = c, this.processRowGroupCallback = d;
  }
  prepare(e) {
    this.groupColumns = e.filter((t) => !!t.getColDef().showRowGroup);
  }
  extractHeaderValue(e) {
    const t = this.getHeaderName(this.processHeaderCallback, e);
    return t != null ? t : "";
  }
  extractRowCellValue(e, t, i, r, n) {
    const a = (!this.gridOptionsService.is("groupHideOpenParents") || n.footer) && this.shouldRenderGroupSummaryCell(n, e, t) ? this.createValueForGroupNode(n) : this.valueService.getValue(e, n);
    return this.processCell({
      accumulatedRowIndex: i,
      rowNode: n,
      column: e,
      value: a,
      processCellCallback: this.processCellCallback,
      type: r
    });
  }
  shouldRenderGroupSummaryCell(e, t, i) {
    var r;
    if (!(e && e.group))
      return !1;
    if (this.groupColumns.indexOf(t) !== -1) {
      if (((r = e.groupData) === null || r === void 0 ? void 0 : r[t.getId()]) != null)
        return !0;
      if (e.footer && e.level === -1) {
        const l = t.getColDef();
        return l == null || l.showRowGroup === !0 || l.showRowGroup === this.columnModel.getRowGroupColumns()[0].getId();
      }
    }
    const a = this.gridOptionsService.isGroupUseEntireRow(this.columnModel.isPivotMode());
    return i === 0 && a;
  }
  getHeaderName(e, t) {
    return e ? e({
      column: t,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context
    }) : this.columnModel.getDisplayNameForColumn(t, "csv", !0);
  }
  createValueForGroupNode(e) {
    if (this.processRowGroupCallback)
      return this.processRowGroupCallback({
        node: e,
        api: this.gridOptionsService.api,
        columnApi: this.gridOptionsService.columnApi,
        context: this.gridOptionsService.context
      });
    const t = e.footer, i = [e.key];
    if (!this.gridOptionsService.isGroupMultiAutoColumn())
      for (; e.parent; )
        e = e.parent, i.push(e.key);
    const r = i.reverse().join(" -> ");
    return t ? `Total ${r}` : r;
  }
  processCell(e) {
    var t;
    const { accumulatedRowIndex: i, rowNode: r, column: n, value: s, processCellCallback: a, type: l } = e;
    return a ? {
      value: (t = a({
        accumulatedRowIndex: i,
        column: n,
        node: r,
        value: s,
        api: this.gridOptionsService.api,
        columnApi: this.gridOptionsService.columnApi,
        context: this.gridOptionsService.context,
        type: l,
        parseValue: (c) => this.valueParserService.parseValue(n, r, c, this.valueService.getValue(n, r)),
        formatValue: (c) => {
          var d;
          return (d = this.valueFormatterService.formatValue(n, r, c)) !== null && d !== void 0 ? d : c;
        }
      })) !== null && t !== void 0 ? t : ""
    } : n.getColDef().useValueFormatterForExport ? {
      value: s != null ? s : "",
      valueFormatted: this.valueFormatterService.formatValue(n, r, s)
    } : { value: s != null ? s : "" };
  }
}
class Nb {
  static download(e, t) {
    const i = document.defaultView || window;
    if (!i) {
      console.warn("AG Grid: There is no `window` associated with the current `document`");
      return;
    }
    const r = document.createElement("a"), n = i.URL.createObjectURL(t);
    r.setAttribute("href", n), r.setAttribute("download", e), r.style.display = "none", document.body.appendChild(r), r.dispatchEvent(new MouseEvent("click", {
      bubbles: !1,
      cancelable: !0,
      view: i
    })), document.body.removeChild(r), i.setTimeout(() => {
      i.URL.revokeObjectURL(n);
    }, 0);
  }
}
const a0 = `\r
`;
class sG extends Nx {
  constructor(e) {
    super(e), this.isFirstLine = !0, this.result = "";
    const { suppressQuotes: t, columnSeparator: i } = e;
    this.suppressQuotes = t, this.columnSeparator = i;
  }
  addCustomContent(e) {
    e && (typeof e == "string" ? (/^\s*\n/.test(e) || this.beginNewLine(), e = e.replace(/\r?\n/g, a0), this.result += e) : e.forEach((t) => {
      this.beginNewLine(), t.forEach((i, r) => {
        r !== 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(i.data.value || ""), i.mergeAcross && this.appendEmptyCells(i.mergeAcross);
      });
    }));
  }
  onNewHeaderGroupingRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewHeaderGroupingRowColumn.bind(this)
    };
  }
  onNewHeaderGroupingRowColumn(e, t, i, r) {
    i != 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(t), this.appendEmptyCells(r);
  }
  appendEmptyCells(e) {
    for (let t = 1; t <= e; t++)
      this.result += this.columnSeparator + this.putInQuotes("");
  }
  onNewHeaderRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewHeaderRowColumn.bind(this)
    };
  }
  onNewHeaderRowColumn(e, t) {
    t != 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(this.extractHeaderValue(e));
  }
  onNewBodyRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewBodyRowColumn.bind(this)
    };
  }
  onNewBodyRowColumn(e, t, i) {
    var r;
    t != 0 && (this.result += this.columnSeparator);
    const n = this.extractRowCellValue(e, t, t, "csv", i);
    this.result += this.putInQuotes((r = n.valueFormatted) !== null && r !== void 0 ? r : n.value);
  }
  putInQuotes(e) {
    if (this.suppressQuotes)
      return e;
    if (e == null)
      return '""';
    let t;
    return typeof e == "string" ? t = e : typeof e.toString == "function" ? t = e.toString() : (console.warn("AG Grid: unknown value type during csv conversion"), t = ""), '"' + t.replace(/"/g, '""') + '"';
  }
  parse() {
    return this.result;
  }
  beginNewLine() {
    this.isFirstLine || (this.result += a0), this.isFirstLine = !1;
  }
}
var $a = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Bn = class extends Lx {
  postConstruct() {
    this.setBeans({
      gridSerializer: this.gridSerializer,
      gridOptionsService: this.gridOptionsService
    });
  }
  getMergedParams(e) {
    const t = this.gridOptionsService.get("defaultCsvExportParams");
    return Object.assign({}, t, e);
  }
  export(e) {
    if (this.isExportSuppressed())
      return console.warn("AG Grid: Export cancelled. Export is not allowed as per your configuration."), "";
    const t = this.getMergedParams(e), i = this.getData(t), r = new Blob(["\uFEFF", i], { type: "text/plain" });
    return Nb.download(this.getFileName(t.fileName), r), i;
  }
  exportDataAsCsv(e) {
    return this.export(e);
  }
  getDataAsCsv(e, t = !1) {
    const i = t ? Object.assign({}, e) : this.getMergedParams(e);
    return this.getData(i);
  }
  getDefaultFileName() {
    return "export.csv";
  }
  getDefaultFileExtension() {
    return "csv";
  }
  createSerializingSession(e) {
    const { columnModel: t, valueService: i, gridOptionsService: r, valueFormatterService: n, valueParserService: s } = this, { processCellCallback: a, processHeaderCallback: l, processGroupHeaderCallback: c, processRowGroupCallback: d, suppressQuotes: u, columnSeparator: h } = e;
    return new sG({
      columnModel: t,
      valueService: i,
      gridOptionsService: r,
      valueFormatterService: n,
      valueParserService: s,
      processCellCallback: a || void 0,
      processHeaderCallback: l || void 0,
      processGroupHeaderCallback: c || void 0,
      processRowGroupCallback: d || void 0,
      suppressQuotes: u || !1,
      columnSeparator: h || ","
    });
  }
  isExportSuppressed() {
    return this.gridOptionsService.is("suppressCsvExport");
  }
};
$a([
  S("columnModel")
], Bn.prototype, "columnModel", void 0);
$a([
  S("valueService")
], Bn.prototype, "valueService", void 0);
$a([
  S("gridSerializer")
], Bn.prototype, "gridSerializer", void 0);
$a([
  S("gridOptionsService")
], Bn.prototype, "gridOptionsService", void 0);
$a([
  S("valueFormatterService")
], Bn.prototype, "valueFormatterService", void 0);
$a([
  S("valueParserService")
], Bn.prototype, "valueParserService", void 0);
$a([
  B
], Bn.prototype, "postConstruct", null);
Bn = $a([
  q("csvCreator")
], Bn);
var za = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, Al;
(function(o) {
  o[o.HEADER_GROUPING = 0] = "HEADER_GROUPING", o[o.HEADER = 1] = "HEADER", o[o.BODY = 2] = "BODY";
})(Al || (Al = {}));
let Hn = class extends H {
  serialize(e, t = {}) {
    const i = this.getColumnsToExport(t.allColumns, t.columnKeys);
    return x.compose(
      // first pass, put in the header names of the cols
      this.prepareSession(i),
      this.prependContent(t),
      this.exportColumnGroups(t, i),
      this.exportHeaders(t, i),
      this.processPinnedTopRows(t, i),
      this.processRows(t, i),
      this.processPinnedBottomRows(t, i),
      this.appendContent(t)
    )(e).parse();
  }
  processRow(e, t, i, r) {
    const n = t.shouldRowBeSkipped || (() => !1), s = this.gridOptionsService.context, a = this.gridOptionsService.api, l = this.gridOptionsService.columnApi, c = this.gridOptionsService.is("groupRemoveSingleChildren"), d = this.gridOptionsService.is("groupRemoveLowestSingleChildren"), h = t.rowPositions != null || !!t.onlySelected, p = this.gridOptionsService.is("groupHideOpenParents") && !h, f = this.columnModel.isPivotMode() ? r.leafGroup : !r.group, g = !!r.footer, v = t.skipGroups || t.skipRowGroups, y = d && r.leafGroup, m = r.allChildrenCount === 1 && (c || y);
    if (v && t.skipGroups && x.doOnce(() => console.warn("AG Grid: Since v25.2 `skipGroups` has been renamed to `skipRowGroups`."), "gridSerializer-skipGroups"), !f && !g && (t.skipRowGroups || m || p) || t.onlySelected && !r.isSelected() || t.skipPinnedTop && r.rowPinned === "top" || t.skipPinnedBottom && r.rowPinned === "bottom" || r.level === -1 && !f && !g || n({ node: r, api: a, columnApi: l, context: s }))
      return;
    const E = e.onNewBodyRow(r);
    if (i.forEach((b, T) => {
      E.onColumn(b, T, r);
    }), t.getCustomContentBelowRow) {
      const b = t.getCustomContentBelowRow({ node: r, api: a, columnApi: l, context: s });
      b && e.addCustomContent(b);
    }
  }
  appendContent(e) {
    return (t) => {
      const i = e.customFooter || e.appendContent;
      return i && (e.customFooter && x.doOnce(() => console.warn("AG Grid: Since version 25.2.0 the `customFooter` param has been deprecated. Use `appendContent` instead."), "gridSerializer-customFooter"), t.addCustomContent(i)), t;
    };
  }
  prependContent(e) {
    return (t) => {
      const i = e.customHeader || e.prependContent;
      return i && (e.customHeader && x.doOnce(() => console.warn("AG Grid: Since version 25.2.0 the `customHeader` param has been deprecated. Use `prependContent` instead."), "gridSerializer-customHeader"), t.addCustomContent(i)), t;
    };
  }
  prepareSession(e) {
    return (t) => (t.prepare(e), t);
  }
  exportColumnGroups(e, t) {
    return (i) => {
      if (e.skipColumnGroupHeaders)
        e.columnGroups && x.doOnce(() => console.warn("AG Grid: Since v25.2 the `columnGroups` param has deprecated, and groups are exported by default."), "gridSerializer-columnGroups");
      else {
        const r = new eT(), n = this.displayedGroupCreator.createDisplayedGroups(t, this.columnModel.getGridBalancedTree(), r, null);
        this.recursivelyAddHeaderGroups(n, i, e.processGroupHeaderCallback);
      }
      return i;
    };
  }
  exportHeaders(e, t) {
    return (i) => {
      if (!e.skipHeader && !e.skipColumnHeaders) {
        const r = i.onNewHeaderRow();
        t.forEach((n, s) => {
          r.onColumn(n, s, void 0);
        });
      } else
        e.skipHeader && x.doOnce(() => console.warn("AG Grid: Since v25.2 the `skipHeader` param has been renamed to `skipColumnHeaders`."), "gridSerializer-skipHeader");
      return i;
    };
  }
  processPinnedTopRows(e, t) {
    return (i) => {
      const r = this.processRow.bind(this, i, e, t);
      return e.rowPositions ? e.rowPositions.filter((n) => n.rowPinned === "top").sort((n, s) => n.rowIndex - s.rowIndex).map((n) => this.pinnedRowModel.getPinnedTopRow(n.rowIndex)).forEach(r) : this.pinnedRowModel.forEachPinnedTopRow(r), i;
    };
  }
  processRows(e, t) {
    return (i) => {
      const r = this.rowModel, n = r.getType(), s = n === "clientSide", a = n === "serverSide", l = !s && e.onlySelected, c = this.processRow.bind(this, i, e, t), { exportedRows: d = "filteredAndSorted" } = e;
      if (e.rowPositions)
        e.rowPositions.filter((u) => u.rowPinned == null).sort((u, h) => u.rowIndex - h.rowIndex).map((u) => r.getRow(u.rowIndex)).forEach(c);
      else if (this.columnModel.isPivotMode())
        s ? r.forEachPivotNode(c, !0) : r.forEachNode(c);
      else if (e.onlySelectedAllPages || l) {
        const u = this.selectionService.getSelectedNodes();
        this.replicateSortedOrder(u), u.forEach(c);
      } else
        d === "all" ? r.forEachNode(c) : s ? r.forEachNodeAfterFilterAndSort(c, !0) : a ? r.forEachNodeAfterFilterAndSort(c) : r.forEachNode(c);
      return i;
    };
  }
  replicateSortedOrder(e) {
    const t = this.sortController.getSortOptions(), i = (r, n) => {
      var s, a, l, c;
      return r.rowIndex != null && n.rowIndex != null ? r.rowIndex - n.rowIndex : r.level === n.level ? ((s = r.parent) === null || s === void 0 ? void 0 : s.id) === ((a = n.parent) === null || a === void 0 ? void 0 : a.id) ? this.rowNodeSorter.compareRowNodes(t, {
        rowNode: r,
        currentPos: (l = r.rowIndex) !== null && l !== void 0 ? l : -1
      }, {
        rowNode: n,
        currentPos: (c = n.rowIndex) !== null && c !== void 0 ? c : -1
      }) : i(r.parent, n.parent) : r.level > n.level ? i(r.parent, n) : i(r, n.parent);
    };
    e.sort(i);
  }
  processPinnedBottomRows(e, t) {
    return (i) => {
      const r = this.processRow.bind(this, i, e, t);
      return e.rowPositions ? e.rowPositions.filter((n) => n.rowPinned === "bottom").sort((n, s) => n.rowIndex - s.rowIndex).map((n) => this.pinnedRowModel.getPinnedBottomRow(n.rowIndex)).forEach(r) : this.pinnedRowModel.forEachPinnedBottomRow(r), i;
    };
  }
  getColumnsToExport(e = !1, t) {
    const i = this.columnModel.isPivotMode();
    return t && t.length ? this.columnModel.getGridColumns(t) : e && !i ? (this.gridOptionsService.isTreeData() ? this.columnModel.getGridColumns([bs]) : []).concat(this.columnModel.getAllGridColumns() || []) : this.columnModel.getAllDisplayedColumns();
  }
  recursivelyAddHeaderGroups(e, t, i) {
    const r = [];
    e.forEach((n) => {
      const s = n;
      s.getChildren && s.getChildren().forEach((a) => r.push(a));
    }), e.length > 0 && e[0] instanceof pt && this.doAddHeaderHeader(t, e, i), r && r.length > 0 && this.recursivelyAddHeaderGroups(r, t, i);
  }
  doAddHeaderHeader(e, t, i) {
    const r = e.onNewHeaderGroupingRow();
    let n = 0;
    t.forEach((s) => {
      const a = s;
      let l;
      i ? l = i({
        columnGroup: a,
        api: this.gridOptionsService.api,
        columnApi: this.gridOptionsService.columnApi,
        context: this.gridOptionsService.context
      }) : l = this.columnModel.getDisplayNameForColumnGroup(a, "header");
      const c = a.getLeafColumns().reduce((d, u, h, p) => {
        let f = x.last(d);
        return u.getColumnGroupShow() === "open" ? (!f || f[1] != null) && (f = [h], d.push(f)) : f && f[1] == null && (f[1] = h - 1), h === p.length - 1 && f && f[1] == null && (f[1] = h), d;
      }, []);
      r.onColumn(a, l || "", n++, a.getLeafColumns().length - 1, c);
    });
  }
};
za([
  S("displayedGroupCreator")
], Hn.prototype, "displayedGroupCreator", void 0);
za([
  S("columnModel")
], Hn.prototype, "columnModel", void 0);
za([
  S("rowModel")
], Hn.prototype, "rowModel", void 0);
za([
  S("pinnedRowModel")
], Hn.prototype, "pinnedRowModel", void 0);
za([
  S("selectionService")
], Hn.prototype, "selectionService", void 0);
za([
  S("rowNodeSorter")
], Hn.prototype, "rowNodeSorter", void 0);
za([
  S("sortController")
], Hn.prototype, "sortController", void 0);
Hn = za([
  q("gridSerializer")
], Hn);
const aG = "30.0.5", Gb = {
  version: aG,
  moduleName: Q.CsvExportModule,
  beans: [Bn, Hn]
}, jf = `\r
`;
class kC {
  static createHeader(e = {}) {
    const t = "<?", i = "?>", r = ["version"];
    e.version || (e.version = "1.0"), e.encoding && r.push("encoding"), e.standalone && r.push("standalone");
    const n = r.map((s) => `${s}="${e[s]}"`).join(" ");
    return `${t}xml ${n} ${i}`;
  }
  static createXml(e, t) {
    let i = "";
    e.properties && (e.properties.prefixedAttributes && e.properties.prefixedAttributes.forEach((n) => {
      Object.keys(n.map).forEach((s) => {
        i += this.returnAttributeIfPopulated(n.prefix + s, n.map[s], t);
      });
    }), e.properties.rawMap && Object.keys(e.properties.rawMap).forEach((n) => {
      i += this.returnAttributeIfPopulated(n, e.properties.rawMap[n], t);
    }));
    let r = "<" + e.name + i;
    return !e.children && e.textNode == null ? r + "/>" + jf : e.textNode != null ? r + ">" + e.textNode + "</" + e.name + ">" + jf : (r += ">" + jf, e.children && e.children.forEach((n) => {
      r += this.createXml(n, t);
    }), r + "</" + e.name + ">" + jf);
  }
  static returnAttributeIfPopulated(e, t, i) {
    if (!t && t !== "" && t !== 0)
      return "";
    let r = t;
    return typeof t == "boolean" && i && (r = i(t)), ` ${e}="${r}"`;
  }
}
const lG = new Uint32Array([
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
]);
class oi {
  static addFolders(e) {
    e.forEach(this.addFolder.bind(this));
  }
  static addFolder(e) {
    this.folders.push({
      path: e,
      created: /* @__PURE__ */ new Date(),
      isBase64: !1
    });
  }
  static addFile(e, t, i = !1) {
    this.files.push({
      path: e,
      created: /* @__PURE__ */ new Date(),
      content: t,
      isBase64: i
    });
  }
  static getContent(e = "application/zip") {
    const t = this.buildFileStream(), i = this.buildUint8Array(t);
    return this.clearStream(), new Blob([i], { type: e });
  }
  static clearStream() {
    this.folders = [], this.files = [];
  }
  static buildFileStream(e = "") {
    const t = this.folders.concat(this.files), i = t.length;
    let r = "", n = 0, s = 0;
    for (const l of t) {
      const { fileHeader: c, folderHeader: d, content: u } = this.getHeader(l, n);
      n += c.length + u.length, s += d.length, e += c + u, r += d;
    }
    const a = this.buildFolderEnd(i, s, n);
    return e + r + a;
  }
  static getHeader(e, t) {
    const { content: i, path: r, created: n, isBase64: s } = e, { utf8_encode: a, decToHex: l } = x, c = a(r), d = c !== r, u = this.convertTime(n), h = this.convertDate(n);
    let p = "";
    if (d) {
      const C = l(1, 1) + l(this.getFromCrc32Table(c), 4) + c;
      p = "up" + l(C.length, 2) + C;
    }
    const { size: f, content: g } = i ? this.getConvertedContent(i, s) : { size: 0, content: "" }, v = `
\0` + (d ? "\0\b" : "\0\0") + "\0\0" + l(u, 2) + // last modified time
    l(h, 2) + // last modified date
    l(f ? this.getFromCrc32Table(g) : 0, 4) + l(f, 4) + // compressed size
    l(f, 4) + // uncompressed size
    l(c.length, 2) + // file name length
    l(p.length, 2), y = "PK" + v + c + p, m = "PK\0" + v + // file header
    "\0\0\0\0\0\0" + (i ? "\0\0\0\0" : "\0\0\0") + // external file attributes
    l(t, 4) + // relative offset of local header
    c + // file name
    p;
    return { fileHeader: y, folderHeader: m, content: g || "" };
  }
  static getConvertedContent(e, t = !1) {
    return t && (e = e.split(";base64,")[1]), e = t ? atob(e) : e, {
      size: e.length,
      content: e
    };
  }
  static buildFolderEnd(e, t, i) {
    const { decToHex: r } = x;
    return "PK\0\0\0\0" + r(e, 2) + // total number of entries in the central folder
    r(e, 2) + // total number of entries in the central folder
    r(t, 4) + // size of the central folder
    r(i, 4) + // central folder start offset
    "\0\0";
  }
  static buildUint8Array(e) {
    const t = new Uint8Array(e.length);
    for (let i = 0; i < t.length; i++)
      t[i] = e.charCodeAt(i);
    return t;
  }
  static getFromCrc32Table(e) {
    if (!e.length)
      return 0;
    const t = e.length, i = new Uint8Array(t);
    for (let l = 0; l < t; l++)
      i[l] = e.charCodeAt(l);
    let r = -1, n = 0, s = 0, a = 0;
    for (let l = 0; l < t; l++)
      n = i[l], s = (r ^ n) & 255, a = lG[s], r = r >>> 8 ^ a;
    return r ^ -1;
  }
  static convertTime(e) {
    let t = e.getHours();
    return t <<= 6, t = t | e.getMinutes(), t <<= 5, t = t | e.getSeconds() / 2, t;
  }
  static convertDate(e) {
    let t = e.getFullYear() - 1980;
    return t <<= 4, t = t | e.getMonth() + 1, t <<= 5, t = t | e.getDate(), t;
  }
}
oi.folders = [];
oi.files = [];
const Gx = [iG, oG, Gb];
Z.registerModules(Gx);
/**
          * @ag-grid-enterprise/all-modules - Advanced Data Grid / Data Table supporting Javascript / Typescript / React / Angular / Vue * @version v30.0.5
          * @link https://www.ag-grid.com/
          * @license Commercial
          */
class cG {
  constructor() {
    this.ieCompatibility = !1;
  }
  init() {
    this.ieCompatibility = this.md5("hello") != "5d41402abc4b2a76b9719d911017c592";
  }
  md5cycle(e, t) {
    let i = e[0], r = e[1], n = e[2], s = e[3];
    i = this.ff(i, r, n, s, t[0], 7, -680876936), s = this.ff(s, i, r, n, t[1], 12, -389564586), n = this.ff(n, s, i, r, t[2], 17, 606105819), r = this.ff(r, n, s, i, t[3], 22, -1044525330), i = this.ff(i, r, n, s, t[4], 7, -176418897), s = this.ff(s, i, r, n, t[5], 12, 1200080426), n = this.ff(n, s, i, r, t[6], 17, -1473231341), r = this.ff(r, n, s, i, t[7], 22, -45705983), i = this.ff(i, r, n, s, t[8], 7, 1770035416), s = this.ff(s, i, r, n, t[9], 12, -1958414417), n = this.ff(n, s, i, r, t[10], 17, -42063), r = this.ff(r, n, s, i, t[11], 22, -1990404162), i = this.ff(i, r, n, s, t[12], 7, 1804603682), s = this.ff(s, i, r, n, t[13], 12, -40341101), n = this.ff(n, s, i, r, t[14], 17, -1502002290), r = this.ff(r, n, s, i, t[15], 22, 1236535329), i = this.gg(i, r, n, s, t[1], 5, -165796510), s = this.gg(s, i, r, n, t[6], 9, -1069501632), n = this.gg(n, s, i, r, t[11], 14, 643717713), r = this.gg(r, n, s, i, t[0], 20, -373897302), i = this.gg(i, r, n, s, t[5], 5, -701558691), s = this.gg(s, i, r, n, t[10], 9, 38016083), n = this.gg(n, s, i, r, t[15], 14, -660478335), r = this.gg(r, n, s, i, t[4], 20, -405537848), i = this.gg(i, r, n, s, t[9], 5, 568446438), s = this.gg(s, i, r, n, t[14], 9, -1019803690), n = this.gg(n, s, i, r, t[3], 14, -187363961), r = this.gg(r, n, s, i, t[8], 20, 1163531501), i = this.gg(i, r, n, s, t[13], 5, -1444681467), s = this.gg(s, i, r, n, t[2], 9, -51403784), n = this.gg(n, s, i, r, t[7], 14, 1735328473), r = this.gg(r, n, s, i, t[12], 20, -1926607734), i = this.hh(i, r, n, s, t[5], 4, -378558), s = this.hh(s, i, r, n, t[8], 11, -2022574463), n = this.hh(n, s, i, r, t[11], 16, 1839030562), r = this.hh(r, n, s, i, t[14], 23, -35309556), i = this.hh(i, r, n, s, t[1], 4, -1530992060), s = this.hh(s, i, r, n, t[4], 11, 1272893353), n = this.hh(n, s, i, r, t[7], 16, -155497632), r = this.hh(r, n, s, i, t[10], 23, -1094730640), i = this.hh(i, r, n, s, t[13], 4, 681279174), s = this.hh(s, i, r, n, t[0], 11, -358537222), n = this.hh(n, s, i, r, t[3], 16, -722521979), r = this.hh(r, n, s, i, t[6], 23, 76029189), i = this.hh(i, r, n, s, t[9], 4, -640364487), s = this.hh(s, i, r, n, t[12], 11, -421815835), n = this.hh(n, s, i, r, t[15], 16, 530742520), r = this.hh(r, n, s, i, t[2], 23, -995338651), i = this.ii(i, r, n, s, t[0], 6, -198630844), s = this.ii(s, i, r, n, t[7], 10, 1126891415), n = this.ii(n, s, i, r, t[14], 15, -1416354905), r = this.ii(r, n, s, i, t[5], 21, -57434055), i = this.ii(i, r, n, s, t[12], 6, 1700485571), s = this.ii(s, i, r, n, t[3], 10, -1894986606), n = this.ii(n, s, i, r, t[10], 15, -1051523), r = this.ii(r, n, s, i, t[1], 21, -2054922799), i = this.ii(i, r, n, s, t[8], 6, 1873313359), s = this.ii(s, i, r, n, t[15], 10, -30611744), n = this.ii(n, s, i, r, t[6], 15, -1560198380), r = this.ii(r, n, s, i, t[13], 21, 1309151649), i = this.ii(i, r, n, s, t[4], 6, -145523070), s = this.ii(s, i, r, n, t[11], 10, -1120210379), n = this.ii(n, s, i, r, t[2], 15, 718787259), r = this.ii(r, n, s, i, t[9], 21, -343485551), e[0] = this.add32(i, e[0]), e[1] = this.add32(r, e[1]), e[2] = this.add32(n, e[2]), e[3] = this.add32(s, e[3]);
  }
  cmn(e, t, i, r, n, s) {
    return t = this.add32(this.add32(t, e), this.add32(r, s)), this.add32(t << n | t >>> 32 - n, i);
  }
  ff(e, t, i, r, n, s, a) {
    return this.cmn(t & i | ~t & r, e, t, n, s, a);
  }
  gg(e, t, i, r, n, s, a) {
    return this.cmn(t & r | i & ~r, e, t, n, s, a);
  }
  hh(e, t, i, r, n, s, a) {
    return this.cmn(t ^ i ^ r, e, t, n, s, a);
  }
  ii(e, t, i, r, n, s, a) {
    return this.cmn(i ^ (t | ~r), e, t, n, s, a);
  }
  md51(e) {
    const t = e.length, i = [1732584193, -271733879, -1732584194, 271733878];
    let r;
    for (r = 64; r <= e.length; r += 64)
      this.md5cycle(i, this.md5blk(e.substring(r - 64, r)));
    e = e.substring(r - 64);
    const n = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (r = 0; r < e.length; r++)
      n[r >> 2] |= e.charCodeAt(r) << (r % 4 << 3);
    if (n[r >> 2] |= 128 << (r % 4 << 3), r > 55)
      for (this.md5cycle(i, n), r = 0; r < 16; r++)
        n[r] = 0;
    return n[14] = t * 8, this.md5cycle(i, n), i;
  }
  /* there needs to be support for Unicode here, * unless we pretend that we can redefine the MD-5
   * algorithm for multi-byte characters (perhaps by adding every four 16-bit characters and
   * shortening the sum to 32 bits). Otherwise I suthis.ggest performing MD-5 as if every character
   * was two bytes--e.g., 0040 0025 = @%--but then how will an ordinary MD-5 sum be matched?
   * There is no way to standardize text to something like UTF-8 before transformation; speed cost is
   * utterly prohibitive. The JavaScript standard itself needs to look at this: it should start
   * providing access to strings as preformed UTF-8 8-bit unsigned value arrays.
   */
  md5blk(e) {
    const t = [];
    for (let i = 0; i < 64; i += 4)
      t[i >> 2] = e.charCodeAt(i) + (e.charCodeAt(i + 1) << 8) + (e.charCodeAt(i + 2) << 16) + (e.charCodeAt(i + 3) << 24);
    return t;
  }
  rhex(e) {
    const t = "0123456789abcdef".split("");
    let i = "", r = 0;
    for (; r < 4; r++)
      i += t[e >> r * 8 + 4 & 15] + t[e >> r * 8 & 15];
    return i;
  }
  hex(e) {
    for (let t = 0; t < e.length; t++)
      e[t] = this.rhex(e[t]);
    return e.join("");
  }
  md5(e) {
    return this.hex(this.md51(e));
  }
  add32(e, t) {
    return this.ieCompatibility ? this.add32Compat(e, t) : this.add32Std(e, t);
  }
  /* this function is much faster, so if possible we use it. Some IEs are the only ones I know of that
   need the idiotic second function, generated by an if clause.  */
  add32Std(e, t) {
    return e + t & 4294967295;
  }
  add32Compat(e, t) {
    const i = (e & 65535) + (t & 65535);
    return (e >> 16) + (t >> 16) + (i >> 16) << 16 | i & 65535;
  }
}
function l0(o) {
  return o == null || o.length === 0;
}
function dG(o, e = !1) {
  return o != null && (o !== "" || e);
}
class bt {
  constructor(e) {
    this.watermarkMessage = void 0, this.document = e, this.md5 = new cG(), this.md5.init();
  }
  validateLicense() {
    if (l0(bt.licenseKey))
      (!this.isWebsiteUrl() || this.isForceWatermark()) && this.outputMissingLicenseKey();
    else if (bt.licenseKey.length > 32)
      if (bt.licenseKey.indexOf("For_Trialing_ag-Grid_Only") !== -1)
        this.outputInvalidLicenseKey();
      else {
        const { md5: e, license: t, version: i, isTrial: r } = bt.extractLicenseComponents(bt.licenseKey);
        e === this.md5.md5(t) ? dG(i) && i ? this.validateLicenseKeyForVersion(i, !!r, t) : this.validateLegacyKey(t) : this.outputInvalidLicenseKey();
      }
    else
      this.outputInvalidLicenseKey();
  }
  static extractExpiry(e) {
    const t = e.substring(e.lastIndexOf("_") + 1, e.length);
    return new Date(parseInt(bt.decode(t), 10));
  }
  static extractLicenseComponents(e) {
    let t = e.replace(/[\u200B-\u200D\uFEFF]/g, "");
    t = t.replace(/\r?\n|\r/g, "");
    const i = t.length - 32, r = t.substring(i), n = t.substring(0, i), [s, a] = bt.extractBracketedInformation(t);
    return { md5: r, license: n, version: s, isTrial: a };
  }
  getLicenseDetails(e) {
    const { md5: t, license: i, version: r, isTrial: n } = bt.extractLicenseComponents(e);
    let s = t === this.md5.md5(i) && e.indexOf("For_Trialing_ag-Grid_Only") === -1, a = null, l = null;
    return s && (l = bt.extractExpiry(i), s = !isNaN(l.getTime()), n && (a = l < /* @__PURE__ */ new Date())), {
      licenseKey: e,
      valid: s,
      expiry: s ? bt.formatDate(l) : null,
      version: r || "legacy",
      isTrial: n,
      trialExpired: a
    };
  }
  isDisplayWatermark() {
    return this.isForceWatermark() || !this.isLocalhost() && !this.isWebsiteUrl() && !l0(this.watermarkMessage);
  }
  getWatermarkMessage() {
    return this.watermarkMessage || "";
  }
  getHostname() {
    const t = (this.document.defaultView || window).location, { hostname: i = "" } = t;
    return i;
  }
  isForceWatermark() {
    const t = (this.document.defaultView || window).location, { pathname: i } = t;
    return i ? i.indexOf("forceWatermark") !== -1 : !1;
  }
  isWebsiteUrl() {
    return this.getHostname().match(/^((?:\w+\.)?ag-grid\.com)$/) !== null;
  }
  isLocalhost() {
    return this.getHostname().match(/^(?:127\.0\.0\.1|localhost)$/) !== null;
  }
  static formatDate(e) {
    const t = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ], i = e.getDate(), r = e.getMonth(), n = e.getFullYear();
    return i + " " + t[r] + " " + n;
  }
  static getGridReleaseDate() {
    return new Date(parseInt(bt.decode(bt.RELEASE_INFORMATION), 10));
  }
  static decode(e) {
    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    let i = "", r, n, s, a, l, c, d, u = 0;
    const h = e.replace(/[^A-Za-z0-9+/=]/g, "");
    for (; u < h.length; )
      a = t.indexOf(h.charAt(u++)), l = t.indexOf(h.charAt(u++)), c = t.indexOf(h.charAt(u++)), d = t.indexOf(h.charAt(u++)), r = a << 2 | l >> 4, n = (l & 15) << 4 | c >> 2, s = (c & 3) << 6 | d, i = i + String.fromCharCode(r), c != 64 && (i = i + String.fromCharCode(n)), d != 64 && (i = i + String.fromCharCode(s));
    return i = bt.utf8_decode(i), i;
  }
  static utf8_decode(e) {
    e = e.replace(/rn/g, "n");
    let t = "";
    for (let i = 0; i < e.length; i++) {
      const r = e.charCodeAt(i);
      r < 128 ? t += String.fromCharCode(r) : r > 127 && r < 2048 ? (t += String.fromCharCode(r >> 6 | 192), t += String.fromCharCode(r & 63 | 128)) : (t += String.fromCharCode(r >> 12 | 224), t += String.fromCharCode(r >> 6 & 63 | 128), t += String.fromCharCode(r & 63 | 128));
    }
    return t;
  }
  static setLicenseKey(e) {
    this.licenseKey = e;
  }
  static extractBracketedInformation(e) {
    const t = e.split("[").filter(function(n) {
      return n.indexOf("]") > -1;
    }).map(function(n) {
      return n.split("]")[0];
    });
    if (!t || t.length === 0)
      return [null, null];
    const i = t.filter((n) => n === "TRIAL").length === 1;
    return [t.filter((n) => n.indexOf("v") === 0).map((n) => n.replace(/^v/, ""))[0], i];
  }
  validateLicenseKeyForVersion(e, t, i) {
    e === "2" && (t ? this.validateForTrial(i) : this.validateLegacyKey(i));
  }
  validateLegacyKey(e) {
    const t = bt.getGridReleaseDate(), i = bt.extractExpiry(e);
    let r = !1, n = !1;
    if (isNaN(i.getTime()) || (r = !0, n = t < i), !r)
      this.outputInvalidLicenseKey();
    else if (!n) {
      const s = bt.formatDate(i), a = bt.formatDate(t);
      this.outputIncompatibleVersion(s, a);
    }
  }
  validateForTrial(e) {
    const t = bt.extractExpiry(e), i = /* @__PURE__ */ new Date();
    let r = !1, n = !1;
    if (isNaN(t.getTime()) || (r = !0, n = t > i), !r)
      this.outputInvalidLicenseKey();
    else if (!n) {
      const s = bt.formatDate(t);
      this.outputExpiredTrialKey(s);
    }
  }
  outputInvalidLicenseKey() {
    console.error("*****************************************************************************************************************"), console.error("***************************************** AG Grid Enterprise License ********************************************"), console.error("********************************************* Invalid License ***************************************************"), console.error("* Your license for AG Grid Enterprise is not valid - please contact info@ag-grid.com to obtain a valid license. *"), console.error("*****************************************************************************************************************"), console.error("*****************************************************************************************************************"), this.watermarkMessage = "Invalid License";
  }
  outputExpiredTrialKey(e) {
    console.error("****************************************************************************************************************"), console.error("***************************************** AG Grid Enterprise License *******************************************"), console.error("*****************************************   Trial Period Expired.    *******************************************"), console.error(`* Your license for AG Grid Enterprise expired on ${e}.                                                *`), console.error("* Please email info@ag-grid.com to purchase a license.                                                         *"), console.error("****************************************************************************************************************"), console.error("****************************************************************************************************************"), this.watermarkMessage = "Trial Period Expired";
  }
  outputMissingLicenseKey() {
    console.error("****************************************************************************************************************"), console.error("***************************************** AG Grid Enterprise License *******************************************"), console.error("****************************************** License Key Not Found ***********************************************"), console.error("* All AG Grid Enterprise features are unlocked.                                                                *"), console.error("* This is an evaluation only version, it is not licensed for development projects intended for production.     *"), console.error("* If you want to hide the watermark, please email info@ag-grid.com for a trial license.                        *"), console.error("****************************************************************************************************************"), console.error("****************************************************************************************************************"), this.watermarkMessage = "For Trial Use Only";
  }
  outputIncompatibleVersion(e, t) {
    console.error("****************************************************************************************************************************"), console.error("****************************************************************************************************************************"), console.error("*                                             AG Grid Enterprise License                                                   *"), console.error("*                           License not compatible with installed version of AG Grid Enterprise.                           *"), console.error("*                                                                                                                          *"), console.error("* Your AG Grid License entitles you to all versions of AG Grid that we release within the time covered by your license     *"), console.error("* - typically we provide one year licenses which entitles you to all releases / updates of AG Grid within that year.       *"), console.error("* Your license has an end (expiry) date which stops the license key working with versions of AG Grid released after the    *"), console.error(`* license end date. The license key that you have expires on ${e}, however the version of AG Grid you    *`), console.error(`* are trying to use was released on ${t}.                                                               *`), console.error("*                                                                                                                          *"), console.error("* Please contact info@ag-grid.com to renew your subscription to new versions and get a new license key to work with this   *"), console.error("* version of AG Grid.                                                                                                      *"), console.error("****************************************************************************************************************************"), console.error("****************************************************************************************************************************"), this.watermarkMessage = "License Expired";
  }
}
bt.RELEASE_INFORMATION = "MTY4OTUzMzE0MDAzNw==";
var kx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let jg = class extends H {
  validateLicense() {
    this.licenseManager = new bt(this.gridOptionsService.getDocument()), this.licenseManager.validateLicense();
  }
  static getLicenseDetails(e) {
    return new bt(null).getLicenseDetails(e);
  }
  isDisplayWatermark() {
    return this.licenseManager.isDisplayWatermark();
  }
  getWatermarkMessage() {
    return this.licenseManager.getWatermarkMessage();
  }
  static setLicenseKey(e) {
    bt.setLicenseKey(e);
  }
};
kx([
  su
], jg.prototype, "validateLicense", null);
jg = kx([
  q("licenseManager")
], jg);
var kb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class wm extends X {
  constructor() {
    super(
      /* html*/
      `<div class="ag-watermark">
                <div ref="eLicenseTextRef" class="ag-watermark-text"></div>
            </div>`
    );
  }
  postConstruct() {
    const e = this.shouldDisplayWatermark();
    this.setDisplayed(e), e && (this.eLicenseTextRef.innerText = this.licenseManager.getWatermarkMessage(), window.setTimeout(() => this.addCssClass("ag-opacity-zero"), 0), window.setTimeout(() => this.setDisplayed(!1), 5e3));
  }
  shouldDisplayWatermark() {
    return this.licenseManager.isDisplayWatermark();
  }
}
kb([
  S("licenseManager")
], wm.prototype, "licenseManager", void 0);
kb([
  L("eLicenseTextRef")
], wm.prototype, "eLicenseTextRef", void 0);
kb([
  B
], wm.prototype, "postConstruct", null);
const uG = "30.0.5", Pi = {
  version: uG,
  moduleName: Q.EnterpriseCoreModule,
  beans: [jg],
  agStackComponents: [
    { componentName: "AgWatermark", componentClass: wm }
  ]
};
var Ai = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, VC;
const Py = "paste", Ay = "dragCopy", c0 = "clipboard";
var yl;
(function(o) {
  o[o.CellRange = 0] = "CellRange", o[o.SelectedRows = 1] = "SelectedRows", o[o.FocusedCell = 2] = "FocusedCell";
})(yl || (yl = {}));
let ii = VC = class extends H {
  constructor() {
    super(...arguments), this.lastPasteOperationTime = 0, this.navigatorApiFailed = !1;
  }
  init() {
    this.logger = this.loggerFactory.create("ClipboardService"), this.rowModel.getType() === "clientSide" && (this.clientSideRowModel = this.rowModel), this.ctrlsService.whenReady((e) => {
      this.gridCtrl = e.gridCtrl;
    });
  }
  pasteFromClipboard() {
    this.logger.log("pasteFromClipboard"), !this.gridOptionsService.is("suppressClipboardApi") && !this.navigatorApiFailed && navigator.clipboard && navigator.clipboard.readText ? navigator.clipboard.readText().then(this.processClipboardData.bind(this)).catch((t) => {
      x.doOnce(() => {
        console.warn(t), console.warn("AG Grid: Unable to use the Clipboard API (navigator.clipboard.readText()). The reason why it could not be used has been logged in the previous line. For this reason the grid has defaulted to using a workaround which doesn't perform as well. Either fix why Clipboard API is blocked, OR stop this message from appearing by setting grid property suppressClipboardApi=true (which will default the grid to using the workaround rather than the API");
      }, "clipboardApiError"), this.navigatorApiFailed = !0, this.pasteFromClipboardLegacy();
    }) : this.pasteFromClipboardLegacy();
  }
  pasteFromClipboardLegacy() {
    let e = !1;
    const t = (i) => {
      const r = (/* @__PURE__ */ new Date()).getTime();
      r - this.lastPasteOperationTime < 50 && (e = !0, i.preventDefault()), this.lastPasteOperationTime = r;
    };
    this.executeOnTempElement((i) => {
      i.addEventListener("paste", t), i.focus({ preventScroll: !0 });
    }, (i) => {
      const r = i.value;
      e ? this.refocusLastFocusedCell() : this.processClipboardData(r), i.removeEventListener("paste", t);
    });
  }
  refocusLastFocusedCell() {
    const e = this.focusService.getFocusedCell();
    e && this.focusService.setFocusedCell({
      rowIndex: e.rowIndex,
      column: e.column,
      rowPinned: e.rowPinned,
      forceBrowserFocus: !0
    });
  }
  getClipboardDelimiter() {
    const e = this.gridOptionsService.get("clipboardDelimiter");
    return x.exists(e) ? e : "	";
  }
  processClipboardData(e) {
    if (e == null)
      return;
    let t = VC.stringToArray(e, this.getClipboardDelimiter());
    const i = this.gridOptionsService.getCallback("processDataFromClipboard");
    if (i && (t = i({ data: t })), t == null)
      return;
    this.gridOptionsService.is("suppressLastEmptyLineOnPaste") && this.removeLastLineIfBlank(t);
    const r = (n, s, a, l) => {
      this.rangeService && this.rangeService.isMoreThanOneCell() && !this.hasOnlyOneValueToPaste(t) ? this.pasteIntoActiveRange(t, n, s, l) : this.pasteStartingFromFocusedCell(t, n, s, a, l);
    };
    this.doPasteOperation(r);
  }
  // This will parse a delimited string into an array of arrays.
  static stringToArray(e, t = ",") {
    const i = [], r = (s) => s === "\r" || s === `
`;
    let n = !1;
    if (e === "")
      return [[""]];
    for (let s = 0, a = 0, l = 0; l < e.length; l++) {
      const c = e[l - 1], d = e[l], u = e[l + 1], h = () => {
        i[s] || (i[s] = []), i[s][a] || (i[s][a] = "");
      };
      if (h(), d === '"' && (n ? u === '"' ? (i[s][a] += '"', l++) : n = !1 : (c === void 0 || c === t || r(c)) && (n = !0)), !n && d !== '"') {
        if (d === t) {
          a++, h();
          continue;
        } else if (r(d)) {
          a = 0, s++, h(), d === "\r" && u === `
` && l++;
          continue;
        }
      }
      i[s][a] += d;
    }
    return i;
  }
  // common code to paste operations, e.g. paste to cell, paste to range, and copy range down
  doPasteOperation(e) {
    const t = this.gridOptionsService.api, i = this.gridOptionsService.columnApi, r = "clipboard";
    this.eventService.dispatchEvent({
      type: w.EVENT_PASTE_START,
      api: t,
      columnApi: i,
      source: r
    });
    let n;
    if (this.clientSideRowModel) {
      const u = this.gridOptionsService.is("aggregateOnlyChangedColumns");
      n = new dm(u, this.clientSideRowModel.getRootNode());
    }
    const s = {}, a = [], l = this.focusService.getFocusedCell();
    e(s, a, l, n);
    const c = [...a];
    n && (this.clientSideRowModel.doAggregate(n), n.forEachChangedNodeDepthFirst((u) => {
      c.push(u);
    })), this.rowRenderer.refreshCells({ rowNodes: c }), this.dispatchFlashCells(s), this.fireRowChanged(a), this.refocusLastFocusedCell();
    const d = {
      type: w.EVENT_PASTE_END,
      source: r
    };
    this.eventService.dispatchEvent(d);
  }
  pasteIntoActiveRange(e, t, i, r) {
    const n = this.getRangeSize() % e.length != 0;
    let s = 0, a = 0;
    const l = (c, d, u, h) => {
      if (h - s >= e.length) {
        if (n)
          return;
        s += a, a = 0;
      }
      const f = e[h - s];
      i.push(d);
      const g = this.gridOptionsService.getCallback("processCellFromClipboard");
      u.forEach((v, y) => {
        if (!v.isCellEditable(d) || v.isSuppressPaste(d))
          return;
        y >= f.length && (y = y % f.length);
        const m = this.processCell(d, v, f[y], Ay, g, !0);
        d.setDataValue(v, m, Py), r && r.addParentNode(d.parent, [v]);
        const { rowIndex: C, rowPinned: R } = c, E = this.cellPositionUtils.createIdFromValues({ rowIndex: C, column: v, rowPinned: R });
        t[E] = !0;
      }), a++;
    };
    this.iterateActiveRanges(!1, l);
  }
  pasteStartingFromFocusedCell(e, t, i, r, n) {
    if (!r)
      return;
    const s = { rowIndex: r.rowIndex, rowPinned: r.rowPinned }, a = this.columnModel.getDisplayedColumnsStartingAt(r.column);
    this.isPasteSingleValueIntoRange(e) ? this.pasteSingleValueIntoRange(e, i, t, n) : this.pasteMultipleValues(e, s, i, a, t, c0, n);
  }
  // if range is active, and only one cell, then we paste this cell into all cells in the active range.
  isPasteSingleValueIntoRange(e) {
    return this.hasOnlyOneValueToPaste(e) && this.rangeService != null && !this.rangeService.isEmpty();
  }
  pasteSingleValueIntoRange(e, t, i, r) {
    const n = e[0][0], s = (a, l, c) => {
      t.push(l), c.forEach((d) => this.updateCellValue(l, d, n, i, c0, r));
    };
    this.iterateActiveRanges(!1, s);
  }
  hasOnlyOneValueToPaste(e) {
    return e.length === 1 && e[0].length === 1;
  }
  copyRangeDown() {
    if (!this.rangeService || this.rangeService.isEmpty())
      return;
    const e = [], t = (i, r, n, s) => {
      const a = this.gridOptionsService.getCallback("processCellForClipboard"), l = this.gridOptionsService.getCallback("processCellFromClipboard"), c = (d, u, h) => {
        e.length ? (r.push(u), h.forEach((p, f) => {
          if (!p.isCellEditable(u) || p.isSuppressPaste(u))
            return;
          const g = this.processCell(u, p, e[f], Ay, l, !0);
          u.setDataValue(p, g, Py), s && s.addParentNode(u.parent, [p]);
          const { rowIndex: v, rowPinned: y } = d, m = this.cellPositionUtils.createIdFromValues({ rowIndex: v, column: p, rowPinned: y });
          i[m] = !0;
        })) : h.forEach((p) => {
          const f = this.processCell(u, p, this.valueService.getValue(p, u), Ay, a, !1, !0);
          e.push(f);
        });
      };
      this.iterateActiveRanges(!0, c);
    };
    this.doPasteOperation(t);
  }
  removeLastLineIfBlank(e) {
    const t = x.last(e);
    if (t && t.length === 1 && t[0] === "") {
      if (e.length === 1)
        return;
      x.removeFromArray(e, t);
    }
  }
  fireRowChanged(e) {
    this.gridOptionsService.get("editType") === "fullRow" && e.forEach((t) => {
      const i = {
        type: w.EVENT_ROW_VALUE_CHANGED,
        node: t,
        data: t.data,
        rowIndex: t.rowIndex,
        rowPinned: t.rowPinned
      };
      this.eventService.dispatchEvent(i);
    });
  }
  pasteMultipleValues(e, t, i, r, n, s, a) {
    let l = t;
    const c = this.clientSideRowModel != null && !this.gridOptionsService.is("enableGroupEdit") && !this.gridOptionsService.isTreeData(), d = () => {
      for (; ; ) {
        if (!l)
          return null;
        const u = this.rowPositionUtils.getRowNode(l);
        if (l = this.cellNavigationService.getRowBelow({ rowPinned: l.rowPinned, rowIndex: l.rowIndex }), u == null)
          return null;
        if (!(u.detail || u.footer || c && u.group))
          return u;
      }
    };
    e.forEach((u) => {
      const h = d();
      h && (u.forEach((p, f) => this.updateCellValue(h, r[f], p, n, s, a)), i.push(h));
    });
  }
  updateCellValue(e, t, i, r, n, s) {
    if (!e || !t || !t.isCellEditable(e) || t.isSuppressPaste(e) || e.group && t.isValueActive())
      return;
    const a = this.processCell(e, t, i, n, this.gridOptionsService.getCallback("processCellFromClipboard"), !0);
    e.setDataValue(t, a, Py);
    const { rowIndex: l, rowPinned: c } = e, d = this.cellPositionUtils.createIdFromValues({ rowIndex: l, column: t, rowPinned: c });
    r[d] = !0, s && s.addParentNode(e.parent, [t]);
  }
  copyToClipboard(e = {}) {
    this.copyOrCutToClipboard(e);
  }
  cutToClipboard(e = {}, t = "api") {
    if (this.gridOptionsService.is("suppressCutToClipboard"))
      return;
    const i = {
      type: w.EVENT_CUT_START,
      source: t
    };
    this.eventService.dispatchEvent(i), this.copyOrCutToClipboard(e, !0);
    const r = {
      type: w.EVENT_CUT_END,
      source: t
    };
    this.eventService.dispatchEvent(r);
  }
  copyOrCutToClipboard(e, t) {
    let { includeHeaders: i, includeGroupHeaders: r } = e;
    this.logger.log(`copyToClipboard: includeHeaders = ${i}`), i == null && (i = this.gridOptionsService.is("copyHeadersToClipboard")), r == null && (r = this.gridOptionsService.is("copyGroupHeadersToClipboard"));
    const n = { includeHeaders: i, includeGroupHeaders: r }, s = !this.gridOptionsService.is("suppressCopyRowsToClipboard");
    let a = null;
    this.rangeService && !this.rangeService.isEmpty() && !this.shouldSkipSingleCellRange() ? (this.copySelectedRangeToClipboard(n), a = yl.CellRange) : s && !this.selectionService.isEmpty() ? (this.copySelectedRowsToClipboard(n), a = yl.SelectedRows) : this.focusService.isAnyCellFocused() && (this.copyFocusedCellToClipboard(n), a = yl.FocusedCell), t && a !== null && this.clearCellsAfterCopy(a);
  }
  clearCellsAfterCopy(e) {
    if (this.eventService.dispatchEvent({ type: w.EVENT_KEY_SHORTCUT_CHANGED_CELL_START }), e === yl.CellRange)
      this.rangeService.clearCellRangeCellValues({ cellEventSource: "clipboardService" });
    else if (e === yl.SelectedRows)
      this.clearSelectedRows();
    else {
      const t = this.focusService.getFocusedCell();
      if (t == null)
        return;
      const i = this.rowPositionUtils.getRowNode(t);
      i && this.clearCellValue(i, t.column);
    }
    this.eventService.dispatchEvent({ type: w.EVENT_KEY_SHORTCUT_CHANGED_CELL_END });
  }
  clearSelectedRows() {
    const e = this.selectionService.getSelectedNodes(), t = this.columnModel.getAllDisplayedColumns();
    for (const i of e)
      for (const r of t)
        this.clearCellValue(i, r);
  }
  clearCellValue(e, t) {
    t.isCellEditable(e) && e.setDataValue(t, null, "clipboardService");
  }
  shouldSkipSingleCellRange() {
    return this.gridOptionsService.is("suppressCopySingleCellRanges") && !this.rangeService.isMoreThanOneCell();
  }
  iterateActiveRanges(e, t, i) {
    if (!this.rangeService || this.rangeService.isEmpty())
      return;
    const r = this.rangeService.getCellRanges();
    e ? this.iterateActiveRange(r[0], t, i, !0) : r.forEach((n, s) => this.iterateActiveRange(n, t, i, s === r.length - 1));
  }
  iterateActiveRange(e, t, i, r) {
    if (!this.rangeService)
      return;
    let n = this.rangeService.getRangeStartRow(e);
    const s = this.rangeService.getRangeEndRow(e);
    i && e.columns && i(e.columns);
    let a = 0, l = !1;
    for (; !l && n != null; ) {
      const c = this.rowPositionUtils.getRowNode(n);
      l = this.rowPositionUtils.sameRow(n, s), t(n, c, e.columns, a++, l && r), n = this.cellNavigationService.getRowBelow(n);
    }
  }
  copySelectedRangeToClipboard(e = {}) {
    if (!this.rangeService || this.rangeService.isEmpty())
      return;
    const t = this.rangeService.areAllRangesAbleToMerge(), { data: i, cellsToFlash: r } = t ? this.buildDataFromMergedRanges(e) : this.buildDataFromRanges(e);
    this.copyDataToClipboard(i), this.dispatchFlashCells(r);
  }
  buildDataFromMergedRanges(e) {
    const t = /* @__PURE__ */ new Set(), i = this.rangeService.getCellRanges(), r = /* @__PURE__ */ new Map(), n = [], s = {};
    i.forEach((d) => {
      d.columns.forEach((p) => t.add(p));
      const { rowPositions: u, cellsToFlash: h } = this.getRangeRowPositionsAndCellsToFlash(d);
      u.forEach((p) => {
        const f = `${p.rowIndex}-${p.rowPinned || "null"}`;
        r.get(f) || (r.set(f, !0), n.push(p));
      }), Object.assign(s, h);
    });
    const a = this.columnModel.getAllDisplayedColumns(), l = Array.from(t);
    return l.sort((d, u) => {
      const h = a.indexOf(d), p = a.indexOf(u);
      return h - p;
    }), { data: this.buildExportParams({
      columns: l,
      rowPositions: n,
      includeHeaders: e.includeHeaders,
      includeGroupHeaders: e.includeGroupHeaders
    }), cellsToFlash: s };
  }
  buildDataFromRanges(e) {
    const t = this.rangeService.getCellRanges(), i = [], r = {};
    return t.forEach((n) => {
      const { rowPositions: s, cellsToFlash: a } = this.getRangeRowPositionsAndCellsToFlash(n);
      Object.assign(r, a), i.push(this.buildExportParams({
        columns: n.columns,
        rowPositions: s,
        includeHeaders: e.includeHeaders,
        includeGroupHeaders: e.includeGroupHeaders
      }));
    }), { data: i.join(`
`), cellsToFlash: r };
  }
  getRangeRowPositionsAndCellsToFlash(e) {
    const t = [], i = {}, r = this.rangeService.getRangeStartRow(e), n = this.rangeService.getRangeEndRow(e);
    let s = r;
    for (; s && (t.push(s), e.columns.forEach((a) => {
      const { rowIndex: l, rowPinned: c } = s, d = this.cellPositionUtils.createIdFromValues({ rowIndex: l, column: a, rowPinned: c });
      i[d] = !0;
    }), !this.rowPositionUtils.sameRow(s, n)); )
      s = this.cellNavigationService.getRowBelow(s);
    return { rowPositions: t, cellsToFlash: i };
  }
  copyFocusedCellToClipboard(e = {}) {
    const t = this.focusService.getFocusedCell();
    if (t == null)
      return;
    const i = this.cellPositionUtils.createId(t), r = { rowPinned: t.rowPinned, rowIndex: t.rowIndex }, n = t.column, s = this.buildExportParams({
      columns: [n],
      rowPositions: [r],
      includeHeaders: e.includeHeaders,
      includeGroupHeaders: e.includeGroupHeaders
    });
    this.copyDataToClipboard(s), this.dispatchFlashCells({ [i]: !0 });
  }
  copySelectedRowsToClipboard(e = {}) {
    const { columnKeys: t, includeHeaders: i, includeGroupHeaders: r } = e, n = this.buildExportParams({
      columns: t,
      includeHeaders: i,
      includeGroupHeaders: r
    });
    this.copyDataToClipboard(n);
  }
  buildExportParams(e) {
    const { columns: t, rowPositions: i, includeHeaders: r = !1, includeGroupHeaders: n = !1 } = e, s = {
      columnKeys: t,
      rowPositions: i,
      skipColumnHeaders: !r,
      skipColumnGroupHeaders: !n,
      suppressQuotes: !0,
      columnSeparator: this.getClipboardDelimiter(),
      onlySelected: !i,
      processCellCallback: this.gridOptionsService.getCallback("processCellForClipboard"),
      processRowGroupCallback: (a) => this.processRowGroupCallback(a),
      processHeaderCallback: this.gridOptionsService.getCallback("processHeaderForClipboard"),
      processGroupHeaderCallback: this.gridOptionsService.getCallback("processGroupHeaderForClipboard")
    };
    return this.csvCreator.getDataAsCsv(s, !0);
  }
  processRowGroupCallback(e) {
    const { node: t } = e, { key: i } = t;
    let r = i != null ? i : "";
    if (e.node.footer) {
      let s = "";
      i && i.length && (s = ` ${i}`), r = `Total${s}`;
    }
    const n = this.gridOptionsService.getCallback("processCellForClipboard");
    if (n) {
      let s = t.rowGroupColumn;
      return !s && t.footer && t.level === -1 && (s = this.columnModel.getRowGroupColumns()[0]), n({
        value: r,
        node: t,
        column: s,
        type: "clipboard",
        formatValue: (a) => {
          var l;
          return (l = this.valueFormatterService.formatValue(s, t, a)) !== null && l !== void 0 ? l : a;
        },
        parseValue: (a) => this.valueParserService.parseValue(s, t, a, this.valueService.getValue(s, t))
      });
    }
    return r;
  }
  dispatchFlashCells(e) {
    window.setTimeout(() => {
      const t = {
        type: w.EVENT_FLASH_CELLS,
        cells: e
      };
      this.eventService.dispatchEvent(t);
    }, 0);
  }
  processCell(e, t, i, r, n, s, a) {
    var l;
    return n ? n({
      column: t,
      node: e,
      value: i,
      type: r,
      formatValue: (d) => {
        var u;
        return (u = this.valueFormatterService.formatValue(t, e != null ? e : null, d)) !== null && u !== void 0 ? u : d;
      },
      parseValue: (d) => this.valueParserService.parseValue(t, e != null ? e : null, d, this.valueService.getValue(t, e))
    }) : s && t.getColDef().useValueParserForImport ? this.valueParserService.parseValue(t, e != null ? e : null, i, this.valueService.getValue(t, e)) : a && t.getColDef().useValueFormatterForExport && (l = this.valueFormatterService.formatValue(t, e != null ? e : null, i)) !== null && l !== void 0 ? l : i;
  }
  copyDataToClipboard(e) {
    const t = this.gridOptionsService.getCallback("sendToClipboard");
    if (t) {
      t({ data: e });
      return;
    }
    if (!this.gridOptionsService.is("suppressClipboardApi") && navigator.clipboard) {
      navigator.clipboard.writeText(e).catch((r) => {
        x.doOnce(() => {
          console.warn(r), console.warn("AG Grid: Unable to use the Clipboard API (navigator.clipboard.writeText()). The reason why it could not be used has been logged in the previous line. For this reason the grid has defaulted to using a workaround which doesn't perform as well. Either fix why Clipboard API is blocked, OR stop this message from appearing by setting grid property suppressClipboardApi=true (which will default the grid to using the workaround rather than the API.");
        }, "clipboardApiError"), this.copyDataToClipboardLegacy(e);
      });
      return;
    }
    this.copyDataToClipboardLegacy(e);
  }
  copyDataToClipboardLegacy(e) {
    this.executeOnTempElement((t) => {
      const i = this.gridOptionsService.getDocument(), r = i.activeElement;
      t.value = e || " ", t.select(), t.focus({ preventScroll: !0 }), i.execCommand("copy") || console.warn("AG Grid: Browser did not allow document.execCommand('copy'). Ensure api.copySelectedRowsToClipboard() is invoked via a user event, i.e. button click, otherwise the browser will prevent it for security reasons."), r != null && r.focus != null && r.focus({ preventScroll: !0 });
    });
  }
  executeOnTempElement(e, t) {
    const i = this.gridOptionsService.getDocument(), r = i.createElement("textarea");
    r.style.width = "1px", r.style.height = "1px", r.style.top = i.documentElement.scrollTop + "px", r.style.left = i.documentElement.scrollLeft + "px", r.style.position = "absolute", r.style.opacity = "0";
    const n = this.gridCtrl.getGui();
    n.appendChild(r);
    try {
      e(r);
    } catch (s) {
      console.warn("AG Grid: Browser does not support document.execCommand('copy') for clipboard operations");
    }
    t ? window.setTimeout(() => {
      t(r), n.removeChild(r);
    }, 100) : n.removeChild(r);
  }
  getRangeSize() {
    const e = this.rangeService.getCellRanges();
    let t = 0, i = 0;
    return e.length > 0 && (t = this.rangeService.getRangeStartRow(e[0]).rowIndex, i = this.rangeService.getRangeEndRow(e[0]).rowIndex), t - i + 1;
  }
};
Ai([
  S("csvCreator")
], ii.prototype, "csvCreator", void 0);
Ai([
  S("loggerFactory")
], ii.prototype, "loggerFactory", void 0);
Ai([
  S("selectionService")
], ii.prototype, "selectionService", void 0);
Ai([
  Ve("rangeService")
], ii.prototype, "rangeService", void 0);
Ai([
  S("rowModel")
], ii.prototype, "rowModel", void 0);
Ai([
  S("ctrlsService")
], ii.prototype, "ctrlsService", void 0);
Ai([
  S("valueService")
], ii.prototype, "valueService", void 0);
Ai([
  S("focusService")
], ii.prototype, "focusService", void 0);
Ai([
  S("rowRenderer")
], ii.prototype, "rowRenderer", void 0);
Ai([
  S("columnModel")
], ii.prototype, "columnModel", void 0);
Ai([
  S("cellNavigationService")
], ii.prototype, "cellNavigationService", void 0);
Ai([
  S("cellPositionUtils")
], ii.prototype, "cellPositionUtils", void 0);
Ai([
  S("rowPositionUtils")
], ii.prototype, "rowPositionUtils", void 0);
Ai([
  S("valueFormatterService")
], ii.prototype, "valueFormatterService", void 0);
Ai([
  S("valueParserService")
], ii.prototype, "valueParserService", void 0);
Ai([
  B
], ii.prototype, "init", null);
ii = VC = Ai([
  q("clipboardService")
], ii);
const hG = "30.0.5", pG = {
  version: hG,
  moduleName: Q.ClipboardModule,
  beans: [ii],
  dependantModules: [
    Pi,
    Gb
  ]
};
var df = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, vo;
(function(o) {
  o[o.EXPANDED = 0] = "EXPANDED", o[o.COLLAPSED = 1] = "COLLAPSED", o[o.INDETERMINATE = 2] = "INDETERMINATE";
})(vo || (vo = {}));
class hn extends X {
  constructor() {
    super(hn.TEMPLATE);
  }
  postConstruct() {
    this.createExpandIcons(), this.addManagedListener(this.eExpand, "click", this.onExpandClicked.bind(this)), this.addManagedListener(this.eExpand, "keydown", (t) => {
      t.key === V.SPACE && (t.preventDefault(), this.onExpandClicked());
    }), this.addManagedListener(this.eSelect.getInputElement(), "click", this.onSelectClicked.bind(this)), this.eFilterTextField.onValueChange(() => this.onFilterTextChanged()), this.addManagedListener(this.eFilterTextField.getInputElement(), "keydown", this.onMiniFilterKeyDown.bind(this)), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, this.showOrHideOptions.bind(this));
    const e = this.localeService.getLocaleTextFunc();
    this.eSelect.setInputAriaLabel(e("ariaColumnSelectAll", "Toggle Select All Columns")), this.eFilterTextField.setInputAriaLabel(e("ariaFilterColumnsInput", "Filter Columns Input")), this.activateTabIndex([this.eExpand]);
  }
  init(e) {
    this.params = e, this.columnModel.isReady() && this.showOrHideOptions();
  }
  createExpandIcons() {
    this.eExpand.appendChild(this.eExpandChecked = x.createIconNoSpan("columnSelectOpen", this.gridOptionsService)), this.eExpand.appendChild(this.eExpandUnchecked = x.createIconNoSpan("columnSelectClosed", this.gridOptionsService)), this.eExpand.appendChild(this.eExpandIndeterminate = x.createIconNoSpan("columnSelectIndeterminate", this.gridOptionsService)), this.setExpandState(vo.EXPANDED);
  }
  // we only show expand / collapse if we are showing columns
  showOrHideOptions() {
    const e = !this.params.suppressColumnFilter, t = !this.params.suppressColumnSelectAll, i = !this.params.suppressColumnExpandAll, r = this.columnModel.isPrimaryColumnGroupsPresent(), n = this.localeService.getLocaleTextFunc();
    this.eFilterTextField.setInputPlaceholder(n("searchOoo", "Search...")), x.setDisplayed(this.eFilterTextField.getGui(), e), x.setDisplayed(this.eSelect.getGui(), t), x.setDisplayed(this.eExpand, i && r);
  }
  onFilterTextChanged() {
    this.onFilterTextChangedDebounced || (this.onFilterTextChangedDebounced = x.debounce(() => {
      const e = this.eFilterTextField.getValue();
      this.dispatchEvent({ type: "filterChanged", filterText: e });
    }, hn.DEBOUNCE_DELAY)), this.onFilterTextChangedDebounced();
  }
  onMiniFilterKeyDown(e) {
    e.key === V.ENTER && setTimeout(() => this.onSelectClicked(), hn.DEBOUNCE_DELAY);
  }
  onSelectClicked() {
    this.dispatchEvent({ type: this.selectState ? "unselectAll" : "selectAll" });
  }
  onExpandClicked() {
    this.dispatchEvent({ type: this.expandState === vo.EXPANDED ? "collapseAll" : "expandAll" });
  }
  setExpandState(e) {
    this.expandState = e, x.setDisplayed(this.eExpandChecked, this.expandState === vo.EXPANDED), x.setDisplayed(this.eExpandUnchecked, this.expandState === vo.COLLAPSED), x.setDisplayed(this.eExpandIndeterminate, this.expandState === vo.INDETERMINATE);
  }
  setSelectionState(e) {
    this.selectState = e, this.eSelect.setValue(this.selectState);
  }
}
hn.DEBOUNCE_DELAY = 300;
hn.TEMPLATE = `<div class="ag-column-select-header" role="presentation">
            <div ref="eExpand" class="ag-column-select-header-icon"></div>
            <ag-checkbox ref="eSelect" class="ag-column-select-header-checkbox"></ag-checkbox>
            <ag-input-text-field class="ag-column-select-header-filter-wrapper" ref="eFilterTextField"></ag-input-text-field>
        </div>`;
df([
  S("columnModel")
], hn.prototype, "columnModel", void 0);
df([
  L("eExpand")
], hn.prototype, "eExpand", void 0);
df([
  L("eSelect")
], hn.prototype, "eSelect", void 0);
df([
  L("eFilterTextField")
], hn.prototype, "eFilterTextField", void 0);
df([
  B
], hn.prototype, "postConstruct", null);
class na {
  constructor(e, t, i, r = !1, n) {
    this.eventService = new _r(), this.displayName = e, this.dept = i, this.group = r, r ? (this.columnGroup = t, this.expanded = n, this.children = []) : this.column = t;
  }
  isGroup() {
    return this.group;
  }
  getDisplayName() {
    return this.displayName;
  }
  getColumnGroup() {
    return this.columnGroup;
  }
  getColumn() {
    return this.column;
  }
  getDept() {
    return this.dept;
  }
  isExpanded() {
    return !!this.expanded;
  }
  getChildren() {
    return this.children;
  }
  isPassesFilter() {
    return this.passesFilter;
  }
  setExpanded(e) {
    e !== this.expanded && (this.expanded = e, this.eventService.dispatchEvent({ type: na.EVENT_EXPANDED_CHANGED }));
  }
  setPassesFilter(e) {
    this.passesFilter = e;
  }
  addEventListener(e, t) {
    this.eventService.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.eventService.removeEventListener(e, t);
  }
}
na.EVENT_EXPANDED_CHANGED = "expandedChanged";
var Em = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Ru extends X {
  constructor(e, t, i) {
    super(
      /* html */
      '<div class="ag-menu"></div>'
    ), this.column = e, this.mouseEvent = t, this.parentEl = i, this.displayName = null;
  }
  postConstruct() {
    this.initializeProperties(this.column), this.buildMenuItemMap(), this.column instanceof me ? this.displayName = this.columnModel.getDisplayNameForColumn(this.column, "columnToolPanel") : this.displayName = this.columnModel.getDisplayNameForProvidedColumnGroup(null, this.column, "columnToolPanel"), this.isActive() && (this.mouseEvent.preventDefault(), this.displayContextMenu());
  }
  initializeProperties(e) {
    e instanceof Be ? this.columns = e.getLeafColumns() : this.columns = [e], this.allowGrouping = this.columns.some((t) => t.isPrimary() && t.isAllowRowGroup()), this.allowValues = this.columns.some((t) => t.isPrimary() && t.isAllowValue()), this.allowPivoting = this.columnModel.isPivotMode() && this.columns.some((t) => t.isPrimary() && t.isAllowPivot());
  }
  buildMenuItemMap() {
    const e = this.localeService.getLocaleTextFunc();
    this.menuItemMap = /* @__PURE__ */ new Map(), this.menuItemMap.set("rowGroup", {
      allowedFunction: (t) => t.isPrimary() && t.isAllowRowGroup(),
      activeFunction: (t) => t.isRowGroupActive(),
      activateLabel: () => `${e("groupBy", "Group by")} ${this.displayName}`,
      deactivateLabel: () => `${e("ungroupBy", "Un-Group by")} ${this.displayName}`,
      activateFunction: () => {
        const t = this.columnModel.getRowGroupColumns();
        this.columnModel.setRowGroupColumns(this.addColumnsToList(t), "toolPanelUi");
      },
      deActivateFunction: () => {
        const t = this.columnModel.getRowGroupColumns();
        this.columnModel.setRowGroupColumns(this.removeColumnsFromList(t), "toolPanelUi");
      },
      addIcon: "menuAddRowGroup",
      removeIcon: "menuRemoveRowGroup"
    }), this.menuItemMap.set("value", {
      allowedFunction: (t) => t.isPrimary() && t.isAllowValue(),
      activeFunction: (t) => t.isValueActive(),
      activateLabel: () => e("addToValues", `Add ${this.displayName} to values`, [this.displayName]),
      deactivateLabel: () => e("removeFromValues", `Remove ${this.displayName} from values`, [this.displayName]),
      activateFunction: () => {
        const t = this.columnModel.getValueColumns();
        this.columnModel.setValueColumns(this.addColumnsToList(t), "toolPanelUi");
      },
      deActivateFunction: () => {
        const t = this.columnModel.getValueColumns();
        this.columnModel.setValueColumns(this.removeColumnsFromList(t), "toolPanelUi");
      },
      addIcon: "valuePanel",
      removeIcon: "valuePanel"
    }), this.menuItemMap.set("pivot", {
      allowedFunction: (t) => this.columnModel.isPivotMode() && t.isPrimary() && t.isAllowPivot(),
      activeFunction: (t) => t.isPivotActive(),
      activateLabel: () => e("addToLabels", `Add ${this.displayName} to labels`, [this.displayName]),
      deactivateLabel: () => e("removeFromLabels", `Remove ${this.displayName} from labels`, [this.displayName]),
      activateFunction: () => {
        const t = this.columnModel.getPivotColumns();
        this.columnModel.setPivotColumns(this.addColumnsToList(t), "toolPanelUi");
      },
      deActivateFunction: () => {
        const t = this.columnModel.getPivotColumns();
        this.columnModel.setPivotColumns(this.removeColumnsFromList(t), "toolPanelUi");
      },
      addIcon: "pivotPanel",
      removeIcon: "pivotPanel"
    });
  }
  addColumnsToList(e) {
    return [...e].concat(this.columns.filter((t) => e.indexOf(t) === -1));
  }
  removeColumnsFromList(e) {
    return e.filter((t) => this.columns.indexOf(t) === -1);
  }
  displayContextMenu() {
    const e = this.getGui(), t = this.createBean(new Ro()), i = this.getMappedMenuItems(), r = this.localeService.getLocaleTextFunc();
    let n = () => {
    };
    e.appendChild(t.getGui()), t.addMenuItems(i), t.addManagedListener(t, _t.EVENT_MENU_ITEM_SELECTED, () => {
      this.parentEl.focus(), n();
    });
    const s = this.popupService.addPopup({
      modal: !0,
      eChild: e,
      closeOnEsc: !0,
      afterGuiAttached: () => this.focusService.focusInto(t.getGui()),
      ariaLabel: r("ariaLabelContextMenu", "Context Menu"),
      closedCallback: (a) => {
        a instanceof KeyboardEvent && this.parentEl.focus(), this.destroyBean(t);
      }
    });
    s && (n = s.hideFunc), this.popupService.positionPopupUnderMouseEvent({
      type: "columnContextMenu",
      mouseEvent: this.mouseEvent,
      ePopup: e
    });
  }
  isActive() {
    return this.allowGrouping || this.allowValues || this.allowPivoting;
  }
  getMappedMenuItems() {
    const e = [];
    for (const t of this.menuItemMap.values()) {
      const i = this.columns.some((n) => t.allowedFunction(n) && !t.activeFunction(n)), r = this.columns.some((n) => t.allowedFunction(n) && t.activeFunction(n));
      i && e.push({
        name: t.activateLabel(this.displayName),
        icon: x.createIconNoSpan(t.addIcon, this.gridOptionsService, null),
        action: () => t.activateFunction()
      }), r && e.push({
        name: t.deactivateLabel(this.displayName),
        icon: x.createIconNoSpan(t.removeIcon, this.gridOptionsService, null),
        action: () => t.deActivateFunction()
      });
    }
    return e;
  }
}
Em([
  S("columnModel")
], Ru.prototype, "columnModel", void 0);
Em([
  S("popupService")
], Ru.prototype, "popupService", void 0);
Em([
  S("focusService")
], Ru.prototype, "focusService", void 0);
Em([
  B
], Ru.prototype, "postConstruct", null);
var Gs = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class cr extends X {
  constructor(e, t, i, r) {
    super(), this.modelItem = e, this.allowDragging = t, this.eventType = i, this.focusWrapper = r, this.processingColumnStateChange = !1, this.modelItem = e, this.columnGroup = e.getColumnGroup(), this.columnDept = e.getDept(), this.displayName = e.getDisplayName(), this.allowDragging = t;
  }
  init() {
    this.setTemplate(cr.TEMPLATE), this.eDragHandle = x.createIconNoSpan("columnDrag", this.gridOptionsService), this.eDragHandle.classList.add("ag-drag-handle", "ag-column-select-column-group-drag-handle");
    const e = this.cbSelect.getGui(), t = this.cbSelect.getInputElement();
    e.insertAdjacentElement("afterend", this.eDragHandle), t.setAttribute("tabindex", "-1"), x.missing(this.displayName) && (this.displayName = ">>"), this.eLabel.innerHTML = this.displayName ? this.displayName : "", this.setupExpandContract(), this.addCssClass("ag-column-select-indent-" + this.columnDept), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onColumnStateChanged.bind(this)), this.addManagedListener(this.eLabel, "click", this.onLabelClicked.bind(this)), this.addManagedListener(this.cbSelect, rr.EVENT_CHANGED, this.onCheckboxChanged.bind(this)), this.addManagedListener(this.modelItem, na.EVENT_EXPANDED_CHANGED, this.onExpandChanged.bind(this)), this.addManagedListener(this.focusWrapper, "keydown", this.handleKeyDown.bind(this)), this.addManagedListener(this.focusWrapper, "contextmenu", this.onContextMenu.bind(this)), this.setOpenClosedIcons(), this.setupDragging(), this.onColumnStateChanged(), this.addVisibilityListenersToAllChildren(), this.refreshAriaExpanded(), this.refreshAriaLabel(), this.setupTooltip(), jp.getToolPanelClassesFromColDef(this.columnGroup.getColGroupDef(), this.gridOptionsService, null, this.columnGroup).forEach((r) => this.addOrRemoveCssClass(r, !0));
  }
  getColumns() {
    return this.columnGroup.getLeafColumns();
  }
  setupTooltip() {
    const e = this.columnGroup.getColGroupDef();
    if (!e)
      return;
    const t = () => {
      const i = e.headerTooltip;
      this.setTooltip(i);
    };
    t(), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, t);
  }
  getTooltipParams() {
    const e = super.getTooltipParams();
    return e.location = "columnToolPanelColumnGroup", e;
  }
  handleKeyDown(e) {
    switch (e.key) {
      case V.LEFT:
        e.preventDefault(), this.modelItem.setExpanded(!1);
        break;
      case V.RIGHT:
        e.preventDefault(), this.modelItem.setExpanded(!0);
        break;
      case V.SPACE:
        e.preventDefault(), this.isSelectable() && this.onSelectAllChanged(!this.isSelected());
        break;
    }
  }
  onContextMenu(e) {
    const { columnGroup: t, gridOptionsService: i } = this;
    if (i.is("functionsReadOnly"))
      return;
    const r = this.createBean(new Ru(t, e, this.focusWrapper));
    this.addDestroyFunc(() => {
      r.isAlive() && this.destroyBean(r);
    });
  }
  addVisibilityListenersToAllChildren() {
    this.columnGroup.getLeafColumns().forEach((e) => {
      this.addManagedListener(e, me.EVENT_VISIBLE_CHANGED, this.onColumnStateChanged.bind(this)), this.addManagedListener(e, me.EVENT_VALUE_CHANGED, this.onColumnStateChanged.bind(this)), this.addManagedListener(e, me.EVENT_PIVOT_CHANGED, this.onColumnStateChanged.bind(this)), this.addManagedListener(e, me.EVENT_ROW_GROUP_CHANGED, this.onColumnStateChanged.bind(this));
    });
  }
  setupDragging() {
    if (!this.allowDragging) {
      x.setDisplayed(this.eDragHandle, !1);
      return;
    }
    const e = !this.gridOptionsService.is("suppressDragLeaveHidesColumns"), t = {
      type: Dt.ToolPanel,
      eElement: this.eDragHandle,
      dragItemName: this.displayName,
      defaultIconName: e ? Te.ICON_HIDE : Te.ICON_NOT_ALLOWED,
      getDragItem: () => this.createDragItem(),
      onDragStarted: () => {
        const i = {
          type: w.EVENT_COLUMN_PANEL_ITEM_DRAG_START,
          column: this.columnGroup
        };
        this.eventService.dispatchEvent(i);
      },
      onDragStopped: () => {
        const i = {
          type: w.EVENT_COLUMN_PANEL_ITEM_DRAG_END
        };
        this.eventService.dispatchEvent(i);
      },
      onGridEnter: (i) => {
        e && this.modelItemUtils.updateColumns({
          columns: this.columnGroup.getLeafColumns(),
          visibleState: i == null ? void 0 : i.visibleState,
          pivotState: i == null ? void 0 : i.pivotState,
          eventType: this.eventType
        });
      },
      onGridExit: () => {
        e && this.onChangeCommon(!1);
      }
    };
    this.dragAndDropService.addDragSource(t, !0), this.addDestroyFunc(() => this.dragAndDropService.removeDragSource(t));
  }
  createDragItem() {
    const e = this.columnGroup.getLeafColumns(), t = {}, i = {};
    return e.forEach((r) => {
      const n = r.getId();
      t[n] = r.isVisible(), i[n] = this.modelItemUtils.createPivotState(r);
    }), {
      columns: e,
      visibleState: t,
      pivotState: i
    };
  }
  setupExpandContract() {
    this.eGroupClosedIcon.appendChild(x.createIcon("columnSelectClosed", this.gridOptionsService, null)), this.eGroupOpenedIcon.appendChild(x.createIcon("columnSelectOpen", this.gridOptionsService, null)), this.addManagedListener(this.eGroupClosedIcon, "click", this.onExpandOrContractClicked.bind(this)), this.addManagedListener(this.eGroupOpenedIcon, "click", this.onExpandOrContractClicked.bind(this));
    const e = new mt(this.eColumnGroupIcons, !0);
    this.addManagedListener(e, mt.EVENT_TAP, this.onExpandOrContractClicked.bind(this)), this.addDestroyFunc(e.destroy.bind(e));
  }
  onLabelClicked() {
    const e = !this.cbSelect.getValue();
    this.onChangeCommon(e);
  }
  onCheckboxChanged(e) {
    this.onChangeCommon(e.selected);
  }
  getVisibleLeafColumns() {
    const e = [], t = (i) => {
      i.forEach((r) => {
        r.isPassesFilter() && (r.isGroup() ? t(r.getChildren()) : e.push(r.getColumn()));
      });
    };
    return t(this.modelItem.getChildren()), e;
  }
  onChangeCommon(e) {
    this.refreshAriaLabel(), !this.processingColumnStateChange && this.modelItemUtils.selectAllChildren(this.modelItem.getChildren(), e, this.eventType);
  }
  refreshAriaLabel() {
    const e = this.localeService.getLocaleTextFunc(), t = e("ariaColumnGroup", "Column Group"), i = this.cbSelect.getValue(), r = i === void 0 ? e("ariaIndeterminate", "indeterminate") : i ? e("ariaVisible", "visible") : e("ariaHidden", "hidden"), n = e("ariaToggleVisibility", "Press SPACE to toggle visibility");
    x.setAriaLabel(this.focusWrapper, `${this.displayName} ${t}`), this.cbSelect.setInputAriaLabel(`${n} (${r})`), x.setAriaDescribedBy(this.focusWrapper, this.cbSelect.getInputElement().id);
  }
  onColumnStateChanged() {
    const e = this.workOutSelectedValue(), t = this.workOutReadOnlyValue();
    this.processingColumnStateChange = !0, this.cbSelect.setValue(e), this.cbSelect.setReadOnly(t), this.addOrRemoveCssClass("ag-column-select-column-group-readonly", t), this.processingColumnStateChange = !1;
  }
  workOutSelectedValue() {
    const e = this.columnModel.isPivotMode(), t = this.getVisibleLeafColumns();
    let i = 0, r = 0;
    if (t.forEach((n) => {
      !e && n.getColDef().lockVisible || (this.isColumnChecked(n, e) ? i++ : r++);
    }), !(i > 0 && r > 0))
      return i > 0;
  }
  workOutReadOnlyValue() {
    const e = this.columnModel.isPivotMode();
    let t = 0;
    return this.columnGroup.getLeafColumns().forEach((i) => {
      e ? i.isAnyFunctionAllowed() && t++ : i.getColDef().lockVisible || t++;
    }), t === 0;
  }
  isColumnChecked(e, t) {
    if (t) {
      const i = e.isPivotActive(), r = e.isRowGroupActive(), n = e.isValueActive();
      return i || r || n;
    }
    return e.isVisible();
  }
  onExpandOrContractClicked() {
    const e = this.modelItem.isExpanded();
    this.modelItem.setExpanded(!e);
  }
  onExpandChanged() {
    this.setOpenClosedIcons(), this.refreshAriaExpanded();
  }
  setOpenClosedIcons() {
    const e = this.modelItem.isExpanded();
    x.setDisplayed(this.eGroupClosedIcon, !e), x.setDisplayed(this.eGroupOpenedIcon, e);
  }
  refreshAriaExpanded() {
    x.setAriaExpanded(this.focusWrapper, this.modelItem.isExpanded());
  }
  getDisplayName() {
    return this.displayName;
  }
  onSelectAllChanged(e) {
    const t = this.cbSelect.getValue();
    !this.cbSelect.isReadOnly() && (e && !t || !e && t) && this.cbSelect.toggle();
  }
  isSelected() {
    return this.cbSelect.getValue();
  }
  isSelectable() {
    return !this.cbSelect.isReadOnly();
  }
  setSelected(e) {
    this.cbSelect.setValue(e, !0);
  }
}
cr.TEMPLATE = `<div class="ag-column-select-column-group" aria-hidden="true">
            <span class="ag-column-group-icons" ref="eColumnGroupIcons" >
                <span class="ag-column-group-closed-icon" ref="eGroupClosedIcon"></span>
                <span class="ag-column-group-opened-icon" ref="eGroupOpenedIcon"></span>
            </span>
            <ag-checkbox ref="cbSelect" class="ag-column-select-checkbox"></ag-checkbox>
            <span class="ag-column-select-column-label" ref="eLabel"></span>
        </div>`;
Gs([
  S("columnModel")
], cr.prototype, "columnModel", void 0);
Gs([
  S("dragAndDropService")
], cr.prototype, "dragAndDropService", void 0);
Gs([
  S("modelItemUtils")
], cr.prototype, "modelItemUtils", void 0);
Gs([
  L("cbSelect")
], cr.prototype, "cbSelect", void 0);
Gs([
  L("eLabel")
], cr.prototype, "eLabel", void 0);
Gs([
  L("eGroupOpenedIcon")
], cr.prototype, "eGroupOpenedIcon", void 0);
Gs([
  L("eGroupClosedIcon")
], cr.prototype, "eGroupClosedIcon", void 0);
Gs([
  L("eColumnGroupIcons")
], cr.prototype, "eColumnGroupIcons", void 0);
Gs([
  B
], cr.prototype, "init", null);
var Vb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const My = "ag-list-item-hovered";
class Rm extends H {
  constructor(e, t) {
    super(), this.comp = e, this.virtualList = t, this.currentDragColumn = null, this.lastHoveredColumnItem = null;
  }
  postConstruct() {
    this.addManagedListener(this.eventService, w.EVENT_COLUMN_PANEL_ITEM_DRAG_START, this.columnPanelItemDragStart.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PANEL_ITEM_DRAG_END, this.columnPanelItemDragEnd.bind(this)), this.createDropTarget(), this.createAutoScrollService();
  }
  columnPanelItemDragStart({ column: e }) {
    this.currentDragColumn = e, this.getCurrentColumns().find((r) => {
      const n = r.getColDef();
      return !!n.suppressMovable || !!n.lockPosition;
    }) && (this.moveBlocked = !0);
  }
  columnPanelItemDragEnd() {
    window.setTimeout(() => {
      this.currentDragColumn = null, this.moveBlocked = !1;
    }, 10);
  }
  createDropTarget() {
    const e = {
      isInterestedIn: (t) => t === Dt.ToolPanel,
      getIconName: () => Te[this.moveBlocked ? "ICON_NOT_ALLOWED" : "ICON_MOVE"],
      getContainer: () => this.comp.getGui(),
      onDragging: (t) => this.onDragging(t),
      onDragStop: () => this.onDragStop(),
      onDragLeave: () => this.onDragLeave()
    };
    this.dragAndDropService.addDropTarget(e);
  }
  createAutoScrollService() {
    const e = this.virtualList.getGui();
    this.autoScrollService = new Xv({
      scrollContainer: e,
      scrollAxis: "y",
      getVerticalPosition: () => e.scrollTop,
      setVerticalPosition: (t) => e.scrollTop = t
    });
  }
  onDragging(e) {
    if (!this.currentDragColumn || this.moveBlocked)
      return;
    const t = this.getDragColumnItem(e), i = this.virtualList.getComponentAt(t.rowIndex);
    if (!i)
      return;
    const r = i.getGui().parentElement;
    this.lastHoveredColumnItem && this.lastHoveredColumnItem.rowIndex === t.rowIndex && this.lastHoveredColumnItem.position === t.position || (this.autoScrollService.check(e.event), this.clearHoveredItems(), this.lastHoveredColumnItem = t, x.radioCssClass(r, `${My}`), x.radioCssClass(r, `ag-item-highlight-${t.position}`));
  }
  getDragColumnItem(e) {
    const t = this.virtualList.getGui(), i = parseFloat(window.getComputedStyle(t).paddingTop), r = this.virtualList.getRowHeight(), n = this.virtualList.getScrollTop(), s = Math.max(0, (e.y - i + n) / r), a = this.comp.getDisplayedColsList().length - 1, l = Math.min(a, s) | 0;
    return {
      rowIndex: l,
      position: Math.round(s) > s || s > a ? "bottom" : "top",
      component: this.virtualList.getComponentAt(l)
    };
  }
  onDragStop() {
    if (this.moveBlocked)
      return;
    const e = this.getTargetIndex(), t = this.getCurrentColumns();
    e != null && this.columnModel.moveColumns(t, e, "toolPanelUi"), this.clearHoveredItems(), this.autoScrollService.ensureCleared();
  }
  getMoveDiff(e) {
    const t = this.columnModel.getAllGridColumns(), i = this.getCurrentColumns(), r = i[0], n = i.length;
    return t.indexOf(r) < e ? n : 0;
  }
  getCurrentColumns() {
    return this.currentDragColumn instanceof Be ? this.currentDragColumn.getLeafColumns() : [this.currentDragColumn];
  }
  getTargetIndex() {
    if (!this.lastHoveredColumnItem)
      return null;
    const e = this.lastHoveredColumnItem.component;
    let t = this.lastHoveredColumnItem.position === "top", i;
    e instanceof cr ? (i = e.getColumns()[0], t = !0) : i = e.getColumn();
    const r = this.columnModel.getAllGridColumns().indexOf(i), n = t ? r : r + 1, s = this.getMoveDiff(n);
    return n - s;
  }
  onDragLeave() {
    this.clearHoveredItems(), this.autoScrollService.ensureCleared();
  }
  clearHoveredItems() {
    this.virtualList.getGui().querySelectorAll(`.${My}`).forEach((t) => {
      [
        My,
        "ag-item-highlight-top",
        "ag-item-highlight-bottom"
      ].forEach((i) => {
        t.classList.remove(i);
      });
    }), this.lastHoveredColumnItem = null;
  }
}
Vb([
  S("columnModel")
], Rm.prototype, "columnModel", void 0);
Vb([
  S("dragAndDropService")
], Rm.prototype, "dragAndDropService", void 0);
Vb([
  B
], Rm.prototype, "postConstruct", null);
var Tu = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Wo extends X {
  constructor(e, t, i, r) {
    super(), this.allowDragging = t, this.groupsExist = i, this.focusWrapper = r, this.processingColumnStateChange = !1, this.column = e.getColumn(), this.columnDept = e.getDept(), this.displayName = e.getDisplayName();
  }
  init() {
    this.setTemplate(Wo.TEMPLATE), this.eDragHandle = x.createIconNoSpan("columnDrag", this.gridOptionsService), this.eDragHandle.classList.add("ag-drag-handle", "ag-column-select-column-drag-handle");
    const e = this.cbSelect.getGui(), t = this.cbSelect.getInputElement();
    e.insertAdjacentElement("afterend", this.eDragHandle), t.setAttribute("tabindex", "-1");
    const i = x.escapeString(this.displayName);
    this.eLabel.innerHTML = i;
    const r = this.columnDept;
    this.groupsExist && this.addCssClass("ag-column-select-add-group-indent"), this.addCssClass(`ag-column-select-indent-${r}`), this.setupDragging(), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onColumnStateChanged.bind(this)), this.addManagedListener(this.column, me.EVENT_VALUE_CHANGED, this.onColumnStateChanged.bind(this)), this.addManagedListener(this.column, me.EVENT_PIVOT_CHANGED, this.onColumnStateChanged.bind(this)), this.addManagedListener(this.column, me.EVENT_ROW_GROUP_CHANGED, this.onColumnStateChanged.bind(this)), this.addManagedListener(this.column, me.EVENT_VISIBLE_CHANGED, this.onColumnStateChanged.bind(this)), this.addManagedListener(this.focusWrapper, "keydown", this.handleKeyDown.bind(this)), this.addManagedListener(this.focusWrapper, "contextmenu", this.onContextMenu.bind(this)), this.addManagedPropertyListener("functionsReadOnly", this.onColumnStateChanged.bind(this)), this.addManagedListener(this.cbSelect, rr.EVENT_CHANGED, this.onCheckboxChanged.bind(this)), this.addManagedListener(this.eLabel, "click", this.onLabelClicked.bind(this)), this.onColumnStateChanged(), this.refreshAriaLabel(), this.setupTooltip(), jp.getToolPanelClassesFromColDef(this.column.getColDef(), this.gridOptionsService, this.column, null).forEach((s) => this.addOrRemoveCssClass(s, !0));
  }
  getColumn() {
    return this.column;
  }
  setupTooltip() {
    const e = () => {
      const t = this.column.getColDef().headerTooltip;
      this.setTooltip(t);
    };
    e(), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, e);
  }
  getTooltipParams() {
    const e = super.getTooltipParams();
    return e.location = "columnToolPanelColumn", e.colDef = this.column.getColDef(), e;
  }
  onContextMenu(e) {
    const { column: t, gridOptionsService: i } = this;
    if (i.is("functionsReadOnly"))
      return;
    const r = this.createBean(new Ru(t, e, this.focusWrapper));
    this.addDestroyFunc(() => {
      r.isAlive() && this.destroyBean(r);
    });
  }
  handleKeyDown(e) {
    e.key === V.SPACE && (e.preventDefault(), this.isSelectable() && this.onSelectAllChanged(!this.isSelected()));
  }
  onLabelClicked() {
    if (this.gridOptionsService.is("functionsReadOnly"))
      return;
    const e = !this.cbSelect.getValue();
    this.onChangeCommon(e);
  }
  onCheckboxChanged(e) {
    this.onChangeCommon(e.selected);
  }
  onChangeCommon(e) {
    this.cbSelect.isReadOnly() || (this.refreshAriaLabel(), !this.processingColumnStateChange && this.modelItemUtils.setColumn(this.column, e, "toolPanelUi"));
  }
  refreshAriaLabel() {
    const e = this.localeService.getLocaleTextFunc(), t = e("ariaColumn", "Column"), i = this.cbSelect.getValue() ? e("ariaVisible", "visible") : e("ariaHidden", "hidden"), r = e("ariaToggleVisibility", "Press SPACE to toggle visibility");
    x.setAriaLabel(this.focusWrapper, `${this.displayName} ${t}`), this.cbSelect.setInputAriaLabel(`${r} (${i})`), x.setAriaDescribedBy(this.focusWrapper, this.cbSelect.getInputElement().id);
  }
  setupDragging() {
    if (!this.allowDragging) {
      x.setDisplayed(this.eDragHandle, !1);
      return;
    }
    const e = !this.gridOptionsService.is("suppressDragLeaveHidesColumns"), t = {
      type: Dt.ToolPanel,
      eElement: this.eDragHandle,
      dragItemName: this.displayName,
      defaultIconName: e ? Te.ICON_HIDE : Te.ICON_NOT_ALLOWED,
      getDragItem: () => this.createDragItem(),
      onDragStarted: () => {
        const i = {
          type: w.EVENT_COLUMN_PANEL_ITEM_DRAG_START,
          column: this.column
        };
        this.eventService.dispatchEvent(i);
      },
      onDragStopped: () => {
        const i = {
          type: w.EVENT_COLUMN_PANEL_ITEM_DRAG_END
        };
        this.eventService.dispatchEvent(i);
      },
      onGridEnter: (i) => {
        e && this.modelItemUtils.updateColumns({
          columns: [this.column],
          visibleState: i == null ? void 0 : i.visibleState,
          pivotState: i == null ? void 0 : i.pivotState,
          eventType: "toolPanelUi"
        });
      },
      onGridExit: () => {
        e && this.onChangeCommon(!1);
      }
    };
    this.dragAndDropService.addDragSource(t, !0), this.addDestroyFunc(() => this.dragAndDropService.removeDragSource(t));
  }
  createDragItem() {
    const e = this.column.getColId(), t = { [e]: this.column.isVisible() }, i = { [e]: this.modelItemUtils.createPivotState(this.column) };
    return {
      columns: [this.column],
      visibleState: t,
      pivotState: i
    };
  }
  onColumnStateChanged() {
    this.processingColumnStateChange = !0;
    const e = this.columnModel.isPivotMode();
    if (e) {
      const n = this.column.isAnyFunctionActive();
      this.cbSelect.setValue(n);
    } else
      this.cbSelect.setValue(this.column.isVisible());
    let t = !0, i = !0;
    if (e) {
      const n = this.gridOptionsService.is("functionsReadOnly"), s = !this.column.isAnyFunctionAllowed();
      t = !n && !s, i = t;
    } else {
      const { enableRowGroup: n, enableValue: s, lockPosition: a, suppressMovable: l, lockVisible: c } = this.column.getColDef(), d = !!n || !!s, u = !!a || !!l;
      t = !c, i = d || !u;
    }
    this.cbSelect.setReadOnly(!t), this.eDragHandle.classList.toggle("ag-column-select-column-readonly", !i), this.addOrRemoveCssClass("ag-column-select-column-readonly", !i && !t);
    const r = e && this.gridOptionsService.is("functionsPassive");
    this.cbSelect.setPassive(r), this.processingColumnStateChange = !1;
  }
  getDisplayName() {
    return this.displayName;
  }
  onSelectAllChanged(e) {
    e !== this.cbSelect.getValue() && (this.cbSelect.isReadOnly() || this.cbSelect.toggle());
  }
  isSelected() {
    return this.cbSelect.getValue();
  }
  isSelectable() {
    return !this.cbSelect.isReadOnly();
  }
  isExpandable() {
    return !1;
  }
  setExpanded(e) {
    console.warn("AG Grid: can not expand a column item that does not represent a column group header");
  }
}
Wo.TEMPLATE = `<div class="ag-column-select-column" aria-hidden="true">
            <ag-checkbox ref="cbSelect" class="ag-column-select-checkbox"></ag-checkbox>
            <span class="ag-column-select-column-label" ref="eLabel"></span>
        </div>`;
Tu([
  S("columnModel")
], Wo.prototype, "columnModel", void 0);
Tu([
  S("dragAndDropService")
], Wo.prototype, "dragAndDropService", void 0);
Tu([
  S("modelItemUtils")
], Wo.prototype, "modelItemUtils", void 0);
Tu([
  L("eLabel")
], Wo.prototype, "eLabel", void 0);
Tu([
  L("cbSelect")
], Wo.prototype, "cbSelect", void 0);
Tu([
  B
], Wo.prototype, "init", null);
var Tm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class fG {
  constructor(e) {
    this.items = e;
  }
  getRowCount() {
    return this.items.length;
  }
  getRow(e) {
    return this.items[e];
  }
}
const gG = "ag-column-select-list";
class Ka extends X {
  constructor() {
    super(Ka.TEMPLATE), this.destroyColumnItemFuncs = [];
  }
  destroyColumnTree() {
    this.allColsTree = [], this.destroyColumnItemFuncs.forEach((e) => e()), this.destroyColumnItemFuncs = [];
  }
  init(e, t, i) {
    this.params = e, this.allowDragging = t, this.eventType = i, this.params.suppressSyncLayoutWithGrid || this.addManagedListener(this.eventService, w.EVENT_COLUMN_MOVED, this.onColumnsChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, this.onColumnsChanged.bind(this)), [
      w.EVENT_COLUMN_PIVOT_CHANGED,
      w.EVENT_COLUMN_PIVOT_MODE_CHANGED,
      w.EVENT_COLUMN_ROW_GROUP_CHANGED,
      w.EVENT_COLUMN_VALUE_CHANGED,
      w.EVENT_COLUMN_VISIBLE,
      w.EVENT_NEW_COLUMNS_LOADED
    ].forEach((a) => {
      this.addManagedListener(this.eventService, a, this.fireSelectionChangedEvent.bind(this));
    }), this.expandGroupsByDefault = !this.params.contractColumnSelection;
    const s = this.localeService.getLocaleTextFunc()("ariaColumnList", "Column List");
    this.virtualList = this.createManagedBean(new Ls("column-select", "tree", s)), this.appendChild(this.virtualList.getGui()), this.virtualList.setComponentCreator((a, l) => (x.setAriaLevel(l, a.getDept() + 1), this.createComponentFromItem(a, l))), this.columnModel.isReady() && this.onColumnsChanged(), !e.suppressColumnMove && !this.gridOptionsService.is("suppressMovableColumns") && this.createManagedBean(new Rm(this, this.virtualList));
  }
  createComponentFromItem(e, t) {
    if (e.isGroup()) {
      const r = new cr(e, this.allowDragging, this.eventType, t);
      return this.getContext().createBean(r), r;
    }
    const i = new Wo(e, this.allowDragging, this.groupsExist, t);
    return this.getContext().createBean(i), i;
  }
  onColumnsChanged() {
    const e = this.getExpandedStates(), t = this.columnModel.isPivotMode();
    !this.params.suppressSyncLayoutWithGrid && !t ? this.buildTreeFromWhatGridIsDisplaying() : this.buildTreeFromProvidedColumnDefs(), this.setExpandedStates(e), this.markFilteredColumns(), this.flattenAndFilterModel();
  }
  getDisplayedColsList() {
    return this.displayedColsList;
  }
  getExpandedStates() {
    if (!this.allColsTree)
      return {};
    const e = {};
    return this.forEachItem((t) => {
      if (!t.isGroup())
        return;
      const i = t.getColumnGroup();
      i && (e[i.getId()] = t.isExpanded());
    }), e;
  }
  setExpandedStates(e) {
    this.allColsTree && this.forEachItem((t) => {
      if (!t.isGroup())
        return;
      const i = t.getColumnGroup();
      if (i) {
        const r = e[i.getId()];
        r != null && t.setExpanded(r);
      }
    });
  }
  buildTreeFromWhatGridIsDisplaying() {
    this.colDefService.syncLayoutWithGrid(this.setColumnLayout.bind(this));
  }
  setColumnLayout(e) {
    const t = this.colDefService.createColumnTree(e);
    this.buildListModel(t), this.groupsExist = e.some((i) => i && typeof i.children != "undefined"), this.markFilteredColumns(), this.flattenAndFilterModel();
  }
  buildTreeFromProvidedColumnDefs() {
    this.buildListModel(this.columnModel.getPrimaryColumnTree()), this.groupsExist = this.columnModel.isPrimaryColumnGroupsPresent();
  }
  buildListModel(e) {
    const t = this.onColumnExpanded.bind(this), i = (a) => {
      a.addEventListener(na.EVENT_EXPANDED_CHANGED, t);
      const l = a.removeEventListener.bind(a, na.EVENT_EXPANDED_CHANGED, t);
      this.destroyColumnItemFuncs.push(l);
    }, r = (a, l, c) => {
      a.forEach((d) => {
        d instanceof Be ? n(d, l, c) : s(d, l, c);
      });
    }, n = (a, l, c) => {
      const d = a.getColGroupDef();
      if (d && d.suppressColumnsToolPanel)
        return;
      if (a.isPadding()) {
        r(a.getChildren(), l, c);
        return;
      }
      const h = this.columnModel.getDisplayNameForProvidedColumnGroup(null, a, "columnToolPanel"), p = new na(h, a, l, !0, this.expandGroupsByDefault);
      c.push(p), i(p), r(a.getChildren(), l + 1, p.getChildren());
    }, s = (a, l, c) => {
      if (a.getColDef() && a.getColDef().suppressColumnsToolPanel)
        return;
      const u = this.columnModel.getDisplayNameForColumn(a, "columnToolPanel");
      c.push(new na(u, a, l));
    };
    this.destroyColumnTree(), r(e, 0, this.allColsTree);
  }
  onColumnExpanded() {
    this.flattenAndFilterModel();
  }
  flattenAndFilterModel() {
    this.displayedColsList = [];
    const e = (i) => {
      i.isPassesFilter() && (this.displayedColsList.push(i), i.isGroup() && i.isExpanded() && i.getChildren().forEach(e));
    };
    this.allColsTree.forEach(e), this.virtualList.setModel(new fG(this.displayedColsList));
    const t = this.virtualList.getLastFocusedRow();
    this.virtualList.refresh(), t != null && this.focusRowIfAlive(t), this.notifyListeners();
  }
  focusRowIfAlive(e) {
    window.setTimeout(() => {
      this.isAlive() && this.virtualList.focusRow(e);
    }, 0);
  }
  forEachItem(e) {
    const t = (i) => {
      i.forEach((r) => {
        e(r), r.isGroup() && t(r.getChildren());
      });
    };
    t(this.allColsTree);
  }
  doSetExpandedAll(e) {
    this.forEachItem((t) => {
      t.isGroup() && t.setExpanded(e);
    });
  }
  setGroupsExpanded(e, t) {
    if (!t) {
      this.doSetExpandedAll(e);
      return;
    }
    const i = [];
    this.forEachItem((n) => {
      if (!n.isGroup())
        return;
      const s = n.getColumnGroup().getId();
      t.indexOf(s) >= 0 && (n.setExpanded(e), i.push(s));
    });
    const r = t.filter((n) => !x.includes(i, n));
    r.length > 0 && console.warn("AG Grid: unable to find group(s) for supplied groupIds:", r);
  }
  getExpandState() {
    let e = 0, t = 0;
    return this.forEachItem((i) => {
      i.isGroup() && (i.isExpanded() ? e++ : t++);
    }), e > 0 && t > 0 ? vo.INDETERMINATE : t > 0 ? vo.COLLAPSED : vo.EXPANDED;
  }
  doSetSelectedAll(e) {
    this.modelItemUtils.selectAllChildren(this.allColsTree, e, this.eventType);
  }
  getSelectionState() {
    let e = 0, t = 0;
    const i = this.columnModel.isPivotMode();
    if (this.forEachItem((r) => {
      if (r.isGroup() || !r.isPassesFilter())
        return;
      const n = r.getColumn(), s = n.getColDef();
      let a;
      if (i) {
        if (!n.isAllowPivot() && !n.isAllowRowGroup() && !n.isAllowValue())
          return;
        a = n.isValueActive() || n.isPivotActive() || n.isRowGroupActive();
      } else {
        if (s.lockVisible)
          return;
        a = n.isVisible();
      }
      a ? e++ : t++;
    }), !(e > 0 && t > 0))
      return !(e === 0 || t > 0);
  }
  setFilterText(e) {
    this.filterText = x.exists(e) ? e.toLowerCase() : null, this.markFilteredColumns(), this.flattenAndFilterModel();
  }
  markFilteredColumns() {
    const e = (i) => {
      if (!x.exists(this.filterText))
        return !0;
      const r = i.getDisplayName();
      return r == null || r.toLowerCase().indexOf(this.filterText) !== -1;
    }, t = (i, r) => {
      let n = !1;
      if (i.isGroup()) {
        const a = e(i);
        i.getChildren().forEach((l) => {
          const c = t(l, a || r);
          c && (n = c);
        });
      }
      const s = r || n ? !0 : e(i);
      return i.setPassesFilter(s), s;
    };
    this.allColsTree.forEach((i) => t(i, !1));
  }
  notifyListeners() {
    this.fireGroupExpandedEvent(), this.fireSelectionChangedEvent();
  }
  fireGroupExpandedEvent() {
    const e = this.getExpandState();
    this.dispatchEvent({ type: "groupExpanded", state: e });
  }
  fireSelectionChangedEvent() {
    const e = this.getSelectionState();
    this.dispatchEvent({ type: "selectionChanged", state: e });
  }
}
Ka.TEMPLATE = `<div class="${gG}" role="presentation"></div>`;
Tm([
  S("columnModel")
], Ka.prototype, "columnModel", void 0);
Tm([
  S("toolPanelColDefService")
], Ka.prototype, "colDefService", void 0);
Tm([
  S("modelItemUtils")
], Ka.prototype, "modelItemUtils", void 0);
Tm([
  dt
], Ka.prototype, "destroyColumnTree", null);
var Bb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class sp extends X {
  createTemplate() {
    return (
      /* html */
      `<div class="ag-pivot-mode-panel">
                <ag-toggle-button ref="cbPivotMode" class="ag-pivot-mode-select"></ag-toggle-button>
            </div>`
    );
  }
  init() {
    this.setTemplate(this.createTemplate()), this.cbPivotMode.setValue(this.columnModel.isPivotMode());
    const e = this.localeService.getLocaleTextFunc();
    this.cbPivotMode.setLabel(e("pivotMode", "Pivot Mode")), this.addManagedListener(this.cbPivotMode, rr.EVENT_CHANGED, this.onBtPivotMode.bind(this)), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, this.onPivotModeChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onPivotModeChanged.bind(this));
  }
  onBtPivotMode() {
    const e = !!this.cbPivotMode.getValue();
    if (e !== this.columnModel.isPivotMode()) {
      this.columnModel.setPivotMode(e, "toolPanelUi");
      const t = this.gridOptionsService.api;
      t && t.refreshHeader();
    }
  }
  onPivotModeChanged() {
    const e = this.columnModel.isPivotMode();
    this.cbPivotMode.setValue(e);
  }
}
Bb([
  S("columnModel")
], sp.prototype, "columnModel", void 0);
Bb([
  L("cbPivotMode")
], sp.prototype, "cbPivotMode", void 0);
Bb([
  su
], sp.prototype, "init", null);
var uc = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Ts = class extends H {
  init() {
    this.alwaysAggregateAtRootLevel = this.gridOptionsService.is("alwaysAggregateAtRootLevel"), this.addManagedPropertyListener("alwaysAggregateAtRootLevel", (e) => this.alwaysAggregateAtRootLevel = e.currentValue), this.groupIncludeTotalFooter = this.gridOptionsService.is("groupIncludeTotalFooter"), this.addManagedPropertyListener("groupIncludeTotalFooter", (e) => this.groupIncludeTotalFooter = e.currentValue);
  }
  // it's possible to recompute the aggregate without doing the other parts
  // + api.refreshClientSideRowModel('aggregate')
  execute(e) {
    const t = x.missingOrEmpty(this.columnModel.getValueColumns()), i = !this.gridOptionsService.getCallback("getGroupRowAgg"), r = e.changedPath && e.changedPath.isActive();
    if (t && i && r)
      return;
    const n = this.createAggDetails(e);
    this.recursivelyCreateAggData(n);
  }
  createAggDetails(e) {
    const t = this.columnModel.isPivotActive(), i = this.columnModel.getValueColumns(), r = t ? this.columnModel.getPivotColumns() : [];
    return {
      changedPath: e.changedPath,
      valueColumns: i,
      pivotColumns: r
    };
  }
  isSuppressAggFilteredOnly() {
    return this.gridOptionsService.getGroupAggFiltering() !== void 0 || this.gridOptionsService.is("suppressAggFilteredOnly");
  }
  recursivelyCreateAggData(e) {
    this.filteredOnly = !this.isSuppressAggFilteredOnly();
    const t = (i) => {
      if (!i.hasChildren()) {
        i.aggData && i.setAggData(null);
        return;
      }
      if (i.level === -1 && !this.groupIncludeTotalFooter) {
        const s = !this.columnModel.isPivotMode();
        if (!this.alwaysAggregateAtRootLevel && s)
          return;
      }
      this.aggregateRowNode(i, e);
    };
    e.changedPath.forEachChangedNodeDepthFirst(t, !0);
  }
  aggregateRowNode(e, t) {
    const i = t.valueColumns.length === 0, r = t.pivotColumns.length === 0, n = this.gridOptionsService.getCallback("getGroupRowAgg");
    let s;
    if (n) {
      const a = { nodes: e.childrenAfterFilter };
      s = n(a);
    } else
      i ? s = null : r ? s = this.aggregateRowNodeUsingValuesOnly(e, t) : s = this.aggregateRowNodeUsingValuesAndPivot(e);
    e.setAggData(s), e.sibling && e.sibling.setAggData(s);
  }
  aggregateRowNodeUsingValuesAndPivot(e) {
    var t;
    const i = {}, r = (t = this.columnModel.getSecondaryColumns()) !== null && t !== void 0 ? t : [];
    return r.forEach((n) => {
      const { pivotValueColumn: s, pivotTotalColumnIds: a, colId: l, pivotKeys: c } = n.getColDef();
      if (x.exists(a))
        return;
      const d = c != null ? c : [];
      let u;
      e.leafGroup ? u = this.getValuesFromMappedSet(e.childrenMapped, d, s) : u = this.getValuesPivotNonLeaf(e, l), i[l] = this.aggregateValues(u, s.getAggFunc(), s, e, n);
    }), r.forEach((n) => {
      const { pivotValueColumn: s, pivotTotalColumnIds: a, colId: l } = n.getColDef();
      if (!x.exists(a))
        return;
      const c = [];
      !a || !a.length || (a.forEach((d) => {
        c.push(i[d]);
      }), i[l] = this.aggregateValues(c, s.getAggFunc(), s, e, n));
    }), i;
  }
  aggregateRowNodeUsingValuesOnly(e, t) {
    const i = {}, r = t.changedPath.isActive() ? t.changedPath.getValueColumnsForNode(e, t.valueColumns) : t.valueColumns, n = t.changedPath.isActive() ? t.changedPath.getNotValueColumnsForNode(e, t.valueColumns) : null, s = this.getValuesNormal(e, r), a = e.aggData;
    return r.forEach((l, c) => {
      i[l.getId()] = this.aggregateValues(s[c], l.getAggFunc(), l, e);
    }), n && a && n.forEach((l) => {
      i[l.getId()] = a[l.getId()];
    }), i;
  }
  getValuesPivotNonLeaf(e, t) {
    const i = [];
    return e.childrenAfterFilter.forEach((r) => {
      const n = r.aggData[t];
      i.push(n);
    }), i;
  }
  getValuesFromMappedSet(e, t, i) {
    let r = e;
    if (t.forEach((s) => r = r ? r[s] : null), !r)
      return [];
    const n = [];
    return r.forEach((s) => {
      const a = this.valueService.getValue(i, s);
      n.push(a);
    }), n;
  }
  getValuesNormal(e, t) {
    const i = [];
    t.forEach(() => i.push([]));
    const r = t.length, n = this.filteredOnly ? e.childrenAfterFilter : e.childrenAfterGroup, s = n.length;
    for (let a = 0; a < s; a++) {
      const l = n[a];
      for (let c = 0; c < r; c++) {
        const d = t[c], u = this.valueService.getValue(d, l);
        i[c].push(u);
      }
    }
    return i;
  }
  aggregateValues(e, t, i, r, n) {
    const s = typeof t == "string" ? this.aggFuncService.getAggFunc(t) : t;
    if (typeof s != "function")
      return console.error(`AG Grid: unrecognised aggregation function ${t}`), null;
    const a = s, l = {
      values: e,
      column: i,
      colDef: i ? i.getColDef() : void 0,
      pivotResultColumn: n,
      rowNode: r,
      data: r ? r.data : void 0,
      api: this.gridApi,
      columnApi: this.columnApi,
      context: this.gridOptionsService.context
    };
    return a(l);
  }
};
uc([
  S("columnModel")
], Ts.prototype, "columnModel", void 0);
uc([
  S("valueService")
], Ts.prototype, "valueService", void 0);
uc([
  S("aggFuncService")
], Ts.prototype, "aggFuncService", void 0);
uc([
  S("gridApi")
], Ts.prototype, "gridApi", void 0);
uc([
  S("columnApi")
], Ts.prototype, "columnApi", void 0);
uc([
  B
], Ts.prototype, "init", null);
Ts = uc([
  q("aggregationStage")
], Ts);
class _y {
  constructor() {
    this.allSets = {}, this.allParents = [];
  }
  removeFromChildrenAfterGroup(e, t) {
    const i = this.getSet(e);
    i.removeFromChildrenAfterGroup[t.id] = !0;
  }
  isRemoveFromAllLeafChildren(e, t) {
    return !!this.getSet(e).removeFromAllLeafChildren[t.id];
  }
  preventRemoveFromAllLeafChildren(e, t) {
    const i = this.getSet(e);
    delete i.removeFromAllLeafChildren[t.id];
  }
  removeFromAllLeafChildren(e, t) {
    const i = this.getSet(e);
    i.removeFromAllLeafChildren[t.id] = !0;
  }
  getSet(e) {
    return this.allSets[e.id] || (this.allSets[e.id] = {
      removeFromAllLeafChildren: {},
      removeFromChildrenAfterGroup: {}
    }, this.allParents.push(e)), this.allSets[e.id];
  }
  getAllParents() {
    return this.allParents;
  }
  flush() {
    this.allParents.forEach((e) => {
      const t = this.allSets[e.id];
      e.childrenAfterGroup = e.childrenAfterGroup.filter((i) => !t.removeFromChildrenAfterGroup[i.id]), e.allLeafChildren = e.allLeafChildren.filter((i) => !t.removeFromAllLeafChildren[i.id]), e.updateHasChildren(), e.sibling && (e.sibling.childrenAfterGroup = e.childrenAfterGroup, e.sibling.allLeafChildren = e.allLeafChildren);
    }), this.allSets = {}, this.allParents.length = 0;
  }
}
var hc = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let xs = class extends H {
  constructor() {
    super(...arguments), this.groupIdSequence = new Ei();
  }
  postConstruct() {
    this.usingTreeData = this.gridOptionsService.isTreeData(), this.usingTreeData && (this.getDataPath = this.gridOptionsService.get("getDataPath"));
  }
  execute(e) {
    const t = this.createGroupingDetails(e);
    if (t.transactions)
      this.handleTransaction(t);
    else {
      const i = e.afterColumnsChanged === !0;
      this.shotgunResetEverything(t, i);
    }
    this.positionLeafsAndGroups(e.changedPath), this.orderGroups(t.rootNode), this.selectableService.updateSelectableAfterGrouping(t.rootNode);
  }
  positionLeafsAndGroups(e) {
    this.usingTreeData || e.forEachChangedNodeDepthFirst((t) => {
      if (t.childrenAfterGroup) {
        const i = [], r = [];
        let n;
        t.childrenAfterGroup.forEach((s) => {
          var a;
          !((a = s.childrenAfterGroup) === null || a === void 0) && a.length ? s.key === "" && !n ? n = s : r.push(s) : i.push(s);
        }), n && r.push(n), t.childrenAfterGroup = [...i, ...r];
      }
    }, !1);
  }
  createGroupingDetails(e) {
    const { rowNode: t, changedPath: i, rowNodeTransactions: r, rowNodeOrder: n } = e, s = this.usingTreeData ? null : this.columnModel.getRowGroupColumns();
    return {
      // someone complained that the parent attribute was causing some change detection
      // to break is some angular add-on - which i never used. taking the parent out breaks
      // a cyclic dependency, hence this flag got introduced.
      includeParents: !this.gridOptionsService.is("suppressParentsInRowNodes"),
      expandByDefault: this.gridOptionsService.getNum("groupDefaultExpanded"),
      groupedCols: s,
      rootNode: t,
      pivotMode: this.columnModel.isPivotMode(),
      groupedColCount: this.usingTreeData || !s ? 0 : s.length,
      rowNodeOrder: n,
      transactions: r,
      // if no transaction, then it's shotgun, changed path would be 'not active' at this point anyway
      changedPath: i
    };
  }
  handleTransaction(e) {
    e.transactions.forEach((t) => {
      const i = this.usingTreeData ? void 0 : new _y();
      if (x.existsAndNotEmpty(t.remove) && this.removeNodes(t.remove, e, i), x.existsAndNotEmpty(t.update) && this.moveNodesInWrongPath(t.update, e, i), x.existsAndNotEmpty(t.add) && this.insertNodes(t.add, e, !1), i) {
        const r = i.getAllParents().slice();
        i.flush(), this.removeEmptyGroups(r, e);
      }
    }), e.rowNodeOrder && this.sortChildren(e);
  }
  // this is used when doing delta updates, eg Redux, keeps nodes in right order
  sortChildren(e) {
    e.changedPath.forEachChangedNodeDepthFirst((t) => {
      if (!t.childrenAfterGroup)
        return;
      x.sortRowNodesByOrder(t.childrenAfterGroup, e.rowNodeOrder) && e.changedPath.addParentNode(t);
    }, !1, !0);
  }
  orderGroups(e) {
    if (this.usingTreeData)
      return;
    const t = this.gridOptionsService.getCallback("initialGroupOrderComparator");
    x.exists(t) && i(e);
    function i(r) {
      x.exists(r.childrenAfterGroup) && // we only want to sort groups, so we do not sort leafs (a leaf group has leafs as children)
      !r.leafGroup && (r.childrenAfterGroup.sort((s, a) => t({ nodeA: s, nodeB: a })), r.childrenAfterGroup.forEach((s) => i(s)));
    }
  }
  getExistingPathForNode(e, t) {
    const i = [];
    let r = this.usingTreeData ? e : e.parent;
    for (; r && r !== t.rootNode; )
      i.push({
        key: r.key,
        rowGroupColumn: r.rowGroupColumn,
        field: r.field
      }), r = r.parent;
    return i.reverse(), i;
  }
  moveNodesInWrongPath(e, t, i) {
    e.forEach((r) => {
      t.changedPath.isActive() && t.changedPath.addParentNode(r.parent);
      const n = (c) => c.key, s = this.getExistingPathForNode(r, t).map(n), a = this.getGroupInfo(r, t).map(n);
      x.areEqual(s, a) || this.moveNode(r, t, i);
    });
  }
  moveNode(e, t, i) {
    if (this.removeNodesInStages([e], t, i), this.insertOneNode(e, t, !0, i), e.setData(e.data), t.changedPath.isActive()) {
      const r = e.parent;
      t.changedPath.addParentNode(r);
    }
  }
  removeNodes(e, t, i) {
    this.removeNodesInStages(e, t, i), t.changedPath.isActive() && e.forEach((r) => t.changedPath.addParentNode(r.parent));
  }
  removeNodesInStages(e, t, i) {
    if (this.removeNodesFromParents(e, t, i), this.usingTreeData) {
      this.postRemoveCreateFillerNodes(e, t);
      const r = e.map((n) => n.parent);
      this.removeEmptyGroups(r, t);
    }
  }
  forEachParentGroup(e, t, i) {
    let r = t;
    for (; r && r !== e.rootNode; )
      i(r), r = r.parent;
  }
  removeNodesFromParents(e, t, i) {
    const r = i == null, n = i || new _y();
    e.forEach((s) => {
      this.removeFromParent(s, n), this.forEachParentGroup(t, s.parent, (a) => {
        n.removeFromAllLeafChildren(a, s);
      });
    }), r && n.flush();
  }
  postRemoveCreateFillerNodes(e, t) {
    e.forEach((i) => {
      if (i.hasChildren()) {
        const n = this.getExistingPathForNode(i, t), s = this.findParentForNode(i, n, t);
        s.expanded = i.expanded, s.allLeafChildren = i.allLeafChildren, s.childrenAfterGroup = i.childrenAfterGroup, s.childrenMapped = i.childrenMapped, s.updateHasChildren(), s.childrenAfterGroup.forEach((a) => a.parent = s);
      }
    });
  }
  removeEmptyGroups(e, t) {
    let i = !0;
    const r = (n) => {
      const s = this.getChildrenMappedKey(n.key, n.rowGroupColumn), a = n.parent;
      return (a && a.childrenMapped ? !a.childrenMapped[s] : !0) ? !1 : !!n.isEmptyRowGroupNode();
    };
    for (; i; ) {
      i = !1;
      const n = new _y();
      e.forEach((s) => {
        this.forEachParentGroup(t, s, (a) => {
          r(a) && (i = !0, this.removeFromParent(a, n), a.setSelectedParams({ newValue: !1, source: "rowGroupChanged" }));
        });
      }), n.flush();
    }
  }
  // removes the node from the parent by:
  // a) removing from childrenAfterGroup (using batchRemover if present, otherwise immediately)
  // b) removing from childrenMapped (immediately)
  // c) setRowTop(null) - as the rowRenderer uses this to know the RowNode is no longer needed
  // d) setRowIndex(null) - as the rowNode will no longer be displayed.
  removeFromParent(e, t) {
    e.parent && (t ? t.removeFromChildrenAfterGroup(e.parent, e) : (x.removeFromArray(e.parent.childrenAfterGroup, e), e.parent.updateHasChildren()));
    const i = this.getChildrenMappedKey(e.key, e.rowGroupColumn);
    e.parent && e.parent.childrenMapped && (e.parent.childrenMapped[i] = void 0), e.setRowTop(null), e.setRowIndex(null);
  }
  addToParent(e, t) {
    const i = this.getChildrenMappedKey(e.key, e.rowGroupColumn);
    t && (t.childrenMapped != null && (t.childrenMapped[i] = e), t.childrenAfterGroup.push(e), t.updateHasChildren());
  }
  areGroupColsEqual(e, t) {
    return e == null || t == null || e.pivotMode !== t.pivotMode ? !1 : x.areEqual(e.groupedCols, t.groupedCols);
  }
  checkAllGroupDataAfterColsChanged(e) {
    const t = (i) => {
      i && i.forEach((r) => {
        if (!this.usingTreeData && !r.group)
          return;
        const s = {
          field: r.field,
          key: r.key,
          rowGroupColumn: r.rowGroupColumn
        };
        this.setGroupData(r, s), t(r.childrenAfterGroup);
      });
    };
    t(e.rootNode.childrenAfterGroup);
  }
  shotgunResetEverything(e, t) {
    if (this.noChangeInGroupingColumns(e, t))
      return;
    this.selectionService.filterFromSelection((s) => s && !s.group);
    const { rootNode: i, groupedCols: r } = e;
    i.leafGroup = this.usingTreeData ? !1 : r.length === 0, i.childrenAfterGroup = [], i.childrenMapped = {}, i.updateHasChildren();
    const n = i.sibling;
    n && (n.childrenAfterGroup = i.childrenAfterGroup, n.childrenMapped = i.childrenMapped), this.insertNodes(i.allLeafChildren, e, !1);
  }
  noChangeInGroupingColumns(e, t) {
    let i = !1;
    const r = this.columnModel.getGroupDisplayColumns(), n = r ? r.map((s) => s.getId()).join("-") : "";
    return t && (i = this.usingTreeData || this.areGroupColsEqual(e, this.oldGroupingDetails), this.oldGroupDisplayColIds !== n && this.checkAllGroupDataAfterColsChanged(e)), this.oldGroupingDetails = e, this.oldGroupDisplayColIds = n, i;
  }
  insertNodes(e, t, i) {
    e.forEach((r) => {
      this.insertOneNode(r, t, i), t.changedPath.isActive() && t.changedPath.addParentNode(r.parent);
    });
  }
  insertOneNode(e, t, i, r) {
    const n = this.getGroupInfo(e, t), s = this.findParentForNode(e, n, t, r);
    s.group || console.warn("AG Grid: duplicate group keys for row data, keys should be unique", [s.data, e.data]), this.usingTreeData ? this.swapGroupWithUserNode(s, e, i) : (e.parent = s, e.level = n.length, s.childrenAfterGroup.push(e), s.updateHasChildren());
  }
  findParentForNode(e, t, i, r) {
    let n = i.rootNode;
    return t.forEach((s, a) => {
      n = this.getOrCreateNextNode(n, s, a, i), r != null && r.isRemoveFromAllLeafChildren(n, e) ? r == null || r.preventRemoveFromAllLeafChildren(n, e) : n.allLeafChildren.push(e);
    }), n;
  }
  swapGroupWithUserNode(e, t, i) {
    t.parent = e.parent, t.key = e.key, t.field = e.field, t.groupData = e.groupData, t.level = e.level, i || (t.expanded = e.expanded), t.leafGroup = e.leafGroup, t.rowGroupIndex = e.rowGroupIndex, t.allLeafChildren = e.allLeafChildren, t.childrenAfterGroup = e.childrenAfterGroup, t.childrenMapped = e.childrenMapped, t.sibling = e.sibling, t.updateHasChildren(), this.removeFromParent(e), t.childrenAfterGroup.forEach((r) => r.parent = t), this.addToParent(t, e.parent);
  }
  getOrCreateNextNode(e, t, i, r) {
    const n = this.getChildrenMappedKey(t.key, t.rowGroupColumn);
    let s = e.childrenMapped ? e.childrenMapped[n] : void 0;
    return s || (s = this.createGroup(t, e, i, r), this.addToParent(s, e)), s;
  }
  createGroup(e, t, i, r) {
    const n = new re(this.beans);
    return n.group = !0, n.field = e.field, n.rowGroupColumn = e.rowGroupColumn, this.setGroupData(n, e), n.id = re.ID_PREFIX_ROW_GROUP + this.groupIdSequence.next(), n.key = e.key, n.level = i, n.leafGroup = this.usingTreeData ? !1 : i === r.groupedColCount - 1, n.allLeafChildren = [], n.setAllChildrenCount(0), n.rowGroupIndex = this.usingTreeData ? null : i, n.childrenAfterGroup = [], n.childrenMapped = {}, n.updateHasChildren(), n.parent = r.includeParents ? t : null, this.setExpandedInitialValue(r, n), this.gridOptionsService.is("groupIncludeFooter") && n.createFooter(), n;
  }
  setGroupData(e, t) {
    e.groupData = {}, this.columnModel.getGroupDisplayColumns().forEach((r) => {
      (this.usingTreeData || (e.rowGroupColumn ? r.isRowGroupDisplayed(e.rowGroupColumn.getId()) : !1)) && (e.groupData[r.getColId()] = t.key);
    });
  }
  getChildrenMappedKey(e, t) {
    return t ? t.getId() + "-" + e : e;
  }
  setExpandedInitialValue(e, t) {
    if (e.pivotMode && t.leafGroup) {
      t.expanded = !1;
      return;
    }
    const i = this.gridOptionsService.getCallback("isGroupOpenByDefault");
    if (i) {
      const n = {
        rowNode: t,
        field: t.field,
        key: t.key,
        level: t.level,
        rowGroupColumn: t.rowGroupColumn
      };
      t.expanded = i(n) == !0;
      return;
    }
    const { expandByDefault: r } = e;
    if (e.expandByDefault === -1) {
      t.expanded = !0;
      return;
    }
    t.expanded = t.level < r;
  }
  getGroupInfo(e, t) {
    return this.usingTreeData ? this.getGroupInfoFromCallback(e) : this.getGroupInfoFromGroupColumns(e, t);
  }
  getGroupInfoFromCallback(e) {
    const t = this.getDataPath ? this.getDataPath(e.data) : null;
    (t == null || t.length === 0) && x.doOnce(() => console.warn("AG Grid: getDataPath() should not return an empty path for data", e.data), "groupStage.getGroupInfoFromCallback");
    const i = (r) => ({ key: r, field: null, rowGroupColumn: null });
    return t ? t.map(i) : [];
  }
  getGroupInfoFromGroupColumns(e, t) {
    const i = [];
    return t.groupedCols.forEach((r) => {
      let n = this.valueService.getKeyForNode(r, e), s = n != null && n !== "";
      if ((t.pivotMode || !this.gridOptionsService.is("groupAllowUnbalanced")) && !s && (n = "", s = !0), s) {
        const l = {
          key: n,
          field: r.getColDef().field,
          rowGroupColumn: r
        };
        i.push(l);
      }
    }), i;
  }
};
hc([
  S("columnModel")
], xs.prototype, "columnModel", void 0);
hc([
  S("selectableService")
], xs.prototype, "selectableService", void 0);
hc([
  S("valueService")
], xs.prototype, "valueService", void 0);
hc([
  S("beans")
], xs.prototype, "beans", void 0);
hc([
  S("selectionService")
], xs.prototype, "selectionService", void 0);
hc([
  B
], xs.prototype, "postConstruct", null);
xs = hc([
  q("groupStage")
], xs);
var Vx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, gg;
let ap = gg = class extends H {
  createPivotColumnDefs(e) {
    const t = this.columnModel.getPivotColumns(), i = this.columnModel.getValueColumns(), r = t.length, n = this.recursiveBuildGroup(0, e, [], r, t);
    function s(c, d = []) {
      return c.forEach((u) => {
        u.children !== void 0 ? s(u.children, d) : d.push(u);
      }), d;
    }
    const a = s(n);
    this.addRowGroupTotals(n, a, i), this.addExpandablePivotGroups(n, a), this.addPivotTotalsToGroups(n, a);
    const l = a.map((c) => x.cloneObject(c));
    return {
      pivotColumnGroupDefs: n,
      pivotColumnDefs: l
    };
  }
  recursiveBuildGroup(e, t, i, r, n) {
    const s = this.columnModel.getValueColumns();
    if (e >= r)
      return this.buildMeasureCols(i);
    const a = n[e].getColDef(), l = this.headerNameComparator.bind(this, a.pivotComparator);
    if (s.length === 1 && this.gridOptionsService.is("removePivotHeaderRowWhenSingleValueColumn") && e === r - 1) {
      const d = [];
      return x.iterateObject(t, (u) => {
        const h = [...i, u];
        d.push(Object.assign(Object.assign({}, this.createColDef(s[0], u, h)), { columnGroupShow: "open" }));
      }), d.sort(l), d;
    }
    const c = [];
    return x.iterateObject(t, (d, u) => {
      const h = [...i, d];
      c.push({
        children: this.recursiveBuildGroup(e + 1, u, h, r, n),
        headerName: d,
        pivotKeys: h,
        columnGroupShow: "open",
        groupId: this.generateColumnGroupId(h)
      });
    }), c.sort(l), c;
  }
  buildMeasureCols(e) {
    const t = this.columnModel.getValueColumns();
    return t.length === 0 ? [this.createColDef(null, "-", e)] : t.map((i) => {
      const r = this.columnModel.getDisplayNameForColumn(i, "header");
      return Object.assign(Object.assign({}, this.createColDef(i, r, e)), { columnGroupShow: "open" });
    });
  }
  addExpandablePivotGroups(e, t) {
    if (this.gridOptionsService.is("suppressExpandablePivotGroups") || this.gridOptionsService.get("pivotColumnGroupTotals"))
      return;
    const i = (r, n, s) => {
      const a = r;
      if (a.children) {
        const l = /* @__PURE__ */ new Map();
        a.children.forEach((d) => {
          i(d, n, l);
        });
        const c = !a.children.some((d) => d.children);
        this.columnModel.getValueColumns().forEach((d) => {
          const u = this.columnModel.getDisplayNameForColumn(d, "header"), h = this.createColDef(d, u, r.pivotKeys);
          h.pivotTotalColumnIds = l.get(d.getColId()), h.columnGroupShow = "closed", h.aggFunc = d.getAggFunc(), c || (r.children.push(h), n.push(h));
        }), this.merge(s, l);
      } else {
        const l = r;
        if (!l.pivotValueColumn)
          return;
        const c = l.pivotValueColumn.getColId(), d = s.has(c) ? s.get(c) : [];
        d.push(l.colId), s.set(c, d);
      }
    };
    e.forEach((r) => {
      i(r, t, /* @__PURE__ */ new Map());
    });
  }
  addPivotTotalsToGroups(e, t) {
    if (!this.gridOptionsService.get("pivotColumnGroupTotals"))
      return;
    const i = this.gridOptionsService.get("pivotColumnGroupTotals") === "after", r = this.columnModel.getValueColumns(), n = r.map((a) => a.getAggFunc());
    if (!n || n.length < 1 || !this.sameAggFuncs(n))
      return;
    const s = r[0];
    e.forEach((a) => {
      this.recursivelyAddPivotTotal(a, t, s, i);
    });
  }
  recursivelyAddPivotTotal(e, t, i, r) {
    const n = e;
    if (!n.children) {
      const a = e;
      return a.colId ? [a.colId] : null;
    }
    let s = [];
    if (n.children.forEach((a) => {
      const l = this.recursivelyAddPivotTotal(a, t, i, r);
      l && (s = s.concat(l));
    }), n.children.length > 1) {
      const l = this.localeService.getLocaleTextFunc()("pivotColumnGroupTotals", "Total"), c = this.createColDef(i, l, e.pivotKeys, !0);
      c.pivotTotalColumnIds = s, c.aggFunc = i.getAggFunc();
      const d = e.children;
      r ? d.push(c) : d.unshift(c), t.push(c);
    }
    return s;
  }
  addRowGroupTotals(e, t, i) {
    if (!this.gridOptionsService.get("pivotRowTotals"))
      return;
    const r = this.gridOptionsService.get("pivotRowTotals") === "after", n = r ? i.slice() : i.slice().reverse();
    for (let s = 0; s < n.length; s++) {
      const a = n[s];
      let l = [];
      e.forEach((d) => {
        l = l.concat(this.extractColIdsForValueColumn(d, a));
      });
      const c = n.length > 1 || !this.gridOptionsService.is("removePivotHeaderRowWhenSingleValueColumn");
      this.createRowGroupTotal(e, t, a, l, r, c);
    }
  }
  extractColIdsForValueColumn(e, t) {
    const i = e;
    if (!i.children) {
      const n = i;
      return n.pivotValueColumn === t && n.colId ? [n.colId] : [];
    }
    let r = [];
    return i.children.forEach((n) => {
      this.extractColIdsForValueColumn(n, t);
      const s = this.extractColIdsForValueColumn(n, t);
      r = r.concat(s);
    }), r;
  }
  createRowGroupTotal(e, t, i, r, n, s) {
    const a = this.columnModel.getValueColumns();
    let l;
    if (a.length === 0)
      l = this.createColDef(null, "-", []);
    else {
      const d = this.columnModel.getDisplayNameForColumn(i, "header");
      l = this.createColDef(i, d, []), l.pivotTotalColumnIds = r;
    }
    l.colId = gg.PIVOT_ROW_TOTAL_PREFIX + l.colId, t.push(l);
    const c = s ? {
      children: [l],
      pivotKeys: [],
      groupId: `${gg.PIVOT_ROW_TOTAL_PREFIX}_pivotGroup_${i.getColId()}`
    } : l;
    n ? e.push(c) : e.unshift(c);
  }
  createColDef(e, t, i, r = !1) {
    const n = {};
    if (e) {
      const s = e.getColDef();
      Object.assign(n, s), n.hide = !1;
    }
    return n.headerName = t, n.colId = this.generateColumnId(i || [], e && !r ? e.getColId() : ""), n.field = n.colId, n.valueGetter = (s) => {
      var a;
      return (a = s.data) === null || a === void 0 ? void 0 : a[s.colDef.field];
    }, n.pivotKeys = i, n.pivotValueColumn = e, n.filter === !0 && (n.filter = "agNumberColumnFilter"), n;
  }
  sameAggFuncs(e) {
    if (e.length == 1)
      return !0;
    for (let t = 1; t < e.length; t++)
      if (e[t] !== e[0])
        return !1;
    return !0;
  }
  headerNameComparator(e, t, i) {
    return e ? e(t.headerName, i.headerName) : t.headerName && !i.headerName ? 1 : !t.headerName && i.headerName ? -1 : !t.headerName || !i.headerName ? 0 : t.headerName < i.headerName ? -1 : t.headerName > i.headerName ? 1 : 0;
  }
  merge(e, t) {
    t.forEach((i, r, n) => {
      const a = [...e.has(r) ? e.get(r) : [], ...i];
      e.set(r, a);
    });
  }
  generateColumnGroupId(e) {
    return `pivotGroup_${this.columnModel.getPivotColumns().map((i) => i.getColId()).join("-")}_${e.join("-")}`;
  }
  generateColumnId(e, t) {
    return `pivot_${this.columnModel.getPivotColumns().map((r) => r.getColId()).join("-")}_${e.join("-")}_${t}`;
  }
};
ap.PIVOT_ROW_TOTAL_PREFIX = "PivotRowTotal_";
Vx([
  S("columnModel")
], ap.prototype, "columnModel", void 0);
ap = gg = Vx([
  q("pivotColDefService")
], ap);
var xm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let zd = class extends H {
  constructor() {
    super(...arguments), this.uniqueValues = {};
  }
  execute(e) {
    const t = e.changedPath;
    this.columnModel.isPivotActive() ? this.executePivotOn(t) : this.executePivotOff(t);
  }
  executePivotOff(e) {
    this.aggregationColumnsHashLastTime = null, this.uniqueValues = {}, this.columnModel.isSecondaryColumnsPresent() && (this.columnModel.setSecondaryColumns(null, "rowModelUpdated"), e && e.setInactive());
  }
  executePivotOn(e) {
    const t = this.bucketUpRowNodes(e), i = this.setUniqueValues(t), r = this.columnModel.getValueColumns(), n = r.map((u) => `${u.getId()}-${u.getColDef().headerName}`).join("#"), s = r.map((u) => u.getAggFunc().toString()).join("#"), a = this.aggregationColumnsHashLastTime !== n, l = this.aggregationFuncsHashLastTime !== s;
    this.aggregationColumnsHashLastTime = n, this.aggregationFuncsHashLastTime = s;
    const c = this.columnModel.getRowGroupColumns().map((u) => u.getId()).join("#"), d = c !== this.groupColumnsHashLastTime;
    if (this.groupColumnsHashLastTime = c, i || a || d || l) {
      const { pivotColumnGroupDefs: u, pivotColumnDefs: h } = this.pivotColDefService.createPivotColumnDefs(this.uniqueValues);
      this.pivotColumnDefs = h, this.columnModel.setSecondaryColumns(u, "rowModelUpdated"), e && e.setInactive();
    }
  }
  setUniqueValues(e) {
    const t = JSON.stringify(e), i = JSON.stringify(this.uniqueValues);
    return t !== i ? (this.uniqueValues = e, !0) : !1;
  }
  bucketUpRowNodes(e) {
    const t = {};
    e.forEachChangedNodeDepthFirst((r) => {
      r.leafGroup && (r.childrenMapped = null);
    });
    const i = (r) => {
      var n;
      r.leafGroup ? this.bucketRowNode(r, t) : (n = r.childrenAfterFilter) === null || n === void 0 || n.forEach(i);
    };
    return e.executeFromRootNode(i), t;
  }
  bucketRowNode(e, t) {
    const i = this.columnModel.getPivotColumns();
    i.length === 0 ? e.childrenMapped = null : e.childrenMapped = this.bucketChildren(e.childrenAfterFilter, i, 0, t), e.sibling && (e.sibling.childrenMapped = e.childrenMapped);
  }
  bucketChildren(e, t, i, r) {
    const n = {}, s = t[i];
    if (e.forEach((a) => {
      let l = this.valueService.getKeyForNode(s, a);
      x.missing(l) && (l = ""), r[l] || (r[l] = {}), n[l] || (n[l] = []), n[l].push(a);
    }), i === t.length - 1)
      return n;
    {
      const a = {};
      return x.iterateObject(n, (l, c) => {
        a[l] = this.bucketChildren(c, t, i + 1, r[l]);
      }), a;
    }
  }
  getPivotColumnDefs() {
    return this.pivotColumnDefs;
  }
};
xm([
  S("valueService")
], zd.prototype, "valueService", void 0);
xm([
  S("columnModel")
], zd.prototype, "columnModel", void 0);
xm([
  S("pivotColDefService")
], zd.prototype, "pivotColDefService", void 0);
zd = xm([
  q("pivotStage")
], zd);
var Bx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, An;
const ho = typeof BigInt == "undefined" ? null : BigInt;
let Wn = An = class extends H {
  constructor() {
    super(...arguments), this.aggFuncsMap = {}, this.initialised = !1;
  }
  init() {
    this.initialised || (this.initialiseWithDefaultAggregations(), this.addAggFuncs(this.gridOptionsService.get("aggFuncs")));
  }
  initialiseWithDefaultAggregations() {
    this.aggFuncsMap[An.AGG_SUM] = vG, this.aggFuncsMap[An.AGG_FIRST] = mG, this.aggFuncsMap[An.AGG_LAST] = yG, this.aggFuncsMap[An.AGG_MIN] = CG, this.aggFuncsMap[An.AGG_MAX] = SG, this.aggFuncsMap[An.AGG_COUNT] = bG, this.aggFuncsMap[An.AGG_AVG] = wG, this.initialised = !0;
  }
  isAggFuncPossible(e, t) {
    const i = this.getFuncNames(e), r = x.includes(i, t), n = x.exists(this.aggFuncsMap[t]);
    return r && n;
  }
  getDefaultAggFunc(e) {
    const t = e.getColDef().defaultAggFunc;
    if (x.exists(t) && this.isAggFuncPossible(e, t))
      return t;
    if (this.isAggFuncPossible(e, An.AGG_SUM))
      return An.AGG_SUM;
    const i = this.getFuncNames(e);
    return x.existsAndNotEmpty(i) ? i[0] : null;
  }
  addAggFuncs(e) {
    x.iterateObject(e, this.addAggFunc.bind(this));
  }
  addAggFunc(e, t) {
    this.init(), this.aggFuncsMap[e] = t;
  }
  getAggFunc(e) {
    return this.init(), this.aggFuncsMap[e];
  }
  getFuncNames(e) {
    const t = e.getColDef().allowedAggFuncs;
    return t == null ? Object.keys(this.aggFuncsMap).sort() : t;
  }
  clear() {
    this.aggFuncsMap = {};
  }
};
Wn.AGG_SUM = "sum";
Wn.AGG_FIRST = "first";
Wn.AGG_LAST = "last";
Wn.AGG_MIN = "min";
Wn.AGG_MAX = "max";
Wn.AGG_COUNT = "count";
Wn.AGG_AVG = "avg";
Bx([
  B
], Wn.prototype, "init", null);
Wn = An = Bx([
  q("aggFuncService")
], Wn);
function vG(o) {
  const { values: e } = o;
  let t = null;
  for (let i = 0; i < e.length; i++) {
    const r = e[i];
    typeof r == "number" ? t === null ? t = r : ho ? t += typeof t == "number" ? r : ho(r) : t += r : typeof r == "bigint" && (t === null ? t = r : t = (typeof t == "bigint" ? t : ho(t)) + r);
  }
  return t;
}
function mG(o) {
  return o.values.length > 0 ? o.values[0] : null;
}
function yG(o) {
  return o.values.length > 0 ? x.last(o.values) : null;
}
function CG(o) {
  const { values: e } = o;
  let t = null;
  for (let i = 0; i < e.length; i++) {
    const r = e[i];
    (typeof r == "number" || typeof r == "bigint") && (t === null || t > r) && (t = r);
  }
  return t;
}
function SG(o) {
  const { values: e } = o;
  let t = null;
  for (let i = 0; i < e.length; i++) {
    const r = e[i];
    (typeof r == "number" || typeof r == "bigint") && (t === null || t < r) && (t = r);
  }
  return t;
}
function bG(o) {
  var e, t;
  const { values: i } = o;
  let r = 0;
  for (let s = 0; s < i.length; s++) {
    const a = i[s];
    r += a != null && typeof a.value == "number" ? a.value : 1;
  }
  const n = (t = (e = o.rowNode) === null || e === void 0 ? void 0 : e.aggData) === null || t === void 0 ? void 0 : t[o.column.getColId()];
  return n && n.value === r ? n : {
    value: r,
    toString: function() {
      return this.value.toString();
    },
    // used for sorting
    toNumber: function() {
      return this.value;
    }
  };
}
function wG(o) {
  var e, t, i;
  const { values: r } = o;
  let n = 0, s = 0;
  for (let c = 0; c < r.length; c++) {
    const d = r[c];
    let u = null;
    typeof d == "number" || typeof d == "bigint" ? (u = d, s++) : d != null && (typeof d.value == "number" || typeof d.value == "bigint") && typeof d.count == "number" && (ho ? u = d.value * (typeof d.value == "number" ? d.count : ho(d.count)) : u = d.value * d.count, s += d.count), typeof u == "number" ? ho ? n += typeof n == "number" ? u : ho(u) : n += u : typeof u == "bigint" && (n = (typeof n == "bigint" ? n : ho(n)) + u);
  }
  let a = null;
  s > 0 && (ho ? a = n / (typeof n == "number" ? s : ho(s)) : a = n / s);
  const l = (t = (e = o.rowNode) === null || e === void 0 ? void 0 : e.aggData) === null || t === void 0 ? void 0 : t[(i = o.column) === null || i === void 0 ? void 0 : i.getColId()];
  return l && l.count === s && l.value === a ? l : {
    count: s,
    value: a,
    // the grid by default uses toString to render values for an object, so this
    // is a trick to get the default cellRenderer to display the avg value
    toString: function() {
      return typeof this.value == "number" || typeof this.value == "bigint" ? this.value.toString() : "";
    },
    // used for sorting
    toNumber: function() {
      return this.value;
    }
  };
}
var jo = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class xi extends X {
  constructor(e, t, i, r, n) {
    super(), this.column = e, this.dragSourceDropTarget = t, this.ghost = i, this.dropZonePurpose = r, this.horizontal = n, this.popupShowing = !1;
  }
  init() {
    this.setTemplate(xi.TEMPLATE);
    const e = this.getGui(), t = this.gridOptionsService.is("functionsReadOnly");
    this.addElementClasses(e), this.addElementClasses(this.eDragHandle, "drag-handle"), this.addElementClasses(this.eText, "text"), this.addElementClasses(this.eButton, "button"), this.eDragHandle.appendChild(x.createIconNoSpan("columnDrag", this.gridOptionsService)), this.eButton.appendChild(x.createIconNoSpan("cancel", this.gridOptionsService)), this.setupSort(), this.displayName = this.columnModel.getDisplayNameForColumn(this.column, "columnDrop"), this.setupComponents(), !this.ghost && !t && this.addDragSource(), this.setupAria(), this.addManagedListener(this.eventService, me.EVENT_SORT_CHANGED, () => {
      this.setupAria();
    }), this.setupTooltip(), this.activateTabIndex();
  }
  setupAria() {
    const e = this.localeService.getLocaleTextFunc(), { name: t, aggFuncName: i } = this.getColumnAndAggFuncName(), r = e("ariaDropZoneColumnComponentAggFuncSeparator", " of "), n = {
      asc: e("ariaDropZoneColumnComponentSortAscending", "ascending"),
      desc: e("ariaDropZoneColumnComponentSortDescending", "descending")
    }, s = this.column.getSort(), a = this.gridOptionsService.is("rowGroupPanelSuppressSort"), l = [
      [
        i && `${i}${r}`,
        t,
        this.isGroupingZone() && !a && s && `, ${n[s]}`
      ].filter((u) => !!u).join("")
    ], c = this.gridOptionsService.is("functionsReadOnly");
    if (this.isAggregationZone() && !c) {
      const u = e("ariaDropZoneColumnValueItemDescription", "Press ENTER to change the aggregation type");
      l.push(u);
    }
    if (this.isGroupingZone() && this.column.getColDef().sortable && !a) {
      const u = e("ariaDropZoneColumnGroupItemDescription", "Press ENTER to sort");
      l.push(u);
    }
    const d = e("ariaDropZoneColumnComponentDescription", "Press DELETE to remove");
    l.push(d), x.setAriaLabel(this.getGui(), l.join(". "));
  }
  setupTooltip() {
    const e = () => {
      const t = this.column.getColDef().headerTooltip;
      this.setTooltip(t);
    };
    e(), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, e);
  }
  setupSort() {
    const e = this.column.getColDef().sortable, t = this.isGroupingZone();
    if (!(!e || !t) && !this.gridOptionsService.is("rowGroupPanelSuppressSort")) {
      this.eSortIndicator.setupSort(this.column, !0);
      const i = (r) => {
        r.preventDefault();
        const s = this.gridOptionsService.get("multiSortKey") === "ctrl" ? r.ctrlKey || r.metaKey : r.shiftKey;
        this.sortController.progressSort(this.column, s, "uiColumnSorted");
      };
      this.addGuiEventListener("click", i), this.addGuiEventListener("keydown", (r) => {
        r.key === V.ENTER && this.isGroupingZone() && i(r);
      });
    }
  }
  addDragSource() {
    const e = {
      type: Dt.ToolPanel,
      eElement: this.eDragHandle,
      defaultIconName: Te.ICON_HIDE,
      getDragItem: () => this.createDragItem(),
      dragItemName: this.displayName,
      dragSourceDropTarget: this.dragSourceDropTarget
    };
    this.dragAndDropService.addDragSource(e, !0), this.addDestroyFunc(() => this.dragAndDropService.removeDragSource(e));
  }
  createDragItem() {
    const e = {};
    return e[this.column.getId()] = this.column.isVisible(), {
      columns: [this.column],
      visibleState: e
    };
  }
  setupComponents() {
    this.setTextValue(), this.setupRemove(), this.ghost && this.addCssClass("ag-column-drop-cell-ghost"), this.isAggregationZone() && !this.gridOptionsService.is("functionsReadOnly") && this.addGuiEventListener("click", this.onShowAggFuncSelection.bind(this));
  }
  setupRemove() {
    x.setDisplayed(this.eButton, !this.gridOptionsService.is("functionsReadOnly"));
    const e = { type: xi.EVENT_COLUMN_REMOVE };
    this.addGuiEventListener("keydown", (i) => {
      const r = i.key === V.ENTER;
      i.key === V.DELETE && (i.preventDefault(), this.dispatchEvent(e)), r && this.isAggregationZone() && !this.gridOptionsService.is("functionsReadOnly") && (i.preventDefault(), this.onShowAggFuncSelection());
    }), this.addManagedListener(this.eButton, "click", (i) => {
      this.dispatchEvent(e), i.stopPropagation();
    });
    const t = new mt(this.eButton);
    this.addManagedListener(t, mt.EVENT_TAP, () => {
      this.dispatchEvent(e);
    }), this.addDestroyFunc(t.destroy.bind(t));
  }
  getColumnAndAggFuncName() {
    const e = this.displayName;
    let t = "";
    if (this.isAggregationZone()) {
      const i = this.column.getAggFunc(), r = typeof i == "string" ? i : "agg";
      t = this.localeService.getLocaleTextFunc()(r, r);
    }
    return { name: e, aggFuncName: t };
  }
  setTextValue() {
    const { name: e, aggFuncName: t } = this.getColumnAndAggFuncName(), i = this.isAggregationZone() ? `${t}(${e})` : e, r = x.escapeString(i);
    this.eText.innerHTML = r;
  }
  onShowAggFuncSelection() {
    if (this.popupShowing)
      return;
    this.popupShowing = !0;
    const e = new Ls("select-agg-func"), t = this.aggFuncService.getFuncNames(this.column), i = this.getGui(), r = e.getGui();
    e.setModel({
      getRow: function(u) {
        return t[u];
      },
      getRowCount: function() {
        return t.length;
      }
    }), this.getContext().createBean(e);
    const n = x.loadTemplate(
      /* html*/
      '<div class="ag-select-agg-func-popup"></div>'
    );
    n.style.top = "0px", n.style.left = "0px", n.appendChild(r), n.style.width = `${i.clientWidth}px`;
    const s = this.addManagedListener(n, "focusout", (u) => {
      !n.contains(u.relatedTarget) && c && c.hideFunc();
    }), a = (u) => {
      this.destroyBean(e), this.popupShowing = !1, (u == null ? void 0 : u.key) === "Escape" && i.focus(), s && s();
    }, l = this.localeService.getLocaleTextFunc(), c = this.popupService.addPopup({
      modal: !0,
      eChild: n,
      closeOnEsc: !0,
      closedCallback: a,
      ariaLabel: l("ariaLabelAggregationFunction", "Aggregation Function")
    });
    c && e.setComponentCreator(this.createAggSelect.bind(this, c.hideFunc)), e.addGuiEventListener("keydown", (u) => {
      if (u.key === V.ENTER || u.key === V.SPACE) {
        const h = e.getLastFocusedRow();
        if (h == null)
          return;
        const p = e.getComponentAt(h);
        p && p.selectItem();
      }
    }), this.popupService.positionPopupByComponent({
      type: "aggFuncSelect",
      eventSource: i,
      ePopup: n,
      keepWithinBounds: !0,
      column: this.column,
      position: "under"
    }), e.refresh();
    let d = t.findIndex((u) => u === this.column.getAggFunc());
    d === -1 && (d = 0), e.focusRow(d);
  }
  createAggSelect(e, t) {
    const i = () => {
      if (e(), this.gridOptionsService.is("functionsPassive")) {
        const l = {
          type: w.EVENT_COLUMN_AGG_FUNC_CHANGE_REQUEST,
          columns: [this.column],
          aggFunc: t
        };
        this.eventService.dispatchEvent(l);
      } else
        this.columnModel.setColumnAggFunc(this.column, t, "toolPanelDragAndDrop");
    }, r = this.localeService.getLocaleTextFunc(), n = t.toString(), s = r(n, n);
    return new EG(i, s);
  }
  addElementClasses(e, t) {
    t = t ? `-${t}` : "";
    const i = this.horizontal ? "horizontal" : "vertical";
    e.classList.add(`ag-column-drop-cell${t}`, `ag-column-drop-${i}-cell${t}`);
  }
  isAggregationZone() {
    return this.dropZonePurpose === "aggregation";
  }
  isGroupingZone() {
    return this.dropZonePurpose === "rowGroup";
  }
}
xi.EVENT_COLUMN_REMOVE = "columnRemove";
xi.TEMPLATE = `<span role="option">
          <span ref="eDragHandle" class="ag-drag-handle ag-column-drop-cell-drag-handle" role="presentation"></span>
          <span ref="eText" class="ag-column-drop-cell-text" aria-hidden="true"></span>
          <ag-sort-indicator ref="eSortIndicator"></ag-sort-indicator>
          <span ref="eButton" class="ag-column-drop-cell-button" role="presentation"></span>
        </span>`;
jo([
  S("dragAndDropService")
], xi.prototype, "dragAndDropService", void 0);
jo([
  S("columnModel")
], xi.prototype, "columnModel", void 0);
jo([
  S("popupService")
], xi.prototype, "popupService", void 0);
jo([
  Ve("aggFuncService")
], xi.prototype, "aggFuncService", void 0);
jo([
  S("sortController")
], xi.prototype, "sortController", void 0);
jo([
  L("eText")
], xi.prototype, "eText", void 0);
jo([
  L("eDragHandle")
], xi.prototype, "eDragHandle", void 0);
jo([
  L("eButton")
], xi.prototype, "eButton", void 0);
jo([
  L("eSortIndicator")
], xi.prototype, "eSortIndicator", void 0);
jo([
  B
], xi.prototype, "init", null);
class EG extends X {
  constructor(e, t) {
    super(
      /* html */
      '<div class="ag-select-agg-func-item"/>'
    ), this.selectItem = e, this.getGui().innerText = t, this.addGuiEventListener("click", this.selectItem);
  }
}
var Hx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class vi extends X {
  constructor(e, t) {
    super(
      /* html */
      '<div class="ag-unselectable" role="presentation"></div>'
    ), this.horizontal = e, this.dropZonePurpose = t, this.state = vi.STATE_NOT_DRAGGING, this.guiDestroyFunctions = [], this.childColumnComponents = [], this.resizeEnabled = !1, this.addElementClasses(this.getGui()), this.eColumnDropList = document.createElement("div"), this.addElementClasses(this.eColumnDropList, "list"), x.setAriaRole(this.eColumnDropList, "listbox");
  }
  isHorizontal() {
    return this.horizontal;
  }
  toggleResizable(e) {
    this.positionableFeature.setResizable(e ? { bottom: !0 } : !1), this.resizeEnabled = e;
  }
  setBeans(e) {
    this.beans = e;
  }
  destroy() {
    this.destroyGui(), super.destroy();
  }
  destroyGui() {
    this.guiDestroyFunctions.forEach((e) => e()), this.guiDestroyFunctions.length = 0, this.childColumnComponents.length = 0, x.clearElement(this.getGui()), x.clearElement(this.eColumnDropList);
  }
  init(e) {
    this.params = e, this.createManagedBean(new Ji(this.getFocusableElement(), {
      handleKeyDown: this.handleKeyDown.bind(this)
    })), this.addManagedListener(this.beans.eventService, w.EVENT_NEW_COLUMNS_LOADED, this.refreshGui.bind(this)), this.addManagedPropertyListener("functionsReadOnly", this.refreshGui.bind(this)), this.setupDropTarget(), this.positionableFeature = new ec(this.getGui(), { minHeight: 100 }), this.createManagedBean(this.positionableFeature), this.refreshGui(), x.setAriaLabel(this.eColumnDropList, this.getAriaLabel());
  }
  handleKeyDown(e) {
    const t = !this.horizontal;
    let i = e.key === V.DOWN, r = e.key === V.UP;
    if (!t) {
      const s = this.gridOptionsService.is("enableRtl");
      i = !s && e.key === V.RIGHT || s && e.key === V.LEFT, r = !s && e.key === V.LEFT || s && e.key === V.RIGHT;
    }
    if (!i && !r)
      return;
    const n = this.focusService.findNextFocusableElement(this.getFocusableElement(), !1, r);
    n && (e.preventDefault(), n.focus());
  }
  addElementClasses(e, t) {
    t = t ? `-${t}` : "";
    const i = this.horizontal ? "horizontal" : "vertical";
    e.classList.add(`ag-column-drop${t}`, `ag-column-drop-${i}${t}`);
  }
  setupDropTarget() {
    this.dropTarget = {
      getContainer: this.getGui.bind(this),
      getIconName: this.getIconName.bind(this),
      onDragging: this.onDragging.bind(this),
      onDragEnter: this.onDragEnter.bind(this),
      onDragLeave: this.onDragLeave.bind(this),
      onDragStop: this.onDragStop.bind(this),
      isInterestedIn: this.isInterestedIn.bind(this)
    }, this.beans.dragAndDropService.addDropTarget(this.dropTarget);
  }
  isInterestedIn(e) {
    return e === Dt.HeaderCell || e === Dt.ToolPanel;
  }
  checkInsertIndex(e) {
    const t = this.getNewInsertIndex(e);
    if (t < 0)
      return !1;
    const i = t !== this.insertIndex;
    return i && (this.insertIndex = t), i;
  }
  getNewInsertIndex(e) {
    const t = e.event, i = this.horizontal ? t.clientX : t.clientY, r = this.childColumnComponents.map((s) => s.getGui().getBoundingClientRect()), n = r.findIndex((s) => this.horizontal ? s.right > i && s.left < i : s.top < i && s.bottom > i);
    if (n === -1) {
      const s = this.beans.gridOptionsService.is("enableRtl");
      return r.every((c) => i > (this.horizontal ? c.right : c.bottom)) ? s && this.horizontal ? 0 : this.childColumnComponents.length : r.every((c) => i < (this.horizontal ? c.left : c.top)) ? s && this.horizontal ? this.childColumnComponents.length : 0 : this.insertIndex;
    }
    return this.insertIndex <= n ? n + 1 : n;
  }
  checkDragStartedBySelf(e) {
    this.state === vi.STATE_NOT_DRAGGING && (this.state = vi.STATE_REARRANGE_COLUMNS, this.potentialDndColumns = e.dragSource.getDragItem().columns || [], this.refreshGui(), this.checkInsertIndex(e), this.refreshGui());
  }
  onDragging(e) {
    this.checkDragStartedBySelf(e), this.checkInsertIndex(e) && this.refreshGui();
  }
  onDragEnter(e) {
    const t = e.dragSource.getDragItem().columns || [];
    this.state = vi.STATE_NEW_COLUMNS_IN;
    const i = t.filter(this.isColumnDroppable.bind(this));
    if (i.length > 0) {
      if (this.isRowGroupPanel() && !this.gridOptionsService.is("suppressRowGroupHidesColumns") && !e.fromNudge) {
        const s = e.dragSource.getDragItem().columns;
        this.setColumnsVisible(s, !1, "uiColumnDragged");
      }
      this.potentialDndColumns = i, this.checkInsertIndex(e), this.refreshGui();
    }
  }
  setColumnsVisible(e, t, i = "api") {
    if (e) {
      const r = e.filter((n) => !n.getColDef().lockVisible);
      this.colModel.setColumnsVisible(r, t, i);
    }
  }
  isPotentialDndColumns() {
    return x.existsAndNotEmpty(this.potentialDndColumns);
  }
  isRowGroupPanel() {
    return this.dropZonePurpose === "rowGroup";
  }
  onDragLeave(e) {
    if (this.state === vi.STATE_REARRANGE_COLUMNS) {
      const t = e.dragSource.getDragItem().columns || [];
      this.removeColumns(t);
    }
    if (this.isPotentialDndColumns()) {
      if (this.isRowGroupPanel() && !this.gridOptionsService.is("suppressMakeColumnVisibleAfterUnGroup") && !e.fromNudge) {
        const i = e.dragSource.getDragItem();
        this.setColumnsVisible(i.columns, !0, "uiColumnDragged");
      }
      this.potentialDndColumns = [], this.refreshGui();
    }
    this.state = vi.STATE_NOT_DRAGGING;
  }
  onDragStop() {
    if (this.isPotentialDndColumns()) {
      let e = !1;
      this.state === vi.STATE_NEW_COLUMNS_IN ? (this.addColumns(this.potentialDndColumns), e = !0) : e = this.rearrangeColumns(this.potentialDndColumns), this.potentialDndColumns = [], (!this.beans.gridOptionsService.is("functionsPassive") || !e) && this.refreshGui();
    }
    this.state = vi.STATE_NOT_DRAGGING;
  }
  removeColumns(e) {
    const t = this.getExistingColumns().filter((i) => !x.includes(e, i));
    this.updateColumns(t);
  }
  addColumns(e) {
    if (!e)
      return;
    const t = this.getExistingColumns().slice(), i = e.filter((r) => t.indexOf(r) < 0);
    x.insertArrayIntoArray(t, i, this.insertIndex), this.updateColumns(t);
  }
  rearrangeColumns(e) {
    const t = this.getNonGhostColumns().slice();
    return x.insertArrayIntoArray(t, e, this.insertIndex), x.areEqual(t, this.getExistingColumns()) ? !1 : (this.updateColumns(t), !0);
  }
  refreshGui() {
    const e = this.eColumnDropList.scrollTop, t = this.resizeEnabled, i = this.getFocusedItem();
    let r = this.focusService.findNextFocusableElement();
    r || (r = this.focusService.findNextFocusableElement(void 0, !1, !0)), this.toggleResizable(!1), this.destroyGui(), this.addIconAndTitleToGui(), this.addEmptyMessageToGui(), this.addColumnsToGui(), this.isHorizontal() || (this.eColumnDropList.scrollTop = e), t && this.toggleResizable(t), this.focusService.isKeyboardMode() && this.restoreFocus(i, r);
  }
  getFocusedItem() {
    const e = this.getGui(), t = this.gridOptionsService.getDocument().activeElement;
    return e.contains(t) ? Array.from(e.querySelectorAll(".ag-column-drop-cell")).indexOf(t) : -1;
  }
  restoreFocus(e, t) {
    const i = this.getGui(), r = Array.from(i.querySelectorAll(".ag-column-drop-cell"));
    if (e === -1)
      return;
    r.length === 0 && t.focus();
    const n = Math.min(r.length - 1, e), s = r[n];
    s && s.focus();
  }
  getNonGhostColumns() {
    const e = this.getExistingColumns();
    return this.isPotentialDndColumns() ? e.filter((t) => !x.includes(this.potentialDndColumns, t)) : e;
  }
  addColumnsToGui() {
    const t = this.getNonGhostColumns().map((i) => this.createColumnComponent(i, !1));
    if (this.isPotentialDndColumns()) {
      const i = this.potentialDndColumns.map((r) => this.createColumnComponent(r, !0));
      this.insertIndex >= t.length ? t.push(...i) : t.splice(this.insertIndex, 0, ...i);
    }
    this.appendChild(this.eColumnDropList), t.forEach((i, r) => {
      r > 0 && this.addArrow(this.eColumnDropList), this.eColumnDropList.appendChild(i.getGui());
    }), this.addAriaLabelsToComponents();
  }
  addAriaLabelsToComponents() {
    this.childColumnComponents.forEach((e, t) => {
      const i = e.getGui();
      x.setAriaPosInSet(i, t + 1), x.setAriaSetSize(i, this.childColumnComponents.length);
    });
  }
  createColumnComponent(e, t) {
    const i = new xi(e, this.dropTarget, t, this.dropZonePurpose, this.horizontal);
    return i.addEventListener(xi.EVENT_COLUMN_REMOVE, this.removeColumns.bind(this, [e])), this.beans.context.createBean(i), this.guiDestroyFunctions.push(() => this.destroyBean(i)), t || this.childColumnComponents.push(i), i;
  }
  addIconAndTitleToGui() {
    const e = this.params.icon, t = document.createElement("div");
    if (x.setAriaHidden(t, !0), this.addElementClasses(t, "title-bar"), this.addElementClasses(e, "icon"), this.addOrRemoveCssClass("ag-column-drop-empty", this.isExistingColumnsEmpty()), t.appendChild(e), !this.horizontal) {
      const i = document.createElement("span");
      this.addElementClasses(i, "title"), i.innerHTML = this.params.title, t.appendChild(i);
    }
    this.appendChild(t);
  }
  isExistingColumnsEmpty() {
    return this.getExistingColumns().length === 0;
  }
  addEmptyMessageToGui() {
    if (!this.isExistingColumnsEmpty() || this.isPotentialDndColumns())
      return;
    const e = document.createElement("span");
    e.innerHTML = this.params.emptyMessage, this.addElementClasses(e, "empty-message"), this.eColumnDropList.appendChild(e);
  }
  addArrow(e) {
    if (this.horizontal) {
      const t = this.beans.gridOptionsService.is("enableRtl"), i = x.createIconNoSpan(t ? "smallLeft" : "smallRight", this.beans.gridOptionsService);
      this.addElementClasses(i, "cell-separator"), e.appendChild(i);
    }
  }
}
vi.STATE_NOT_DRAGGING = "notDragging";
vi.STATE_NEW_COLUMNS_IN = "newColumnsIn";
vi.STATE_REARRANGE_COLUMNS = "rearrangeColumns";
Hx([
  S("columnModel")
], vi.prototype, "colModel", void 0);
Hx([
  S("focusService")
], vi.prototype, "focusService", void 0);
var Dm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Bl extends vi {
  constructor(e) {
    super(e, "rowGroup");
  }
  passBeansUp() {
    super.setBeans({
      gridOptionsService: this.gridOptionsService,
      eventService: this.eventService,
      context: this.getContext(),
      loggerFactory: this.loggerFactory,
      dragAndDropService: this.dragAndDropService
    });
    const e = this.localeService.getLocaleTextFunc(), t = e("rowGroupColumnsEmptyMessage", "Drag here to set row groups"), i = e("groups", "Row Groups");
    super.init({
      dragAndDropIcon: Te.ICON_GROUP,
      icon: x.createIconNoSpan("rowGroupPanel", this.gridOptionsService, null),
      emptyMessage: t,
      title: i
    }), this.addManagedListener(this.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, this.refreshGui.bind(this));
  }
  getAriaLabel() {
    return this.localeService.getLocaleTextFunc()("ariaRowGroupDropZonePanelLabel", "Row Groups");
  }
  getTooltipParams() {
    const e = super.getTooltipParams();
    return e.location = "rowGroupColumnsList", e;
  }
  isColumnDroppable(e) {
    return this.gridOptionsService.is("functionsReadOnly") || !e.isPrimary() ? !1 : e.isAllowRowGroup() && !e.isRowGroupActive();
  }
  updateColumns(e) {
    if (this.gridOptionsService.is("functionsPassive")) {
      const t = {
        type: w.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST,
        columns: e
      };
      this.eventService.dispatchEvent(t);
    } else
      this.columnModel.setRowGroupColumns(e, "toolPanelUi");
  }
  getIconName() {
    return this.isPotentialDndColumns() ? Te.ICON_GROUP : Te.ICON_NOT_ALLOWED;
  }
  getExistingColumns() {
    return this.columnModel.getRowGroupColumns();
  }
}
Dm([
  S("columnModel")
], Bl.prototype, "columnModel", void 0);
Dm([
  S("loggerFactory")
], Bl.prototype, "loggerFactory", void 0);
Dm([
  S("dragAndDropService")
], Bl.prototype, "dragAndDropService", void 0);
Dm([
  B
], Bl.prototype, "passBeansUp", null);
var Om = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Hl extends vi {
  constructor(e) {
    super(e, "pivot");
  }
  passBeansUp() {
    super.setBeans({
      gridOptionsService: this.gridOptionsService,
      eventService: this.eventService,
      context: this.getContext(),
      loggerFactory: this.loggerFactory,
      dragAndDropService: this.dragAndDropService
    });
    const e = this.localeService.getLocaleTextFunc(), t = e("pivotColumnsEmptyMessage", "Drag here to set column labels"), i = e("pivots", "Column Labels");
    super.init({
      dragAndDropIcon: Te.ICON_GROUP,
      icon: x.createIconNoSpan("pivotPanel", this.gridOptionsService, null),
      emptyMessage: t,
      title: i
    }), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, this.refresh.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_CHANGED, this.refresh.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.checkVisibility.bind(this)), this.refresh();
  }
  getAriaLabel() {
    return this.localeService.getLocaleTextFunc()("ariaPivotDropZonePanelLabel", "Column Labels");
  }
  getTooltipParams() {
    const e = super.getTooltipParams();
    return e.location = "pivotColumnsList", e;
  }
  refresh() {
    this.checkVisibility(), this.refreshGui();
  }
  checkVisibility() {
    const e = this.columnModel.isPivotMode();
    if (this.isHorizontal())
      switch (this.gridOptionsService.get("pivotPanelShow")) {
        case "always":
          this.setDisplayed(e);
          break;
        case "onlyWhenPivoting":
          const t = this.columnModel.isPivotActive();
          this.setDisplayed(e && t);
          break;
        default:
          this.setDisplayed(!1);
          break;
      }
    else
      this.setDisplayed(e);
  }
  isColumnDroppable(e) {
    return this.gridOptionsService.is("functionsReadOnly") || !e.isPrimary() ? !1 : e.isAllowPivot() && !e.isPivotActive();
  }
  updateColumns(e) {
    if (this.gridOptionsService.is("functionsPassive")) {
      const t = {
        type: w.EVENT_COLUMN_PIVOT_CHANGE_REQUEST,
        columns: e
      };
      this.eventService.dispatchEvent(t);
    } else
      this.columnModel.setPivotColumns(e, "toolPanelUi");
  }
  getIconName() {
    return this.isPotentialDndColumns() ? Te.ICON_PIVOT : Te.ICON_NOT_ALLOWED;
  }
  getExistingColumns() {
    return this.columnModel.getPivotColumns();
  }
}
Om([
  S("columnModel")
], Hl.prototype, "columnModel", void 0);
Om([
  S("loggerFactory")
], Hl.prototype, "loggerFactory", void 0);
Om([
  S("dragAndDropService")
], Hl.prototype, "dragAndDropService", void 0);
Om([
  B
], Hl.prototype, "passBeansUp", null);
var Wx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Hb extends X {
  constructor() {
    super();
  }
  postConstruct() {
    this.setGui(this.createNorthPanel()), this.addManagedListener(this.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onRowGroupChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, this.onRowGroupChanged.bind(this)), this.addManagedPropertyListener("rowGroupPanelShow", this.onRowGroupChanged.bind(this)), this.onRowGroupChanged();
  }
  createNorthPanel() {
    const e = document.createElement("div"), t = this.onDropPanelVisible.bind(this);
    return e.classList.add("ag-column-drop-wrapper"), x.setAriaRole(e, "presentation"), this.rowGroupComp = new Bl(!0), this.createManagedBean(this.rowGroupComp), this.pivotComp = new Hl(!0), this.createManagedBean(this.pivotComp), e.appendChild(this.rowGroupComp.getGui()), e.appendChild(this.pivotComp.getGui()), this.addManagedListener(this.rowGroupComp, X.EVENT_DISPLAYED_CHANGED, t), this.addManagedListener(this.pivotComp, X.EVENT_DISPLAYED_CHANGED, t), this.onDropPanelVisible(), e;
  }
  onDropPanelVisible() {
    const e = this.rowGroupComp.isDisplayed() && this.pivotComp.isDisplayed();
    this.rowGroupComp.addOrRemoveCssClass("ag-column-drop-horizontal-half-width", e), this.pivotComp.addOrRemoveCssClass("ag-column-drop-horizontal-half-width", e);
  }
  onRowGroupChanged() {
    if (!this.rowGroupComp)
      return;
    const e = this.gridOptionsService.get("rowGroupPanelShow");
    if (e === "always")
      this.rowGroupComp.setDisplayed(!0);
    else if (e === "onlyWhenGrouping") {
      const t = !this.columnModel.isRowGroupEmpty();
      this.rowGroupComp.setDisplayed(t);
    } else
      this.rowGroupComp.setDisplayed(!1);
  }
}
Wx([
  S("columnModel")
], Hb.prototype, "columnModel", void 0);
Wx([
  B
], Hb.prototype, "postConstruct", null);
var Wb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let lp = class extends H {
  execute(e) {
    const t = this.columnModel.isPivotMode(), i = this.filterManager.isAggregateFilterPresent() || this.filterManager.isAggregateQuickFilterPresent(), r = (d) => !d.node.group, n = (d) => d.node.leafGroup, s = this.gridOptionsService.getGroupAggFiltering() || (t ? n : r), { changedPath: a } = e, l = (d, u = !1) => {
      d.childrenAfterFilter && (d.childrenAfterAggFilter = d.childrenAfterFilter, u && d.childrenAfterAggFilter.forEach((h) => l(h, u)), this.setAllChildrenCount(d)), d.sibling && (d.sibling.childrenAfterAggFilter = d.childrenAfterAggFilter);
    }, c = (d) => {
      var u;
      d.childrenAfterAggFilter = ((u = d.childrenAfterFilter) === null || u === void 0 ? void 0 : u.filter((h) => {
        var p;
        return s({ node: h }) && this.filterManager.doesRowPassAggregateFilters({ rowNode: h }) ? (l(h, !0), !0) : (p = h.childrenAfterAggFilter) === null || p === void 0 ? void 0 : p.length;
      })) || null, this.setAllChildrenCount(d), d.sibling && (d.sibling.childrenAfterAggFilter = d.childrenAfterAggFilter);
    };
    a.forEachChangedNodeDepthFirst(i ? c : l, !0);
  }
  setAllChildrenCountTreeData(e) {
    let t = 0;
    e.childrenAfterAggFilter.forEach((i) => {
      t++, t += i.allChildrenCount;
    }), e.setAllChildrenCount(t);
  }
  setAllChildrenCountGridGrouping(e) {
    let t = 0;
    e.childrenAfterAggFilter.forEach((i) => {
      i.group ? t += i.allChildrenCount : t++;
    }), e.setAllChildrenCount(t);
  }
  setAllChildrenCount(e) {
    if (!e.hasChildren()) {
      e.setAllChildrenCount(null);
      return;
    }
    this.gridOptionsService.isTreeData() ? this.setAllChildrenCountTreeData(e) : this.setAllChildrenCountGridGrouping(e);
  }
};
Wb([
  S("filterManager")
], lp.prototype, "filterManager", void 0);
Wb([
  S("columnModel")
], lp.prototype, "columnModel", void 0);
lp = Wb([
  q("filterAggregatesStage")
], lp);
const RG = "30.0.5";
var uf = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Fr extends mu {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-group-filter">
                <div ref="eGroupField"></div>
                <div ref="eUnderlyingFilter"></div>
            </div>
        `
    );
  }
  postConstruct() {
    this.initialiseTabGuard({});
  }
  init(e) {
    return this.params = e, this.validateParams(), this.updateGroups().then(() => {
      this.addManagedListener(this.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.onColumnRowGroupChanged());
    });
  }
  validateParams() {
    const { colDef: e } = this.params;
    e.field && x.doOnce(() => console.warn('AG Grid: Group Column Filter does not work with the colDef property "field". This property will be ignored.'), "groupFilterFieldParam"), e.filterValueGetter && x.doOnce(() => console.warn('AG Grid: Group Column Filter does not work with the colDef property "filterValueGetter". This property will be ignored.'), "groupFilterFilterValueGetterParam"), e.filterParams && x.doOnce(() => console.warn('AG Grid: Group Column Filter does not work with the colDef property "filterParams". This property will be ignored.'), "groupFilterFilterParams");
  }
  updateGroups() {
    const e = this.updateGroupField();
    return this.getUnderlyingFilters(e);
  }
  getSourceColumns() {
    if (this.groupColumn = this.params.column, this.gridOptionsService.is("treeData"))
      return x.doOnce(() => console.warn("AG Grid: Group Column Filter does not work with Tree Data enabled. Please disable Tree Data, or use a different filter."), "groupFilterTreeData"), [];
    const e = this.columnModel.getSourceColumnsForGroupColumn(this.groupColumn);
    return e || (x.doOnce(() => console.warn("AG Grid: Group Column Filter only works on group columns. Please use a different filter."), "groupFilterNotGroupColumn"), []);
  }
  updateGroupField() {
    x.clearElement(this.eGroupField), this.eGroupFieldSelect && this.destroyBean(this.eGroupFieldSelect);
    const e = this.getSourceColumns(), t = e.filter((i) => i.isFilterAllowed());
    return t.length ? (e.length === 1 ? (this.selectedColumn = t[0], x.setDisplayed(this.eGroupField, !1)) : ((!this.selectedColumn || !t.some((i) => i.getId() === this.selectedColumn.getId())) && (this.selectedColumn = t[0]), this.createGroupFieldSelectElement(t), this.eGroupField.appendChild(this.eGroupFieldSelect.getGui()), this.eGroupField.appendChild(x.loadTemplate(
      /* html */
      '<div class="ag-filter-separator"></div>'
    )), x.setDisplayed(this.eGroupField, !0)), t) : (this.selectedColumn = void 0, x.setDisplayed(this.eGroupField, !1), null);
  }
  createGroupFieldSelectElement(e) {
    this.eGroupFieldSelect = this.createManagedBean(new zn());
    const t = this.localeService.getLocaleTextFunc();
    this.eGroupFieldSelect.setLabel(t("groupFilterSelect", "Select field:")), this.eGroupFieldSelect.setLabelAlignment("top"), this.eGroupFieldSelect.addOptions(e.map((i) => {
      var r;
      return {
        value: i.getId(),
        text: (r = this.columnModel.getDisplayNameForColumn(i, "groupFilter", !1)) !== null && r !== void 0 ? r : void 0
      };
    })), this.eGroupFieldSelect.setValue(this.selectedColumn.getId()), this.eGroupFieldSelect.onValueChange((i) => this.updateSelectedColumn(i)), this.eGroupFieldSelect.addCssClass("ag-group-filter-field-select-wrapper"), e.length === 1 && this.eGroupFieldSelect.setDisabled(!0);
  }
  getUnderlyingFilters(e) {
    if (!e)
      return this.filterColumnPairs = void 0, this.selectedFilter = void 0, this.groupColumn.setFilterActive(!1, "columnRowGroupChanged"), Qe.resolve();
    const t = [], i = [];
    return e.forEach((r) => {
      const n = this.filterManager.getOrCreateFilterWrapper(r, "COLUMN_MENU");
      n != null && n.filterPromise && t.push(n.filterPromise.then((s) => (s && i.push({
        filter: s,
        column: r
      }), r.getId() === this.selectedColumn.getId() && (this.selectedFilter = s != null ? s : void 0), s)));
    }), Qe.all(t).then(() => {
      this.filterColumnPairs = i, this.groupColumn.setFilterActive(this.isFilterActive(), "columnRowGroupChanged");
    });
  }
  addUnderlyingFilterElement() {
    if (x.clearElement(this.eUnderlyingFilter), !this.selectedColumn)
      return Qe.resolve();
    const e = this.filterManager.getOrCreateFilterWrapper(this.selectedColumn, "COLUMN_MENU");
    return e ? e.guiPromise.then((t) => {
      var i;
      this.eUnderlyingFilter.appendChild(t), (i = e.filterPromise) === null || i === void 0 || i.then((r) => {
        var n, s;
        (n = r == null ? void 0 : r.afterGuiAttached) === null || n === void 0 || n.call(r, this.afterGuiAttachedParams), !(!((s = this.afterGuiAttachedParams) === null || s === void 0) && s.suppressFocus) && this.eGroupFieldSelect && !this.eGroupFieldSelect.isDisabled() && this.eGroupFieldSelect.getFocusableElement().focus();
      });
    }) : Qe.resolve();
  }
  updateSelectedColumn(e) {
    var t, i;
    if (!e)
      return;
    (i = (t = this.selectedFilter) === null || t === void 0 ? void 0 : t.afterGuiDetached) === null || i === void 0 || i.call(t);
    const r = this.getFilterColumnPair(e);
    this.selectedColumn = r == null ? void 0 : r.column, this.selectedFilter = r == null ? void 0 : r.filter, this.dispatchEvent({
      type: Fr.EVENT_SELECTED_COLUMN_CHANGED
    }), this.addUnderlyingFilterElement();
  }
  isFilterActive() {
    var e;
    return !!(!((e = this.filterColumnPairs) === null || e === void 0) && e.some(({ filter: t }) => t.isFilterActive()));
  }
  doesFilterPass() {
    return !0;
  }
  getModel() {
    return null;
  }
  setModel() {
    return Qe.resolve();
  }
  afterGuiAttached(e) {
    this.afterGuiAttachedParams = e, this.addUnderlyingFilterElement();
  }
  afterGuiDetached() {
    var e, t;
    x.clearElement(this.eUnderlyingFilter), (t = (e = this.selectedFilter) === null || e === void 0 ? void 0 : e.afterGuiDetached) === null || t === void 0 || t.call(e);
  }
  onColumnRowGroupChanged() {
    this.updateGroups().then(() => {
      this.dispatchEvent({
        type: Fr.EVENT_COLUMN_ROW_GROUP_CHANGED
      }), this.eventService.dispatchEvent({
        type: "filterAllowedUpdated"
      });
    });
  }
  getFilterColumnPair(e) {
    var t;
    if (e)
      return (t = this.filterColumnPairs) === null || t === void 0 ? void 0 : t.find(({ column: i }) => i.getId() === e);
  }
  getSelectedFilter() {
    return this.selectedFilter;
  }
  getSelectedColumn() {
    return this.selectedColumn;
  }
  isFilterAllowed() {
    return !!this.selectedColumn;
  }
  destroy() {
    super.destroy();
  }
}
Fr.EVENT_COLUMN_ROW_GROUP_CHANGED = "columnRowGroupChanged";
Fr.EVENT_SELECTED_COLUMN_CHANGED = "selectedColumnChanged";
uf([
  S("filterManager")
], Fr.prototype, "filterManager", void 0);
uf([
  S("columnModel")
], Fr.prototype, "columnModel", void 0);
uf([
  L("eGroupField")
], Fr.prototype, "eGroupField", void 0);
uf([
  L("eUnderlyingFilter")
], Fr.prototype, "eUnderlyingFilter", void 0);
uf([
  B
], Fr.prototype, "postConstruct", null);
var jb = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Pm extends X {
  constructor() {
    super(
      /* html */
      `
            <div ref="eFloatingFilter" class="ag-group-floating-filter ag-floating-filter-input" role="presentation"></div>
        `
    );
  }
  init(e) {
    this.params = e;
    const t = this.gridOptionsService.get("groupDisplayType") === "multipleColumns";
    return new Qe((i) => {
      this.params.parentFilterInstance((r) => {
        this.parentFilterInstance = r, t ? this.setupUnderlyingFloatingFilterElement().then(() => i()) : (this.setupReadOnlyFloatingFilterElement(), i());
      });
    }).then(() => {
      this.addManagedListener(this.parentFilterInstance, Fr.EVENT_SELECTED_COLUMN_CHANGED, () => this.onSelectedColumnChanged()), this.addManagedListener(this.parentFilterInstance, Fr.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.onColumnRowGroupChanged());
    });
  }
  setupReadOnlyFloatingFilterElement() {
    if (!this.eFloatingFilterText) {
      this.eFloatingFilterText = this.createManagedBean(new Na());
      const e = this.columnModel.getDisplayNameForColumn(this.params.column, "header", !0), t = this.localeService.getLocaleTextFunc();
      this.eFloatingFilterText.setDisabled(!0).setInputAriaLabel(`${e} ${t("ariaFilterInput", "Filter Input")}`).addGuiEventListener("click", () => this.params.showParentFilter());
    }
    this.updateDisplayedValue(), this.eFloatingFilter.appendChild(this.eFloatingFilterText.getGui());
  }
  setupUnderlyingFloatingFilterElement() {
    this.showingUnderlyingFloatingFilter = !1, this.underlyingFloatingFilter = void 0, x.clearElement(this.eFloatingFilter);
    const e = this.parentFilterInstance.getSelectedColumn();
    if (e && !e.isVisible()) {
      const t = this.filterManager.getFloatingFilterCompDetails(e, this.params.showParentFilter);
      if (t)
        return this.columnVisibleChangedListener || (this.columnVisibleChangedListener = this.addManagedListener(e, me.EVENT_VISIBLE_CHANGED, this.onColumnVisibleChanged.bind(this))), t.newAgStackInstance().then((i) => {
          var r, n;
          this.underlyingFloatingFilter = i, (r = this.underlyingFloatingFilter) === null || r === void 0 || r.onParentModelChanged((n = this.parentFilterInstance.getSelectedFilter()) === null || n === void 0 ? void 0 : n.getModel()), this.appendChild(i.getGui()), this.showingUnderlyingFloatingFilter = !0;
        });
    }
    return this.setupReadOnlyFloatingFilterElement(), Qe.resolve();
  }
  onColumnVisibleChanged() {
    this.setupUnderlyingFloatingFilterElement();
  }
  onParentModelChanged(e, t) {
    var i, r;
    this.showingUnderlyingFloatingFilter ? (i = this.underlyingFloatingFilter) === null || i === void 0 || i.onParentModelChanged((r = this.parentFilterInstance.getSelectedFilter()) === null || r === void 0 ? void 0 : r.getModel(), t) : this.updateDisplayedValue();
  }
  updateDisplayedValue() {
    if (!this.parentFilterInstance || !this.eFloatingFilterText)
      return;
    const e = this.parentFilterInstance.getSelectedFilter();
    if (!e) {
      this.eFloatingFilterText.setValue(""), this.eFloatingFilterText.setDisplayed(!1);
      return;
    }
    if (this.eFloatingFilterText.setDisplayed(!0), e.getModelAsString) {
      const t = e.getModel();
      this.eFloatingFilterText.setValue(t == null ? "" : e.getModelAsString(t));
    } else
      this.eFloatingFilterText.setValue("");
  }
  onSelectedColumnChanged() {
    this.showingUnderlyingFloatingFilter || this.updateDisplayedValue();
  }
  onColumnRowGroupChanged() {
    this.showingUnderlyingFloatingFilter || this.updateDisplayedValue();
  }
  destroy() {
    super.destroy();
  }
}
jb([
  S("columnModel")
], Pm.prototype, "columnModel", void 0);
jb([
  S("filterManager")
], Pm.prototype, "filterManager", void 0);
jb([
  L("eFloatingFilter")
], Pm.prototype, "eFloatingFilter", void 0);
const jx = {
  version: RG,
  moduleName: Q.RowGroupingModule,
  beans: [Ts, lp, xs, ap, zd, Wn],
  agStackComponents: [
    { componentName: "AgGridHeaderDropZones", componentClass: Hb }
  ],
  userComponents: [
    { componentName: "agGroupColumnFilter", componentClass: Fr },
    { componentName: "agGroupColumnFloatingFilter", componentClass: Pm }
  ],
  dependantModules: [
    Pi
  ]
};
var Am = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Kd extends vi {
  constructor(e) {
    super(e, "aggregation");
  }
  passBeansUp() {
    super.setBeans({
      gridOptionsService: this.gridOptionsService,
      eventService: this.eventService,
      context: this.getContext(),
      loggerFactory: this.loggerFactory,
      dragAndDropService: this.dragAndDropService
    });
    const e = this.localeService.getLocaleTextFunc(), t = e("valueColumnsEmptyMessage", "Drag here to aggregate"), i = e("values", "Values");
    super.init({
      dragAndDropIcon: Te.ICON_AGGREGATE,
      icon: x.createIconNoSpan("valuePanel", this.gridOptionsService, null),
      emptyMessage: t,
      title: i
    }), this.addManagedListener(this.eventService, w.EVENT_COLUMN_VALUE_CHANGED, this.refreshGui.bind(this));
  }
  getAriaLabel() {
    return this.localeService.getLocaleTextFunc()("ariaValuesDropZonePanelLabel", "Values");
  }
  getTooltipParams() {
    const e = super.getTooltipParams();
    return e.location = "valueColumnsList", e;
  }
  getIconName() {
    return this.isPotentialDndColumns() ? Te.ICON_AGGREGATE : Te.ICON_NOT_ALLOWED;
  }
  isColumnDroppable(e) {
    return this.gridOptionsService.is("functionsReadOnly") || !e.isPrimary() ? !1 : e.isAllowValue() && !e.isValueActive();
  }
  updateColumns(e) {
    if (this.gridOptionsService.is("functionsPassive")) {
      const t = {
        type: w.EVENT_COLUMN_VALUE_CHANGE_REQUEST,
        columns: e
      };
      this.eventService.dispatchEvent(t);
    } else
      this.columnModel.setValueColumns(e, "toolPanelUi");
  }
  getExistingColumns() {
    return this.columnModel.getValueColumns();
  }
}
Am([
  S("columnModel")
], Kd.prototype, "columnModel", void 0);
Am([
  S("loggerFactory")
], Kd.prototype, "loggerFactory", void 0);
Am([
  S("dragAndDropService")
], Kd.prototype, "dragAndDropService", void 0);
Am([
  B
], Kd.prototype, "passBeansUp", null);
var Ux = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Ya extends X {
  constructor() {
    super(Ya.TEMPLATE);
  }
  // we allow dragging in the toolPanel, but not when this component appears in the column menu
  init(e, t, i) {
    this.allowDragging = e, this.params = t, this.eventType = i, this.primaryColsHeaderPanel.init(this.params);
    const r = this.params.suppressColumnFilter, n = this.params.suppressColumnSelectAll;
    this.params.suppressColumnExpandAll && r && n && this.primaryColsHeaderPanel.setDisplayed(!1), this.addManagedListener(this.primaryColsListPanel, "groupExpanded", this.onGroupExpanded.bind(this)), this.addManagedListener(this.primaryColsListPanel, "selectionChanged", this.onSelectionChange.bind(this)), this.primaryColsListPanel.init(this.params, this.allowDragging, this.eventType), this.addManagedListener(this.primaryColsHeaderPanel, "expandAll", this.onExpandAll.bind(this)), this.addManagedListener(this.primaryColsHeaderPanel, "collapseAll", this.onCollapseAll.bind(this)), this.addManagedListener(this.primaryColsHeaderPanel, "selectAll", this.onSelectAll.bind(this)), this.addManagedListener(this.primaryColsHeaderPanel, "unselectAll", this.onUnselectAll.bind(this)), this.addManagedListener(this.primaryColsHeaderPanel, "filterChanged", this.onFilterChanged.bind(this)), this.positionableFeature = new ec(this.getGui(), { minHeight: 100 }), this.createManagedBean(this.positionableFeature);
  }
  toggleResizable(e) {
    this.positionableFeature.setResizable(e ? { bottom: !0 } : !1);
  }
  onExpandAll() {
    this.primaryColsListPanel.doSetExpandedAll(!0);
  }
  onCollapseAll() {
    this.primaryColsListPanel.doSetExpandedAll(!1);
  }
  expandGroups(e) {
    this.primaryColsListPanel.setGroupsExpanded(!0, e);
  }
  collapseGroups(e) {
    this.primaryColsListPanel.setGroupsExpanded(!1, e);
  }
  setColumnLayout(e) {
    this.primaryColsListPanel.setColumnLayout(e);
  }
  onFilterChanged(e) {
    this.primaryColsListPanel.setFilterText(e.filterText);
  }
  syncLayoutWithGrid() {
    this.primaryColsListPanel.onColumnsChanged();
  }
  onSelectAll() {
    this.primaryColsListPanel.doSetSelectedAll(!0);
  }
  onUnselectAll() {
    this.primaryColsListPanel.doSetSelectedAll(!1);
  }
  onGroupExpanded(e) {
    this.primaryColsHeaderPanel.setExpandState(e.state);
  }
  onSelectionChange(e) {
    this.primaryColsHeaderPanel.setSelectionState(e.state);
  }
}
Ya.TEMPLATE = `<div class="ag-column-select">
            <ag-primary-cols-header ref="primaryColsHeaderPanel"></ag-primary-cols-header>
            <ag-primary-cols-list ref="primaryColsListPanel"></ag-primary-cols-list>
        </div>`;
Ux([
  L("primaryColsHeaderPanel")
], Ya.prototype, "primaryColsHeaderPanel", void 0);
Ux([
  L("primaryColsListPanel")
], Ya.prototype, "primaryColsListPanel", void 0);
var $x = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class xu extends X {
  constructor() {
    super(xu.TEMPLATE), this.initialised = !1, this.childDestroyFuncs = [];
  }
  // lazy initialise the panel
  setVisible(e) {
    super.setDisplayed(e), e && !this.initialised && this.init(this.params);
  }
  init(e) {
    const t = {
      suppressColumnMove: !1,
      suppressColumnSelectAll: !1,
      suppressColumnFilter: !1,
      suppressColumnExpandAll: !1,
      contractColumnSelection: !1,
      suppressPivotMode: !1,
      suppressRowGroups: !1,
      suppressValues: !1,
      suppressPivots: !1,
      suppressSyncLayoutWithGrid: !1,
      api: this.gridApi,
      columnApi: this.columnApi
    };
    if (this.params = Object.assign(Object.assign(Object.assign({}, t), e), { context: this.gridOptionsService.context }), this.isRowGroupingModuleLoaded() && !this.params.suppressPivotMode && (this.pivotModePanel = this.createBean(new sp()), this.childDestroyFuncs.push(() => this.destroyBean(this.pivotModePanel)), this.appendChild(this.pivotModePanel)), this.primaryColsPanel = this.createBean(new Ya()), this.childDestroyFuncs.push(() => this.destroyBean(this.primaryColsPanel)), this.primaryColsPanel.init(!0, this.params, "toolPanelUi"), this.primaryColsPanel.addCssClass("ag-column-panel-column-select"), this.appendChild(this.primaryColsPanel), this.isRowGroupingModuleLoaded()) {
      this.params.suppressRowGroups || (this.rowGroupDropZonePanel = this.createBean(new Bl(!1)), this.childDestroyFuncs.push(() => this.destroyBean(this.rowGroupDropZonePanel)), this.appendChild(this.rowGroupDropZonePanel)), this.params.suppressValues || (this.valuesDropZonePanel = this.createBean(new Kd(!1)), this.childDestroyFuncs.push(() => this.destroyBean(this.valuesDropZonePanel)), this.appendChild(this.valuesDropZonePanel)), this.params.suppressPivots || (this.pivotDropZonePanel = this.createBean(new Hl(!1)), this.childDestroyFuncs.push(() => this.destroyBean(this.pivotDropZonePanel)), this.appendChild(this.pivotDropZonePanel)), this.setLastVisible();
      const i = this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_MODE_CHANGED, () => {
        this.resetChildrenHeight(), this.setLastVisible();
      });
      this.childDestroyFuncs.push(() => i());
    }
    this.initialised = !0;
  }
  setPivotModeSectionVisible(e) {
    this.isRowGroupingModuleLoaded() && (this.pivotModePanel ? this.pivotModePanel.setDisplayed(e) : e && (this.pivotModePanel = this.createBean(new sp()), this.getGui().insertBefore(this.pivotModePanel.getGui(), this.getGui().firstChild), this.childDestroyFuncs.push(() => this.destroyBean(this.pivotModePanel))), this.setLastVisible());
  }
  setRowGroupsSectionVisible(e) {
    this.isRowGroupingModuleLoaded() && (this.rowGroupDropZonePanel ? this.rowGroupDropZonePanel.setDisplayed(e) : e && (this.rowGroupDropZonePanel = this.createManagedBean(new Bl(!1)), this.appendChild(this.rowGroupDropZonePanel)), this.setLastVisible());
  }
  setValuesSectionVisible(e) {
    this.isRowGroupingModuleLoaded() && (this.valuesDropZonePanel ? this.valuesDropZonePanel.setDisplayed(e) : e && (this.valuesDropZonePanel = this.createManagedBean(new Kd(!1)), this.appendChild(this.valuesDropZonePanel)), this.setLastVisible());
  }
  setPivotSectionVisible(e) {
    this.isRowGroupingModuleLoaded() && (this.pivotDropZonePanel ? this.pivotDropZonePanel.setDisplayed(e) : e && (this.pivotDropZonePanel = this.createManagedBean(new Hl(!1)), this.appendChild(this.pivotDropZonePanel), this.pivotDropZonePanel.setDisplayed(e)), this.setLastVisible());
  }
  setResizers() {
    [
      this.primaryColsPanel,
      this.rowGroupDropZonePanel,
      this.valuesDropZonePanel,
      this.pivotDropZonePanel
    ].forEach((e) => {
      if (!e)
        return;
      const t = e.getGui();
      e.toggleResizable(!t.classList.contains("ag-last-column-drop") && !t.classList.contains("ag-hidden"));
    });
  }
  setLastVisible() {
    const e = this.getGui();
    Array.prototype.slice.call(e.querySelectorAll(".ag-column-drop")).forEach((n) => n.classList.remove("ag-last-column-drop"));
    const i = e.querySelectorAll(".ag-column-drop:not(.ag-hidden)"), r = x.last(i);
    r && r.classList.add("ag-last-column-drop"), this.setResizers();
  }
  resetChildrenHeight() {
    const t = this.getGui().children;
    for (let i = 0; i < t.length; i++) {
      const r = t[i];
      r.style.removeProperty("height"), r.style.removeProperty("flex");
    }
  }
  isRowGroupingModuleLoaded() {
    return Z.__assertRegistered(Q.RowGroupingModule, "Row Grouping", this.context.getGridId());
  }
  expandColumnGroups(e) {
    this.primaryColsPanel.expandGroups(e);
  }
  collapseColumnGroups(e) {
    this.primaryColsPanel.collapseGroups(e);
  }
  setColumnLayout(e) {
    this.primaryColsPanel.setColumnLayout(e);
  }
  syncLayoutWithGrid() {
    this.primaryColsPanel.syncLayoutWithGrid();
  }
  destroyChildren() {
    this.childDestroyFuncs.forEach((e) => e()), this.childDestroyFuncs.length = 0, x.clearElement(this.getGui());
  }
  refresh() {
    this.destroyChildren(), this.init(this.params);
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so this must be public.
  destroy() {
    this.destroyChildren(), super.destroy();
  }
}
xu.TEMPLATE = '<div class="ag-column-panel"></div>';
$x([
  S("gridApi")
], xu.prototype, "gridApi", void 0);
$x([
  S("columnApi")
], xu.prototype, "columnApi", void 0);
var zx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Mm extends X {
  constructor() {
    super(
      /* html */
      '<div class="ag-tool-panel-horizontal-resize"></div>'
    ), this.minWidth = 100, this.maxWidth = null;
  }
  setElementToResize(e) {
    this.elementToResize = e;
  }
  postConstruct() {
    const e = this.horizontalResizeService.addResizeBar({
      eResizeBar: this.getGui(),
      dragStartPixels: 1,
      onResizeStart: this.onResizeStart.bind(this),
      onResizing: this.onResizing.bind(this),
      onResizeEnd: this.onResizeEnd.bind(this)
    });
    this.addDestroyFunc(e), this.setInverted(this.gridOptionsService.is("enableRtl"));
  }
  dispatchResizeEvent(e, t, i) {
    const r = {
      type: w.EVENT_TOOL_PANEL_SIZE_CHANGED,
      width: i,
      started: e,
      ended: t
    };
    this.eventService.dispatchEvent(r);
  }
  onResizeStart() {
    this.startingWidth = this.elementToResize.offsetWidth, this.dispatchResizeEvent(!0, !1, this.startingWidth);
  }
  onResizeEnd(e) {
    return this.onResizing(e, !0);
  }
  onResizing(e, t = !1) {
    const i = this.inverted ? -1 : 1;
    let r = Math.max(this.minWidth, Math.floor(this.startingWidth - e * i));
    this.maxWidth != null && (r = Math.min(this.maxWidth, r)), this.elementToResize.style.width = `${r}px`, this.dispatchResizeEvent(!1, t, r);
  }
  setInverted(e) {
    this.inverted = e;
  }
  setMaxWidth(e) {
    this.maxWidth = e;
  }
  setMinWidth(e) {
    e != null ? this.minWidth = e : this.minWidth = 100;
  }
}
zx([
  S("horizontalResizeService")
], Mm.prototype, "horizontalResizeService", void 0);
zx([
  B
], Mm.prototype, "postConstruct", null);
var _m = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Ds extends X {
  constructor(e) {
    super(), this.toolPanelDef = e;
  }
  getToolPanelId() {
    return this.toolPanelDef.id;
  }
  postConstruct() {
    const e = this.createTemplate();
    this.setTemplate(e), this.setLabel(), this.setIcon(), this.addManagedListener(this.eToggleButton, "click", this.onButtonPressed.bind(this)), this.eToggleButton.setAttribute("id", `ag-${this.getCompId()}-button`);
  }
  createTemplate() {
    return (
      /* html */
      `<div class="ag-side-button" role="presentation">
                <button type="button" ref="eToggleButton" tabindex="-1" role="tab" aria-expanded="false" class="ag-button ag-side-button-button">
                    <div ref="eIconWrapper" class="ag-side-button-icon-wrapper" aria-hidden="true"></div>
                    <span ref ="eLabel" class="ag-side-button-label"></span>
                </button>
            </div>`
    );
  }
  setLabel() {
    const e = this.localeService.getLocaleTextFunc(), t = this.toolPanelDef, i = e(t.labelKey, t.labelDefault);
    this.eLabel.innerText = i;
  }
  setIcon() {
    this.eIconWrapper.insertAdjacentElement("afterbegin", x.createIconNoSpan(this.toolPanelDef.iconKey, this.gridOptionsService));
  }
  onButtonPressed() {
    this.dispatchEvent({ type: Ds.EVENT_TOGGLE_BUTTON_CLICKED });
  }
  setSelected(e) {
    this.addOrRemoveCssClass("ag-selected", e), x.setAriaExpanded(this.eToggleButton, e);
  }
  getButtonElement() {
    return this.eToggleButton;
  }
}
Ds.EVENT_TOGGLE_BUTTON_CLICKED = "toggleButtonClicked";
_m([
  L("eToggleButton")
], Ds.prototype, "eToggleButton", void 0);
_m([
  L("eIconWrapper")
], Ds.prototype, "eIconWrapper", void 0);
_m([
  L("eLabel")
], Ds.prototype, "eLabel", void 0);
_m([
  B
], Ds.prototype, "postConstruct", null);
var Im = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class jn extends X {
  constructor() {
    super(jn.TEMPLATE), this.buttonComps = [];
  }
  postConstruct() {
    this.addManagedListener(this.getFocusableElement(), "keydown", this.handleKeyDown.bind(this));
  }
  handleKeyDown(e) {
    if (e.key !== V.TAB || !e.shiftKey)
      return;
    const t = x.last(this.columnModel.getAllDisplayedColumns());
    this.focusService.focusGridView(t, !0) && e.preventDefault();
  }
  setActiveButton(e) {
    this.buttonComps.forEach((t) => {
      t.setSelected(e === t.getToolPanelId());
    });
  }
  addButtonComp(e) {
    const t = this.createBean(new Ds(e));
    return this.buttonComps.push(t), this.appendChild(t), t.addEventListener(Ds.EVENT_TOGGLE_BUTTON_CLICKED, () => {
      this.dispatchEvent({
        type: jn.EVENT_SIDE_BAR_BUTTON_CLICKED,
        toolPanelId: e.id
      });
    }), t;
  }
  clearButtons() {
    this.buttonComps = this.destroyBeans(this.buttonComps), x.clearElement(this.getGui());
  }
}
jn.EVENT_SIDE_BAR_BUTTON_CLICKED = "sideBarButtonClicked";
jn.TEMPLATE = '<div class="ag-side-buttons" role="tablist"></div>';
Im([
  S("focusService")
], jn.prototype, "focusService", void 0);
Im([
  S("columnModel")
], jn.prototype, "columnModel", void 0);
Im([
  B
], jn.prototype, "postConstruct", null);
Im([
  dt
], jn.prototype, "clearButtons", null);
class Ki {
  static parse(e) {
    if (!e)
      return;
    if (e === !0)
      return {
        toolPanels: [
          Ki.DEFAULT_COLUMN_COMP,
          Ki.DEFAULT_FILTER_COMP
        ],
        defaultToolPanel: "columns"
      };
    if (typeof e == "string")
      return Ki.parse([e]);
    if (Array.isArray(e)) {
      const i = [];
      return e.forEach((r) => {
        const n = Ki.DEFAULT_BY_KEY[r];
        if (!n) {
          console.warn(`AG Grid: the key ${r} is not a valid key for specifying a tool panel, valid keys are: ${Object.keys(Ki.DEFAULT_BY_KEY).join(",")}`);
          return;
        }
        i.push(n);
      }), i.length === 0 ? void 0 : {
        toolPanels: i,
        defaultToolPanel: i[0].id
      };
    }
    return {
      toolPanels: Ki.parseComponents(e.toolPanels),
      defaultToolPanel: e.defaultToolPanel,
      hiddenByDefault: e.hiddenByDefault,
      position: e.position
    };
  }
  static parseComponents(e) {
    const t = [];
    return e && e.forEach((i) => {
      let r = null;
      if (typeof i == "string") {
        const n = Ki.DEFAULT_BY_KEY[i];
        if (!n) {
          console.warn(`AG Grid: the key ${i} is not a valid key for specifying a tool panel, valid keys are: ${Object.keys(Ki.DEFAULT_BY_KEY).join(",")}`);
          return;
        }
        r = n;
      } else
        r = i;
      t.push(r);
    }), t;
  }
}
Ki.DEFAULT_COLUMN_COMP = {
  id: "columns",
  labelDefault: "Columns",
  labelKey: "columns",
  iconKey: "columns",
  toolPanel: "agColumnsToolPanel"
};
Ki.DEFAULT_FILTER_COMP = {
  id: "filters",
  labelDefault: "Filters",
  labelKey: "filters",
  iconKey: "filter",
  toolPanel: "agFiltersToolPanel"
};
Ki.DEFAULT_BY_KEY = {
  columns: Ki.DEFAULT_COLUMN_COMP,
  filters: Ki.DEFAULT_FILTER_COMP
};
var Kx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Du extends X {
  constructor() {
    super(Du.TEMPLATE);
  }
  setupResize() {
    const e = this.getGui(), t = this.resizeBar = this.createManagedBean(new Mm());
    e.setAttribute("id", `ag-${this.getCompId()}`), t.setElementToResize(e), this.appendChild(t);
  }
  getToolPanelId() {
    return this.toolPanelId;
  }
  setToolPanelDef(e) {
    const { id: t, minWidth: i, maxWidth: r, width: n } = e;
    this.toolPanelId = t, this.width = n;
    const s = {}, l = this.userComponentFactory.getToolPanelCompDetails(e, s).newAgStackInstance();
    if (l == null) {
      console.warn(`AG Grid: error processing tool panel component ${t}. You need to specify 'toolPanel'`);
      return;
    }
    l.then(this.setToolPanelComponent.bind(this)), i != null && this.resizeBar.setMinWidth(i), r != null && this.resizeBar.setMaxWidth(r);
  }
  setToolPanelComponent(e) {
    this.toolPanelCompInstance = e, this.appendChild(e.getGui()), this.addDestroyFunc(() => {
      this.destroyBean(e);
    }), this.width && (this.getGui().style.width = `${this.width}px`);
  }
  getToolPanelInstance() {
    return this.toolPanelCompInstance;
  }
  setResizerSizerSide(e) {
    const t = this.gridOptionsService.is("enableRtl"), i = e === "left", r = t ? i : !i;
    this.resizeBar.setInverted(r);
  }
  refresh() {
    this.toolPanelCompInstance.refresh();
  }
}
Du.TEMPLATE = '<div class="ag-tool-panel-wrapper" role="tabpanel"/>';
Kx([
  S("userComponentFactory")
], Du.prototype, "userComponentFactory", void 0);
Kx([
  B
], Du.prototype, "setupResize", null);
var Fm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Xa extends X {
  constructor() {
    super(Xa.TEMPLATE), this.toolPanelWrappers = [];
  }
  postConstruct() {
    this.sideBarButtonsComp.addEventListener(jn.EVENT_SIDE_BAR_BUTTON_CLICKED, this.onToolPanelButtonClicked.bind(this)), this.setSideBarDef(), this.addManagedPropertyListener("sideBar", () => {
      this.clearDownUi(), this.setSideBarDef();
    }), this.gridApi.registerSideBarComp(this), this.createManagedBean(new Ji(this.getFocusableElement(), {
      onTabKeyDown: this.onTabKeyDown.bind(this),
      handleKeyDown: this.handleKeyDown.bind(this)
    }));
  }
  onTabKeyDown(e) {
    if (e.defaultPrevented)
      return;
    const { focusService: t, sideBarButtonsComp: i } = this, r = this.getGui(), n = i.getGui(), a = this.gridOptionsService.getDocument().activeElement, l = r.querySelector(".ag-tool-panel-wrapper:not(.ag-hidden)"), c = e.target;
    if (!l)
      return;
    if (n.contains(a)) {
      t.focusInto(l, e.shiftKey) && e.preventDefault();
      return;
    }
    if (!e.shiftKey)
      return;
    let d = null;
    l.contains(a) ? d = this.focusService.findNextFocusableElement(l, void 0, !0) : t.isTargetUnderManagedComponent(l, c) && e.shiftKey && (d = this.focusService.findFocusableElementBeforeTabGuard(l, c)), d || (d = n.querySelector(".ag-selected button")), d && (e.preventDefault(), d.focus());
  }
  handleKeyDown(e) {
    const t = this.gridOptionsService.getDocument();
    if (!this.sideBarButtonsComp.getGui().contains(t.activeElement))
      return;
    const i = this.sideBarButtonsComp.getGui(), r = Array.prototype.slice.call(i.querySelectorAll(".ag-side-button")), n = t.activeElement, s = r.findIndex((c) => c.contains(n));
    let a = null;
    switch (e.key) {
      case V.LEFT:
      case V.UP:
        a = Math.max(0, s - 1);
        break;
      case V.RIGHT:
      case V.DOWN:
        a = Math.min(s + 1, r.length - 1);
        break;
    }
    if (a === null)
      return;
    const l = r[a].querySelector("button");
    l && (l.focus(), e.preventDefault());
  }
  onToolPanelButtonClicked(e) {
    const t = e.toolPanelId;
    this.openedItem() === t ? this.openToolPanel(void 0, "sideBarButtonClicked") : this.openToolPanel(t, "sideBarButtonClicked");
  }
  clearDownUi() {
    this.sideBarButtonsComp.clearButtons(), this.destroyToolPanelWrappers();
  }
  setSideBarDef() {
    this.setDisplayed(!1);
    const e = this.gridOptionsService.get("sideBar");
    if (this.sideBar = Ki.parse(e), this.sideBar && this.sideBar.toolPanels) {
      const t = !this.sideBar.hiddenByDefault;
      this.setDisplayed(t);
      const i = this.sideBar.toolPanels;
      this.createToolPanelsAndSideButtons(i), this.setSideBarPosition(this.sideBar.position), this.sideBar.hiddenByDefault || this.openToolPanel(this.sideBar.defaultToolPanel, "sideBarInitializing");
    }
  }
  getDef() {
    return this.sideBar;
  }
  setSideBarPosition(e) {
    e || (e = "right");
    const t = e === "left", i = t ? "right" : "left";
    return this.addOrRemoveCssClass("ag-side-bar-left", t), this.addOrRemoveCssClass("ag-side-bar-right", !t), this.toolPanelWrappers.forEach((r) => {
      r.setResizerSizerSide(i);
    }), this;
  }
  createToolPanelsAndSideButtons(e) {
    for (const t of e)
      this.createToolPanelAndSideButton(t);
  }
  validateDef(e) {
    return e.id == null ? (console.warn("AG Grid: please review all your toolPanel components, it seems like at least one of them doesn't have an id"), !1) : !(e.toolPanel === "agColumnsToolPanel" && !Z.__assertRegistered(Q.ColumnsToolPanelModule, "Column Tool Panel", this.context.getGridId()) || e.toolPanel === "agFiltersToolPanel" && !Z.__assertRegistered(Q.FiltersToolPanelModule, "Filters Tool Panel", this.context.getGridId()));
  }
  createToolPanelAndSideButton(e) {
    if (!this.validateDef(e))
      return;
    const t = this.sideBarButtonsComp.addButtonComp(e), i = this.getContext().createBean(new Du());
    i.setToolPanelDef(e), i.setDisplayed(!1);
    const r = i.getGui();
    this.appendChild(r), this.toolPanelWrappers.push(i), x.setAriaControls(t.getButtonElement(), r);
  }
  refresh() {
    this.toolPanelWrappers.forEach((e) => e.refresh());
  }
  openToolPanel(e, t = "api") {
    const i = this.openedItem();
    if (i === e)
      return;
    this.toolPanelWrappers.forEach((s) => {
      const a = e === s.getToolPanelId();
      s.setDisplayed(a);
    });
    const r = this.openedItem();
    i !== r && (this.sideBarButtonsComp.setActiveButton(e), this.raiseToolPanelVisibleEvent(e, i != null ? i : void 0, t));
  }
  getToolPanelInstance(e) {
    const t = this.toolPanelWrappers.filter((i) => i.getToolPanelId() === e)[0];
    if (!t) {
      console.warn(`AG Grid: unable to lookup Tool Panel as invalid key supplied: ${e}`);
      return;
    }
    return t.getToolPanelInstance();
  }
  raiseToolPanelVisibleEvent(e, t, i) {
    const r = !!e && !!t;
    if (t) {
      const n = {
        type: w.EVENT_TOOL_PANEL_VISIBLE_CHANGED,
        source: i,
        key: t,
        visible: !1,
        switchingToolPanel: r
      };
      this.eventService.dispatchEvent(n);
    }
    if (e) {
      const n = {
        type: w.EVENT_TOOL_PANEL_VISIBLE_CHANGED,
        source: i,
        key: e,
        visible: !0,
        switchingToolPanel: r
      };
      this.eventService.dispatchEvent(n);
    }
  }
  close(e = "api") {
    this.openToolPanel(void 0, e);
  }
  isToolPanelShowing() {
    return !!this.openedItem();
  }
  openedItem() {
    let e = null;
    return this.toolPanelWrappers.forEach((t) => {
      t.isDisplayed() && (e = t.getToolPanelId());
    }), e;
  }
  destroyToolPanelWrappers() {
    this.toolPanelWrappers.forEach((e) => {
      x.removeFromParent(e.getGui()), this.destroyBean(e);
    }), this.toolPanelWrappers.length = 0;
  }
  destroy() {
    this.destroyToolPanelWrappers(), super.destroy();
  }
}
Xa.TEMPLATE = `<div class="ag-side-bar ag-unselectable">
            <ag-side-bar-buttons ref="sideBarButtons"></ag-side-bar-buttons>
        </div>`;
Fm([
  S("gridApi")
], Xa.prototype, "gridApi", void 0);
Fm([
  S("focusService")
], Xa.prototype, "focusService", void 0);
Fm([
  L("sideBarButtons")
], Xa.prototype, "sideBarButtonsComp", void 0);
Fm([
  B
], Xa.prototype, "postConstruct", null);
var Yx = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Ug = class extends H {
  constructor() {
    super(...arguments), this.isColGroupDef = (e) => e && typeof e.children != "undefined", this.getId = (e) => this.isColGroupDef(e) ? e.groupId : e.colId;
  }
  createColumnTree(e) {
    const t = [], i = (n, s) => {
      if (this.isColGroupDef(n)) {
        const a = n, l = typeof a.groupId != "undefined" ? a.groupId : a.headerName, c = new Be(a, l, !1, s), d = [];
        return a.children.forEach((u) => {
          const h = i(u, s + 1);
          h && d.push(h);
        }), c.setChildren(d), c;
      } else {
        const a = n, l = a.colId ? a.colId : a.field, c = this.columnModel.getPrimaryColumn(l);
        return c || t.push(a), c;
      }
    }, r = [];
    return e.forEach((n) => {
      const s = i(n, 0);
      s && r.push(s);
    }), t.length > 0 && console.warn("AG Grid: unable to find grid columns for the supplied colDef(s):", t), r;
  }
  syncLayoutWithGrid(e) {
    const t = this.getLeafPathTrees(), i = this.mergeLeafPathTrees(t);
    e(i);
  }
  getLeafPathTrees() {
    const e = (r, n) => {
      let s;
      if (r instanceof Be)
        if (r.isPadding())
          s = n;
        else {
          const l = Object.assign({}, r.getColGroupDef());
          l.groupId = r.getGroupId(), l.children = [n], s = l;
        }
      else {
        const l = Object.assign({}, r.getColDef());
        l.colId = r.getColId(), s = l;
      }
      const a = r.getOriginalParent();
      return a ? e(a, s) : s;
    };
    return this.columnModel.getAllGridColumns().filter((r) => {
      const n = r.getColDef();
      return r.isPrimary() && !n.showRowGroup;
    }).map((r) => e(r, r.getColDef()));
  }
  mergeLeafPathTrees(e) {
    const t = (n, s) => this.isColGroupDef(n) && this.isColGroupDef(s) && this.getId(n) === this.getId(s), i = (n, s) => {
      if (!this.isColGroupDef(s))
        return n;
      const a = n, l = s;
      return l.children && l.groupId && this.addChildrenToGroup(a, l.groupId, l.children[0]) || l.children.forEach((c) => i(a, c)), a;
    }, r = [];
    for (let n = 1; n <= e.length; n++) {
      const s = e[n - 1], a = e[n];
      t(s, a) ? e[n] = i(s, a) : r.push(s);
    }
    return r;
  }
  addChildrenToGroup(e, t, i) {
    const r = (a, l) => {
      const c = a.children.map(this.getId), d = x.includes(c, this.getId(l)), u = x.last(a.children), h = u && this.getId(u) !== this.getId(l);
      return d && h;
    };
    if (!this.isColGroupDef(e))
      return !0;
    const n = e, s = i;
    if (r(n, s))
      return n.children.push(s), !0;
    if (n.groupId === t) {
      const a = n.children.map(this.getId);
      if (!x.includes(a, this.getId(s)))
        return n.children.push(s), !0;
    }
    return n.children.forEach((a) => this.addChildrenToGroup(a, t, i)), !1;
  }
};
Yx([
  S("columnModel")
], Ug.prototype, "columnModel", void 0);
Ug = Yx([
  q("toolPanelColDefService")
], Ug);
const TG = "30.0.5", Ub = {
  version: TG,
  moduleName: Q.SideBarModule,
  beans: [Ug],
  agStackComponents: [
    { componentName: "AgHorizontalResize", componentClass: Mm },
    { componentName: "AgSideBar", componentClass: Xa },
    { componentName: "AgSideBarButtons", componentClass: jn }
  ],
  dependantModules: [
    Pi
  ]
};
var hf = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Wl = class {
  selectAllChildren(e, t, i) {
    const r = this.extractAllLeafColumns(e);
    this.setAllColumns(r, t, i);
  }
  setColumn(e, t, i) {
    this.setAllColumns([e], t, i);
  }
  setAllColumns(e, t, i) {
    this.columnModel.isPivotMode() ? this.setAllPivot(e, t, i) : this.setAllVisible(e, t, i);
  }
  extractAllLeafColumns(e) {
    const t = [], i = (r) => {
      r.forEach((n) => {
        n.isPassesFilter() && (n.isGroup() ? i(n.getChildren()) : t.push(n.getColumn()));
      });
    };
    return i(e), t;
  }
  setAllVisible(e, t, i) {
    const r = [];
    e.forEach((n) => {
      n.getColDef().lockVisible || n.isVisible() != t && r.push({
        colId: n.getId(),
        hide: !t
      });
    }), r.length > 0 && this.columnModel.applyColumnState({ state: r }, i);
  }
  setAllPivot(e, t, i) {
    this.gridOptionsService.is("functionsPassive") ? this.setAllPivotPassive(e, t) : this.setAllPivotActive(e, t, i);
  }
  setAllPivotPassive(e, t) {
    const i = this.columnModel.getPivotColumns().slice(), r = this.columnModel.getValueColumns().slice(), n = this.columnModel.getRowGroupColumns().slice();
    let s = !1, a = !1, l = !1;
    const u = t ? (h) => {
      h.isAnyFunctionActive() || (h.isAllowValue() ? (r.push(h), a = !0) : h.isAllowRowGroup() ? (n.push(h), s = !0) : h.isAllowPivot() && (i.push(h), l = !0));
    } : (h) => {
      h.isAnyFunctionActive() && (i.indexOf(h) >= 0 && (x.removeFromArray(i, h), s = !0), r.indexOf(h) >= 0 && (x.removeFromArray(r, h), a = !0), n.indexOf(h) >= 0 && (x.removeFromArray(n, h), l = !0));
    };
    if (e.forEach(u), s) {
      const h = {
        type: w.EVENT_COLUMN_PIVOT_CHANGE_REQUEST,
        columns: i
      };
      this.eventService.dispatchEvent(h);
    }
    if (l) {
      const h = {
        type: w.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST,
        columns: n
      };
      this.eventService.dispatchEvent(h);
    }
    if (a) {
      const h = {
        type: w.EVENT_COLUMN_VALUE_CHANGE_REQUEST,
        columns: n
      };
      this.eventService.dispatchEvent(h);
    }
  }
  setAllPivotActive(e, t, i) {
    const r = [], a = t ? (l) => {
      if (!l.isAnyFunctionActive())
        if (l.isAllowValue()) {
          const c = typeof l.getAggFunc() == "string" ? l.getAggFunc() : this.aggFuncService.getDefaultAggFunc(l);
          r.push({
            colId: l.getId(),
            aggFunc: c
          });
        } else
          l.isAllowRowGroup() ? r.push({
            colId: l.getId(),
            rowGroup: !0
          }) : l.isAllowPivot() && r.push({
            colId: l.getId(),
            pivot: !0
          });
    } : (l) => {
      (l.isPivotActive() || l.isRowGroupActive() || l.isValueActive()) && r.push({
        colId: l.getId(),
        pivot: !1,
        rowGroup: !1,
        aggFunc: null
      });
    };
    e.forEach(a), r.length > 0 && this.columnModel.applyColumnState({ state: r }, i);
  }
  updateColumns(e) {
    const { columns: t, visibleState: i, pivotState: r, eventType: n } = e, s = t.map((a) => {
      const l = a.getColId();
      if (this.columnModel.isPivotMode()) {
        const c = r == null ? void 0 : r[l];
        return {
          colId: l,
          pivot: c == null ? void 0 : c.pivot,
          rowGroup: c == null ? void 0 : c.rowGroup,
          aggFunc: c == null ? void 0 : c.aggFunc
        };
      } else
        return {
          colId: l,
          hide: !(i != null && i[l])
        };
    });
    this.columnModel.applyColumnState({ state: s }, n);
  }
  createPivotState(e) {
    return {
      pivot: e.isPivotActive(),
      rowGroup: e.isRowGroupActive(),
      aggFunc: e.isValueActive() ? e.getAggFunc() : void 0
    };
  }
};
hf([
  S("aggFuncService")
], Wl.prototype, "aggFuncService", void 0);
hf([
  S("columnModel")
], Wl.prototype, "columnModel", void 0);
hf([
  S("gridOptionsService")
], Wl.prototype, "gridOptionsService", void 0);
hf([
  S("eventService")
], Wl.prototype, "eventService", void 0);
Wl = hf([
  q("modelItemUtils")
], Wl);
const xG = "30.0.5", DG = {
  version: xG,
  moduleName: Q.ColumnsToolPanelModule,
  beans: [Wl],
  agStackComponents: [
    { componentName: "AgPrimaryColsHeader", componentClass: hn },
    { componentName: "AgPrimaryColsList", componentClass: Ka },
    { componentName: "AgPrimaryCols", componentClass: Ya }
  ],
  userComponents: [
    { componentName: "agColumnsToolPanel", componentClass: xu }
  ],
  dependantModules: [
    Pi,
    jx,
    Ub
  ]
}, OG = {
  getTemplate() {
    return {
      name: "Workbook",
      properties: {
        prefixedAttributes: [{
          prefix: "xmlns:",
          map: {
            o: "urn:schemas-microsoft-com:office:office",
            x: "urn:schemas-microsoft-com:office:excel",
            ss: "urn:schemas-microsoft-com:office:spreadsheet",
            html: "http://www.w3.org/TR/REC-html40"
          }
        }],
        rawMap: {
          xmlns: "urn:schemas-microsoft-com:office:spreadsheet"
        }
      }
    };
  }
}, PG = {
  getTemplate() {
    return {
      name: "ExcelWorkbook",
      properties: {
        rawMap: {
          xmlns: "urn:schemas-microsoft-com:office:excel"
        }
      },
      children: [{
        name: "WindowHeight",
        textNode: "8130"
      }, {
        name: "WindowWidth",
        textNode: "15135"
      }, {
        name: "WindowHeight",
        textNode: "8130"
      }, {
        name: "WindowTopX",
        textNode: "120"
      }, {
        name: "WindowTopY",
        textNode: "45"
      }, {
        name: "ProtectStructure",
        textNode: "False"
      }, {
        name: "ProtectWindow",
        textNode: "False"
      }]
    };
  }
}, AG = {
  getTemplate(o) {
    const { width: e } = o;
    return {
      name: "Column",
      properties: {
        prefixedAttributes: [{
          prefix: "ss:",
          map: {
            Width: e
          }
        }]
      }
    };
  }
}, MG = {
  getTemplate(o) {
    const { mergeAcross: e, styleId: t, data: i } = o, r = {};
    return e && (r.MergeAcross = e), t && (r.StyleID = t), {
      name: "Cell",
      properties: {
        prefixedAttributes: [{
          prefix: "ss:",
          map: r
        }]
      },
      children: [{
        name: "Data",
        properties: {
          prefixedAttributes: [{
            prefix: "ss:",
            map: {
              Type: i == null ? void 0 : i.type
            }
          }]
        },
        textNode: i == null ? void 0 : i.value
      }]
    };
  }
}, _G = {
  getTemplate(o) {
    const { cells: e } = o;
    return {
      name: "Row",
      children: e.map((t) => MG.getTemplate(t))
    };
  }
}, IG = {
  getTemplate(o) {
    const { table: e, name: t } = o, { columns: i, rows: r } = e, n = i.map((a) => AG.getTemplate(a)), s = r.map((a) => _G.getTemplate(a));
    return {
      name: "Worksheet",
      children: [{
        name: "Table",
        children: n.concat(s)
      }],
      properties: {
        prefixedAttributes: [{
          prefix: "ss:",
          map: {
            Name: t
          }
        }]
      }
    };
  }
}, FG = {
  getTemplate() {
    return {
      name: "DocumentProperties",
      properties: {
        rawMap: {
          xmlns: "urn:schemas-microsoft-com:office:office"
        }
      },
      children: [{
        name: "Version",
        textNode: "12.00"
      }]
    };
  }
}, LG = {
  getTemplate(o) {
    const { vertical: e, horizontal: t, indent: i, readingOrder: r, rotate: n, shrinkToFit: s, verticalText: a, wrapText: l } = o.alignment;
    return {
      name: "Alignment",
      properties: {
        prefixedAttributes: [{
          prefix: "ss:",
          map: {
            Vertical: e,
            Horizontal: t,
            Indent: i,
            ReadingOrder: r,
            Rotate: n,
            ShrinkToFit: s,
            VerticalText: a,
            WrapText: l
          }
        }]
      }
    };
  }
}, NG = {
  getTemplate(o) {
    const { borderBottom: e, borderLeft: t, borderRight: i, borderTop: r } = o.borders;
    return {
      name: "Borders",
      children: [e, t, i, r].map((n, s) => ({
        name: "Border",
        properties: {
          prefixedAttributes: [{
            prefix: "ss:",
            map: {
              Position: s == 0 ? "Bottom" : s == 1 ? "Left" : s == 2 ? "Right" : "Top",
              LineStyle: n.lineStyle,
              Weight: n.weight,
              Color: n.color
            }
          }]
        }
      }))
    };
  }
}, GG = {
  getTemplate(o) {
    const { bold: e, fontName: t, italic: i, color: r, outline: n, shadow: s, size: a, strikeThrough: l, underline: c, verticalAlign: d, charSet: u, family: h } = o.font;
    return {
      name: "Font",
      properties: {
        prefixedAttributes: [{
          prefix: "ss:",
          map: {
            Bold: e,
            FontName: t,
            Italic: i,
            Color: r,
            Outline: n,
            Shadow: s,
            Size: a,
            StrikeThrough: l,
            Underline: c,
            VerticalAlign: d
          }
        }, {
          prefix: "x:",
          map: {
            CharSet: u,
            Family: h
          }
        }]
      }
    };
  }
}, kG = {
  getTemplate(o) {
    const { color: e, pattern: t, patternColor: i } = o.interior;
    return {
      name: "Interior",
      properties: {
        prefixedAttributes: [{
          prefix: "ss:",
          map: {
            Color: e,
            Pattern: t,
            PatternColor: i
          }
        }]
      }
    };
  }
}, VG = {
  getTemplate(o) {
    return {
      name: "Protection",
      properties: {
        prefixedAttributes: [{
          prefix: "ss:",
          map: {
            Protected: o.protection.protected,
            HideFormula: o.protection.hideFormula
          }
        }]
      }
    };
  }
}, BG = {
  getTemplate(o) {
    const { format: e } = o.numberFormat;
    return {
      name: "NumberFormat",
      properties: {
        prefixedAttributes: [{
          prefix: "ss:",
          map: {
            Format: e
          }
        }]
      }
    };
  }
}, HG = {
  getTemplate(o) {
    const { id: e, name: t } = o;
    return {
      name: "Style",
      properties: {
        prefixedAttributes: [{
          prefix: "ss:",
          map: {
            ID: e,
            Name: t || e
          }
        }]
      }
    };
  }
};
class $g {
  static createExcel(e, t) {
    const i = this.excelXmlHeader(), r = FG.getTemplate(), n = PG.getTemplate(), s = this.workbook(r, n, e, t);
    return `${i}${kC.createXml(s, (a) => a ? "1" : "0")}`;
  }
  static workbook(e, t, i, r) {
    const n = [
      e,
      t,
      this.stylesXmlElement(i)
    ].concat(IG.getTemplate(r));
    return Object.assign({}, OG.getTemplate(), { children: n });
  }
  static excelXmlHeader() {
    return `<?xml version="1.0" ?>
        <?mso-application progid="Excel.Sheet" ?>
        `;
  }
  static stylesXmlElement(e) {
    return {
      name: "Styles",
      children: e ? e.map((t) => this.styleXmlElement(t)) : []
    };
  }
  static styleXmlElement(e) {
    const t = x.compose(this.addProperty("alignment", e), this.addProperty("borders", e), this.addProperty("font", e), this.addProperty("interior", e), this.addProperty("protection", e), this.addProperty("numberFormat", e))([]);
    return Object.assign({}, HG.getTemplate(e), { children: t });
  }
  static addProperty(e, t) {
    return (i) => {
      if (!t[e])
        return i;
      const r = {
        alignment: LG,
        borders: NG,
        font: GG,
        interior: kG,
        numberFormat: BG,
        protection: VG
      };
      return i.concat(r[e].getTemplate(t));
    };
  }
}
$g.factoryMode = Fl.SINGLE_SHEET;
const WG = 9525, d0 = {
  0: 1,
  "0.00": 2,
  "#,##0": 3,
  "#,##0.00": 4,
  "0%": 9,
  "0.00%": 10,
  "0.00E+00": 11,
  "# ?/?": 12,
  "# ??/??": 13,
  "mm-dd-yy": 14,
  "d-mmm-yy": 15,
  "d-mmm": 16,
  "mmm-yy": 17,
  "h:mm AM/PM": 18,
  "h:mm:ss AM/PM": 19,
  "h:mm": 20,
  "h:mm:ss": 21,
  "m/d/yy h:mm": 22,
  "#,##0 ;(#,##0)": 37,
  "#,##0 ;[Red](#,##0)": 38,
  "#,##0.00;(#,##0.00)": 39,
  "#,##0.00;[Red](#,##0.00)": 40,
  "mm:ss": 45,
  "[h]:mm:ss": 46,
  "mmss.0": 47,
  "##0.0E+0": 48,
  "@": 49
}, jG = (o) => Math.round(o * 72 / 96), UG = (o) => Math.round(o * 96 / 72), Lc = (o) => Math.ceil(o * WG), $G = (o) => {
  if (o === void 0)
    return;
  const t = ["Automatic", "Roman", "Swiss", "Modern", "Script", "Decorative"].indexOf(o || "Automatic");
  return Math.max(t, 0);
}, vg = (o, e) => {
  if (!e)
    return;
  let t;
  return typeof e == "number" ? t = e : t = e({ rowIndex: o }), jG(t);
}, zG = (o, e) => {
  const { colSpan: t, column: i } = o.position;
  if (o.width)
    if (t) {
      const r = e.slice(i - 1, i + t - 1);
      let n = 0;
      for (let s = 0; s < r.length; s++) {
        const a = r[s].getActualWidth();
        if (o.width < n + a) {
          o.position.colSpan = s + 1, o.totalWidth = o.width, o.width = o.totalWidth - n;
          break;
        }
        n += a;
      }
    } else
      o.totalWidth = o.width;
}, KG = (o, e) => {
  const { rowSpan: t, row: i } = o.position;
  if (o.height)
    if (t) {
      let r = 0, n = 0;
      for (let s = i; s < i + t; s++) {
        const a = UG(vg(s, e) || 20);
        if (o.height < r + a) {
          o.position.rowSpan = n + 1, o.totalHeight = o.height, o.height = o.totalHeight - r;
          break;
        }
        r += a, n++;
      }
    } else
      o.totalHeight = o.height;
}, Yr = (o) => {
  const e = kC.createHeader({
    encoding: "UTF-8",
    standalone: "yes"
  }), t = kC.createXml(o);
  return `${e}${t}`;
}, cp = (o) => {
  const i = String.fromCharCode, r = Math.floor(o / 26), n = o % 26;
  return !r || o === 26 ? i(65 + o - 1) : n ? r < 26 ? i(65 + r - 1) + i(65 + n - 1) : cp(r) + i(65 + n - 1) : cp(r - 1) + "Z";
};
class Xx extends Nx {
  constructor(e) {
    super(e), this.mixedStyles = {}, this.mixedStyleCounter = 0, this.rows = [], this.config = Object.assign({}, e), this.stylesByIds = {}, this.config.baseExcelStyles.forEach((t) => {
      this.stylesByIds[t.id] = t;
    }), this.excelStyles = [...this.config.baseExcelStyles];
  }
  addCustomContent(e) {
    e.forEach((t) => {
      const i = this.rows.length + 1;
      let r;
      !this.config.suppressRowOutline && t.outlineLevel != null && (r = t.outlineLevel);
      const n = {
        height: vg(i, t.height || this.config.rowHeight),
        cells: (t.cells || []).map((s, a) => {
          var l, c, d;
          const u = this.addImage(i, this.columnsToExport[a], (l = s.data) === null || l === void 0 ? void 0 : l.value);
          let h = null;
          s.styleId && (h = typeof s.styleId == "string" ? [s.styleId] : s.styleId);
          const p = this.getStyleId(h);
          if (u)
            return this.createCell(p, this.getDataTypeForValue(u.value), u.value == null ? "" : u.value);
          const f = (d = (c = s.data) === null || c === void 0 ? void 0 : c.value) !== null && d !== void 0 ? d : "", g = this.getDataTypeForValue(f);
          return s.mergeAcross ? this.createMergedCell(p, g, f, s.mergeAcross) : this.createCell(p, g, f);
        }),
        outlineLevel: r
      };
      t.collapsed != null && (n.collapsed = t.collapsed), t.hidden != null && (n.hidden = t.hidden), this.rows.push(n);
    });
  }
  onNewHeaderGroupingRow() {
    const e = [];
    return this.rows.push({
      cells: e,
      height: vg(this.rows.length + 1, this.config.headerRowHeight)
    }), {
      onColumn: (t, i, r, n, s) => {
        const a = this.config.styleLinker({ rowType: Al.HEADER_GROUPING, rowIndex: 1, value: `grouping-${i}`, columnGroup: t });
        e.push(Object.assign(Object.assign({}, this.createMergedCell(this.getStyleId(a), this.getDataTypeForValue("string"), i, n)), { collapsibleRanges: s }));
      }
    };
  }
  onNewHeaderRow() {
    return this.onNewRow(this.onNewHeaderColumn, this.config.headerRowHeight);
  }
  onNewBodyRow(e) {
    const t = this.onNewRow(this.onNewBodyColumn, this.config.rowHeight);
    return e && this.addRowOutlineIfNecessary(e), t;
  }
  addRowOutlineIfNecessary(e) {
    const { gridOptionsService: t, suppressRowOutline: i, rowGroupExpandState: r = "expanded" } = this.config;
    if (t.is("groupHideOpenParents") || i || e.level == null)
      return;
    const s = e.footer ? 1 : 0, a = x.last(this.rows);
    if (a.outlineLevel = e.level + s, r === "expanded")
      return;
    const l = r === "collapsed";
    if (e.isExpandable()) {
      const c = !l && e.expanded;
      a.collapsed = !c;
    }
    a.hidden = // always show the node if there is no parent to be expanded
    !!e.parent && // or if it is a child of the root node
    e.parent.level !== -1 && (l || this.isAnyParentCollapsed(e.parent));
  }
  isAnyParentCollapsed(e) {
    for (; e && e.level !== -1; ) {
      if (!e.expanded)
        return !0;
      e = e.parent;
    }
    return !1;
  }
  prepare(e) {
    super.prepare(e), this.columnsToExport = [...e], this.cols = e.map((t, i) => this.convertColumnToExcel(t, i));
  }
  parse() {
    const e = this.rows.reduce((i, r) => Math.max(i, r.cells.length), 0);
    for (; this.cols.length < e; )
      this.cols.push(this.convertColumnToExcel(null, this.cols.length + 1));
    const t = {
      name: this.config.sheetName,
      table: {
        columns: this.cols,
        rows: this.rows
      }
    };
    return this.createExcel(t);
  }
  isFormula(e) {
    return e == null ? !1 : this.config.autoConvertFormulas && e.toString().startsWith("=");
  }
  isNumerical(e) {
    return typeof e == "bigint" ? !0 : isFinite(e) && e !== "" && !isNaN(parseFloat(e));
  }
  getStyleById(e) {
    return e == null ? null : this.stylesByIds[e] || null;
  }
  convertColumnToExcel(e, t) {
    const i = this.config.columnWidth;
    return i ? typeof i == "number" ? { width: i } : { width: i({ column: e, index: t }) } : e ? { width: Math.max(e.getActualWidth(), 75) } : {};
  }
  onNewHeaderColumn(e, t) {
    return (i, r) => {
      const n = this.extractHeaderValue(i), s = this.config.styleLinker({ rowType: Al.HEADER, rowIndex: e, value: n, column: i });
      t.push(this.createCell(this.getStyleId(s), this.getDataTypeForValue("string"), n));
    };
  }
  onNewRow(e, t) {
    const i = [];
    return this.rows.push({
      cells: i,
      height: vg(this.rows.length + 1, t)
    }), {
      onColumn: e.bind(this, this.rows.length, i)()
    };
  }
  onNewBodyColumn(e, t) {
    let i = 0;
    return (r, n, s) => {
      if (i > 0) {
        i -= 1;
        return;
      }
      const { value: a, valueFormatted: l } = this.extractRowCellValue(r, n, e, "excel", s), c = this.config.styleLinker({ rowType: Al.BODY, rowIndex: e, value: a, column: r, node: s }), d = this.getStyleId(c), u = r.getColSpan(s), h = this.addImage(e, r, a);
      h ? t.push(this.createCell(d, this.getDataTypeForValue(h.value), h.value == null ? "" : h.value)) : u > 1 ? (i = u - 1, t.push(this.createMergedCell(d, this.getDataTypeForValue(a), a, u - 1))) : t.push(this.createCell(d, this.getDataTypeForValue(a), a, l));
    };
  }
  getStyleId(e) {
    if (!e || !e.length)
      return null;
    if (e.length === 1)
      return e[0];
    const t = e.join("-");
    return this.mixedStyles[t] || this.addNewMixedStyle(e), this.mixedStyles[t].excelID;
  }
  addNewMixedStyle(e) {
    this.mixedStyleCounter += 1;
    const t = `mixedStyle${this.mixedStyleCounter}`, i = {};
    e.forEach((n) => {
      this.excelStyles.forEach((s) => {
        s.id === n && x.mergeDeep(i, x.deepCloneObject(s));
      });
    }), i.id = t, i.name = t;
    const r = e.join("-");
    this.mixedStyles[r] = {
      excelID: t,
      key: r,
      result: i
    }, this.excelStyles.push(i), this.stylesByIds[t] = i;
  }
}
class YG extends Xx {
  createExcel(e) {
    return $g.createExcel(this.excelStyles, e);
  }
  getDataTypeForValue(e) {
    return this.isNumerical(e) ? "Number" : "String";
  }
  getType(e, t, i) {
    if (this.isFormula(i))
      return "Formula";
    if (t && t.dataType)
      switch (t.dataType.toLocaleLowerCase()) {
        case "string":
          return "Formula";
        case "number":
          return "Number";
        case "datetime":
          return "DateTime";
        case "error":
          return "Error";
        case "boolean":
          return "Boolean";
        default:
          console.warn(`AG Grid: Unrecognized data type for excel export [${t.id}.dataType=${t.dataType}]`);
      }
    return e;
  }
  addImage() {
  }
  createCell(e, t, i, r) {
    const n = this.getStyleById(e);
    !(n != null && n.dataType) && t === "String" && r && (i = r);
    const s = this.getType(t, n, i) || t;
    return {
      styleId: n ? e : void 0,
      data: {
        type: s,
        value: this.getValueTransformed(s, i)
      }
    };
  }
  getValueTransformed(e, t) {
    const i = (n) => {
      if (this.config.suppressTextAsCDATA)
        return x.escapeString(n);
      const s = "<![CDATA[", a = "]]>", l = new RegExp(a, "g");
      return s + String(n).replace(l, "]]" + a + s + ">") + a;
    }, r = (n) => !n || n === "0" || n === "false" ? "0" : "1";
    switch (e) {
      case "String":
        return i(t);
      case "Number":
        return Number(t).valueOf() + "";
      case "Boolean":
        return r(t);
      default:
        return t;
    }
  }
  createMergedCell(e, t, i, r) {
    return {
      styleId: this.getStyleById(e) ? e : void 0,
      data: {
        type: t,
        value: i
      },
      mergeAcross: r
    };
  }
}
const XG = {
  getTemplate(o) {
    const t = (/* @__PURE__ */ new Date()).toJSON();
    return {
      name: "cp:coreProperties",
      properties: {
        prefixedAttributes: [{
          prefix: "xmlns:",
          map: {
            cp: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
            dc: "http://purl.org/dc/elements/1.1/",
            dcterms: "http://purl.org/dc/terms/",
            dcmitype: "http://purl.org/dc/dcmitype/",
            xsi: "http://www.w3.org/2001/XMLSchema-instance"
          }
        }]
      },
      children: [{
        name: "dc:creator",
        textNode: o
      }, {
        name: "dc:title",
        textNode: "Workbook"
      }, {
        name: "dcterms:created",
        properties: {
          rawMap: {
            "xsi:type": "dcterms:W3CDTF"
          }
        },
        textNode: t
      }, {
        name: "dcterms:modified",
        properties: {
          rawMap: {
            "xsi:type": "dcterms:W3CDTF"
          }
        },
        textNode: t
      }]
    };
  }
}, qG = {
  getTemplate(o) {
    const { name: e, ContentType: t, Extension: i, PartName: r } = o;
    return {
      name: e,
      properties: {
        rawMap: {
          Extension: i,
          PartName: r,
          ContentType: t
        }
      }
    };
  }
}, ZG = {
  getTemplate(o) {
    const e = new Array(o).fill(void 0).map((a, l) => ({
      name: "Override",
      ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
      PartName: `/xl/worksheets/sheet${l + 1}.xml`
    })), t = et.worksheetImages.size, i = {};
    et.workbookImageIds.forEach((a) => {
      i[a.type] = !0;
    });
    const r = new Array(t).fill(void 0).map((a, l) => ({
      name: "Override",
      ContentType: "application/vnd.openxmlformats-officedocument.drawing+xml",
      PartName: `/xl/drawings/drawing${l + 1}.xml`
    })), s = [
      ...Object.keys(i).map((a) => ({
        name: "Default",
        ContentType: `image/${a}`,
        Extension: a
      })),
      {
        name: "Default",
        Extension: "rels",
        ContentType: "application/vnd.openxmlformats-package.relationships+xml"
      },
      {
        name: "Default",
        ContentType: "application/xml",
        Extension: "xml"
      },
      {
        name: "Override",
        ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
        PartName: "/xl/workbook.xml"
      },
      ...e,
      {
        name: "Override",
        ContentType: "application/vnd.openxmlformats-officedocument.theme+xml",
        PartName: "/xl/theme/theme1.xml"
      },
      {
        name: "Override",
        ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
        PartName: "/xl/styles.xml"
      },
      {
        name: "Override",
        ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
        PartName: "/xl/sharedStrings.xml"
      },
      ...r,
      {
        name: "Override",
        ContentType: "application/vnd.openxmlformats-package.core-properties+xml",
        PartName: "/docProps/core.xml"
      }
    ].map((a) => qG.getTemplate(a));
    return {
      name: "Types",
      properties: {
        rawMap: {
          xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
        }
      },
      children: s
    };
  }
}, u0 = (o, e) => ({
  name: `xdr:${o}`,
  children: [{
    name: "xdr:col",
    textNode: e.col.toString()
  }, {
    name: "xdr:colOff",
    textNode: e.offsetX.toString()
  }, {
    name: "xdr:row",
    textNode: e.row.toString()
  }, {
    name: "xdr:rowOff",
    textNode: e.offsetY.toString()
  }]
}), QG = (o) => {
  const e = [{
    name: "a:ext",
    properties: {
      rawMap: {
        uri: "{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}"
      }
    },
    children: [{
      name: "a16:creationId",
      properties: {
        rawMap: {
          id: "{822E6D20-D7BC-2841-A643-D49A6EF008A2}",
          "xmlns:a16": "http://schemas.microsoft.com/office/drawing/2014/main"
        }
      }
    }]
  }];
  switch (o.recolor && o.recolor.toLowerCase()) {
    case "grayscale":
    case "sepia":
    case "washout":
      e.push({
        name: "a:ext",
        properties: {
          rawMap: {
            uri: "{C183D7F6-B498-43B3-948B-1728B52AA6E4}"
          }
        },
        children: [{
          name: "adec:decorative",
          properties: {
            rawMap: {
              val: "0",
              "xmlns:adec": "http://schemas.microsoft.com/office/drawing/2017/decorative"
            }
          }
        }]
      });
  }
  return {
    name: "a:extLst",
    children: e
  };
}, JG = (o, e) => ({
  name: "xdr:nvPicPr",
  children: [{
    name: "xdr:cNvPr",
    properties: {
      rawMap: {
        id: e,
        name: o.id,
        descr: o.altText != null ? o.altText : void 0
      }
    },
    children: [QG(o)]
  }, {
    name: "xdr:cNvPicPr",
    properties: {
      rawMap: {
        preferRelativeResize: "0"
      }
    },
    children: [{
      name: "a:picLocks"
    }]
  }]
}), h0 = (o) => {
  if (!o.saturation && !o.tint)
    return;
  const e = [];
  return o.saturation && e.push({
    name: "a:satMod",
    properties: {
      rawMap: {
        val: o.saturation * 1e3
      }
    }
  }), o.tint && e.push({
    name: "a:tint",
    properties: {
      rawMap: {
        val: o.tint * 1e3
      }
    }
  }), e;
}, ek = (o, e) => ({
  name: "a:duotone",
  children: [{
    name: "a:prstClr",
    properties: {
      rawMap: {
        val: o.color
      }
    },
    children: h0(o)
  }, {
    name: "a:srgbClr",
    properties: {
      rawMap: {
        val: e.color
      }
    },
    children: h0(e)
  }]
}), tk = (o, e) => {
  let t;
  if (o.transparency) {
    const i = Math.min(Math.max(o.transparency, 0), 100);
    t = [{
      name: "a:alphaModFix",
      properties: {
        rawMap: {
          amt: 1e5 - Math.round(i * 1e3)
        }
      }
    }];
  }
  if (o.recolor)
    switch (t || (t = []), o.recolor.toLocaleLowerCase()) {
      case "grayscale":
        t.push({ name: "a:grayscl" });
        break;
      case "sepia":
        t.push(ek({ color: "black" }, { color: "D9C3A5", tint: 50, saturation: 180 }));
        break;
      case "washout":
        t.push({
          name: "a:lum",
          properties: {
            rawMap: {
              bright: "70000",
              contrast: "-70000"
            }
          }
        });
        break;
    }
  return {
    name: "xdr:blipFill",
    children: [{
      name: "a:blip",
      properties: {
        rawMap: {
          cstate: "print",
          "r:embed": `rId${e}`,
          "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
        }
      },
      children: t
    }, {
      name: "a:stretch",
      children: [{
        name: "a:fillRect"
      }]
    }]
  };
}, ik = (o, e) => {
  const t = {
    name: "a:xfrm",
    children: [{
      name: "a:off",
      properties: {
        rawMap: {
          x: 0,
          y: 0
        }
      }
    }, {
      name: "a:ext",
      properties: {
        rawMap: {
          cx: e.width,
          cy: e.height
        }
      }
    }]
  };
  if (o.rotation) {
    const n = o.rotation;
    t.properties = {
      rawMap: {
        rot: Math.min(Math.max(n, 0), 360) * 6e4
      }
    };
  }
  return {
    name: "xdr:spPr",
    children: [t, {
      name: "a:prstGeom",
      properties: {
        rawMap: {
          prst: "rect"
        }
      },
      children: [{ name: "a:avLst" }]
    }]
  };
}, rk = (o) => {
  o.fitCell = !!o.fitCell || !o.width || !o.height;
  const { position: e = {}, fitCell: t, width: i = 0, height: r = 0, totalHeight: n, totalWidth: s } = o, { offsetX: a = 0, offsetY: l = 0, row: c = 1, rowSpan: d = 1, column: u = 1, colSpan: h = 1 } = e;
  return {
    from: {
      row: c - 1,
      col: u - 1,
      offsetX: Lc(a),
      offsetY: Lc(l)
    },
    to: {
      row: c - 1 + (t ? 1 : d - 1),
      col: u - 1 + (t ? 1 : h - 1),
      offsetX: Lc(i + a),
      offsetY: Lc(r + l)
    },
    height: Lc(n || r),
    width: Lc(s || i)
  };
}, nk = (o, e, t, i) => ({
  name: "xdr:pic",
  children: [
    JG(o, e + 1),
    tk(o, t + 1),
    ik(o, i)
  ]
}), ok = {
  getTemplate(o) {
    const { sheetIndex: e } = o, t = et.worksheetImages.get(e), i = et.worksheetImageIds.get(e), r = t.map((n, s) => {
      const a = rk(n);
      return {
        name: "xdr:twoCellAnchor",
        properties: {
          rawMap: {
            editAs: "absolute"
          }
        },
        children: [
          u0("from", a.from),
          u0("to", a.to),
          nk(n, s, i.get(n.id).index, a),
          { name: "xdr:clientData" }
        ]
      };
    });
    return {
      name: "xdr:wsDr",
      properties: {
        rawMap: {
          "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main",
          "xmlns:xdr": "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing"
        }
      },
      children: r
    };
  }
}, Xr = (o) => {
  const [e, t, i, r] = o;
  return {
    name: `a:${e}`,
    children: [{
      name: `a:${t}`,
      properties: {
        rawMap: {
          val: i,
          lastClr: r
        }
      }
    }]
  };
}, sk = {
  getTemplate() {
    return {
      name: "a:clrScheme",
      properties: {
        rawMap: {
          name: "Office"
        }
      },
      children: [
        Xr(["dk1", "sysClr", "windowText", "000000"]),
        Xr(["lt1", "sysClr", "window", "FFFFFF"]),
        Xr(["dk2", "srgbClr", "44546A"]),
        Xr(["lt2", "srgbClr", "E7E6E6"]),
        Xr(["accent1", "srgbClr", "4472C4"]),
        Xr(["accent2", "srgbClr", "ED7D31"]),
        Xr(["accent3", "srgbClr", "A5A5A5"]),
        Xr(["accent4", "srgbClr", "FFC000"]),
        Xr(["accent5", "srgbClr", "5B9BD5"]),
        Xr(["accent6", "srgbClr", "70AD47"]),
        Xr(["hlink", "srgbClr", "0563C1"]),
        Xr(["folHlink", "srgbClr", "954F72"])
      ]
    };
  }
}, ie = (o) => {
  const [e, t, i, r] = o;
  return {
    name: `a:${e}`,
    properties: {
      rawMap: {
        script: i,
        typeface: t,
        panose: r
      }
    }
  };
}, ak = {
  getTemplate() {
    const { utf8_encode: o } = x;
    return {
      name: "a:fontScheme",
      properties: {
        rawMap: {
          name: "Office"
        }
      },
      children: [{
        name: "a:majorFont",
        children: [
          ie(["latin", "Calibri Light", void 0, "020F0302020204030204"]),
          ie(["ea", ""]),
          ie(["cs", ""]),
          ie(["font", o("游ゴシック Light"), "Jpan"]),
          ie(["font", o("맑은 고딕"), "Hang"]),
          ie(["font", o("等线 Light"), "Hans"]),
          ie(["font", o("新細明體"), "Hant"]),
          ie(["font", "Times New Roman", "Arab"]),
          ie(["font", "Times New Roman", "Hebr"]),
          ie(["font", "Tahoma", "Thai"]),
          ie(["font", "Nyala", "Ethi"]),
          ie(["font", "Vrinda", "Beng"]),
          ie(["font", "Shruti", "Gujr"]),
          ie(["font", "MoolBoran", "Khmr"]),
          ie(["font", "Tunga", "Knda"]),
          ie(["font", "Raavi", "Guru"]),
          ie(["font", "Euphemia", "Cans"]),
          ie(["font", "Plantagenet Cherokee", "Cher"]),
          ie(["font", "Microsoft Yi Baiti", "Yiii"]),
          ie(["font", "Microsoft Himalaya", "Tibt"]),
          ie(["font", "MV Boli", "Thaa"]),
          ie(["font", "Mangal", "Deva"]),
          ie(["font", "Gautami", "Telu"]),
          ie(["font", "Latha", "Taml"]),
          ie(["font", "Estrangelo Edessa", "Syrc"]),
          ie(["font", "Kalinga", "Orya"]),
          ie(["font", "Kartika", "Mlym"]),
          ie(["font", "DokChampa", "Laoo"]),
          ie(["font", "Iskoola Pota", "Sinh"]),
          ie(["font", "Mongolian Baiti", "Mong"]),
          ie(["font", "Times New Roman", "Viet"]),
          ie(["font", "Microsoft Uighur", "Uigh"]),
          ie(["font", "Sylfaen", "Geor"]),
          ie(["font", "Arial", "Armn"]),
          ie(["font", "Leelawadee UI", "Bugi"]),
          ie(["font", "Microsoft JhengHei", "Bopo"]),
          ie(["font", "Javanese Text", "Java"]),
          ie(["font", "Segoe UI", "Lisu"]),
          ie(["font", "Myanmar Text", "Mymr"]),
          ie(["font", "Ebrima", "Nkoo"]),
          ie(["font", "Nirmala UI", "Olck"]),
          ie(["font", "Ebrima", "Osma"]),
          ie(["font", "Phagspa", "Phag"]),
          ie(["font", "Estrangelo Edessa", "Syrn"]),
          ie(["font", "Estrangelo Edessa", "Syrj"]),
          ie(["font", "Estrangelo Edessa", "Syre"]),
          ie(["font", "Nirmala UI", "Sora"]),
          ie(["font", "Microsoft Tai Le", "Tale"]),
          ie(["font", "Microsoft New Tai Lue", "Talu"]),
          ie(["font", "Ebrima", "Tfng"])
        ]
      }, {
        name: "a:minorFont",
        children: [
          ie(["latin", "Calibri", void 0, "020F0502020204030204"]),
          ie(["ea", ""]),
          ie(["cs", ""]),
          ie(["font", o("游ゴシック"), "Jpan"]),
          ie(["font", o("맑은 고딕"), "Hang"]),
          ie(["font", o("等线"), "Hans"]),
          ie(["font", o("新細明體"), "Hant"]),
          ie(["font", "Arial", "Arab"]),
          ie(["font", "Arial", "Hebr"]),
          ie(["font", "Tahoma", "Thai"]),
          ie(["font", "Nyala", "Ethi"]),
          ie(["font", "Vrinda", "Beng"]),
          ie(["font", "Shruti", "Gujr"]),
          ie(["font", "DaunPenh", "Khmr"]),
          ie(["font", "Tunga", "Knda"]),
          ie(["font", "Raavi", "Guru"]),
          ie(["font", "Euphemia", "Cans"]),
          ie(["font", "Plantagenet Cherokee", "Cher"]),
          ie(["font", "Microsoft Yi Baiti", "Yiii"]),
          ie(["font", "Microsoft Himalaya", "Tibt"]),
          ie(["font", "MV Boli", "Thaa"]),
          ie(["font", "Mangal", "Deva"]),
          ie(["font", "Gautami", "Telu"]),
          ie(["font", "Latha", "Taml"]),
          ie(["font", "Estrangelo Edessa", "Syrc"]),
          ie(["font", "Kalinga", "Orya"]),
          ie(["font", "Kartika", "Mlym"]),
          ie(["font", "DokChampa", "Laoo"]),
          ie(["font", "Iskoola Pota", "Sinh"]),
          ie(["font", "Mongolian Baiti", "Mong"]),
          ie(["font", "Arial", "Viet"]),
          ie(["font", "Microsoft Uighur", "Uigh"]),
          ie(["font", "Sylfaen", "Geor"]),
          ie(["font", "Arial", "Armn"]),
          ie(["font", "Leelawadee UI", "Bugi"]),
          ie(["font", "Microsoft JhengHei", "Bopo"]),
          ie(["font", "Javanese Text", "Java"]),
          ie(["font", "Segoe UI", "Lisu"]),
          ie(["font", "Myanmar Text", "Mymr"]),
          ie(["font", "Ebrima", "Nkoo"]),
          ie(["font", "Nirmala UI", "Olck"]),
          ie(["font", "Ebrima", "Osma"]),
          ie(["font", "Phagspa", "Phag"]),
          ie(["font", "Estrangelo Edessa", "Syrn"]),
          ie(["font", "Estrangelo Edessa", "Syrj"]),
          ie(["font", "Estrangelo Edessa", "Syre"]),
          ie(["font", "Nirmala UI", "Sora"]),
          ie(["font", "Microsoft Tai Le", "Tale"]),
          ie(["font", "Microsoft New Tai Lue", "Talu"]),
          ie(["font", "Ebrima", "Tfng"])
        ]
      }]
    };
  }
}, So = (o, e, t) => ({
  name: `a:${o}`,
  properties: {
    rawMap: {
      val: e
    }
  },
  children: t
}), Iy = (o) => {
  const [e, t, i, r, n, s] = o, a = [];
  return a.push(So("satMod", i)), r && a.push(So("lumMod", r)), n && a.push(So("tint", n)), s && a.push(So("shade", s)), {
    name: "a:gs",
    properties: {
      rawMap: {
        pos: e
      }
    },
    children: [{
      name: "a:schemeClr",
      properties: {
        rawMap: {
          val: t
        }
      },
      children: a
    }]
  };
}, zg = (o, e) => ({
  name: "a:solidFill",
  children: [So("schemeClr", o, e)]
}), BC = (o) => {
  const [e, t, i, r, n] = o, [s, a] = n;
  return {
    name: "a:gradFill",
    properties: {
      rawMap: {
        rotWithShape: e
      }
    },
    children: [{
      name: "a:gsLst",
      children: [
        Iy(t),
        Iy(i),
        Iy(r)
      ]
    }, {
      name: "a:lin",
      properties: {
        rawMap: {
          ang: s,
          scaled: a
        }
      }
    }]
  };
}, Fy = (o) => {
  const [e, t, i, r] = o;
  return {
    name: "a:ln",
    properties: {
      rawMap: { w: e, cap: t, cmpd: i, algn: r }
    },
    children: [
      zg("phClr"),
      So("prstDash", "solid"),
      {
        name: "a:miter",
        properties: {
          rawMap: {
            lim: "800000"
          }
        }
      }
    ]
  };
}, Ly = (o) => {
  const e = [];
  if (o) {
    const [t, i, r, n, s] = o;
    e.push({
      name: "a:outerShdw",
      properties: {
        rawMap: { blurRad: t, dist: i, dir: r, algn: n, rotWithShape: s }
      },
      children: [
        So("srgbClr", "000000", [So("alpha", "63000")])
      ]
    });
  }
  return {
    name: "a:effectStyle",
    children: [Object.assign({}, {
      name: "a:effectLst"
    }, e.length ? { children: e } : {})]
  };
}, lk = () => ({
  name: "a:fillStyleLst",
  children: [
    zg("phClr"),
    BC([
      "1",
      ["0", "phClr", "105000", "110000", "67000"],
      ["50000", "phClr", "103000", "105000", "73000"],
      ["100000", "phClr", "109000", "105000", "81000"],
      ["5400000", "0"]
    ]),
    BC([
      "1",
      ["0", "phClr", "103000", "102000", "94000"],
      ["50000", "phClr", "110000", "100000", void 0, "100000"],
      ["100000", "phClr", "120000", "99000", void 0, "78000"],
      ["5400000", "0"]
    ])
  ]
}), ck = () => ({
  name: "a:lnStyleLst",
  children: [
    Fy(["6350", "flat", "sng", "ctr"]),
    Fy(["12700", "flat", "sng", "ctr"]),
    Fy(["19050", "flat", "sng", "ctr"])
  ]
}), dk = () => ({
  name: "a:effectStyleLst",
  children: [
    Ly(),
    Ly(),
    Ly(["57150", "19050", "5400000", "ctr", "0"])
  ]
}), uk = () => ({
  name: "a:bgFillStyleLst",
  children: [
    zg("phClr"),
    zg("phClr", [
      So("tint", "95000"),
      So("satMod", "170000")
    ]),
    BC([
      "1",
      ["0", "phClr", "150000", "102000", "93000", "98000"],
      ["50000", "phClr", "130000", "103000", "98000", "90000"],
      ["100000", "phClr", "120000", void 0, void 0, "63000"],
      ["5400000", "0"]
    ])
  ]
}), hk = {
  getTemplate() {
    return {
      name: "a:fmtScheme",
      properties: {
        rawMap: {
          name: "Office"
        }
      },
      children: [
        lk(),
        ck(),
        dk(),
        uk()
      ]
    };
  }
}, pk = {
  getTemplate() {
    return {
      name: "a:themeElements",
      children: [
        sk.getTemplate(),
        ak.getTemplate(),
        hk.getTemplate()
      ]
    };
  }
}, fk = {
  getTemplate() {
    return {
      name: "a:theme",
      properties: {
        prefixedAttributes: [{
          prefix: "xmlns:",
          map: {
            a: "http://schemas.openxmlformats.org/drawingml/2006/main"
          }
        }],
        rawMap: {
          name: "Office Theme"
        }
      },
      children: [
        pk.getTemplate(),
        {
          name: "a:objectDefaults"
        },
        {
          name: "a:extraClrSchemeLst"
        }
      ]
    };
  }
}, gk = (o) => {
  const e = [];
  return o.forEach((t, i) => {
    const r = i.toString(), n = {
      name: "t",
      textNode: x.utf8_encode(x.escapeString(r))
    };
    r.trim().length !== r.length && (n.properties = {
      rawMap: {
        "xml:space": "preserve"
      }
    }), e.push({
      name: "si",
      children: [n]
    });
  }), e;
}, vk = {
  getTemplate(o) {
    return {
      name: "sst",
      properties: {
        rawMap: {
          xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
          count: o.size,
          uniqueCount: o.size
        }
      },
      children: gk(o)
    };
  }
};
function mk(o) {
  const e = o.split(/(\[[^\]]*\])/);
  for (let t = 0; t < e.length; t++) {
    let i = e[t];
    i.length && (i.startsWith("[") || (i = i.replace(/\$/g, '"$"')), e[t] = x.escapeString(i));
  }
  return e.join("");
}
const yk = {
  getTemplate(o) {
    let { formatCode: e, numFmtId: t } = o;
    return e.length && (e = mk(e)), {
      name: "numFmt",
      properties: {
        rawMap: {
          formatCode: e,
          numFmtId: t
        }
      }
    };
  }
}, Ck = {
  getTemplate(o) {
    return {
      name: "numFmts",
      properties: {
        rawMap: {
          count: o.length
        }
      },
      children: o.map((e) => yk.getTemplate(e))
    };
  }
}, Sk = {
  getTemplate(o) {
    const { size: e, colorTheme: t, color: i = "FF000000", fontName: r = "Calibri", family: n, scheme: s, italic: a, bold: l, strikeThrough: c, outline: d, shadow: u, underline: h, verticalAlign: p } = o, f = [
      { name: "sz", properties: { rawMap: { val: e } } },
      { name: "color", properties: { rawMap: { theme: t, rgb: i } } },
      { name: "name", properties: { rawMap: { val: r } } }
    ];
    return n && f.push({ name: "family", properties: { rawMap: { val: n } } }), s && f.push({ name: "scheme", properties: { rawMap: { val: s } } }), a && f.push({ name: "i" }), l && f.push({ name: "b" }), c && f.push({ name: "strike" }), d && f.push({ name: "outline" }), u && f.push({ name: "shadow" }), h && f.push({ name: "u", properties: { rawMap: { val: h } } }), p && f.push({ name: "vertAlign", properties: { rawMap: { val: p } } }), { name: "font", children: f };
  }
}, bk = {
  getTemplate(o) {
    return {
      name: "fonts",
      properties: {
        rawMap: {
          count: o.length
        }
      },
      children: o.map((e) => Sk.getTemplate(e))
    };
  }
}, wk = {
  getTemplate(o) {
    const { patternType: e, fgTheme: t, fgTint: i, fgRgb: r, bgRgb: n, bgIndexed: s } = o, a = {
      name: "patternFill",
      properties: {
        rawMap: {
          patternType: e
        }
      }
    };
    return (t || i || r) && (a.children = [{
      name: "fgColor",
      properties: {
        rawMap: {
          theme: t,
          tint: i,
          rgb: r
        }
      }
    }]), (s || n) && (a.children || (a.children = []), a.children.push({
      name: "bgColor",
      properties: {
        rawMap: {
          indexed: s,
          rgb: n
        }
      }
    })), {
      name: "fill",
      children: [a]
    };
  }
}, Ek = {
  getTemplate(o) {
    return {
      name: "fills",
      properties: {
        rawMap: {
          count: o.length
        }
      },
      children: o.map((e) => wk.getTemplate(e))
    };
  }
}, Rk = (o) => {
  switch (o) {
    case 1:
      return "thin";
    case 2:
      return "medium";
    case 3:
      return "thick";
    default:
      return "hair";
  }
}, Tk = {
  None: "None",
  Dot: "Dotted",
  Dash: "Dashed",
  Double: "Double",
  DashDot: "DashDot",
  DashDotDot: "DashDotDot",
  SlantDashDot: "SlantDashDot"
}, xk = ["Dashed", "DashDot", "DashDotDot"], Dk = {
  None: "none",
  Solid: "solid",
  Gray50: "mediumGray",
  Gray75: "darkGray",
  Gray25: "lightGray",
  HorzStripe: "darkHorizontal",
  VertStripe: "darkVertical",
  ReverseDiagStripe: "darkDown",
  DiagStripe: "darkUp",
  DiagCross: "darkGrid",
  ThickDiagCross: "darkTrellis",
  ThinHorzStripe: "lightHorizontal",
  ThinVertStripe: "lightVertical",
  ThinReverseDiagStripe: "lightDown",
  ThinDiagStripe: "lightUp",
  ThinHorzCross: "lightGrid",
  ThinDiagCross: "lightTrellis",
  Gray125: "gray125",
  Gray0625: "gray0625"
}, Ok = {
  Automatic: "general",
  Left: "left",
  Center: "center",
  Right: "right",
  Fill: "fill",
  Justify: "justify",
  CenterAcrossSelection: "centerContinuous",
  Distributed: "distributed",
  JustifyDistributed: "justify"
}, Pk = {
  Automatic: void 0,
  Top: "top",
  Bottom: "bottom",
  Center: "center",
  Justify: "justify",
  Distributed: "distributed",
  JustifyDistributed: "justify"
}, Ak = (o) => o ? Dk[o] || o : "none", oa = (o) => o == null ? o : (o.charAt(0) === "#" && (o = o.substr(1)), o.length === 6 ? "FF" + o : o), Uf = (o, e) => {
  if (!o)
    return "thin";
  const t = Rk(e), i = Tk[o];
  return o === "Continuous" ? t : t === "medium" && xk.indexOf(i) !== -1 ? `medium${i}` : i.charAt(0).toLowerCase() + i.substr(1);
}, Mk = (o) => Ok[o] || "general", _k = (o) => Pk[o] || void 0, eh = (o) => ({
  name: "color",
  properties: {
    rawMap: {
      rgb: oa(o || "#000000")
    }
  }
}), Ik = {
  getTemplate(o) {
    const { left: e, right: t, top: i, bottom: r, diagonal: n } = o, s = e ? [eh(e.color)] : void 0, a = t ? [eh(t.color)] : void 0, l = i ? [eh(i.color)] : void 0, c = r ? [eh(r.color)] : void 0, d = n ? [eh(n.color)] : void 0;
    return {
      name: "border",
      children: [{
        name: "left",
        properties: { rawMap: { style: e && e.style } },
        children: s
      }, {
        name: "right",
        properties: { rawMap: { style: t && t.style } },
        children: a
      }, {
        name: "top",
        properties: { rawMap: { style: i && i.style } },
        children: l
      }, {
        name: "bottom",
        properties: { rawMap: { style: r && r.style } },
        children: c
      }, {
        name: "diagonal",
        properties: { rawMap: { style: n && n.style } },
        children: d
      }]
    };
  }
}, Fk = {
  getTemplate(o) {
    return {
      name: "borders",
      properties: {
        rawMap: {
          count: o.length
        }
      },
      children: o.map((e) => Ik.getTemplate(e))
    };
  }
}, Lk = (o) => {
  const t = ["Context", "LeftToRight", "RightToLeft"].indexOf(o);
  return Math.max(t, 0);
}, Nk = {
  getTemplate(o) {
    const { horizontal: e, indent: t, readingOrder: i, rotate: r, shrinkToFit: n, vertical: s, wrapText: a } = o;
    return {
      name: "alignment",
      properties: {
        rawMap: {
          horizontal: e && Mk(e),
          indent: t,
          readingOrder: i && Lk(i),
          textRotation: r,
          shrinkToFit: n,
          vertical: s && _k(s),
          wrapText: a
        }
      }
    };
  }
}, Gk = {
  getTemplate(o) {
    const e = o.protected === !1 ? 0 : 1;
    return {
      name: "protection",
      properties: {
        rawMap: {
          hidden: o.hideFormula === !0 ? 1 : 0,
          locked: e
        }
      }
    };
  }
}, qx = {
  getTemplate(o) {
    const { alignment: e, borderId: t, fillId: i, fontId: r, numFmtId: n, protection: s, xfId: a } = o, l = [];
    return e && l.push(Nk.getTemplate(e)), s && l.push(Gk.getTemplate(s)), {
      name: "xf",
      properties: {
        rawMap: {
          applyAlignment: e ? 1 : void 0,
          applyProtection: s ? 1 : void 0,
          applyBorder: t ? 1 : void 0,
          applyFill: i ? 1 : void 0,
          borderId: t,
          fillId: i,
          applyFont: r ? 1 : void 0,
          fontId: r,
          applyNumberFormat: n ? 1 : void 0,
          numFmtId: n,
          xfId: a
        }
      },
      children: l.length ? l : void 0
    };
  }
}, kk = {
  getTemplate(o) {
    return {
      name: "cellStyleXfs",
      properties: {
        rawMap: {
          count: o.length
        }
      },
      children: o.map((e) => qx.getTemplate(e))
    };
  }
}, Vk = {
  getTemplate(o) {
    return {
      name: "cellXfs",
      properties: {
        rawMap: {
          count: o.length
        }
      },
      children: o.map((e) => qx.getTemplate(e))
    };
  }
}, Bk = {
  getTemplate(o) {
    const { builtinId: e, name: t, xfId: i } = o;
    return {
      name: "cellStyle",
      properties: {
        rawMap: {
          builtinId: e,
          name: t,
          xfId: i
        }
      }
    };
  }
}, Hk = {
  getTemplate(o) {
    return {
      name: "cellStyles",
      properties: {
        rawMap: {
          count: o.length
        }
      },
      children: o.map((e) => Bk.getTemplate(e))
    };
  }
};
let Kg, ud, Eh, Rh, Th, Zx, Yg, Qx, HC;
const Jx = (o, e) => (o.indexOf("mixedStyle") !== -1 && e > 1 && (o += `_${e}`), o), eD = () => {
  Kg = { base: 0 }, ud = [], Eh = [{ fontName: "Calibri", colorTheme: "1", family: "2", scheme: "minor" }], Rh = [{ patternType: "none" }, { patternType: "gray125" }], Th = [{ left: void 0, right: void 0, top: void 0, bottom: void 0, diagonal: void 0 }], Zx = [{ borderId: 0, fillId: 0, fontId: 0, numFmtId: 0 }], Yg = [{ borderId: 0, fillId: 0, fontId: 0, numFmtId: 0, xfId: 0 }], Qx = [{ builtinId: 0, name: "Normal", xfId: 0 }];
}, Wk = (o) => {
  const e = Ak(o.pattern), t = oa(o.color), i = oa(o.patternColor);
  let r = Rh.findIndex((n) => {
    const { patternType: s, fgRgb: a, bgRgb: l } = n;
    return !(s != e || a != t || l != i);
  });
  return r === -1 && (r = Rh.length, Rh.push({ patternType: e, fgRgb: t, bgRgb: i })), r;
}, jk = (o) => {
  if (o = x.utf8_encode(o), d0[o])
    return d0[o];
  let e = ud.findIndex((t) => t.formatCode === o);
  return e === -1 ? (e = ud.length + 164, ud.push({ formatCode: o, numFmtId: e })) : e = ud[e].numFmtId, e;
}, Uk = (o) => {
  const { borderBottom: e, borderTop: t, borderLeft: i, borderRight: r } = o;
  let n, s, a, l, c, d, u, h;
  i && (a = Uf(i.lineStyle, i.weight), u = oa(i.color)), r && (l = Uf(r.lineStyle, r.weight), h = oa(r.color)), e && (n = Uf(e.lineStyle, e.weight), c = oa(e.color)), t && (s = Uf(t.lineStyle, t.weight), d = oa(t.color));
  let p = Th.findIndex((f) => {
    const { left: g, right: v, top: y, bottom: m } = f;
    if (!g && (a || u) || !v && (l || h) || !y && (s || d) || !m && (n || c))
      return !1;
    const { style: C, color: R } = g || {}, { style: E, color: b } = v || {}, { style: T, color: D } = y || {}, { style: P, color: O } = m || {};
    return !(C != a || R != u || E != l || b != h || T != s || D != d || P != n || O != c);
  });
  return p === -1 && (p = Th.length, Th.push({
    left: {
      style: a,
      color: u
    },
    right: {
      style: l,
      color: h
    },
    top: {
      style: s,
      color: d
    },
    bottom: {
      style: n,
      color: c
    },
    diagonal: {
      style: void 0,
      color: void 0
    }
  })), p;
}, $k = (o) => {
  const { fontName: e = "Calibri", color: t, size: i, bold: r, italic: n, outline: s, shadow: a, strikeThrough: l, underline: c, family: d, verticalAlign: u } = o, h = e && x.utf8_encode(e), p = oa(t), f = $G(d), g = c ? c.toLocaleLowerCase() : void 0, v = u ? u.toLocaleLowerCase() : void 0;
  let y = Eh.findIndex((m) => !(m.fontName != h || m.color != p || m.size != i || m.bold != r || m.italic != n || m.outline != s || m.shadow != a || m.strikeThrough != l || m.underline != g || m.verticalAlign != v || // @ts-ignore
  m.family != f));
  return y === -1 && (y = Eh.length, Eh.push({
    fontName: h,
    color: p,
    size: i,
    bold: r,
    italic: n,
    outline: s,
    shadow: a,
    strikeThrough: l,
    underline: g,
    verticalAlign: v,
    family: f != null ? f.toString() : void 0
  })), y;
}, zk = (o) => {
  const { alignment: e, borders: t, font: i, interior: r, numberFormat: n, protection: s } = o;
  let { id: a } = o, l = 0, c = 0, d = 0, u = 0;
  a && (a = Jx(a, HC), Kg[a] == null && (r && (l = Wk(r)), t && (c = Uk(t)), i && (d = $k(i)), n && (u = jk(n.format)), Kg[a] = Yg.length, Yg.push({
    alignment: e,
    borderId: c || 0,
    fillId: l || 0,
    fontId: d || 0,
    numFmtId: u || 0,
    protection: s,
    xfId: 0
  })));
}, Kk = {
  getTemplate(o) {
    const e = Ck.getTemplate(ud), t = bk.getTemplate(Eh.map((l) => Object.assign(Object.assign({}, l), { size: l.size != null ? l.size : o }))), i = Ek.getTemplate(Rh), r = Fk.getTemplate(Th), n = kk.getTemplate(Zx), s = Vk.getTemplate(Yg), a = Hk.getTemplate(Qx);
    return eD(), {
      name: "styleSheet",
      properties: {
        rawMap: {
          "mc:Ignorable": "x14ac x16r2 xr",
          xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
          "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
          "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac",
          "xmlns:x16r2": "http://schemas.microsoft.com/office/spreadsheetml/2015/02/main",
          "xmlns:xr": "http://schemas.microsoft.com/office/spreadsheetml/2014/revision"
        }
      },
      children: [
        e,
        t,
        i,
        r,
        n,
        s,
        a,
        {
          name: "tableStyles",
          properties: {
            rawMap: {
              count: 0,
              defaultPivotStyle: "PivotStyleLight16",
              defaultTableStyle: "TableStyleMedium2"
            }
          }
        }
      ]
    };
  }
}, Yk = (o, e) => Kg[Jx(o, e)] || 0, Xk = (o, e) => {
  HC = e, HC === 1 && eD(), o.forEach(zk);
}, qk = {
  getTemplate(o, e) {
    const t = (e + 1).toString();
    return {
      name: "sheet",
      properties: {
        rawMap: {
          name: o,
          sheetId: t,
          "r:id": `rId${t}`
        }
      }
    };
  }
}, Zk = {
  getTemplate(o) {
    return {
      name: "sheets",
      children: o.map((e, t) => qk.getTemplate(e, t))
    };
  }
}, Qk = {
  getTemplate(o) {
    return {
      name: "workbook",
      properties: {
        prefixedAttributes: [{
          prefix: "xmlns:",
          map: {
            r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
          }
        }],
        rawMap: {
          xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main"
        }
      },
      children: [Zk.getTemplate(o)]
    };
  }
}, Jk = (o) => Math.ceil((o - 12) / 7 + 1), eV = {
  getTemplate(o) {
    const { min: e, max: t, outlineLevel: i, s: r, width: n, hidden: s, bestFit: a } = o;
    let l = 1, c = "0";
    return n > 1 && (l = Jk(n), c = "1"), {
      name: "col",
      properties: {
        rawMap: {
          min: e,
          max: t,
          outlineLevel: i != null ? i : void 0,
          width: l,
          style: r,
          hidden: s ? "1" : "0",
          bestFit: a ? "1" : "0",
          customWidth: c
        }
      }
    };
  }
}, tV = (o) => {
  const e = o.charAt(0).toLowerCase();
  return e === "s" ? "inlineStr" : e;
}, iV = {
  getTemplate(o, e, t) {
    const { ref: i, data: r, styleId: n } = o, { type: s, value: a } = r || { type: "empty", value: null };
    let l = s;
    s === "f" ? l = "str" : s.charAt(0) === s.charAt(0).toUpperCase() && (l = tV(s));
    const c = {
      name: "c",
      properties: {
        rawMap: {
          r: i,
          t: l === "empty" ? void 0 : l,
          s: n ? Yk(n, t) : void 0
        }
      }
    };
    if (l === "empty")
      return c;
    let d;
    return l === "str" && s === "f" ? d = [{
      name: "f",
      textNode: x.escapeString(x.utf8_encode(a))
    }] : l === "inlineStr" ? d = [{
      name: "is",
      children: [{
        name: "t",
        textNode: x.escapeString(x.utf8_encode(a))
      }]
    }] : d = [{
      name: "v",
      textNode: a
    }], Object.assign({}, c, { children: d });
  }
}, rV = (o, e) => {
  const t = [];
  let i = 0;
  for (let r = 0; r < o.length; r++) {
    const n = o[r];
    n.mergeAcross && (t.push({
      pos: r,
      excelPos: i
    }), i += n.mergeAcross), i++;
  }
  if (t.length)
    for (let r = t.length - 1; r >= 0; r--) {
      const n = [], s = o[t[r].pos];
      for (let a = 1; a <= s.mergeAcross; a++)
        n.push({
          ref: `${cp(t[r].excelPos + 1 + a)}${e + 1}`,
          styleId: s.styleId,
          data: { type: "empty", value: null }
        });
      n.length && o.splice(t[r].pos + 1, 0, ...n);
    }
}, nV = (o) => {
  var e;
  return ((e = o.data) === null || e === void 0 ? void 0 : e.value) !== "" || o.styleId !== void 0;
}, oV = {
  getTemplate(o, e, t) {
    const { collapsed: i, hidden: r, height: n, outlineLevel: s, cells: a = [] } = o;
    rV(a, e);
    const l = a.filter(nV).map((c, d) => iV.getTemplate(c, d, t));
    return {
      name: "row",
      properties: {
        rawMap: {
          r: e + 1,
          collapsed: i ? "1" : "0",
          hidden: r ? "1" : "0",
          ht: n,
          customHeight: n != null ? "1" : "0",
          spans: "1:1",
          outlineLevel: s || void 0
        }
      },
      children: l
    };
  }
}, sV = {
  getTemplate(o) {
    return {
      name: "mergeCell",
      properties: {
        rawMap: {
          ref: o
        }
      }
    };
  }
}, aV = (o, e, t) => {
  const i = [], r = [];
  o.forEach((a, l) => {
    const c = a.cells;
    let d = 0, u;
    c.forEach((h, p) => {
      const f = p + d + 1, g = cp(f), v = l + 1;
      if (h.mergeAcross) {
        d += h.mergeAcross;
        const m = cp(p + d + 1);
        i.push(`${g}${v}:${m}${v}`);
      }
      e[f - 1] || (e[f - 1] = {});
      const { collapsibleRanges: y } = h;
      y && y.forEach((m) => {
        r.push([f + m[0], f + m[1]]);
      }), u = e[f - 1], u.min = f, u.max = f, h.ref = `${g}${v}`;
    });
  }), r.sort((a, l) => a[0] !== l[0] ? a[0] - l[0] : l[1] - a[1]);
  const n = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
  return r.filter((a) => {
    const l = a.toString();
    return n.get(l) ? !1 : (n.set(l, !0), !0);
  }).forEach((a) => {
    const l = e.find((d) => d.min == a[0] && d.max == a[1]), c = s.get(a[0]);
    e.push({
      min: a[0],
      max: a[1],
      outlineLevel: t ? void 0 : c || 1,
      width: (l || { width: 100 }).width
    }), s.set(a[0], (c || 0) + 1);
  }), i;
}, lV = (o) => !o || o !== "Portrait" && o !== "Landscape" ? "portrait" : o.toLocaleLowerCase(), cV = (o) => {
  if (o == null)
    return 1;
  const t = ["Letter", "Letter Small", "Tabloid", "Ledger", "Legal", "Statement", "Executive", "A3", "A4", "A4 Small", "A5", "A6", "B4", "B5", "Folio", "Envelope", "Envelope DL", "Envelope C5", "Envelope B5", "Envelope C3", "Envelope C4", "Envelope C6", "Envelope Monarch", "Japanese Postcard", "Japanese Double Postcard"].indexOf(o);
  return t === -1 ? 1 : t + 1;
}, dV = (o) => (e) => (o.length && e.push({
  name: "cols",
  children: o.map((t) => eV.getTemplate(t))
}), e), uV = (o, e) => (t) => (o.length && t.push({
  name: "sheetData",
  children: o.map((i, r) => oV.getTemplate(i, r, e))
}), t), hV = (o) => (e) => (o.length && e.push({
  name: "mergeCells",
  properties: {
    rawMap: {
      count: o.length
    }
  },
  children: o.map((t) => sV.getTemplate(t))
}), e), pV = (o) => (e) => {
  const { top: t = 0.75, right: i = 0.7, bottom: r = 0.75, left: n = 0.7, header: s = 0.3, footer: a = 0.3 } = o;
  return e.push({
    name: "pageMargins",
    properties: {
      rawMap: { bottom: r, footer: a, header: s, left: n, right: i, top: t }
    }
  }), e;
}, fV = (o) => (e) => (o && e.push({
  name: "pageSetup",
  properties: {
    rawMap: {
      horizontalDpi: 0,
      verticalDpi: 0,
      orientation: lV(o.orientation),
      paperSize: cV(o.pageSize)
    }
  }
}), e), gV = (o) => {
  const e = {
    "&[Page]": "&P",
    "&[Pages]": "&N",
    "&[Date]": "&D",
    "&[Time]": "&T",
    "&[Tab]": "&A",
    "&[Path]": "&Z",
    "&[File]": "&F"
  };
  return x.iterateObject(e, (t, i) => {
    o = o.replace(t, i);
  }), o;
}, vV = (o) => o === "Center" ? "C" : o === "Right" ? "R" : "L", mV = (o, e) => (e && (o += "&amp;&quot;", o += e.fontName || "Calibri", e.bold !== e.italic ? o += e.bold ? ",Bold" : ",Italic" : e.bold ? o += ",Bold Italic" : o += ",Regular", o += "&quot;", e.size && (o += `&amp;${e.size}`), e.strikeThrough && (o += "&amp;S"), e.underline && (o += `&amp;${e.underline === "Double" ? "E" : "U"}`), e.color && (o += `&amp;K${e.color.replace("#", "").toUpperCase()}`)), o), yV = (o) => o.reduce((e, t) => {
  const i = vV(t.position);
  return `${mV(`${e}&amp;${i}`, t.font)}${x.escapeString(gV(t.value))}`;
}, ""), CV = (o) => {
  const e = ["all", "first", "even"], t = [];
  return e.forEach((i) => {
    const r = o[i], n = i === "all" ? "odd" : i;
    !r || !r.header && !r.footer || x.iterateObject(r, (s, a) => {
      const l = `${s.charAt(0).toUpperCase()}${s.slice(1)}`;
      a && t.push({
        name: `${n}${l}`,
        properties: {
          rawMap: {
            "xml:space": "preserve"
          }
        },
        textNode: yV(a)
      });
    });
  }), t;
}, SV = (o) => (e) => {
  if (!o)
    return e;
  const t = o.first != null ? 1 : 0, i = o.even != null ? 1 : 0;
  return e.push({
    name: "headerFooter",
    properties: {
      rawMap: {
        differentFirst: t,
        differentOddEven: i
      }
    },
    children: CV(o)
  }), e;
}, bV = (o) => (e) => (et.worksheetImages.get(o) && e.push({
  name: "drawing",
  properties: {
    rawMap: {
      "r:id": "rId1"
    }
  }
}), e), wV = () => (o) => (o.push({
  name: "sheetPr",
  children: [{
    name: "outlinePr",
    properties: {
      rawMap: {
        summaryBelow: 0
      }
    }
  }]
}), o), EV = (o) => (e) => {
  const t = o.reduce((i, r) => r.outlineLevel && r.outlineLevel > i ? r.outlineLevel : i, 0);
  return e.push({
    name: "sheetFormatPr",
    properties: {
      rawMap: {
        baseColWidth: 10,
        defaultRowHeight: 16,
        outlineLevelRow: t || void 0
      }
    }
  }), e;
}, RV = {
  getTemplate(o) {
    const { worksheet: e, currentSheet: t, config: i } = o, { margins: r = {}, pageSetup: n, headerFooterConfig: s, suppressColumnOutline: a } = i, { table: l } = e, { rows: c, columns: d } = l, u = d && d.length ? aV(c, d, !!a) : [], p = x.compose(wV(), EV(c), dV(d), uV(c, t + 1), hV(u), pV(r), fV(n), SV(s), bV(t))([]);
    return {
      name: "worksheet",
      properties: {
        prefixedAttributes: [{
          prefix: "xmlns:",
          map: {
            r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
          }
        }],
        rawMap: {
          xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main"
        }
      },
      children: p
    };
  }
}, TV = {
  getTemplate(o) {
    const { Id: e, Type: t, Target: i } = o;
    return {
      name: "Relationship",
      properties: {
        rawMap: {
          Id: e,
          Type: t,
          Target: i
        }
      }
    };
  }
}, $f = {
  getTemplate(o) {
    const e = o.map((t) => TV.getTemplate(t));
    return {
      name: "Relationships",
      properties: {
        rawMap: {
          xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
        }
      },
      children: e
    };
  }
};
class et {
  static createExcel(e, t, i) {
    return this.addSheetName(t), Xk(e, this.sheetNames.length), this.createWorksheet(t, i);
  }
  static buildImageMap(e, t, i, r, n) {
    const s = this.sheetNames.length, a = this.images.get(e.id);
    (!e.position || !e.position.row || !e.position.column) && (e.position || (e.position = {}), e.position = Object.assign({}, e.position, {
      row: t,
      column: r.indexOf(i) + 1
    }));
    const l = e;
    if (zG(l, r), KG(l, n), a) {
      const c = a.find((d) => d.sheetId === s);
      c ? c.image.push(l) : a.push({
        sheetId: s,
        image: [l]
      });
    } else
      this.images.set(l.id, [{ sheetId: s, image: [l] }]), this.workbookImageIds.set(l.id, { type: l.imageType, index: this.workbookImageIds.size });
    this.buildSheetImageMap(s, l);
  }
  static buildSheetImageMap(e, t) {
    let i = this.worksheetImageIds.get(e);
    i || (i = /* @__PURE__ */ new Map(), this.worksheetImageIds.set(e, i));
    const r = this.worksheetImages.get(e);
    r ? (r.push(t), i.get(t.id) || i.set(t.id, { index: i.size, type: t.imageType })) : (this.worksheetImages.set(e, [t]), i.set(t.id, { index: 0, type: t.imageType }));
  }
  static addSheetName(e) {
    const t = x.escapeString(e.name) || "";
    let i = "";
    for (; this.sheetNames.indexOf(`${t}${i}`) !== -1; )
      i === "" ? i = "_1" : i = `_${parseInt(i.slice(1), 10) + 1}`;
    e.name = `${t}${i}`, this.sheetNames.push(e.name);
  }
  static getStringPosition(e) {
    return this.sharedStrings.has(e) ? this.sharedStrings.get(e) : (this.sharedStrings.set(e, this.sharedStrings.size), this.sharedStrings.size - 1);
  }
  static resetFactory() {
    this.sharedStrings = /* @__PURE__ */ new Map(), this.images = /* @__PURE__ */ new Map(), this.worksheetImages = /* @__PURE__ */ new Map(), this.workbookImageIds = /* @__PURE__ */ new Map(), this.worksheetImageIds = /* @__PURE__ */ new Map(), this.sheetNames = [], this.factoryMode = Fl.SINGLE_SHEET;
  }
  static createWorkbook() {
    return Yr(Qk.getTemplate(this.sheetNames));
  }
  static createStylesheet(e) {
    return Yr(Kk.getTemplate(e));
  }
  static createSharedStrings() {
    return Yr(vk.getTemplate(this.sharedStrings));
  }
  static createCore(e) {
    return Yr(XG.getTemplate(e));
  }
  static createContentTypes(e) {
    return Yr(ZG.getTemplate(e));
  }
  static createRels() {
    const e = $f.getTemplate([{
      Id: "rId1",
      Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
      Target: "xl/workbook.xml"
    }, {
      Id: "rId2",
      Type: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
      Target: "docProps/core.xml"
    }]);
    return Yr(e);
  }
  static createTheme() {
    return Yr(fk.getTemplate());
  }
  static createWorkbookRels(e) {
    const t = new Array(e).fill(void 0).map((r, n) => ({
      Id: `rId${n + 1}`,
      Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
      Target: `worksheets/sheet${n + 1}.xml`
    })), i = $f.getTemplate([
      ...t,
      {
        Id: `rId${e + 1}`,
        Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
        Target: "theme/theme1.xml"
      },
      {
        Id: `rId${e + 2}`,
        Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
        Target: "styles.xml"
      },
      {
        Id: `rId${e + 3}`,
        Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
        Target: "sharedStrings.xml"
      }
    ]);
    return Yr(i);
  }
  static createDrawing(e) {
    return Yr(ok.getTemplate({ sheetIndex: e }));
  }
  static createDrawingRel(e) {
    const t = this.worksheetImageIds.get(e), i = [];
    return t.forEach((r, n) => {
      i.push({
        Id: `rId${r.index + 1}`,
        Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
        Target: `../media/image${this.workbookImageIds.get(n).index + 1}.${r.type}`
      });
    }), Yr($f.getTemplate(i));
  }
  static createWorksheetDrawingRel(e) {
    const t = $f.getTemplate([{
      Id: "rId1",
      Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
      Target: `../drawings/drawing${e + 1}.xml`
    }]);
    return Yr(t);
  }
  static createWorksheet(e, t) {
    return Yr(RV.getTemplate({
      worksheet: e,
      currentSheet: this.sheetNames.length - 1,
      config: t
    }));
  }
}
et.sharedStrings = /* @__PURE__ */ new Map();
et.sheetNames = [];
et.images = /* @__PURE__ */ new Map();
et.worksheetImages = /* @__PURE__ */ new Map();
et.workbookImageIds = /* @__PURE__ */ new Map();
et.worksheetImageIds = /* @__PURE__ */ new Map();
et.factoryMode = Fl.SINGLE_SHEET;
class xV extends Xx {
  createExcel(e) {
    const { excelStyles: t, config: i } = this;
    return et.createExcel(t, e, i);
  }
  getDataTypeForValue(e) {
    return e === void 0 ? "empty" : this.isNumerical(e) ? "n" : "s";
  }
  getType(e, t, i) {
    if (this.isFormula(i))
      return "f";
    if (t && t.dataType)
      switch (t.dataType.toLocaleLowerCase()) {
        case "formula":
          return "f";
        case "string":
          return "s";
        case "number":
          return "n";
        case "datetime":
          return "d";
        case "error":
          return "e";
        case "boolean":
          return "b";
        default:
          console.warn(`AG Grid: Unrecognized data type for excel export [${t.id}.dataType=${t.dataType}]`);
      }
    return e;
  }
  addImage(e, t, i) {
    if (!this.config.addImageToCell)
      return;
    const r = this.config.addImageToCell(e, t, i);
    if (r)
      return et.buildImageMap(r.image, e, t, this.columnsToExport, this.config.rowHeight), r;
  }
  createCell(e, t, i, r) {
    const n = this.getStyleById(e);
    !(n != null && n.dataType) && t === "s" && r && (i = r);
    const s = this.getType(t, n, i) || t;
    return {
      styleId: n ? e : void 0,
      data: {
        type: s,
        value: this.getCellValue(s, i)
      }
    };
  }
  createMergedCell(e, t, i, r) {
    const n = i == null ? "" : i;
    return {
      styleId: this.getStyleById(e) ? e : void 0,
      data: {
        type: t,
        value: t === "s" ? et.getStringPosition(n).toString() : i
      },
      mergeAcross: r
    };
  }
  getCellValue(e, t) {
    if (t == null)
      return et.getStringPosition("").toString();
    switch (e) {
      case "s":
        return t === "" ? "" : et.getStringPosition(t).toString();
      case "f":
        return t.slice(1);
      case "n":
        return Number(t).toString();
      default:
        return t;
    }
  }
}
var ks = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const WC = (o) => {
  const { data: e, fontSize: t = 11, author: i = "AG Grid" } = o, r = et.images.size > 0;
  if (oi.addFolders([
    "_rels/",
    "docProps/",
    "xl/",
    "xl/theme/",
    "xl/_rels/",
    "xl/worksheets/"
  ]), r) {
    oi.addFolders([
      "xl/worksheets/_rels",
      "xl/drawings/",
      "xl/drawings/_rels",
      "xl/media/"
    ]);
    let l = 0;
    et.images.forEach((c) => {
      const d = c[0].image[0], u = d.imageType;
      oi.addFile(`xl/media/image${++l}.${u}`, d.base64, !0);
    });
  }
  if (!e || e.length === 0) {
    console.warn("AG Grid: Invalid params supplied to getMultipleSheetsAsExcel() - `ExcelExportParams.data` is empty."), et.resetFactory();
    return;
  }
  const n = e.length;
  let s = 0;
  e.forEach((l, c) => {
    oi.addFile(`xl/worksheets/sheet${c + 1}.xml`, l), r && et.worksheetImages.get(c) && OV(c, s++);
  }), oi.addFile("xl/workbook.xml", et.createWorkbook()), oi.addFile("xl/styles.xml", et.createStylesheet(t)), oi.addFile("xl/sharedStrings.xml", et.createSharedStrings()), oi.addFile("xl/theme/theme1.xml", et.createTheme()), oi.addFile("xl/_rels/workbook.xml.rels", et.createWorkbookRels(n)), oi.addFile("docProps/core.xml", et.createCore(i)), oi.addFile("[Content_Types].xml", et.createContentTypes(n)), oi.addFile("_rels/.rels", et.createRels()), et.resetFactory();
  const a = o.mimeType || "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
  return oi.getContent(a);
}, DV = (o) => {
  const { fileName: e = "export.xlsx" } = o, t = WC(o);
  t && Nb.download(e, t);
}, OV = (o, e) => {
  const t = "xl/drawings", i = `${t}/drawing${e + 1}.xml`, r = `${t}/_rels/drawing${e + 1}.xml.rels`, n = `xl/worksheets/_rels/sheet${o + 1}.xml.rels`;
  oi.addFile(r, et.createDrawingRel(o)), oi.addFile(i, et.createDrawing(o)), oi.addFile(n, et.createWorksheetDrawingRel(e));
};
let Un = class extends Lx {
  constructor() {
    super(...arguments), this.exportMode = "xlsx";
  }
  postConstruct() {
    this.setBeans({
      gridSerializer: this.gridSerializer,
      gridOptionsService: this.gridOptionsService
    });
  }
  getMergedParams(e) {
    const t = this.gridOptionsService.get("defaultExcelExportParams");
    return Object.assign({}, t, e);
  }
  getData(e) {
    return this.setExportMode(e.exportMode || "xlsx"), super.getData(e);
  }
  export(e) {
    if (this.isExportSuppressed())
      return console.warn("AG Grid: Export cancelled. Export is not allowed as per your configuration."), "";
    const t = this.getMergedParams(e), i = this.getData(t), r = {
      data: [i],
      fontSize: t.fontSize,
      author: t.author,
      mimeType: t.mimeType
    }, n = this.packageFile(r);
    return n && Nb.download(this.getFileName(t.fileName), n), i;
  }
  exportDataAsExcel(e) {
    return this.export(e);
  }
  getDataAsExcel(e) {
    const t = this.getMergedParams(e), i = this.getData(t);
    if (e && e.exportMode === "xml")
      return i;
    const r = {
      data: [i],
      fontSize: t.fontSize,
      author: t.author,
      mimeType: t.mimeType
    };
    return this.packageFile(r);
  }
  setFactoryMode(e, t = "xlsx") {
    const i = t === "xlsx" ? et : $g;
    i.factoryMode = e;
  }
  getFactoryMode(e) {
    return (e === "xlsx" ? et : $g).factoryMode;
  }
  getSheetDataForExcel(e) {
    const t = this.getMergedParams(e);
    return this.getData(t);
  }
  getMultipleSheetsAsExcel(e) {
    return WC(e);
  }
  exportMultipleSheetsAsExcel(e) {
    return DV(e);
  }
  getDefaultFileName() {
    return `export.${this.getExportMode()}`;
  }
  getDefaultFileExtension() {
    return this.getExportMode();
  }
  createSerializingSession(e) {
    const { columnModel: t, valueService: i, gridOptionsService: r, valueFormatterService: n, valueParserService: s } = this, a = this.getExportMode() === "xlsx";
    let l = "ag-grid";
    e.sheetName != null && (l = x.utf8_encode(e.sheetName.toString().substr(0, 31)));
    const c = Object.assign(Object.assign({}, e), {
      sheetName: l,
      columnModel: t,
      valueService: i,
      gridOptionsService: r,
      valueFormatterService: n,
      valueParserService: s,
      headerRowHeight: e.headerRowHeight || e.rowHeight,
      baseExcelStyles: this.gridOptionsService.get("excelStyles") || [],
      styleLinker: this.styleLinker.bind(this)
    });
    return new (a ? xV : YG)(c);
  }
  styleLinker(e) {
    const { rowType: t, rowIndex: i, value: r, column: n, columnGroup: s, node: a } = e, l = t === Al.HEADER, c = t === Al.HEADER_GROUPING, d = l ? n : s;
    let u = [];
    if (l || c)
      return u.push("header"), c && u.push("headerGroup"), d && (u = u.concat(jp.getHeaderClassesFromColDef(d.getDefinition(), this.gridOptionsService, n || null, s || null))), u;
    const h = this.gridOptionsService.get("excelStyles"), p = ["cell"];
    if (!h || !h.length)
      return p;
    const f = h.map((g) => g.id);
    return this.stylingService.processAllCellClasses(n.getDefinition(), {
      value: r,
      data: a.data,
      node: a,
      colDef: n.getDefinition(),
      column: n,
      rowIndex: i,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context
    }, (g) => {
      f.indexOf(g) > -1 && p.push(g);
    }), p.sort((g, v) => f.indexOf(g) < f.indexOf(v) ? -1 : 1);
  }
  isExportSuppressed() {
    return this.gridOptionsService.is("suppressExcelExport");
  }
  setExportMode(e) {
    this.exportMode = e;
  }
  getExportMode() {
    return this.exportMode;
  }
  packageFile(e) {
    if (this.getExportMode() === "xml") {
      const t = e.mimeType || "application/vnd.ms-excel";
      return new Blob(["\uFEFF", e.data[0]], { type: t });
    }
    return WC(e);
  }
};
ks([
  S("columnModel")
], Un.prototype, "columnModel", void 0);
ks([
  S("valueService")
], Un.prototype, "valueService", void 0);
ks([
  S("stylingService")
], Un.prototype, "stylingService", void 0);
ks([
  S("gridSerializer")
], Un.prototype, "gridSerializer", void 0);
ks([
  S("gridOptionsService")
], Un.prototype, "gridOptionsService", void 0);
ks([
  S("valueFormatterService")
], Un.prototype, "valueFormatterService", void 0);
ks([
  S("valueParserService")
], Un.prototype, "valueParserService", void 0);
ks([
  B
], Un.prototype, "postConstruct", null);
Un = ks([
  q("excelCreator")
], Un);
const PV = "30.0.5", AV = {
  version: PV,
  moduleName: Q.ExcelExportModule,
  beans: [
    // beans in this module
    Un,
    // these beans are part of CSV Export module
    Hn,
    Bn
  ],
  dependantModules: [
    Gb,
    Pi
  ]
};
var pf = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, mo;
(function(o) {
  o[o.EXPANDED = 0] = "EXPANDED", o[o.COLLAPSED = 1] = "COLLAPSED", o[o.INDETERMINATE = 2] = "INDETERMINATE";
})(mo || (mo = {}));
class Ou extends X {
  preConstruct() {
    this.setTemplate(
      /* html */
      `<div class="ag-filter-toolpanel-search" role="presentation">
                <div ref="eExpand" class="ag-filter-toolpanel-expand"></div>
                <ag-input-text-field ref="eFilterTextField" class="ag-filter-toolpanel-search-input"></ag-input-text-field>
            </div>`
    );
  }
  postConstruct() {
    const e = this.localeService.getLocaleTextFunc();
    this.eFilterTextField.onValueChange(this.onSearchTextChanged.bind(this)), this.eFilterTextField.setInputAriaLabel(e("ariaFilterColumnsInput", "Filter Columns Input")), this.createExpandIcons(), this.setExpandState(mo.EXPANDED), this.addManagedListener(this.eExpand, "click", this.onExpandClicked.bind(this)), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, this.showOrHideOptions.bind(this));
  }
  init(e) {
    this.params = e, this.columnModel.isReady() && this.showOrHideOptions();
  }
  createExpandIcons() {
    this.eExpand.appendChild(this.eExpandChecked = x.createIconNoSpan("columnSelectOpen", this.gridOptionsService)), this.eExpand.appendChild(this.eExpandUnchecked = x.createIconNoSpan("columnSelectClosed", this.gridOptionsService)), this.eExpand.appendChild(this.eExpandIndeterminate = x.createIconNoSpan("columnSelectIndeterminate", this.gridOptionsService));
  }
  // we only show expand / collapse if we are showing filters
  showOrHideOptions() {
    const e = !this.params.suppressFilterSearch, t = !this.params.suppressExpandAll, i = this.localeService.getLocaleTextFunc();
    this.eFilterTextField.setInputPlaceholder(i("searchOoo", "Search..."));
    const r = (s) => s.getOriginalParent() && s.isFilterAllowed(), n = this.columnModel.getAllGridColumns().some(r);
    x.setDisplayed(this.eFilterTextField.getGui(), e), x.setDisplayed(this.eExpand, t && n);
  }
  onSearchTextChanged() {
    this.onSearchTextChangedDebounced || (this.onSearchTextChangedDebounced = x.debounce(() => {
      this.dispatchEvent({ type: "searchChanged", searchText: this.eFilterTextField.getValue() });
    }, 300)), this.onSearchTextChangedDebounced();
  }
  onExpandClicked() {
    const e = this.currentExpandState === mo.EXPANDED ? { type: "collapseAll" } : { type: "expandAll" };
    this.dispatchEvent(e);
  }
  setExpandState(e) {
    this.currentExpandState = e, x.setDisplayed(this.eExpandChecked, this.currentExpandState === mo.EXPANDED), x.setDisplayed(this.eExpandUnchecked, this.currentExpandState === mo.COLLAPSED), x.setDisplayed(this.eExpandIndeterminate, this.currentExpandState === mo.INDETERMINATE);
  }
}
pf([
  S("columnModel")
], Ou.prototype, "columnModel", void 0);
pf([
  L("eExpand")
], Ou.prototype, "eExpand", void 0);
pf([
  L("eFilterTextField")
], Ou.prototype, "eFilterTextField", void 0);
pf([
  su
], Ou.prototype, "preConstruct", null);
pf([
  B
], Ou.prototype, "postConstruct", null);
var qa = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class jr extends X {
  constructor(e = !1) {
    super(jr.TEMPLATE), this.expanded = !1, this.hideHeader = e;
  }
  postConstruct() {
    this.eExpandChecked = x.createIconNoSpan("columnSelectOpen", this.gridOptionsService), this.eExpandUnchecked = x.createIconNoSpan("columnSelectClosed", this.gridOptionsService), this.eExpand.appendChild(this.eExpandChecked), this.eExpand.appendChild(this.eExpandUnchecked);
  }
  setColumn(e) {
    this.column = e, this.eFilterName.innerText = this.columnModel.getDisplayNameForColumn(this.column, "filterToolPanel", !1) || "", this.addManagedListener(this.eFilterToolPanelHeader, "click", this.toggleExpanded.bind(this)), this.addManagedListener(this.eFilterToolPanelHeader, "keydown", (t) => {
      t.key === V.ENTER && this.toggleExpanded();
    }), this.addManagedListener(this.eventService, w.EVENT_FILTER_OPENED, this.onFilterOpened.bind(this)), this.addInIcon("filter", this.eFilterIcon, this.column), x.setDisplayed(this.eFilterIcon, this.isFilterActive(), { skipAriaHidden: !0 }), x.setDisplayed(this.eExpandChecked, !1), this.hideHeader ? (x.setDisplayed(this.eFilterToolPanelHeader, !1), this.eFilterToolPanelHeader.removeAttribute("tabindex")) : this.eFilterToolPanelHeader.setAttribute("tabindex", "0"), this.addManagedListener(this.column, me.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_FILTER_DESTROYED, this.onFilterDestroyed.bind(this));
  }
  getColumn() {
    return this.column;
  }
  getColumnFilterName() {
    return this.columnModel.getDisplayNameForColumn(this.column, "filterToolPanel", !1);
  }
  addCssClassToTitleBar(e) {
    this.eFilterToolPanelHeader.classList.add(e);
  }
  addInIcon(e, t, i) {
    if (t == null)
      return;
    const r = x.createIconNoSpan(e, this.gridOptionsService, i);
    t.appendChild(r);
  }
  isFilterActive() {
    return this.filterManager.isFilterActive(this.column);
  }
  onFilterChanged() {
    x.setDisplayed(this.eFilterIcon, this.isFilterActive(), { skipAriaHidden: !0 }), this.dispatchEvent({ type: me.EVENT_FILTER_CHANGED });
  }
  onFilterDestroyed(e) {
    this.expanded && e.source === "api" && e.column.getId() === this.column.getId() && this.columnModel.getPrimaryColumn(this.column) && (this.removeFilterElement(), this.addFilterElement());
  }
  toggleExpanded() {
    this.expanded ? this.collapse() : this.expand();
  }
  expand() {
    this.expanded || (this.expanded = !0, x.setAriaExpanded(this.eFilterToolPanelHeader, !0), x.setDisplayed(this.eExpandChecked, !0), x.setDisplayed(this.eExpandUnchecked, !1), this.addFilterElement());
  }
  addFilterElement() {
    const e = x.loadTemplate(
      /* html */
      '<div class="ag-filter-toolpanel-instance-filter"></div>'
    ), t = this.filterManager.getOrCreateFilterWrapper(this.column, "TOOLBAR");
    if (!t)
      return;
    const { filterPromise: i, guiPromise: r } = t;
    i == null || i.then((n) => {
      this.underlyingFilter = n, n && r.then((s) => {
        s && e.appendChild(s), this.agFilterToolPanelBody.appendChild(e), n.afterGuiAttached && n.afterGuiAttached({ container: "toolPanel" });
      });
    });
  }
  collapse() {
    var e, t;
    this.expanded && (this.expanded = !1, x.setAriaExpanded(this.eFilterToolPanelHeader, !1), this.removeFilterElement(), x.setDisplayed(this.eExpandChecked, !1), x.setDisplayed(this.eExpandUnchecked, !0), (t = (e = this.underlyingFilter) === null || e === void 0 ? void 0 : e.afterGuiDetached) === null || t === void 0 || t.call(e));
  }
  removeFilterElement() {
    x.clearElement(this.agFilterToolPanelBody);
  }
  isExpanded() {
    return this.expanded;
  }
  refreshFilter(e) {
    var t;
    if (!this.expanded)
      return;
    const i = this.underlyingFilter;
    i && (e ? typeof i.refreshVirtualList == "function" && i.refreshVirtualList() : (t = i.afterGuiDetached) === null || t === void 0 || t.call(i));
  }
  onFilterOpened(e) {
    e.source === "COLUMN_MENU" && e.column === this.column && this.expanded && this.collapse();
  }
}
jr.TEMPLATE = `
        <div class="ag-filter-toolpanel-instance">
            <div class="ag-filter-toolpanel-header ag-filter-toolpanel-instance-header" ref="eFilterToolPanelHeader" role="button" aria-expanded="false">
                <div ref="eExpand" class="ag-filter-toolpanel-expand"></div>
                <span ref="eFilterName" class="ag-header-cell-text"></span>
                <span ref="eFilterIcon" class="ag-header-icon ag-filter-icon ag-filter-toolpanel-instance-header-icon" aria-hidden="true"></span>
            </div>
            <div class="ag-filter-toolpanel-instance-body ag-filter" ref="agFilterToolPanelBody"></div>
        </div>`;
qa([
  L("eFilterToolPanelHeader")
], jr.prototype, "eFilterToolPanelHeader", void 0);
qa([
  L("eFilterName")
], jr.prototype, "eFilterName", void 0);
qa([
  L("agFilterToolPanelBody")
], jr.prototype, "agFilterToolPanelBody", void 0);
qa([
  L("eFilterIcon")
], jr.prototype, "eFilterIcon", void 0);
qa([
  L("eExpand")
], jr.prototype, "eExpand", void 0);
qa([
  S("filterManager")
], jr.prototype, "filterManager", void 0);
qa([
  S("columnModel")
], jr.prototype, "columnModel", void 0);
qa([
  B
], jr.prototype, "postConstruct", null);
var Lm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Yi extends X {
  constructor(e, t, i, r, n) {
    super(), this.columnGroup = e, this.childFilterComps = t, this.depth = r, this.expandedCallback = i, this.showingColumn = n;
  }
  preConstruct() {
    const e = {
      cssIdentifier: "filter-toolpanel",
      direction: "vertical"
    };
    this.setTemplate(Yi.TEMPLATE, { filterGroupComp: e });
  }
  init() {
    this.setGroupTitle(), this.filterGroupComp.setAlignItems("stretch"), this.filterGroupComp.addCssClass(`ag-filter-toolpanel-group-level-${this.depth}`), this.filterGroupComp.addCssClassToTitleBar(`ag-filter-toolpanel-group-level-${this.depth}-header`), this.childFilterComps.forEach((e) => {
      this.filterGroupComp.addItem(e), e.addCssClassToTitleBar(`ag-filter-toolpanel-group-level-${this.depth + 1}-header`);
    }), this.refreshFilterClass(), this.addExpandCollapseListeners(), this.addFilterChangedListeners(), this.setupTooltip();
  }
  setupTooltip() {
    if (!this.showingColumn)
      return;
    const e = () => {
      const t = this.columnGroup.getColDef().headerTooltip;
      this.setTooltip(t);
    };
    e(), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, e);
  }
  getTooltipParams() {
    const e = super.getTooltipParams();
    return e.location = "filterToolPanelColumnGroup", e;
  }
  addCssClassToTitleBar(e) {
    this.filterGroupComp.addCssClassToTitleBar(e);
  }
  refreshFilters(e) {
    this.childFilterComps.forEach((t) => {
      t instanceof Yi ? t.refreshFilters(e) : t.refreshFilter(e);
    });
  }
  isColumnGroup() {
    return this.columnGroup instanceof Be;
  }
  isExpanded() {
    return this.filterGroupComp.isExpanded();
  }
  getChildren() {
    return this.childFilterComps;
  }
  getFilterGroupName() {
    return this.filterGroupName ? this.filterGroupName : "";
  }
  getFilterGroupId() {
    return this.columnGroup.getId();
  }
  hideGroupItem(e, t) {
    this.filterGroupComp.hideItem(e, t);
  }
  hideGroup(e) {
    this.setDisplayed(!e);
  }
  forEachToolPanelFilterChild(e) {
    this.childFilterComps.forEach((t) => {
      t instanceof jr && e(t);
    });
  }
  addExpandCollapseListeners() {
    const e = this.isColumnGroup() ? () => this.expandedCallback() : () => this.forEachToolPanelFilterChild((i) => i.expand()), t = this.isColumnGroup() ? () => this.expandedCallback() : () => this.forEachToolPanelFilterChild((i) => i.collapse());
    this.addManagedListener(this.filterGroupComp, Tt.EVENT_EXPANDED, e), this.addManagedListener(this.filterGroupComp, Tt.EVENT_COLLAPSED, t);
  }
  getColumns() {
    return this.columnGroup instanceof Be ? this.columnGroup.getLeafColumns() : [this.columnGroup];
  }
  addFilterChangedListeners() {
    this.getColumns().forEach((e) => {
      this.addManagedListener(e, me.EVENT_FILTER_CHANGED, () => this.refreshFilterClass());
    }), this.columnGroup instanceof Be || this.addManagedListener(this.eventService, w.EVENT_FILTER_OPENED, this.onFilterOpened.bind(this));
  }
  refreshFilterClass() {
    const e = this.getColumns(), t = () => e.some((i) => i.isFilterActive());
    this.filterGroupComp.addOrRemoveCssClass("ag-has-filter", t());
  }
  onFilterOpened(e) {
    e.source === "COLUMN_MENU" && e.column === this.columnGroup && this.isExpanded() && this.collapse();
  }
  expand() {
    this.filterGroupComp.toggleGroupExpand(!0);
  }
  collapse() {
    this.filterGroupComp.toggleGroupExpand(!1);
  }
  setGroupTitle() {
    this.filterGroupName = this.columnGroup instanceof Be ? this.getColumnGroupName(this.columnGroup) : this.getColumnName(this.columnGroup), this.filterGroupComp.setTitle(this.filterGroupName || "");
  }
  getColumnGroupName(e) {
    return this.columnModel.getDisplayNameForProvidedColumnGroup(null, e, "filterToolPanel");
  }
  getColumnName(e) {
    return this.columnModel.getDisplayNameForColumn(e, "filterToolPanel", !1);
  }
  destroyFilters() {
    this.childFilterComps = this.destroyBeans(this.childFilterComps), x.clearElement(this.getGui());
  }
  destroy() {
    this.destroyFilters(), super.destroy();
  }
}
Yi.TEMPLATE = `<div class="ag-filter-toolpanel-group-wrapper">
            <ag-group-component ref="filterGroupComp"></ag-group-component>
        </div>`;
Lm([
  L("filterGroupComp")
], Yi.prototype, "filterGroupComp", void 0);
Lm([
  S("columnModel")
], Yi.prototype, "columnModel", void 0);
Lm([
  su
], Yi.prototype, "preConstruct", null);
Lm([
  B
], Yi.prototype, "init", null);
var Nm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Za extends X {
  constructor() {
    super(Za.TEMPLATE), this.initialised = !1, this.filterGroupComps = [];
  }
  init(e) {
    this.initialised = !0;
    const t = {
      suppressExpandAll: !1,
      suppressFilterSearch: !1,
      suppressSyncLayoutWithGrid: !1,
      api: this.gridApi,
      columnApi: this.columnApi,
      context: this.gridOptionsService.context
    };
    x.mergeDeep(t, e), this.params = t, this.params.suppressSyncLayoutWithGrid || this.addManagedListener(this.eventService, w.EVENT_COLUMN_MOVED, () => this.onColumnsChanged()), this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, () => this.onColumnsChanged()), this.addManagedListener(this.eventService, w.EVENT_TOOL_PANEL_VISIBLE_CHANGED, (i) => {
      i.key === "filters" && this.refreshFilters(i.visible);
    }), this.columnModel.isReady() && this.onColumnsChanged();
  }
  onColumnsChanged() {
    const e = this.columnModel.isPivotMode();
    !this.params.suppressSyncLayoutWithGrid && !e ? this.syncFilterLayout() : this.buildTreeFromProvidedColumnDefs();
  }
  syncFilterLayout() {
    this.toolPanelColDefService.syncLayoutWithGrid(this.setFiltersLayout.bind(this));
  }
  buildTreeFromProvidedColumnDefs() {
    const e = this.columnModel.getPrimaryColumnTree();
    this.recreateFilters(e);
  }
  setFiltersLayout(e) {
    const t = this.toolPanelColDefService.createColumnTree(e);
    this.recreateFilters(t);
  }
  recreateFilters(e) {
    const t = this.gridOptionsService.getDocument().activeElement, i = this.getExpansionState();
    this.destroyFilters(), this.filterGroupComps = this.recursivelyAddComps(e, 0, i);
    const r = this.filterGroupComps.length;
    r && (this.filterGroupComps.forEach((n) => this.appendChild(n)), this.setFirstAndLastVisible(0, r - 1)), x.exists(this.searchFilterText) && this.searchFilters(this.searchFilterText), this.fireExpandedEvent(), this.getGui().contains(t) && t.focus();
  }
  recursivelyAddComps(e, t, i) {
    return x.flatten(e.map((r) => {
      if (r instanceof Be)
        return x.flatten(this.recursivelyAddFilterGroupComps(r, t, i));
      const n = r;
      if (!this.shouldDisplayFilter(n))
        return [];
      const s = t === 0, a = new jr(s);
      if (this.createBean(a), a.setColumn(n), i.get(n.getId()) && a.expand(), t > 0)
        return a;
      const l = this.createBean(new Yi(n, [a], this.onGroupExpanded.bind(this), t, !0));
      return l.addCssClassToTitleBar("ag-filter-toolpanel-header"), i.get(l.getFilterGroupId()) || l.collapse(), l;
    }));
  }
  recursivelyAddFilterGroupComps(e, t, i) {
    if (!this.filtersExistInChildren(e.getChildren()))
      return;
    const r = e.getColGroupDef();
    if (r && r.suppressFiltersToolPanel)
      return [];
    const n = e.isPadding() ? t : t + 1, s = x.flatten(this.recursivelyAddComps(e.getChildren(), n, i));
    if (e.isPadding())
      return s;
    const a = new Yi(e, s, this.onGroupExpanded.bind(this), t, !1);
    return this.createBean(a), a.addCssClassToTitleBar("ag-filter-toolpanel-header"), i.get(a.getFilterGroupId()) === !1 && a.collapse(), [a];
  }
  filtersExistInChildren(e) {
    return e.some((t) => t instanceof Be ? this.filtersExistInChildren(t.getChildren()) : this.shouldDisplayFilter(t));
  }
  shouldDisplayFilter(e) {
    const t = e.getColDef() && e.getColDef().suppressFiltersToolPanel;
    return e.isFilterAllowed() && !t;
  }
  getExpansionState() {
    const e = /* @__PURE__ */ new Map(), t = (i) => {
      e.set(i.getFilterGroupId(), i.isExpanded()), i.getChildren().forEach((r) => {
        r instanceof Yi ? t(r) : e.set(r.getColumn().getId(), r.isExpanded());
      });
    };
    return this.filterGroupComps.forEach(t), e;
  }
  // we don't support refreshing, but must implement because it's on the tool panel interface
  refresh() {
  }
  // lazy initialise the panel
  setVisible(e) {
    super.setDisplayed(e), e && !this.initialised && this.init(this.params);
  }
  expandFilterGroups(e, t) {
    const i = [], r = (n) => {
      const s = n.getFilterGroupId();
      (!t || x.includes(t, s)) && (e && n.isColumnGroup() ? n.expand() : n.collapse(), i.push(s)), n.getChildren().forEach((l) => {
        l instanceof Yi && r(l);
      });
    };
    if (this.filterGroupComps.forEach(r), this.onGroupExpanded(), t) {
      const n = t.filter((s) => i.indexOf(s) < 0);
      n.length > 0 && console.warn("AG Grid: unable to find groups for these supplied groupIds:", n);
    }
  }
  expandFilters(e, t) {
    const i = [], r = (n) => {
      if (n instanceof Yi) {
        let l = !1;
        return n.getChildren().forEach((c) => {
          r(c) && (e ? (n.expand(), l = !0) : n.isColumnGroup() || n.collapse());
        }), l;
      }
      const s = n.getColumn().getColId(), a = !t || x.includes(t, s);
      return a && (e ? n.expand() : n.collapse(), i.push(s)), a;
    };
    if (this.filterGroupComps.forEach(r), this.onGroupExpanded(), t) {
      const n = t.filter((s) => i.indexOf(s) < 0);
      n.length > 0 && console.warn("AG Grid: unable to find columns for these supplied colIds:", n);
    }
  }
  onGroupExpanded() {
    this.fireExpandedEvent();
  }
  fireExpandedEvent() {
    let e = 0, t = 0;
    const i = (n) => {
      n.isColumnGroup() && (n.isExpanded() ? e++ : t++, n.getChildren().forEach((s) => {
        s instanceof Yi && i(s);
      }));
    };
    this.filterGroupComps.forEach(i);
    let r;
    e > 0 && t > 0 ? r = mo.INDETERMINATE : t > 0 ? r = mo.COLLAPSED : r = mo.EXPANDED, this.dispatchEvent({ type: "groupExpanded", state: r });
  }
  performFilterSearch(e) {
    this.searchFilterText = x.exists(e) ? e.toLowerCase() : null, this.searchFilters(this.searchFilterText);
  }
  searchFilters(e) {
    const t = (s) => !x.exists(e) || s.toLowerCase().indexOf(e) !== -1, i = (s, a) => {
      if (!(s instanceof Yi))
        return t(s.getColumnFilterName() || "");
      const l = s.getChildren(), c = t(s.getFilterGroupName()), d = a || c;
      if (d) {
        s.hideGroup(!1);
        for (let h = 0; h < l.length; h++)
          i(l[h], d), s.hideGroupItem(!1, h);
        return !0;
      }
      let u = !1;
      return l.forEach((h, p) => {
        const f = i(h, a);
        s.hideGroupItem(!f, p), f && (u = !0);
      }), s.hideGroup(!u), u;
    };
    let r, n;
    this.filterGroupComps.forEach((s, a) => {
      i(s, !1), r === void 0 ? s.containsCssClass("ag-hidden") || (r = a, n = a) : !s.containsCssClass("ag-hidden") && n !== a && (n = a);
    }), this.setFirstAndLastVisible(r, n);
  }
  setFirstAndLastVisible(e, t) {
    this.filterGroupComps.forEach((i, r) => {
      i.removeCssClass("ag-first-group-visible"), i.removeCssClass("ag-last-group-visible"), r === e && i.addCssClass("ag-first-group-visible"), r === t && i.addCssClass("ag-last-group-visible");
    });
  }
  refreshFilters(e) {
    this.filterGroupComps.forEach((t) => t.refreshFilters(e));
  }
  destroyFilters() {
    this.filterGroupComps = this.destroyBeans(this.filterGroupComps), x.clearElement(this.getGui());
  }
  destroy() {
    this.destroyFilters(), super.destroy();
  }
}
Za.TEMPLATE = '<div class="ag-filter-list-panel"></div>';
Nm([
  S("gridApi")
], Za.prototype, "gridApi", void 0);
Nm([
  S("columnApi")
], Za.prototype, "columnApi", void 0);
Nm([
  S("toolPanelColDefService")
], Za.prototype, "toolPanelColDefService", void 0);
Nm([
  S("columnModel")
], Za.prototype, "columnModel", void 0);
var Gm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Qa extends X {
  constructor() {
    super(Qa.TEMPLATE), this.initialised = !1, this.listenerDestroyFuncs = [];
  }
  init(e) {
    this.initialised && (this.listenerDestroyFuncs.forEach((n) => n()), this.listenerDestroyFuncs = []), this.initialised = !0;
    const t = {
      suppressExpandAll: !1,
      suppressFilterSearch: !1,
      suppressSyncLayoutWithGrid: !1,
      api: this.gridApi,
      columnApi: this.columnApi
    };
    this.params = Object.assign(Object.assign(Object.assign({}, t), e), { context: this.gridOptionsService.context }), this.filtersToolPanelHeaderPanel.init(this.params), this.filtersToolPanelListPanel.init(this.params);
    const i = this.params.suppressExpandAll, r = this.params.suppressFilterSearch;
    i && r && this.filtersToolPanelHeaderPanel.setDisplayed(!1), this.listenerDestroyFuncs.push(this.addManagedListener(this.filtersToolPanelHeaderPanel, "expandAll", this.onExpandAll.bind(this)), this.addManagedListener(this.filtersToolPanelHeaderPanel, "collapseAll", this.onCollapseAll.bind(this)), this.addManagedListener(this.filtersToolPanelHeaderPanel, "searchChanged", this.onSearchChanged.bind(this)), this.addManagedListener(this.filtersToolPanelListPanel, "groupExpanded", this.onGroupExpanded.bind(this)));
  }
  // lazy initialise the panel
  setVisible(e) {
    super.setDisplayed(e), e && !this.initialised && this.init(this.params);
  }
  onExpandAll() {
    this.filtersToolPanelListPanel.expandFilterGroups(!0);
  }
  onCollapseAll() {
    this.filtersToolPanelListPanel.expandFilterGroups(!1);
  }
  onSearchChanged(e) {
    this.filtersToolPanelListPanel.performFilterSearch(e.searchText);
  }
  setFilterLayout(e) {
    this.filtersToolPanelListPanel.setFiltersLayout(e);
  }
  onGroupExpanded(e) {
    this.filtersToolPanelHeaderPanel.setExpandState(e.state);
  }
  expandFilterGroups(e) {
    this.filtersToolPanelListPanel.expandFilterGroups(!0, e);
  }
  collapseFilterGroups(e) {
    this.filtersToolPanelListPanel.expandFilterGroups(!1, e);
  }
  expandFilters(e) {
    this.filtersToolPanelListPanel.expandFilters(!0, e);
  }
  collapseFilters(e) {
    this.filtersToolPanelListPanel.expandFilters(!1, e);
  }
  syncLayoutWithGrid() {
    this.filtersToolPanelListPanel.syncFilterLayout();
  }
  refresh() {
    this.init(this.params);
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
}
Qa.TEMPLATE = `<div class="ag-filter-toolpanel">
            <ag-filters-tool-panel-header ref="filtersToolPanelHeaderPanel"></ag-filters-tool-panel-header>
            <ag-filters-tool-panel-list ref="filtersToolPanelListPanel"></ag-filters-tool-panel-list>
         </div>`;
Gm([
  L("filtersToolPanelHeaderPanel")
], Qa.prototype, "filtersToolPanelHeaderPanel", void 0);
Gm([
  L("filtersToolPanelListPanel")
], Qa.prototype, "filtersToolPanelListPanel", void 0);
Gm([
  S("gridApi")
], Qa.prototype, "gridApi", void 0);
Gm([
  S("columnApi")
], Qa.prototype, "columnApi", void 0);
const MV = "30.0.5", _V = {
  version: MV,
  moduleName: Q.FiltersToolPanelModule,
  beans: [],
  agStackComponents: [
    { componentName: "AgFiltersToolPanelHeader", componentClass: Ou },
    { componentName: "AgFiltersToolPanelList", componentClass: Za }
  ],
  userComponents: [
    { componentName: "agFiltersToolPanel", componentClass: Qa }
  ],
  dependantModules: [
    Ub,
    Pi
  ]
};
var IV = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Yd = (
  /** @class */
  function() {
    function o(e, t, i) {
      this._encode = e, this._decode = t, this._rangeCallback = i;
    }
    return o.prototype.floor = function(e) {
      var t = new Date(e), i = this._encode(t);
      return this._decode(i);
    }, o.prototype.ceil = function(e) {
      var t = new Date(Number(e) - 1), i = this._encode(t);
      return this._decode(i + 1);
    }, o.prototype.range = function(e, t, i) {
      var r, n = (r = this._rangeCallback) === null || r === void 0 ? void 0 : r.call(this, e, t), s = this._encode(i ? this.floor(e) : this.ceil(e)), a = this._encode(i ? this.ceil(t) : this.floor(t));
      if (a < s)
        return [];
      for (var l = [], c = s; c <= a; c++) {
        var d = this._decode(c);
        l.push(d);
      }
      return n == null || n(), l;
    }, o;
  }()
), Ur = (
  /** @class */
  function(o) {
    IV(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.getOffset = function(t, i) {
      var r = typeof t == "number" || t instanceof Date ? this._encode(new Date(t)) : 0;
      return Math.floor(r) % i;
    }, e.prototype.every = function(t, i) {
      var r = this, n = 0, s, a = (i != null ? i : {}).snapTo, l = a === void 0 ? "start" : a;
      if (typeof l == "string") {
        var c = n;
        s = function(p, f) {
          var g = l === "start" ? p : f;
          return n = r.getOffset(g, t), function() {
            return n = c;
          };
        };
      } else
        typeof l == "number" ? n = this.getOffset(new Date(l), t) : l instanceof Date && (n = this.getOffset(l, t));
      var d = function(p) {
        var f = r._encode(p);
        return Math.floor((f - n) / t);
      }, u = function(p) {
        return r._decode(p * t + n);
      }, h = new Yd(d, u, s);
      return h;
    }, e;
  }(Yd)
);
function FV(o) {
  return o.getTime();
}
function LV(o) {
  return new Date(o);
}
var NV = new Ur(FV, LV);
(/* @__PURE__ */ new Date(0)).getFullYear();
var El = 1e3, Er = El * 60, yo = Er * 60, ua = yo * 24, vh = ua * 7, th = ua * 30, zf = ua * 365, tD = (/* @__PURE__ */ new Date()).getTimezoneOffset() * Er;
function GV(o) {
  return Math.floor((o.getTime() - tD) / El);
}
function kV(o) {
  return new Date(tD + o * El);
}
var VV = new Ur(GV, kV), iD = (/* @__PURE__ */ new Date()).getTimezoneOffset() * Er;
function BV(o) {
  return Math.floor((o.getTime() - iD) / Er);
}
function HV(o) {
  return new Date(iD + o * Er);
}
var WV = new Ur(BV, HV), rD = (/* @__PURE__ */ new Date()).getTimezoneOffset() * Er;
function jV(o) {
  return Math.floor((o.getTime() - rD) / yo);
}
function UV(o) {
  return new Date(rD + o * yo);
}
var $V = new Ur(jV, UV);
function zV(o) {
  var e = o.getTimezoneOffset() * 6e4;
  return Math.floor((o.getTime() - e) / ua);
}
function KV(o) {
  var e = new Date(1970, 0, 1);
  return e.setDate(e.getDate() + o), e;
}
var YV = new Ur(zV, KV);
function pc(o) {
  var e = new Date(2023, 0, 1 + o).getTime();
  function t(r) {
    var n = r.getTime();
    return Math.floor((n - e) / vh);
  }
  function i(r) {
    var n = new Date(e);
    return n.setDate(n.getDate() + r * 7), n;
  }
  return new Ur(t, i);
}
var XV = pc(0);
pc(1);
pc(2);
pc(3);
pc(4);
pc(5);
pc(6);
function qV(o) {
  return o.getFullYear() * 12 + o.getMonth();
}
function ZV(o) {
  var e = Math.floor(o / 12), t = o - e * 12;
  return new Date(e, t, 1);
}
var QV = new Ur(qV, ZV);
function JV(o) {
  return o.getFullYear();
}
function e1(o) {
  var e = /* @__PURE__ */ new Date();
  return e.setFullYear(o), e.setMonth(0, 1), e.setHours(0, 0, 0, 0), e;
}
var t1 = new Ur(JV, e1);
function i1(o) {
  return Math.floor(o.getTime() / Er);
}
function r1(o) {
  return new Date(o * Er);
}
new Ur(i1, r1);
function n1(o) {
  return Math.floor(o.getTime() / yo);
}
function o1(o) {
  return new Date(o * yo);
}
new Ur(n1, o1);
function s1(o) {
  return Math.floor(o.getTime() / ua);
}
function a1(o) {
  var e = /* @__PURE__ */ new Date(0);
  return e.setUTCDate(e.getUTCDate() + o), e.setUTCHours(0, 0, 0, 0), e;
}
new Ur(s1, a1);
function l1(o) {
  return o.getUTCFullYear() * 12 + o.getUTCMonth();
}
function c1(o) {
  var e = Math.floor(o / 12), t = o - e * 12;
  return new Date(Date.UTC(e, t, 1));
}
new Ur(l1, c1);
function d1(o) {
  return o.getUTCFullYear();
}
function u1(o) {
  var e = /* @__PURE__ */ new Date();
  return e.setUTCFullYear(o), e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0), e;
}
new Ur(d1, u1);
var h1 = [/Android/i, /webOS/i, /iPhone/i, /iPad/i, /iPod/i, /BlackBerry/i, /Windows Phone/i];
function nD() {
  var o = navigator.userAgent;
  return !h1.some(function(e) {
    return e.test(o);
  });
}
var It = (
  /** @class */
  function() {
    function o(e) {
      var t = e.document, i = t === void 0 ? window.document : t, r = e.width, n = r === void 0 ? 600 : r, s = e.height, a = s === void 0 ? 300 : s, l = e.domLayer, c = l === void 0 ? !1 : l, d = e.zIndex, u = d === void 0 ? 0 : d, h = e.name, p = h === void 0 ? void 0 : h, f = e.overrideDevicePixelRatio, g = f === void 0 ? void 0 : f;
      this._container = void 0, this._enabled = !0, this._pixelRatio = NaN, this._width = 0, this._height = 0, this.document = i, this.element = i.createElement("canvas"), this.element.width = n, this.element.height = a, this.context = this.element.getContext("2d"), this.imageSource = this.context.canvas;
      var v = this.element.style;
      v.userSelect = "none", v.display = "block", c && (v.position = "absolute", v.zIndex = String(u), v.top = "0", v.left = "0", v.pointerEvents = "none", v.opacity = "1", p && (this.element.id = p)), this.setPixelRatio(g), this.resize(n, a);
    }
    return Object.defineProperty(o.prototype, "container", {
      get: function() {
        return this._container;
      },
      set: function(e) {
        this._container !== e && (this.remove(), e && e.appendChild(this.element), this._container = e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "enabled", {
      get: function() {
        return this._enabled;
      },
      set: function(e) {
        this.element.style.display = e ? "block" : "none", this._enabled = !!e;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.remove = function() {
      var e = this.element.parentNode;
      e != null && e.removeChild(this.element);
    }, o.prototype.destroy = function() {
      this.element.remove(), this.element.width = 0, this.element.height = 0, this.context.clearRect(0, 0, 0, 0), Object.freeze(this);
    }, o.prototype.snapshot = function() {
    }, o.prototype.clear = function() {
      this.context.save(), this.context.resetTransform(), this.context.clearRect(0, 0, this.width, this.height), this.context.restore();
    }, o.prototype.toImage = function() {
      var e = this.document.createElement("img");
      return e.src = this.getDataURL(), e;
    }, o.prototype.getDataURL = function(e) {
      return this.element.toDataURL(e);
    }, o.prototype.download = function(e, t) {
      t === void 0 && (t = "image/png"), e = (e != null ? e : "").trim() || "image";
      var i = this.getDataURL(t), r = this.document, n = r.createElement("a");
      n.href = i, n.download = e, n.style.display = "none", r.body.appendChild(n), n.click(), r.body.removeChild(n);
    }, Object.defineProperty(o.prototype, "pixelRatio", {
      get: function() {
        return this._pixelRatio;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.setPixelRatio = function(e) {
      var t = e != null ? e : window.devicePixelRatio;
      nD() || (t = 1), o.overrideScale(this.context, t), this._pixelRatio = t;
    }, Object.defineProperty(o.prototype, "pixelated", {
      get: function() {
        return this.element.style.imageRendering === "pixelated";
      },
      set: function(e) {
        this.element.style.imageRendering = e ? "pixelated" : "auto";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "width", {
      get: function() {
        return this._width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "height", {
      get: function() {
        return this._height;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.resize = function(e, t) {
      if (e > 0 && t > 0) {
        var i = this, r = i.element, n = i.context, s = i.pixelRatio;
        r.width = Math.round(e * s), r.height = Math.round(t * s), r.style.width = e + "px", r.style.height = t + "px", n.resetTransform(), this._width = e, this._height = t;
      }
    }, Object.defineProperty(o, "textMeasuringContext", {
      get: function() {
        if (this._textMeasuringContext)
          return this._textMeasuringContext;
        var e = document.createElement("canvas");
        return this._textMeasuringContext = e.getContext("2d"), this._textMeasuringContext;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o, "svgText", {
      get: function() {
        if (this._svgText)
          return this._svgText;
        var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "svg");
        t.setAttribute("width", "100"), t.setAttribute("height", "100"), t.classList ? t.classList.add("text-measuring-svg") : t.setAttribute("class", "text-measuring-svg"), t.style.position = "absolute", t.style.top = "-1000px", t.style.visibility = "hidden";
        var i = document.createElementNS(e, "text");
        return i.setAttribute("x", "0"), i.setAttribute("y", "30"), i.setAttribute("text", "black"), t.appendChild(i), document.body.appendChild(t), this._svgText = i, i;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o, "has", {
      get: function() {
        if (this._has)
          return this._has;
        var e = navigator.userAgent.indexOf("Chrome") > -1, t = navigator.userAgent.indexOf("Firefox") > -1, i = !e && navigator.userAgent.indexOf("Safari") > -1;
        return this._has = Object.freeze({
          textMetrics: this.textMeasuringContext.measureText("test").actualBoundingBoxDescent !== void 0 && // Firefox implemented advanced TextMetrics object in v74:
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1102584
          // but it's buggy, so we'll keep using the SVG for text measurement in Firefox for now.
          !t && !i,
          getTransform: this.textMeasuringContext.getTransform !== void 0
        }), this._has;
      },
      enumerable: !1,
      configurable: !0
    }), o.measureText = function(e, t, i, r) {
      var n = this.textMeasuringContext;
      return n.font = t, n.textBaseline = i, n.textAlign = r, n.measureText(e);
    }, o.getTextSize = function(e, t) {
      if (this.has.textMetrics) {
        var i = this.textMeasuringContext;
        i.font = t;
        var r = i.measureText(e);
        return {
          width: r.width,
          height: r.actualBoundingBoxAscent + r.actualBoundingBoxDescent
        };
      } else
        return this.measureSvgText(e, t);
    }, o.measureSvgText = function(e, t) {
      var i = this.textSizeCache, r = i[t];
      if (r) {
        var n = r[e];
        if (n)
          return n;
      } else
        i[t] = {};
      var s = this.svgText;
      s.style.font = t, s.textContent = e;
      var a = s.getBBox(), l = {
        width: a.width,
        height: a.height
      };
      return i[t][e] = l, l;
    }, o.overrideScale = function(e, t) {
      var i = 0, r = {
        save: function() {
          this.$save(), i++;
        },
        restore: function() {
          if (i > 0)
            this.$restore(), i--;
          else
            throw new Error("AG Charts - Unable to restore() past depth 0");
        },
        setTransform: function(s, a, l, c, d, u) {
          typeof s == "object" ? this.$setTransform(s) : this.$setTransform(s * t, a * t, l * t, c * t, d * t, u * t);
        },
        resetTransform: function() {
          this.$setTransform(t, 0, 0, t, 0, 0);
        },
        verifyDepthZero: function() {
          if (i !== 0)
            throw new Error("AG Charts - Save/restore depth is non-zero: " + i);
        }
      };
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e["$" + n] || (e["$" + n] = e[n]), e[n] = r[n]);
    }, o.textSizeCache = {}, o;
  }()
), jC = function() {
  return jC = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, jC.apply(this, arguments);
}, p1 = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, nt = (
  /** @class */
  function() {
    function o(e, t, i, r) {
      this.x = e, this.y = t, this.width = i, this.height = r;
    }
    return o.prototype.clone = function() {
      var e = this, t = e.x, i = e.y, r = e.width, n = e.height;
      return new o(t, i, r, n);
    }, o.prototype.equals = function(e) {
      return this.x === e.x && this.y === e.y && this.width === e.width && this.height === e.height;
    }, o.prototype.containsPoint = function(e, t) {
      return e >= this.x && e <= this.x + this.width && t >= this.y && t <= this.y + this.height;
    }, o.prototype.collidesBBox = function(e) {
      return this.x < e.x + e.width && this.x + this.width > e.x && this.y < e.y + e.height && this.y + this.height > e.y;
    }, o.prototype.isInfinite = function() {
      return Math.abs(this.x) === 1 / 0 || Math.abs(this.y) === 1 / 0 || Math.abs(this.width) === 1 / 0 || Math.abs(this.height) === 1 / 0;
    }, o.prototype.shrink = function(e, t) {
      var i = this, r = function(n, s) {
        switch (n) {
          case "top":
            i.y += s;
          case "bottom":
            i.height -= s;
            break;
          case "left":
            i.x += s;
          case "right":
            i.width -= s;
            break;
          case "vertical":
            i.y += s, i.height -= s * 2;
            break;
          case "horizontal":
            i.x += s, i.width -= s * 2;
            break;
          default:
            i.x += s, i.width -= s * 2, i.y += s, i.height -= s * 2;
        }
      };
      return typeof e == "number" ? r(t, e) : Object.entries(e).forEach(function(n) {
        var s = p1(n, 2), a = s[0], l = s[1];
        return r(a, l);
      }), this;
    }, o.prototype.grow = function(e, t) {
      if (typeof e == "number")
        this.shrink(-e, t);
      else {
        var i = jC({}, e);
        for (var r in i)
          i[r] *= -1;
        this.shrink(i);
      }
      return this;
    }, o.merge = function(e) {
      var t = 1 / 0, i = 1 / 0, r = -1 / 0, n = -1 / 0;
      return e.forEach(function(s) {
        s.x < t && (t = s.x), s.y < i && (i = s.y), s.x + s.width > r && (r = s.x + s.width), s.y + s.height > n && (n = s.y + s.height);
      }), new o(t, i, r - t, n - i);
    }, o;
  }()
), p0 = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, f1 = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, Cl = (
  /** @class */
  function() {
    function o(e) {
      e === void 0 && (e = [1, 0, 0, 1, 0, 0]), this.elements = e;
    }
    return Object.defineProperty(o.prototype, "e", {
      get: function() {
        return f1([], p0(this.elements));
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.setElements = function(e) {
      var t = this.elements;
      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], this;
    }, Object.defineProperty(o.prototype, "identity", {
      get: function() {
        var e = this.elements;
        return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 1 && e[4] === 0 && e[5] === 0;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.AxB = function(e, t, i) {
      var r = e[0] * t[0] + e[2] * t[1], n = e[1] * t[0] + e[3] * t[1], s = e[0] * t[2] + e[2] * t[3], a = e[1] * t[2] + e[3] * t[3], l = e[0] * t[4] + e[2] * t[5] + e[4], c = e[1] * t[4] + e[3] * t[5] + e[5];
      i = i != null ? i : e, i[0] = r, i[1] = n, i[2] = s, i[3] = a, i[4] = l, i[5] = c;
    }, o.prototype.multiplySelf = function(e) {
      return this.AxB(this.elements, e.elements), this;
    }, o.prototype.multiply = function(e) {
      var t = new Array(6);
      return this.AxB(this.elements, e.elements, t), new o(t);
    }, o.prototype.preMultiplySelf = function(e) {
      return this.AxB(e.elements, this.elements, this.elements), this;
    }, o.prototype.inverse = function() {
      var e = this.elements, t = e[0], i = e[1], r = e[2], n = e[3], s = e[4], a = e[5], l = 1 / (t * n - i * r);
      return t *= l, i *= l, r *= l, n *= l, new o([n, -i, -r, t, r * a - n * s, i * s - t * a]);
    }, o.prototype.inverseTo = function(e) {
      var t = this.elements, i = t[0], r = t[1], n = t[2], s = t[3], a = t[4], l = t[5], c = 1 / (i * s - r * n);
      return i *= c, r *= c, n *= c, s *= c, e.setElements([s, -r, -n, i, n * l - s * a, r * a - i * l]), this;
    }, o.prototype.invertSelf = function() {
      var e = this.elements, t = e[0], i = e[1], r = e[2], n = e[3], s = e[4], a = e[5], l = 1 / (t * n - i * r);
      return t *= l, i *= l, r *= l, n *= l, e[0] = n, e[1] = -i, e[2] = -r, e[3] = t, e[4] = r * a - n * s, e[5] = i * s - t * a, this;
    }, o.prototype.transformPoint = function(e, t) {
      var i = this.elements;
      return {
        x: e * i[0] + t * i[2] + i[4],
        y: e * i[1] + t * i[3] + i[5]
      };
    }, o.prototype.transformBBox = function(e, t) {
      var i = this.elements, r = i[0], n = i[1], s = i[2], a = i[3], l = e.width * 0.5, c = e.height * 0.5, d = e.x + l, u = e.y + c, h = Math.abs(l * r) + Math.abs(c * s), p = Math.abs(l * n) + Math.abs(c * a);
      return t || (t = new nt(0, 0, 0, 0)), t.x = d * r + u * s + i[4] - h, t.y = d * n + u * a + i[5] - p, t.width = h + h, t.height = p + p, t;
    }, o.prototype.toContext = function(e) {
      if (!this.identity) {
        var t = this.elements;
        e.transform(t[0], t[1], t[2], t[3], t[4], t[5]);
      }
    }, o.flyweight = function(e) {
      return o.instance.setElements(e.elements);
    }, o.updateTransformMatrix = function(e, t, i, r, n, s, a) {
      var l = p0([0, 0], 2), c = l[0], d = l[1], u = t, h = i, p, f;
      u === 1 && h === 1 ? (p = 0, f = 0) : (p = (a == null ? void 0 : a.scalingCenterX) == null ? c : a == null ? void 0 : a.scalingCenterX, f = (a == null ? void 0 : a.scalingCenterY) == null ? d : a == null ? void 0 : a.scalingCenterY);
      var g = r, v = Math.cos(g), y = Math.sin(g), m, C;
      g === 0 ? (m = 0, C = 0) : (m = (a == null ? void 0 : a.rotationCenterX) == null ? c : a == null ? void 0 : a.rotationCenterX, C = (a == null ? void 0 : a.rotationCenterY) == null ? d : a == null ? void 0 : a.rotationCenterY);
      var R = n, E = s, b = p * (1 - u) - m, T = f * (1 - h) - C;
      return e.setElements([
        v * u,
        y * u,
        -y * h,
        v * h,
        v * b - y * T + m + R,
        y * b + v * T + C + E
      ]), e;
    }, o.fromContext = function(e) {
      var t = e.getTransform();
      return new o([t.a, t.b, t.c, t.d, t.e, t.f]);
    }, o.instance = new o(), o;
  }()
), Xg = {};
function g1() {
  for (var o in Xg)
    delete Xg[o];
}
function Vs(o) {
  var e, t = o.constructor, i = Object.prototype.hasOwnProperty.call(t, "className") ? t.className : t.name;
  if (!i)
    throw new Error("The " + t + " is missing the 'className' property.");
  var r = ((e = Xg[i]) !== null && e !== void 0 ? e : 0) + 1;
  return Xg[i] = r, i + "-" + r;
}
var oe;
(function(o) {
  o[o.NONE = 0] = "NONE", o[o.TRIVIAL = 1] = "TRIVIAL", o[o.MINOR = 2] = "MINOR", o[o.MAJOR = 3] = "MAJOR";
})(oe || (oe = {}));
function v1() {
  try {
    return new Function("return true"), !0;
  } catch (o) {
    return !1;
  }
}
var m1 = v1();
function ve(o) {
  var e = o != null ? o : {}, t = e.changeCb, i = e.convertor;
  return function(r, n) {
    var s = "__" + n;
    r[n] || (m1 && t == null && i == null ? y1(r, n, s, o) : C1(r, n, s, o));
  };
}
function y1(o, e, t, i) {
  var r = i != null ? i : {}, n = r.redraw, s = n === void 0 ? oe.TRIVIAL : n, a = r.type, l = a === void 0 ? "normal" : a, c = r.checkDirtyOnAssignment, d = c === void 0 ? !1 : c, u = new Function("value", `
        const oldValue = this.` + t + `;
        if (value !== oldValue) {
            this.` + t + ` = value;
            ` + (l === "normal" ? "this.markDirty(this, " + s + ");" : "") + `
            ` + (l === "transform" ? "this.markDirtyTransform(" + s + ");" : "") + `
            ` + (l === "path" ? "if (!this._dirtyPath) { this._dirtyPath = true; this.markDirty(this, " + s + "); }" : "") + `
            ` + (l === "font" ? "if (!this._dirtyFont) { this._dirtyFont = true; this.markDirty(this, " + s + "); }" : "") + `
        }
        ` + (d ? "if (value != null && value._dirty > " + oe.NONE + ") { this.markDirty(value, value._dirty); }" : "") + `
`), h = new Function("return this." + t + ";");
  Object.defineProperty(o, e, {
    set: u,
    get: h,
    enumerable: !0,
    configurable: !0
  });
}
function C1(o, e, t, i) {
  var r = i != null ? i : {}, n = r.redraw, s = n === void 0 ? oe.TRIVIAL : n, a = r.type, l = a === void 0 ? "normal" : a, c = r.changeCb, d = r.convertor, u = r.checkDirtyOnAssignment, h = u === void 0 ? !1 : u, p = function(g) {
    var v = this[t];
    g = d ? d(g) : g, g !== v && (this[t] = g, l === "normal" && this.markDirty(this, s), l === "transform" && this.markDirtyTransform(s), l === "path" && !this._dirtyPath && (this._dirtyPath = !0, this.markDirty(this, s)), l === "font" && !this._dirtyFont && (this._dirtyFont = !0, this.markDirty(this, s)), c && c(this)), h && g != null && g._dirty > oe.NONE && this.markDirty(g, g._dirty);
  }, f = function() {
    return this[t];
  };
  Object.defineProperty(o, e, {
    set: p,
    get: f,
    enumerable: !0,
    configurable: !0
  });
}
var $b = (
  /** @class */
  function() {
    function o() {
      this._dirty = oe.MAJOR;
    }
    return o.prototype.markDirty = function(e, t) {
      t === void 0 && (t = oe.TRIVIAL), !(this._dirty > t) && (this._dirty = t);
    }, o.prototype.markClean = function(e) {
      this._dirty = oe.NONE;
    }, o.prototype.isDirty = function() {
      return this._dirty > oe.NONE;
    }, o;
  }()
), S1 = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), qr = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, ts = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Ny = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, Gy = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, ki;
(function(o) {
  o[o.All = 0] = "All", o[o.None = 1] = "None";
})(ki || (ki = {}));
var f0 = function(o) {
  o.parent && (o.parent.dirtyZIndex = !0), o.zIndexChanged();
}, km = (
  /** @class */
  function(o) {
    S1(e, o);
    function e(t) {
      var i = t === void 0 ? {} : t, r = i.isVirtual, n = o.call(this) || this;
      return n.serialNumber = e._nextSerialNumber++, n.id = Vs(n), n.tag = NaN, n.isContainerNode = !1, n._virtualChildren = [], n._children = [], n.childSet = {}, n.matrix = new Cl(), n.inverseMatrix = new Cl(), n.dirtyTransform = !1, n.scalingX = 1, n.scalingY = 1, n.scalingCenterX = null, n.scalingCenterY = null, n.rotationCenterX = null, n.rotationCenterY = null, n.rotation = 0, n.translationX = 0, n.translationY = 0, n.visible = !0, n.dirtyZIndex = !1, n.zIndex = 0, n.zIndexSubOrder = void 0, n.pointerEvents = ki.All, n.isVirtual = r != null ? r : !1, n;
    }
    return Object.defineProperty(e.prototype, "datum", {
      /**
       * Some arbitrary data bound to the node.
       */
      get: function() {
        var t;
        return this._datum !== void 0 ? this._datum : (t = this._parent) === null || t === void 0 ? void 0 : t.datum;
      },
      set: function(t) {
        this._datum = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype._setLayerManager = function(t) {
      var i, r, n, s;
      this._layerManager = t, this._debug = t == null ? void 0 : t.debug;
      try {
        for (var a = ts(this._children), l = a.next(); !l.done; l = a.next()) {
          var c = l.value;
          c._setLayerManager(t);
        }
      } catch (h) {
        i = { error: h };
      } finally {
        try {
          l && !l.done && (r = a.return) && r.call(a);
        } finally {
          if (i)
            throw i.error;
        }
      }
      try {
        for (var d = ts(this._virtualChildren), u = d.next(); !u.done; u = d.next()) {
          var c = u.value;
          c._setLayerManager(t);
        }
      } catch (h) {
        n = { error: h };
      } finally {
        try {
          u && !u.done && (s = d.return) && s.call(d);
        } finally {
          if (n)
            throw n.error;
        }
      }
    }, Object.defineProperty(e.prototype, "layerManager", {
      get: function() {
        return this._layerManager;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "parent", {
      get: function() {
        return this._parent;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "children", {
      get: function() {
        var t, i;
        if (this._virtualChildren.length === 0)
          return this._children;
        var r = Gy([], Ny(this._children));
        try {
          for (var n = ts(this._virtualChildren), s = n.next(); !s.done; s = n.next()) {
            var a = s.value;
            r.push.apply(r, Gy([], Ny(a.children)));
          }
        } catch (l) {
          t = { error: l };
        } finally {
          try {
            s && !s.done && (i = n.return) && i.call(n);
          } finally {
            if (t)
              throw t.error;
          }
        }
        return r;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "virtualChildren", {
      get: function() {
        return this._virtualChildren;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.hasVirtualChildren = function() {
      return this._virtualChildren.length > 0;
    }, e.prototype.append = function(t) {
      var i, r;
      Array.isArray(t) || (t = [t]);
      try {
        for (var n = ts(t), s = n.next(); !s.done; s = n.next()) {
          var a = s.value;
          if (a.parent)
            throw new Error(a + " already belongs to another parent: " + a.parent + ".");
          if (a.layerManager)
            throw new Error(a + " already belongs to a scene: " + a.layerManager + ".");
          if (this.childSet[a.id])
            throw new Error("Duplicate " + a.constructor.name + " node: " + a);
          a.isVirtual ? this._virtualChildren.push(a) : this._children.push(a), this.childSet[a.id] = !0, a._parent = this, a._setLayerManager(this.layerManager);
        }
      } catch (l) {
        i = { error: l };
      } finally {
        try {
          s && !s.done && (r = n.return) && r.call(n);
        } finally {
          if (i)
            throw i.error;
        }
      }
      this.dirtyZIndex = !0, this.markDirty(this, oe.MAJOR);
    }, e.prototype.appendChild = function(t) {
      return this.append(t), t;
    }, e.prototype.removeChild = function(t) {
      var i = function() {
        throw new Error("The node to be removed is not a child of this node.");
      };
      if (t.parent !== this && i(), t.isVirtual) {
        var r = this._virtualChildren.indexOf(t);
        r < 0 && i(), this._virtualChildren.splice(r, 1);
      } else {
        var r = this._children.indexOf(t);
        r < 0 && i(), this._children.splice(r, 1);
      }
      return delete this.childSet[t.id], t._parent = void 0, t._setLayerManager(), this.dirtyZIndex = !0, this.markDirty(t, oe.MAJOR), t;
    }, e.prototype.calculateCumulativeMatrix = function() {
      this.computeTransformMatrix();
      for (var t = Cl.flyweight(this.matrix), i = this.parent; i; )
        i.computeTransformMatrix(), t.preMultiplySelf(i.matrix), i = i.parent;
      return t;
    }, e.prototype.transformPoint = function(t, i) {
      var r = this.calculateCumulativeMatrix();
      return r.invertSelf().transformPoint(t, i);
    }, e.prototype.inverseTransformPoint = function(t, i) {
      var r = this.calculateCumulativeMatrix();
      return r.transformPoint(t, i);
    }, e.prototype.transformBBox = function(t) {
      var i = this.calculateCumulativeMatrix();
      return i.invertSelf().transformBBox(t);
    }, e.prototype.inverseTransformBBox = function(t) {
      var i = this.calculateCumulativeMatrix();
      return i.transformBBox(t);
    }, e.prototype.markDirtyTransform = function() {
      this.dirtyTransform = !0, this.markDirty(this, oe.MAJOR);
    }, e.prototype.containsPoint = function(t, i) {
      return !1;
    }, e.prototype.pickNode = function(t, i) {
      var r;
      if (!(!this.visible || this.pointerEvents === ki.None || !this.containsPoint(t, i))) {
        var n = this.children;
        if (n.length > 1e3)
          for (var s = n.length - 1; s >= 0; s--) {
            var a = n[s], l = (r = a.computeTransformedBBox()) === null || r === void 0 ? void 0 : r.containsPoint(t, i), c = l ? a.pickNode(t, i) : void 0;
            if (c)
              return c;
          }
        else if (n.length)
          for (var s = n.length - 1; s >= 0; s--) {
            var c = n[s].pickNode(t, i);
            if (c)
              return c;
          }
        else if (!this.isContainerNode)
          return this;
      }
    }, e.prototype.findNodes = function(t) {
      var i, r, n = t(this) ? [this] : [];
      try {
        for (var s = ts(this.children), a = s.next(); !a.done; a = s.next()) {
          var l = a.value, c = l.findNodes(t);
          c && n.push.apply(n, Gy([], Ny(c)));
        }
      } catch (d) {
        i = { error: d };
      } finally {
        try {
          a && !a.done && (r = s.return) && r.call(s);
        } finally {
          if (i)
            throw i.error;
        }
      }
      return n;
    }, e.prototype.computeBBox = function() {
    }, e.prototype.computeTransformedBBox = function() {
      var t = this.computeBBox();
      if (t) {
        this.computeTransformMatrix();
        for (var i = Cl.flyweight(this.matrix), r = this.parent; r; )
          r.computeTransformMatrix(), i.preMultiplySelf(r.matrix), r = r.parent;
        return i.transformBBox(t, t), t;
      }
    }, e.prototype.computeTransformMatrix = function() {
      if (this.dirtyTransform) {
        var t = this, i = t.matrix, r = t.scalingX, n = t.scalingY, s = t.rotation, a = t.translationX, l = t.translationY, c = t.scalingCenterX, d = t.scalingCenterY, u = t.rotationCenterX, h = t.rotationCenterY;
        Cl.updateTransformMatrix(i, r, n, s, a, l, {
          scalingCenterX: c,
          scalingCenterY: d,
          rotationCenterX: u,
          rotationCenterY: h
        }), i.inverseTo(this.inverseMatrix), this.dirtyTransform = !1;
      }
    }, e.prototype.render = function(t) {
      var i = t.stats;
      this._dirty = oe.NONE, i && i.nodesRendered++;
    }, e.prototype.clearBBox = function(t) {
      var i = this.computeBBox();
      if (i != null) {
        var r = i.x, n = i.y, s = i.width, a = i.height, l = this.transformPoint(r, n), c = this.transformPoint(r + s, n + a);
        t.clearRect(l.x, l.y, c.x - l.x, c.y - l.y);
      }
    }, e.prototype.markDirty = function(t, i, r) {
      i === void 0 && (i = oe.TRIVIAL), r === void 0 && (r = i), !(this._dirty > i) && (this._dirty === i && i === r || (this._dirty = i, this.parent ? this.parent.markDirty(this, r) : this.layerManager && this.layerManager.markDirty()));
    }, Object.defineProperty(e.prototype, "dirty", {
      get: function() {
        return this._dirty;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.markClean = function(t) {
      var i, r, n, s, a = t != null ? t : {}, l = a.force, c = l === void 0 ? !1 : l, d = a.recursive, u = d === void 0 ? !0 : d;
      if (!(this._dirty === oe.NONE && !c)) {
        if (this._dirty = oe.NONE, u !== !1)
          try {
            for (var h = ts(this._virtualChildren), p = h.next(); !p.done; p = h.next()) {
              var f = p.value;
              f.markClean({ force: c });
            }
          } catch (y) {
            i = { error: y };
          } finally {
            try {
              p && !p.done && (r = h.return) && r.call(h);
            } finally {
              if (i)
                throw i.error;
            }
          }
        if (u === !0)
          try {
            for (var g = ts(this._children), v = g.next(); !v.done; v = g.next()) {
              var f = v.value;
              f.markClean({ force: c });
            }
          } catch (y) {
            n = { error: y };
          } finally {
            try {
              v && !v.done && (s = g.return) && s.call(g);
            } finally {
              if (n)
                throw n.error;
            }
          }
      }
    }, e.prototype.visibilityChanged = function() {
    }, Object.defineProperty(e.prototype, "nodeCount", {
      get: function() {
        var t, i, r, n, s = 1, a = this._dirty >= oe.NONE || this.dirtyTransform ? 1 : 0, l = this.visible ? 1 : 0, c = function(g) {
          var v = g.nodeCount, y = v.count, m = v.visibleCount, C = v.dirtyCount;
          s += y, l += m, a += C;
        };
        try {
          for (var d = ts(this._children), u = d.next(); !u.done; u = d.next()) {
            var h = u.value;
            c(h);
          }
        } catch (g) {
          t = { error: g };
        } finally {
          try {
            u && !u.done && (i = d.return) && i.call(d);
          } finally {
            if (t)
              throw t.error;
          }
        }
        try {
          for (var p = ts(this._virtualChildren), f = p.next(); !f.done; f = p.next()) {
            var h = f.value;
            c(h);
          }
        } catch (g) {
          r = { error: g };
        } finally {
          try {
            f && !f.done && (n = p.return) && n.call(p);
          } finally {
            if (r)
              throw r.error;
          }
        }
        return { count: s, visibleCount: l, dirtyCount: a };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.zIndexChanged = function() {
    }, e._nextSerialNumber = 0, qr([
      ve({ type: "transform" })
    ], e.prototype, "scalingX", void 0), qr([
      ve({ type: "transform" })
    ], e.prototype, "scalingY", void 0), qr([
      ve({ type: "transform" })
    ], e.prototype, "scalingCenterX", void 0), qr([
      ve({ type: "transform" })
    ], e.prototype, "scalingCenterY", void 0), qr([
      ve({ type: "transform" })
    ], e.prototype, "rotationCenterX", void 0), qr([
      ve({ type: "transform" })
    ], e.prototype, "rotationCenterY", void 0), qr([
      ve({ type: "transform" })
    ], e.prototype, "rotation", void 0), qr([
      ve({ type: "transform" })
    ], e.prototype, "translationX", void 0), qr([
      ve({ type: "transform" })
    ], e.prototype, "translationY", void 0), qr([
      ve({ redraw: oe.MAJOR, changeCb: function(t) {
        return t.visibilityChanged();
      } })
    ], e.prototype, "visible", void 0), qr([
      ve({
        redraw: oe.TRIVIAL,
        changeCb: f0
      })
    ], e.prototype, "zIndex", void 0), qr([
      ve({
        redraw: oe.TRIVIAL,
        changeCb: f0
      })
    ], e.prototype, "zIndexSubOrder", void 0), e;
  }($b)
);
function oD(o, e) {
  var t = 0;
  return typeof o == "number" && typeof e == "number" ? t = o - e : typeof o == "string" && typeof e == "string" ? t = o.localeCompare(e) : o == null && e == null || (o == null ? t = -1 : e == null ? t = 1 : t = String(o).localeCompare(String(e))), t;
}
function sD(o, e, t) {
  var i = function(s) {
    return typeof s == "function" ? s() : s;
  };
  for (var r in o) {
    var n = t(i(o[r]), i(e[r]));
    if (n !== 0)
      return n;
  }
  return 0;
}
var g0 = {};
function v0(o, e) {
  g0[e] || (o(), g0[e] = !0);
}
var Nc = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, Gc = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, pe = {
  debug: function() {
    for (var o = [], e = 0; e < arguments.length; e++)
      o[e] = arguments[e];
    console.log.apply(console, Gc([], Nc(o)));
  },
  warn: function(o) {
    for (var e = [], t = 1; t < arguments.length; t++)
      e[t - 1] = arguments[t];
    console.warn.apply(console, Gc(["AG Charts - " + o], Nc(e)));
  },
  error: function(o) {
    for (var e = [], t = 1; t < arguments.length; t++)
      e[t - 1] = arguments[t];
    typeof o == "object" ? console.error.apply(console, Gc(["AG Charts error", o], Nc(e))) : console.error.apply(console, Gc(["AG Charts - " + o], Nc(e)));
  },
  warnOnce: function(o) {
    for (var e = [], t = 1; t < arguments.length; t++)
      e[t - 1] = arguments[t];
    v0(function() {
      return pe.warn.apply(pe, Gc([o], Nc(e)));
    }, "Logger.warn: " + o);
  },
  errorOnce: function(o) {
    for (var e = [], t = 1; t < arguments.length; t++)
      e[t - 1] = arguments[t];
    v0(function() {
      return pe.error.apply(pe, Gc([o], Nc(e)));
    }, "Logger.warn: " + o);
  }
}, b1 = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), qg = function() {
  return qg = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, qg.apply(this, arguments);
}, w1 = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, ky = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, m0 = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, Kf = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, we = (
  /** @class */
  function(o) {
    b1(e, o);
    function e(t) {
      var i, r = o.call(this, { isVirtual: t == null ? void 0 : t.isVirtual }) || this;
      r.opts = t, r.opacity = 1, r.lastBBox = void 0;
      var n = t != null ? t : {}, s = n.zIndex, a = n.zIndexSubOrder;
      return r.isContainerNode = !0, s !== void 0 && (r.zIndex = s), a !== void 0 && (r.zIndexSubOrder = a), r.name = (i = r.opts) === null || i === void 0 ? void 0 : i.name, r;
    }
    return e.prototype.zIndexChanged = function() {
      var t;
      this.layer && ((t = this._layerManager) === null || t === void 0 || t.moveLayer(this.layer, this.zIndex, this.zIndexSubOrder));
    }, e.prototype.isLayer = function() {
      return this.layer != null;
    }, e.prototype._setLayerManager = function(t) {
      var i = this, r, n;
      if (this._layerManager && this.layer && (this._layerManager.removeLayer(this.layer), this.layer = void 0), this.layer)
        throw new Error("AG Charts - unable to deregister scene rendering layer!");
      if (o.prototype._setLayerManager.call(this, t), t && (!((r = this.opts) === null || r === void 0) && r.layer)) {
        var s = (n = this.opts) !== null && n !== void 0 ? n : {}, a = s.zIndex, l = s.zIndexSubOrder, c = s.name, d = function() {
          return i.getComputedOpacity();
        }, u = function() {
          return i.getVisibility();
        };
        this.layer = t.addLayer({ zIndex: a, zIndexSubOrder: l, name: c, getComputedOpacity: d, getVisibility: u });
      }
    }, e.prototype.getComputedOpacity = function() {
      var t = 1, i = this;
      do
        i instanceof e && (t *= i.opacity);
      while (i = i.parent);
      return t;
    }, e.prototype.getVisibility = function() {
      for (var t = this, i = this.visible; t = t.parent; )
        t.visible || (i = t.visible);
      return i;
    }, e.prototype.visibilityChanged = function() {
      this.layer && (this.layer.enabled = this.visible);
    }, e.prototype.markDirty = function(t, i) {
      if (i === void 0 && (i = oe.TRIVIAL), this.isVirtual) {
        o.prototype.markDirty.call(this, t, i);
        return;
      }
      var r = i;
      (i < oe.MINOR || this.layer != null) && (r = oe.TRIVIAL), o.prototype.markDirty.call(this, t, i, r);
    }, e.prototype.containsPoint = function(t, i) {
      return !0;
    }, e.prototype.computeBBox = function() {
      return this.computeTransformMatrix(), e.computeBBox(this.children);
    }, e.prototype.computeTransformedBBox = function() {
      return this.computeBBox();
    }, e.prototype.render = function(t) {
      var i, r, n, s, a, l, c, d, u = this.opts, h = u === void 0 ? {} : u, p = h.name, f = p === void 0 ? void 0 : p, g = this._debug, v = g === void 0 ? {} : g, y = v.consoleLog, m = y === void 0 ? !1 : y, C = this, R = C.dirty, E = C.dirtyZIndex, b = C.layer, T = C.children, D = C.clipRect, P = C.dirtyTransform, O = t.ctx, M = t.forceRender, _ = t.clipBBox, F = t.resized, I = t.stats, G = O.getTransform(), k = R >= oe.MINOR || E || F, N = k, W = !1;
      try {
        for (var j = ky(T), K = j.next(); !K.done; K = j.next()) {
          var $ = K.value;
          if (N || (N = $.layerManager == null && $.dirty >= oe.TRIVIAL), W || (W = $.layerManager != null && $.dirty >= oe.TRIVIAL), N)
            break;
        }
      } catch (Me) {
        i = { error: Me };
      } finally {
        try {
          K && !K.done && (r = j.return) && r.call(j);
        } finally {
          if (i)
            throw i.error;
        }
      }
      if (f && m && pe.debug({ name: f, group: this, isDirty: k, isChildDirty: N, dirtyTransform: P, renderCtx: t, forceRender: M }), P)
        M = "dirtyTransform";
      else if (b) {
        var ae = this.computeBBox();
        (this.lastBBox === void 0 || !this.lastBBox.equals(ae)) && (M = "dirtyTransform", this.lastBBox = ae);
      }
      if (!k && !N && !W && !M) {
        if (f && m && I) {
          var ee = this.nodeCount;
          pe.debug({ name: f, result: "skipping", renderCtx: t, counts: ee, group: this });
        }
        b && I && (I.layersSkipped++, I.nodesSkipped += this.nodeCount.count), this.markClean({ recursive: !1 });
        return;
      }
      var ne = this.visible;
      if (b) {
        if (O = b.context, O.save(), O.resetTransform(), M !== "dirtyTransform" && (M = N || E), M && b.clear(), _) {
          var Y = _.width, te = _.height, se = _.x, he = _.y;
          m && pe.debug({ name: f, clipBBox: _, ctxTransform: O.getTransform(), renderCtx: t, group: this }), this.clipCtx(O, se, he, Y, te);
        }
        O.setTransform(G);
      } else
        O.globalAlpha *= this.opacity;
      if (this.computeTransformMatrix(), this.matrix.toContext(O), D) {
        var se = D.x, he = D.y, Y = D.width, te = D.height;
        O.save(), m && pe.debug({ name: f, clipRect: D, ctxTransform: O.getTransform(), renderCtx: t, group: this }), this.clipCtx(O, se, he, Y, te), _ = this.matrix.transformBBox(D);
      }
      var be = this.hasVirtualChildren();
      E ? (this.sortChildren(T), M !== "dirtyTransform" && (M = !0)) : be && this.sortChildren(T);
      var ye = M !== t.forceRender || _ !== t.clipBBox || O !== t.ctx, Xe = ye ? qg(qg({}, t), { ctx: O, forceRender: M, clipBBox: _ }) : t, Je = 0;
      try {
        for (var We = ky(T), Ue = We.next(); !Ue.done; Ue = We.next()) {
          var $ = Ue.value;
          if (!$.visible || !ne) {
            $.markClean(), I && (Je += $.nodeCount.count);
            continue;
          }
          if (!M && $.dirty === oe.NONE) {
            I && (Je += $.nodeCount.count);
            continue;
          }
          O.save(), $.render(Xe), O.restore();
        }
      } catch (Me) {
        n = { error: Me };
      } finally {
        try {
          Ue && !Ue.done && (s = We.return) && s.call(We);
        } finally {
          if (n)
            throw n.error;
        }
      }
      if (I && (I.nodesSkipped += Je), o.prototype.render.call(this, t), D && O.restore(), be)
        try {
          for (var J = ky(this.virtualChildren), ge = J.next(); !ge.done; ge = J.next()) {
            var $ = ge.value;
            $.markClean({ recursive: "virtual" });
          }
        } catch (Me) {
          a = { error: Me };
        } finally {
          try {
            ge && !ge.done && (l = J.return) && l.call(J);
          } finally {
            if (a)
              throw a.error;
          }
        }
      if (b && (I && I.layersRendered++, O.restore(), M && b.snapshot(), (d = (c = b.context).verifyDepthZero) === null || d === void 0 || d.call(c)), f && m && I) {
        var ee = this.nodeCount;
        pe.debug({ name: f, result: "rendered", skipped: Je, renderCtx: t, counts: ee, group: this });
      }
    }, e.prototype.sortChildren = function(t) {
      this.dirtyZIndex = !1, t.sort(function(i, r) {
        var n, s;
        return sD(Kf(Kf([i.zIndex], m0((n = i.zIndexSubOrder) !== null && n !== void 0 ? n : [void 0, void 0])), [i.serialNumber]), Kf(Kf([r.zIndex], m0((s = r.zIndexSubOrder) !== null && s !== void 0 ? s : [void 0, void 0])), [r.serialNumber]), oD);
      });
    }, e.prototype.clipCtx = function(t, i, r, n, s) {
      t.beginPath(), t.moveTo(i, r), t.lineTo(i + n, r), t.lineTo(i + n, r + s), t.lineTo(i, r + s), t.closePath(), t.clip();
    }, e.computeBBox = function(t) {
      var i = 1 / 0, r = -1 / 0, n = 1 / 0, s = -1 / 0;
      return t.forEach(function(a) {
        if (a.visible) {
          var l = a.computeTransformedBBox();
          if (l) {
            var c = l.x, d = l.y;
            c < i && (i = c), d < n && (n = d), c + l.width > r && (r = c + l.width), d + l.height > s && (s = d + l.height);
          }
        }
      }), new nt(i, n, r - i, s - n);
    }, e.prototype.setClipRectInGroupCoordinateSpace = function(t) {
      this.clipRect = t ? this.transformBBox(t) : void 0;
    }, e.className = "Group", w1([
      ve({
        redraw: oe.MAJOR,
        convertor: function(t) {
          return Math.min(1, Math.max(0, t));
        }
      })
    ], e.prototype, "opacity", void 0), e;
  }(km)
), y0 = (
  /** @class */
  function() {
    function o(e) {
      var t = e.width, i = t === void 0 ? 600 : t, r = e.height, n = r === void 0 ? 300 : r, s = e.overrideDevicePixelRatio, a = s === void 0 ? void 0 : s;
      this.enabled = !0, this._pixelRatio = NaN, this._width = 0, this._height = 0, this.canvas = new OffscreenCanvas(i, n), this.context = this.canvas.getContext("2d"), this.imageSource = this.canvas.transferToImageBitmap(), this.setPixelRatio(a), this.resize(i, n);
    }
    return o.isSupported = function() {
      return window.OffscreenCanvas != null;
    }, o.prototype.snapshot = function() {
      this.imageSource.close(), this.imageSource = this.canvas.transferToImageBitmap();
    }, o.prototype.destroy = function() {
      this.imageSource.close(), this.canvas.width = 0, this.canvas.height = 0, this.context.clearRect(0, 0, 0, 0);
    }, o.prototype.clear = function() {
      this.context.save(), this.context.resetTransform(), this.context.clearRect(0, 0, this.width, this.height), this.context.restore();
    }, Object.defineProperty(o.prototype, "pixelRatio", {
      get: function() {
        return this._pixelRatio;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.setPixelRatio = function(e) {
      var t = e != null ? e : window.devicePixelRatio;
      nD() || (t = 1), It.overrideScale(this.context, t), this._pixelRatio = t;
    }, Object.defineProperty(o.prototype, "width", {
      get: function() {
        return this._width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "height", {
      get: function() {
        return this._height;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.resize = function(e, t) {
      if (e > 0 && t > 0) {
        var i = this, r = i.canvas, n = i.context, s = i.pixelRatio;
        r.width = Math.round(e * s), r.height = Math.round(t * s), n.resetTransform(), this._width = e, this._height = t;
      }
    }, o;
  }()
);
function Fn(o) {
  var e = typeof window != "undefined" ? window : (
    // typeof global !== 'undefined' ? (global as any) :
    void 0
  );
  return e == null ? void 0 : e[o];
}
var hd;
(function(o) {
  o[o.SUMMARY = 0] = "SUMMARY", o[o.DETAILED = 1] = "DETAILED";
})(hd || (hd = {}));
var Sl = function() {
  return Sl = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, Sl.apply(this, arguments);
}, E1 = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, R1 = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, Zr = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, is = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, ih = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function T1() {
  var o, e = (o = Fn("agChartsSceneDebug")) !== null && o !== void 0 ? o : [];
  typeof e == "string" && (e = [e]);
  var t = [];
  return e.forEach(function(i) {
    i === "layout" ? t.push("seriesRoot", "legend", "root", /.*Axis-\d+-axis.*/) : t.push(i);
  }), t;
}
var zb = (
  /** @class */
  function() {
    function o(e) {
      var t, i, r;
      this.id = Vs(this), this.layers = [], this._nextZIndex = 0, this._nextLayerId = 0, this._dirty = !1, this._root = null, this.debug = {
        dirtyTree: !1,
        stats: !1,
        renderBoundingBoxes: !1,
        consoleLog: !1,
        level: hd.SUMMARY,
        sceneNodeHighlight: []
      };
      var n = e.document, s = n === void 0 ? window.document : n, a = e.mode, l = a === void 0 ? (t = Fn("agChartsSceneRenderModel")) !== null && t !== void 0 ? t : "adv-composite" : a, c = e.width, d = e.height, u = e.overrideDevicePixelRatio, h = u === void 0 ? void 0 : u;
      this.overrideDevicePixelRatio = h, this.opts = { document: s, mode: l }, this.debug.consoleLog = [!0, "scene"].includes(Fn("agChartsDebug")), this.debug.level = ["scene"].includes(Fn("agChartsDebug")) ? hd.DETAILED : hd.SUMMARY, this.debug.stats = (i = Fn("agChartsSceneStats")) !== null && i !== void 0 ? i : !1, this.debug.dirtyTree = (r = Fn("agChartsSceneDirtyTree")) !== null && r !== void 0 ? r : !1, this.debug.sceneNodeHighlight = T1(), this.canvas = new It({ document: s, width: c, height: d, overrideDevicePixelRatio: h });
    }
    return Object.defineProperty(o.prototype, "container", {
      get: function() {
        return this.canvas.container;
      },
      set: function(e) {
        this.canvas.container = e;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.download = function(e, t) {
      this.canvas.download(e, t);
    }, o.prototype.getDataURL = function(e) {
      return this.canvas.getDataURL(e);
    }, Object.defineProperty(o.prototype, "width", {
      get: function() {
        return this.pendingSize ? this.pendingSize[0] : this.canvas.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "height", {
      get: function() {
        return this.pendingSize ? this.pendingSize[1] : this.canvas.height;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.resize = function(e, t) {
      e = Math.round(e), t = Math.round(t);
      var i = e <= 0 || t <= 0, r = isNaN(e) || isNaN(t), n = e === this.width && t === this.height;
      return n || r || i ? !1 : (this.pendingSize = [e, t], this.markDirty(), !0);
    }, o.prototype.addLayer = function(e) {
      var t, i = this.opts.mode, r = ["composite", "dom-composite", "adv-composite"];
      if (r.includes(i)) {
        var n = e.zIndex, s = n === void 0 ? this._nextZIndex++ : n, a = e.name, l = e.zIndexSubOrder, c = e.getComputedOpacity, d = e.getVisibility, u = this, h = u.width, p = u.height, f = u.overrideDevicePixelRatio, g = i === "dom-composite", v = i === "adv-composite", y = !v || !y0.isSupported() ? new It({
          document: this.opts.document,
          width: h,
          height: p,
          domLayer: g,
          zIndex: s,
          name: a,
          overrideDevicePixelRatio: f
        }) : new y0({
          width: h,
          height: p,
          overrideDevicePixelRatio: f
        }), m = {
          id: this._nextLayerId++,
          name: a,
          zIndex: s,
          zIndexSubOrder: l,
          canvas: y,
          getComputedOpacity: c,
          getVisibility: d
        };
        if (s >= this._nextZIndex && (this._nextZIndex = s + 1), this.layers.push(m), this.sortLayers(), g) {
          var C = this.layers.map(function(b) {
            return b.canvas;
          }).filter(function(b) {
            return b instanceof It;
          }), R = C.findIndex(function(b) {
            return b === y;
          }), E = (t = C[R - 1]) !== null && t !== void 0 ? t : this.canvas;
          E.element.insertAdjacentElement("afterend", y.element);
        }
        return this.debug.consoleLog && pe.debug("Scene.addLayer() - layers", this.layers), m.canvas;
      }
    }, o.prototype.removeLayer = function(e) {
      var t = this.layers.findIndex(function(i) {
        return i.canvas === e;
      });
      t >= 0 && (this.layers.splice(t, 1), e.destroy(), this.markDirty(), this.debug.consoleLog && pe.debug("Scene.removeLayer() -  layers", this.layers));
    }, o.prototype.moveLayer = function(e, t, i) {
      var r = this.layers.find(function(n) {
        return n.canvas === e;
      });
      r && (r.zIndex = t, r.zIndexSubOrder = i, this.sortLayers(), this.markDirty(), this.debug.consoleLog && pe.debug("Scene.moveLayer() -  layers", this.layers));
    }, o.prototype.sortLayers = function() {
      this.layers.sort(function(e, t) {
        var i, r;
        return sD(is(is([e.zIndex], Zr((i = e.zIndexSubOrder) !== null && i !== void 0 ? i : [void 0, void 0])), [e.id]), is(is([t.zIndex], Zr((r = t.zIndexSubOrder) !== null && r !== void 0 ? r : [void 0, void 0])), [t.id]), oD);
      });
    }, o.prototype.markDirty = function() {
      this._dirty = !0;
    }, Object.defineProperty(o.prototype, "dirty", {
      get: function() {
        return this._dirty;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "root", {
      get: function() {
        return this._root;
      },
      set: function(e) {
        var t = this;
        e !== this._root && (this._root && this._root._setLayerManager(), this._root = e, e && (e.parent === null && e.layerManager && e.layerManager !== this && (e.layerManager.root = null), e._setLayerManager({
          addLayer: function(i) {
            return t.addLayer(i);
          },
          moveLayer: function() {
            for (var i = [], r = 0; r < arguments.length; r++)
              i[r] = arguments[r];
            return t.moveLayer.apply(t, is([], Zr(i)));
          },
          removeLayer: function() {
            for (var i = [], r = 0; r < arguments.length; r++)
              i[r] = arguments[r];
            return t.removeLayer.apply(t, is([], Zr(i)));
          },
          markDirty: function() {
            return t.markDirty();
          },
          canvas: this.canvas,
          debug: Sl(Sl({}, this.debug), { consoleLog: this.debug.level >= hd.DETAILED })
        })), this.markDirty());
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.strip = function() {
      var e, t, i = this.layers;
      try {
        for (var r = ih(i), n = r.next(); !n.done; n = r.next()) {
          var s = n.value;
          s.canvas.destroy(), delete s.canvas;
        }
      } catch (a) {
        e = { error: a };
      } finally {
        try {
          n && !n.done && (t = r.return) && t.call(r);
        } finally {
          if (e)
            throw e.error;
        }
      }
      i.splice(0, i.length), this.root = null, this._dirty = !1, this.canvas.context.resetTransform();
    }, o.prototype.destroy = function() {
      this.container = void 0, this.strip(), this.canvas.destroy(), Object.assign(this, { canvas: void 0, ctx: void 0 });
    }, o.prototype.render = function(e) {
      var t;
      return E1(this, void 0, void 0, function() {
        var i, r, n, s, a, l, c, d, u, h, p, f, g, v, y, m, C, R;
        return R1(this, function(E) {
          return i = e != null ? e : {}, r = i.debugSplitTimes, n = r === void 0 ? [performance.now()] : r, s = i.extraDebugStats, a = s === void 0 ? {} : s, l = this, c = l.canvas, d = l.canvas.context, u = l.root, h = l.layers, p = l.pendingSize, f = l.opts.mode, p && ((R = this.canvas).resize.apply(R, is([], Zr(p))), this.layers.forEach(function(b) {
            var T;
            return (T = b.canvas).resize.apply(T, is([], Zr(p)));
          }), this.pendingSize = void 0), u && !u.visible ? (this._dirty = !1, [
            2
            /*return*/
          ]) : u && !this.dirty ? (this.debug.consoleLog && pe.debug("Scene.render() - no-op", {
            redrawType: oe[u.dirty],
            tree: this.buildTree(u)
          }), this.debugStats(n, d, void 0, a), [
            2
            /*return*/
          ]) : (g = {
            ctx: d,
            forceRender: !0,
            resized: !!p,
            debugNodes: {}
          }, this.debug.stats === "detailed" && (g.stats = { layersRendered: 0, layersSkipped: 0, nodesRendered: 0, nodesSkipped: 0 }), v = !1, (!u || u.dirty >= oe.TRIVIAL) && (v = !0, c.clear()), u && this.debug.dirtyTree && (y = this.buildDirtyTree(u), m = y.dirtyTree, C = y.paths, pe.debug("Scene.render() - dirtyTree", { dirtyTree: m, paths: C })), u && v && (this.debug.consoleLog && pe.debug("Scene.render() - before", {
            redrawType: oe[u.dirty],
            canvasCleared: v,
            tree: this.buildTree(u)
          }), u.visible && (d.save(), u.render(g), d.restore())), f !== "dom-composite" && h.length > 0 && v && (this.sortLayers(), d.save(), d.setTransform(1 / c.pixelRatio, 0, 0, 1 / c.pixelRatio, 0, 0), h.forEach(function(b) {
            var T = b.canvas, D = T.imageSource, P = T.enabled, O = b.getComputedOpacity, M = b.getVisibility;
            !P || !M() || (d.globalAlpha = O(), d.drawImage(D, 0, 0));
          }), d.restore()), (t = d.verifyDepthZero) === null || t === void 0 || t.call(d), this._dirty = !1, this.debugStats(n, d, g.stats, a), this.debugSceneNodeHighlight(d, this.debug.sceneNodeHighlight, g.debugNodes), u && this.debug.consoleLog && pe.debug("Scene.render() - after", {
            redrawType: oe[u.dirty],
            canvasCleared: v,
            tree: this.buildTree(u)
          }), [
            2
            /*return*/
          ]);
        });
      });
    }, o.prototype.debugStats = function(e, t, i, r) {
      var n, s;
      r === void 0 && (r = {});
      var a = performance.now();
      if (this.debug.stats) {
        var l = e[0];
        e.push(a);
        var c = function(k, N) {
          var W = k + N;
          return k + " / " + W + " (" + Math.round(100 * k / W) + "%)";
        }, d = function(k, N) {
          return Math.round((N - k) * 100) / 100 + "ms";
        }, u = i != null ? i : {}, h = u.layersRendered, p = h === void 0 ? 0 : h, f = u.layersSkipped, g = f === void 0 ? 0 : f, v = u.nodesRendered, y = v === void 0 ? 0 : v, m = u.nodesSkipped, C = m === void 0 ? 0 : m, R = e.map(function(k, N) {
          return N > 0 ? d(e[N - 1], k) : null;
        }).filter(function(k) {
          return k != null;
        }).join(" + "), E = Object.entries(r).map(function(k) {
          var N = Zr(k, 2), W = N[0], j = N[1];
          return W + ": " + j;
        }).join(" ; "), b = [
          d(l, a) + " (" + R + ")",
          "" + E,
          this.debug.stats === "detailed" ? "Layers: " + c(p, g) : null,
          this.debug.stats === "detailed" ? "Nodes: " + c(y, C) : null
        ].filter(function(k) {
          return k != null;
        }), T = b.map(function(k) {
          return [k, It.getTextSize(k, t.font)];
        }), D = Math.max.apply(Math, is([], Zr(T.map(function(k) {
          var N = Zr(k, 2), W = N[1].width;
          return W;
        })))), P = T.reduce(function(k, N) {
          var W = Zr(N, 2), j = W[1].height;
          return k + j;
        }, 0);
        t.save(), t.fillStyle = "white", t.fillRect(0, 0, D, P), t.fillStyle = "black";
        var O = 0;
        try {
          for (var M = ih(T), _ = M.next(); !_.done; _ = M.next()) {
            var F = Zr(_.value, 2), I = F[0], G = F[1];
            O += G.height, t.fillText(I, 2, O);
          }
        } catch (k) {
          n = { error: k };
        } finally {
          try {
            _ && !_.done && (s = M.return) && s.call(M);
          } finally {
            if (n)
              throw n.error;
          }
        }
        t.restore();
      }
    }, o.prototype.debugSceneNodeHighlight = function(e, t, i) {
      var r, n, s, a, l, c, d, u = function(O) {
        return function(M) {
          return O.test(M.id) ? !0 : M instanceof we && M.name != null && O.test(M.name);
        };
      }, h = function(O) {
        return function(M) {
          return O === M.id ? !0 : M instanceof we && M.name != null && O === M.name;
        };
      };
      try {
        for (var p = ih(t), f = p.next(); !f.done; f = p.next()) {
          var g = f.value;
          if (!(typeof g == "string" && i[g] != null)) {
            var v = typeof g == "string" ? h(g) : u(g), y = (d = this.root) === null || d === void 0 ? void 0 : d.findNodes(v);
            if (!y || y.length === 0) {
              pe.debug("Scene.render() - no debugging node with id [" + g + "] in scene graph.");
              continue;
            }
            try {
              for (var m = (s = void 0, ih(y)), C = m.next(); !C.done; C = m.next()) {
                var R = C.value;
                R instanceof we && R.name ? i[R.name] = R : i[R.id] = R;
              }
            } catch (O) {
              s = { error: O };
            } finally {
              try {
                C && !C.done && (a = m.return) && a.call(m);
              } finally {
                if (s)
                  throw s.error;
              }
            }
          }
        }
      } catch (O) {
        r = { error: O };
      } finally {
        try {
          f && !f.done && (n = p.return) && n.call(p);
        } finally {
          if (r)
            throw r.error;
        }
      }
      e.save();
      try {
        for (var E = ih(Object.entries(i)), b = E.next(); !b.done; b = E.next()) {
          var T = Zr(b.value, 2), D = T[0], R = T[1], P = R.computeTransformedBBox();
          if (!P) {
            pe.debug("Scene.render() - no bbox for debugged node [" + D + "].");
            continue;
          }
          e.globalAlpha = 0.8, e.strokeStyle = "red", e.lineWidth = 1, e.strokeRect(P.x, P.y, P.width, P.height), e.fillStyle = "red", e.strokeStyle = "white", e.font = "16px sans-serif", e.textBaseline = "top", e.textAlign = "left", e.lineWidth = 2, e.strokeText(D, P.x, P.y, P.width), e.fillText(D, P.x, P.y, P.width);
        }
      } catch (O) {
        l = { error: O };
      } finally {
        try {
          b && !b.done && (c = E.return) && c.call(E);
        } finally {
          if (l)
            throw l.error;
        }
      }
      e.restore();
    }, o.prototype.buildTree = function(e) {
      var t = this, i, r, n = (i = e instanceof we ? e.name : null) !== null && i !== void 0 ? i : e.id;
      return Sl(Sl({ name: n, node: e, dirty: oe[e.dirty] }, !((r = e.parent) === null || r === void 0) && r.isVirtual ? {
        virtualParentDirty: oe[e.parent.dirty],
        virtualParent: e.parent
      } : {}), e.children.map(function(s) {
        return t.buildTree(s);
      }).reduce(function(s, a) {
        var l = a.name, c = a.node, d = c.visible, u = c.opacity, h = c.zIndex, p = c.zIndexSubOrder, f = a.node, g = a.virtualParent;
        (!d || u <= 0) && (l = "(" + l + ")"), f instanceof we && f.isLayer() && (l = "*" + l + "*");
        for (var v = [
          "" + (l != null ? l : "<unknown>"),
          "z: " + h,
          p && "zo: " + p.map(function(C) {
            return typeof C == "function" ? C() + " (fn)" : C;
          }).join(" / "),
          g && "(virtual parent)"
        ].filter(function(C) {
          return !!C;
        }).join(" "), y = v, m = 1; s[y] != null && m < 100; )
          y = v + " (" + m++ + ")";
        return s[y] = a, s;
      }, {}));
    }, o.prototype.buildDirtyTree = function(e) {
      var t = this, i;
      if (e.dirty === oe.NONE)
        return { dirtyTree: {}, paths: [] };
      var r = e.children.map(function(a) {
        return t.buildDirtyTree(a);
      }).filter(function(a) {
        return a.paths.length > 0;
      }), n = (i = e instanceof we ? e.name : null) !== null && i !== void 0 ? i : e.id, s = r.length === 0 ? [n] : r.map(function(a) {
        return a.paths;
      }).reduce(function(a, l) {
        return a.concat(l);
      }, []).map(function(a) {
        return n + "." + a;
      });
      return {
        dirtyTree: Sl({ name: n, node: e, dirty: oe[e.dirty] }, r.map(function(a) {
          return a.dirtyTree;
        }).filter(function(a) {
          return a.dirty !== void 0;
        }).reduce(function(a, l) {
          var c;
          return a[(c = l.name) !== null && c !== void 0 ? c : "<unknown>"] = l, a;
        }, {})),
        paths: s
      };
    }, o.className = "Scene", o;
  }()
), x1 = (
  /** @class */
  function() {
    function o() {
      this.stops = [];
    }
    return o;
  }()
), bo = Math.PI * 2;
function Vi(o) {
  return o %= bo, o += bo, o %= bo, o;
}
function D1(o) {
  return o %= bo, o += bo, o !== bo && (o %= bo), o;
}
function aD(o) {
  return o %= bo, o < -Math.PI ? o += bo : o >= Math.PI && (o -= bo), o;
}
function xr(o) {
  return o / 180 * Math.PI;
}
function O1(o) {
  return o / Math.PI * 180;
}
var P1 = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), A1 = (
  /** @class */
  function(o) {
    P1(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.angle = 0, t;
    }
    return e.prototype.createGradient = function(t, i) {
      var r = 90, n = this, s = n.stops, a = n.angle, l = Vi(xr(a + r)), c = Math.cos(l), d = Math.sin(l), u = i.width, h = i.height, p = i.x + u * 0.5, f = i.y + h * 0.5;
      if (u > 0 && h > 0) {
        var g = Math.sqrt(h * h + u * u) / 2, v = Math.atan2(h, u), y = void 0;
        l < Math.PI / 2 ? y = l : l < Math.PI ? y = Math.PI - l : l < 3 * Math.PI / 2 ? y = l - Math.PI : y = 2 * Math.PI - l;
        var m = g * Math.abs(Math.cos(y - v)), C = t.createLinearGradient(p + c * m, f + d * m, p - c * m, f - d * m);
        return s.forEach(function(R) {
          C.addColorStop(R.offset, R.color);
        }), C;
      }
      return "black";
    }, e;
  }(x1)
), M1 = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), xn = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, _1 = /^linear-gradient\((.*?)deg,\s*(.*?)\s*\)$/i, Mo = (
  /** @class */
  function(o) {
    M1(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.lastInstanceId = 0, t.fillOpacity = 1, t.strokeOpacity = 1, t.fill = e.defaultStyles.fill, t.stroke = e.defaultStyles.stroke, t.strokeWidth = e.defaultStyles.strokeWidth, t.lineDash = e.defaultStyles.lineDash, t.lineDashOffset = e.defaultStyles.lineDashOffset, t.lineCap = e.defaultStyles.lineCap, t.lineJoin = e.defaultStyles.lineJoin, t.opacity = e.defaultStyles.opacity, t.fillShadow = e.defaultStyles.fillShadow, t;
    }
    return e.createInstance = function(t) {
      var i = Object.create(t);
      return i._setParent(void 0), i.id = t.id + "-Instance-" + String(++t.lastInstanceId), i;
    }, e.prototype.restoreOwnStyles = function() {
      for (var t = this.constructor.defaultStyles, i = Object.getOwnPropertyNames(t), r = 0, n = i.length; r < n; r++) {
        var s = i[r];
        this[s] = t[s];
      }
    }, e.prototype.restoreAllStyles = function() {
      var t = this.constructor.defaultStyles;
      for (var i in t)
        this[i] = t[i];
    }, e.prototype.restoreOverriddenStyles = function() {
      var t = this.constructor.defaultStyles, i = Object.getPrototypeOf(t);
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && Object.prototype.hasOwnProperty.call(i, r) && (this[r] = t[r]);
    }, e.prototype.updateGradient = function() {
      var t = this.fill, i;
      if (t != null && t.startsWith("linear-gradient") && (i = _1.exec(t))) {
        for (var r = parseFloat(i[1]), n = [], s = i[2], a = /(#[0-9a-f]+)|(rgba?\(.+?\))|([a-z]+)/gi, l = void 0; l = a.exec(s); )
          n.push(l[0]);
        this.gradient = new A1(), this.gradient.angle = r, this.gradient.stops = n.map(function(c, d) {
          var u = d / (n.length - 1);
          return { offset: u, color: c };
        });
      } else
        this.gradient = void 0;
    }, e.prototype.align = function(t, i) {
      var r, n, s, a = (s = (n = (r = this.layerManager) === null || r === void 0 ? void 0 : r.canvas) === null || n === void 0 ? void 0 : n.pixelRatio) !== null && s !== void 0 ? s : 1, l = Math.round(t * a) / a;
      return i == null ? l : i === 0 ? 0 : i < 1 ? Math.ceil(i * a) / a : Math.round((i + t) * a) / a - l;
    }, e.prototype.fillStroke = function(t) {
      this.renderFill(t), this.renderStroke(t);
    }, e.prototype.renderFill = function(t) {
      if (this.fill) {
        var i = t.globalAlpha;
        this.applyFill(t), this.applyFillAlpha(t), this.applyShadow(t), t.fill(), t.globalAlpha = i;
      }
      t.shadowColor = "rgba(0, 0, 0, 0)";
    }, e.prototype.applyFill = function(t) {
      this.gradient ? t.fillStyle = this.gradient.createGradient(t, this.computeBBox()) : t.fillStyle = this.fill;
    }, e.prototype.applyFillAlpha = function(t) {
      var i = t.globalAlpha;
      t.globalAlpha = i * this.opacity * this.fillOpacity;
    }, e.prototype.applyShadow = function(t) {
      var i, r, n = (r = (i = this.layerManager) === null || i === void 0 ? void 0 : i.canvas.pixelRatio) !== null && r !== void 0 ? r : 1, s = this.fillShadow;
      s != null && s.enabled && (t.shadowColor = s.color, t.shadowOffsetX = s.xOffset * n, t.shadowOffsetY = s.yOffset * n, t.shadowBlur = s.blur * n);
    }, e.prototype.renderStroke = function(t) {
      if (this.stroke && this.strokeWidth) {
        var i = t.globalAlpha;
        t.strokeStyle = this.stroke, t.globalAlpha = i * this.opacity * this.strokeOpacity, t.lineWidth = this.strokeWidth, this.lineDash && t.setLineDash(this.lineDash), this.lineDashOffset && (t.lineDashOffset = this.lineDashOffset), this.lineCap && (t.lineCap = this.lineCap), this.lineJoin && (t.lineJoin = this.lineJoin), t.stroke(), t.globalAlpha = i;
      }
    }, e.prototype.containsPoint = function(t, i) {
      return this.isPointInPath(t, i);
    }, e.defaultStyles = Object.assign({}, {
      fill: "black",
      stroke: void 0,
      strokeWidth: 0,
      lineDash: void 0,
      lineDashOffset: 0,
      lineCap: void 0,
      lineJoin: void 0,
      opacity: 1,
      fillShadow: void 0
    }), xn([
      ve({ redraw: oe.MINOR })
    ], e.prototype, "fillOpacity", void 0), xn([
      ve({ redraw: oe.MINOR })
    ], e.prototype, "strokeOpacity", void 0), xn([
      ve({ redraw: oe.MINOR, changeCb: function(t) {
        return t.updateGradient();
      } })
    ], e.prototype, "fill", void 0), xn([
      ve({ redraw: oe.MINOR })
    ], e.prototype, "stroke", void 0), xn([
      ve({ redraw: oe.MINOR })
    ], e.prototype, "strokeWidth", void 0), xn([
      ve({ redraw: oe.MINOR })
    ], e.prototype, "lineDash", void 0), xn([
      ve({ redraw: oe.MINOR })
    ], e.prototype, "lineDashOffset", void 0), xn([
      ve({ redraw: oe.MINOR })
    ], e.prototype, "lineCap", void 0), xn([
      ve({ redraw: oe.MINOR })
    ], e.prototype, "lineJoin", void 0), xn([
      ve({
        redraw: oe.MINOR,
        convertor: function(t) {
          return Math.min(1, Math.max(0, t));
        }
      })
    ], e.prototype, "opacity", void 0), xn([
      ve({ redraw: oe.MINOR, checkDirtyOnAssignment: !0 })
    ], e.prototype, "fillShadow", void 0), e;
  }(km)
), I1 = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), ro = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, Vy = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, By = "…";
function Yf(o) {
  var e = o != null ? o : {}, t = e.redraw, i = t === void 0 ? oe.MAJOR : t, r = e.changeCb;
  return ve({ redraw: i, type: "font", changeCb: r });
}
var ut = (
  /** @class */
  function(o) {
    I1(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.x = 0, t.y = 0, t.lines = [], t.text = void 0, t._dirtyFont = !0, t.fontSize = 10, t.fontFamily = "sans-serif", t.textAlign = e.defaultStyles.textAlign, t.textBaseline = e.defaultStyles.textBaseline, t.lineHeight = void 0, t;
    }
    return e.prototype._setLines = function() {
      this.lines = uD(this.text);
    }, Object.defineProperty(e.prototype, "font", {
      get: function() {
        return (this._font == null || this._dirtyFont) && (this._dirtyFont = !1, this._font = jl(this)), this._font;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.computeBBox = function() {
      return It.has.textMetrics ? lD(this.lines, this.x, this.y, this) : cD(this.lines, this.x, this.y, this);
    }, e.prototype.getLineHeight = function(t) {
      var i, r;
      if (this.lineHeight)
        return this.lineHeight;
      if (It.has.textMetrics) {
        var n = It.measureText(t, this.font, this.textBaseline, this.textAlign);
        return ((i = n.fontBoundingBoxAscent) !== null && i !== void 0 ? i : n.emHeightAscent) + ((r = n.fontBoundingBoxDescent) !== null && r !== void 0 ? r : n.emHeightDescent);
      }
      return It.getTextSize(t, this.font).height;
    }, e.prototype.isPointInPath = function(t, i) {
      var r = this.transformPoint(t, i), n = this.computeBBox();
      return n ? n.containsPoint(r.x, r.y) : !1;
    }, e.prototype.render = function(t) {
      var i = t.ctx, r = t.forceRender, n = t.stats;
      if (this.dirty === oe.NONE && !r) {
        n && (n.nodesSkipped += this.nodeCount.count);
        return;
      }
      if (!this.lines.length || !this.layerManager) {
        n && (n.nodesSkipped += this.nodeCount.count);
        return;
      }
      this.computeTransformMatrix(), this.matrix.toContext(i);
      var s = this, a = s.fill, l = s.stroke, c = s.strokeWidth;
      i.font = this.font, i.textAlign = this.textAlign, i.textBaseline = this.textBaseline;
      var d = this.layerManager.canvas.pixelRatio || 1, u = i.globalAlpha;
      if (a) {
        i.fillStyle = a, i.globalAlpha = u * this.opacity * this.fillOpacity;
        var h = this.fillShadow;
        h != null && h.enabled && (i.shadowColor = h.color, i.shadowOffsetX = h.xOffset * d, i.shadowOffsetY = h.yOffset * d, i.shadowBlur = h.blur * d), this.renderLines(function(m, C, R) {
          return i.fillText(m, C, R);
        });
      }
      if (l && c) {
        i.strokeStyle = l, i.lineWidth = c, i.globalAlpha = u * this.opacity * this.strokeOpacity;
        var p = this, f = p.lineDash, g = p.lineDashOffset, v = p.lineCap, y = p.lineJoin;
        f && i.setLineDash(f), g && (i.lineDashOffset = g), v && (i.lineCap = v), y && (i.lineJoin = y), this.renderLines(function(m, C, R) {
          return i.strokeText(m, C, R);
        });
      }
      o.prototype.render.call(this, t);
    }, e.prototype.renderLines = function(t) {
      for (var i = this, r = this, n = r.lines, s = r.x, a = r.y, l = this.lines.map(function(h) {
        return i.getLineHeight(h);
      }), c = l.reduce(function(h, p) {
        return h + p;
      }, 0), d = -(c - l[0]) * dD(this.textBaseline), u = 0; u < n.length; u++)
        t(n[u], s, a + d), d += l[u];
    }, e.wrap = function(t, i, r, n, s) {
      var a, l, c = jl(n), d = F1(c), u = t.split(/\r?\n/g);
      if (u.length === 0)
        return "";
      if (s === "never")
        return e.truncateLine(u[0], i, d, !1);
      var h = [], p = 0;
      try {
        for (var f = Vy(u), g = f.next(); !g.done; g = f.next()) {
          var v = g.value, y = e.wrapLine(v, i, r, d, n, s, p);
          if (h.push(y.result), p = y.cumulativeHeight, y.truncated)
            break;
        }
      } catch (m) {
        a = { error: m };
      } finally {
        try {
          g && !g.done && (l = f.return) && l.call(f);
        } finally {
          if (a)
            throw a.error;
        }
      }
      return h.join(`
`).trim();
    }, e.wrapLine = function(t, i, r, n, s, a, l) {
      if (t = t.trim(), !t)
        return { result: "", truncated: !1, cumulativeHeight: l };
      var c = n.size(t);
      if (c.width <= i)
        return { result: t, truncated: !1, cumulativeHeight: l + c.height };
      if (c.height > r || n.width("W") > i)
        return { result: "", truncated: !0, cumulativeHeight: l };
      var d = t.split(/\s+/g), u = e.wrapLineSequentially(d, i, r, n, s, a, l);
      l = u.cumulativeHeight;
      var h = u.lines;
      if (!(u.wordsBrokenOrTruncated || u.linesTruncated)) {
        var p = u.lines.length, f = e.wrapLineBalanced(d, i, n, p);
        f.length === h.length && (h = f);
      }
      var g = h.map(function(v) {
        return v.join(" ");
      }).join(`
`);
      return { result: g, truncated: u.linesTruncated, cumulativeHeight: l };
    }, e.breakWord = function(t, i, r, n, s) {
      for (var a, l, c = function(D) {
        return e.punctuationMarks.includes(t[D]);
      }, d = n ? s.width("-") : 0, u = [], h = 0, p = 0, f = 0; f < t.length; f++) {
        var g = t[f], v = s.width(g), y = p === 0 ? i : r;
        h + v + d > y && (u.push(f), h = 0, p++), h += v;
      }
      var m = [], C = 0;
      try {
        for (var R = Vy(u), E = R.next(); !E.done; E = R.next()) {
          var b = E.value, T = t.substring(C, b);
          n && T.length > 0 && !c(b - 1) && !c(b) && (T += "-"), m.push(T), C = b;
        }
      } catch (D) {
        a = { error: D };
      } finally {
        try {
          E && !E.done && (l = R.return) && l.call(R);
        } finally {
          if (a)
            throw a.error;
        }
      }
      return m.push(t.substring(C)), m;
    }, e.truncateLine = function(t, i, r, n) {
      var s = r.width(t);
      if (s < i && !n)
        return t;
      var a = r.width(By);
      if (s + a <= i)
        return "" + t + By;
      var l = Math.floor(t.length * i / s) + 1, c, d;
      do
        c = t.substring(0, l), d = r.width(c);
      while (--l >= 0 && d + a > i);
      return "" + c + By;
    }, e.wrapLineSequentially = function(t, i, r, n, s, a, l) {
      var c = s.fontSize, d = s.lineHeight, u = d === void 0 ? c * e.defaultLineHeightRatio : d, h = a === "always" || a === "hyphenate", p = a === "hyphenate", f = n.width(" "), g = !1, v = !1, y = [], m = [], C = 0, R = function() {
        var k = l + u;
        if (k >= r) {
          var N = m.join(" "), W = e.truncateLine(N, i, n, !0);
          return m.splice(0, m.length, W), v = !0, !1;
        }
        return m = [], C = 0, l = k, y.push(m), !0;
      };
      if (!R())
        return { lines: y, linesTruncated: !0, wordsBrokenOrTruncated: g, cumulativeHeight: l };
      for (var E = 0; E < t.length; E++) {
        var b = t[E], T = n.width(b), D = m.length === 0 ? 0 : f, P = C + D + T;
        if (P <= i) {
          m.push(b), C = P;
          continue;
        }
        if (T <= i) {
          if (!R())
            break;
          m.push(b), C = T;
          continue;
        }
        if (g = !0, h) {
          for (var O = i - C - D, M = e.breakWord(b, O, i, p, n), _ = !1, F = 0; F < M.length; F++) {
            var I = M[F];
            if (I && m.push(I), F === M.length - 1)
              C = n.width(I);
            else if (!R()) {
              _ = !0;
              break;
            }
          }
          if (_)
            break;
        } else {
          if (!R())
            break;
          var G = e.truncateLine(b, i, n, !0);
          m.push(G), E < t.length - 1 && (v = !0);
          break;
        }
      }
      return { lines: y, linesTruncated: v, wordsBrokenOrTruncated: g, cumulativeHeight: l };
    }, e.wrapLineBalanced = function(t, i, r, n) {
      var s, a, l = t.reduce(function(E, b) {
        return E + r.width(b);
      }, 0), c = r.width(" "), d = c * (t.length - n - 2), u = (l + d) / n, h = [], p = [], f = r.width(t[0]), g = !0;
      try {
        for (var v = Vy(t), y = v.next(); !y.done; y = v.next()) {
          var m = y.value, C = r.width(m);
          if (g) {
            p = [], p.push(m), f = C, g = !1, h.push(p);
            continue;
          }
          var R = f + c + C;
          R <= u ? (p.push(m), f = R) : R <= i ? (p.push(m), g = !0) : (p = [m], f = C, h.push(p));
        }
      } catch (E) {
        s = { error: E };
      } finally {
        try {
          y && !y.done && (a = v.return) && a.call(v);
        } finally {
          if (s)
            throw s.error;
        }
      }
      return h;
    }, e.prototype.setFont = function(t) {
      this.fontFamily = t.fontFamily, this.fontSize = t.fontSize, this.fontStyle = t.fontStyle, this.fontWeight = t.fontWeight;
    }, e.prototype.setAlign = function(t) {
      this.textAlign = t.textAlign, this.textBaseline = t.textBaseline;
    }, e.className = "Text", e.defaultLineHeightRatio = 1.15, e.defaultStyles = Object.assign({}, Mo.defaultStyles, {
      textAlign: "start",
      fontStyle: void 0,
      fontWeight: void 0,
      fontSize: 10,
      fontFamily: "sans-serif",
      textBaseline: "alphabetic"
    }), e.punctuationMarks = [".", ",", "-", ":", ";", "!", "?", "'", '"', "(", ")"], ro([
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "x", void 0), ro([
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "y", void 0), ro([
      ve({ redraw: oe.MAJOR, changeCb: function(t) {
        return t._setLines();
      } })
    ], e.prototype, "text", void 0), ro([
      Yf()
    ], e.prototype, "fontStyle", void 0), ro([
      Yf()
    ], e.prototype, "fontWeight", void 0), ro([
      Yf()
    ], e.prototype, "fontSize", void 0), ro([
      Yf()
    ], e.prototype, "fontFamily", void 0), ro([
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "textAlign", void 0), ro([
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "textBaseline", void 0), ro([
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "lineHeight", void 0), e;
  }(Mo)
);
function F1(o) {
  var e = /* @__PURE__ */ new Map(), t = function(r) {
    return It.getTextSize(r, o);
  }, i = function(r) {
    if (e.has(r))
      return e.get(r);
    var n = t(r).width;
    return e.set(r, n), n;
  };
  return { size: t, width: i };
}
function jl(o) {
  var e = o.fontFamily, t = o.fontSize, i = o.fontStyle, r = o.fontWeight;
  return [i != null ? i : "", r != null ? r : "", t + "px", e].join(" ").trim();
}
function L1(o, e, t, i) {
  return It.has.textMetrics ? lD(o, e, t, i) : cD(o, e, t, i);
}
function lD(o, e, t, i) {
  for (var r, n, s = 0, a = 0, l = 0, c = 0, d = 0, u = jl(i), h = i.lineHeight, p = i.textBaseline, f = p === void 0 ? ut.defaultStyles.textBaseline : p, g = i.textAlign, v = g === void 0 ? ut.defaultStyles.textAlign : g, y = 0; y < o.length; y++) {
    var m = It.measureText(o[y], u, f, v);
    s = Math.max(s, m.actualBoundingBoxLeft), l = Math.max(l, m.width), y == 0 ? (a += m.actualBoundingBoxAscent, c += m.actualBoundingBoxAscent) : d += (r = m.fontBoundingBoxAscent) !== null && r !== void 0 ? r : m.emHeightAscent, y == o.length - 1 ? c += m.actualBoundingBoxDescent : d += (n = m.fontBoundingBoxDescent) !== null && n !== void 0 ? n : m.emHeightDescent;
  }
  return h !== void 0 && (d = (o.length - 1) * h), c += d, a += d * dD(f), new nt(e - s, t - a, l, c);
}
function cD(o, e, t, i) {
  var r = 0, n = 0, s = 0, a = jl(i), l = i.lineHeight, c = i.textBaseline, d = c === void 0 ? ut.defaultStyles.textBaseline : c, u = i.textAlign, h = u === void 0 ? ut.defaultStyles.textAlign : u;
  if (o.length > 0) {
    var p = It.getTextSize(o[0], a);
    r = p.width, n = p.height;
  }
  for (var f = 1; f < o.length; f++) {
    var p = It.getTextSize(o[f], a);
    r = Math.max(r, p.width), s += l != null ? l : p.height;
  }
  switch (h) {
    case "end":
    case "right":
      e -= r;
      break;
    case "center":
      e -= r / 2;
  }
  switch (d) {
    case "alphabetic":
      t -= n * 0.7 + s * 0.5;
      break;
    case "middle":
      t -= n * 0.45 + s * 0.5;
      break;
    case "ideographic":
      t -= n + s;
      break;
    case "hanging":
      t -= n * 0.2 + s * 0.5;
      break;
    case "bottom":
      t -= n + s;
      break;
  }
  return new nt(e, t, r, n + s);
}
function dD(o) {
  switch (o) {
    case "top":
    case "hanging":
      return 0;
    case "bottom":
    case "alphabetic":
    case "ideographic":
      return 1;
    case "middle":
      return 0.5;
  }
}
function uD(o) {
  return typeof o == "string" ? o.split(/\r?\n/g) : [];
}
var hD = (
  /** @class */
  function() {
    function o() {
      this.allEventListeners = /* @__PURE__ */ new Map();
    }
    return o.prototype.addEventListener = function(e, t) {
      if (typeof t != "function")
        throw new Error("AG Charts - listener must be a Function");
      var i = this.allEventListeners, r = i.get(e);
      r || (r = /* @__PURE__ */ new Set(), i.set(e, r)), r.has(t) || r.add(t);
    }, o.prototype.removeEventListener = function(e, t) {
      var i = this.allEventListeners, r = i.get(e);
      r && (r.delete(t), r.size === 0 && i.delete(e));
    }, o.prototype.hasEventListener = function(e) {
      return this.allEventListeners.has(e);
    }, o.prototype.clearEventListeners = function() {
      this.allEventListeners.clear();
    }, o.prototype.fireEvent = function(e) {
      var t = this.allEventListeners.get(e.type);
      t == null || t.forEach(function(i) {
        return i(e);
      });
    }, o;
  }()
), Kb = function(o) {
  return typeof o == "string";
}, pD = function(o) {
  return !!o && Object.prototype.hasOwnProperty.call(o, "toString") && Kb(o.toString());
}, N1 = function(o) {
  return o instanceof Date && !isNaN(+o);
};
function Zg(o) {
  return Kb(o) || pD(o);
}
function dp(o) {
  var e = function(i) {
    return !!i && Object.prototype.hasOwnProperty.call(i, "valueOf") && Dr(i.valueOf());
  }, t = function(i) {
    return i instanceof Date && !isNaN(+i);
  };
  return Dr(o) || e(o) || t(o);
}
function up(o, e) {
  if (e && dp(o))
    return o;
  if (!e)
    return Zg(o) ? o : String(o);
}
var Dr = function(o) {
  return typeof o == "number" && Number.isFinite(o);
}, C0 = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, Kt = (
  /** @class */
  function() {
    function o(e, t, i, r) {
      r === void 0 && (r = 1), this.r = Math.min(1, Math.max(0, e || 0)), this.g = Math.min(1, Math.max(0, t || 0)), this.b = Math.min(1, Math.max(0, i || 0)), this.a = Math.min(1, Math.max(0, r || 0));
    }
    return o.validColorString = function(e) {
      return e.indexOf("#") >= 0 ? !!o.parseHex(e) : e.indexOf("rgb") >= 0 ? !!o.stringToRgba(e) : !!o.nameToHex[e.toLowerCase()];
    }, o.fromString = function(e) {
      if (e.indexOf("#") >= 0)
        return o.fromHexString(e);
      var t = o.nameToHex[e.toLowerCase()];
      if (t)
        return o.fromHexString(t);
      if (e.indexOf("rgb") >= 0)
        return o.fromRgbaString(e);
      throw new Error("Invalid color string: '" + e + "'");
    }, o.tryParseFromString = function(e) {
      try {
        return o.fromString(e);
      } catch (t) {
        return pe.warnOnce("invalid color string: '" + e + "'."), o.fromArray([0, 0, 0]);
      }
    }, o.parseHex = function(e) {
      e = e.replace(/ /g, "").slice(1);
      var t;
      switch (e.length) {
        case 6:
        case 8:
          t = [];
          for (var i = 0; i < e.length; i += 2)
            t.push(parseInt("" + e[i] + e[i + 1], 16));
          break;
        case 3:
        case 4:
          t = e.split("").map(function(r) {
            return parseInt(r, 16);
          }).map(function(r) {
            return r + r * 16;
          });
          break;
      }
      if ((t == null ? void 0 : t.length) >= 3 && t.every(function(r) {
        return r >= 0;
      }))
        return t.length === 3 && t.push(255), t;
    }, o.fromHexString = function(e) {
      var t = o.parseHex(e);
      if (t) {
        var i = C0(t, 4), r = i[0], n = i[1], s = i[2], a = i[3];
        return new o(r / 255, n / 255, s / 255, a / 255);
      }
      throw new Error("Malformed hexadecimal color string: '" + e + "'");
    }, o.stringToRgba = function(e) {
      for (var t = C0([NaN, NaN], 2), i = t[0], r = t[1], n = 0; n < e.length; n++) {
        var s = e[n];
        if (!i && s === "(")
          i = n;
        else if (s === ")") {
          r = n;
          break;
        }
      }
      var a = i && r && e.substring(i + 1, r);
      if (a) {
        for (var l = a.split(","), c = [], n = 0; n < l.length; n++) {
          var d = l[n], u = parseFloat(d);
          if (isNaN(u))
            return;
          d.indexOf("%") >= 0 ? (u = Math.max(0, Math.min(100, u)), u /= 100) : n === 3 ? u = Math.max(0, Math.min(1, u)) : (u = Math.max(0, Math.min(255, u)), u /= 255), c.push(u);
        }
        return c;
      }
    }, o.fromRgbaString = function(e) {
      var t = o.stringToRgba(e);
      if (t) {
        if (t.length === 3)
          return new o(t[0], t[1], t[2]);
        if (t.length === 4)
          return new o(t[0], t[1], t[2], t[3]);
      }
      throw new Error("Malformed rgb/rgba color string: '" + e + "'");
    }, o.fromArray = function(e) {
      if (e.length === 4)
        return new o(e[0], e[1], e[2], e[3]);
      if (e.length === 3)
        return new o(e[0], e[1], e[2]);
      throw new Error("The given array should contain 3 or 4 color components (numbers).");
    }, o.fromHSB = function(e, t, i, r) {
      r === void 0 && (r = 1);
      var n = o.HSBtoRGB(e, t, i);
      return new o(n[0], n[1], n[2], r);
    }, o.padHex = function(e) {
      return e.length === 1 ? "0" + e : e;
    }, o.prototype.toHexString = function() {
      var e = "#" + o.padHex(Math.round(this.r * 255).toString(16)) + o.padHex(Math.round(this.g * 255).toString(16)) + o.padHex(Math.round(this.b * 255).toString(16));
      return this.a < 1 && (e += o.padHex(Math.round(this.a * 255).toString(16))), e;
    }, o.prototype.toRgbaString = function(e) {
      e === void 0 && (e = 3);
      var t = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)], i = Math.pow(10, e);
      return this.a !== 1 ? (t.push(Math.round(this.a * i) / i), "rgba(" + t.join(", ") + ")") : "rgb(" + t.join(", ") + ")";
    }, o.prototype.toString = function() {
      return this.a === 1 ? this.toHexString() : this.toRgbaString();
    }, o.prototype.toHSB = function() {
      return o.RGBtoHSB(this.r, this.g, this.b);
    }, o.RGBtoHSB = function(e, t, i) {
      var r = Math.min(e, t, i), n = Math.max(e, t, i), s = n !== 0 ? (n - r) / n : 0, a = NaN;
      if (r !== n) {
        var l = n - r, c = (n - e) / l, d = (n - t) / l, u = (n - i) / l;
        e === n ? a = u - d : t === n ? a = 2 + c - u : a = 4 + d - c, a /= 6, a < 0 && (a = a + 1);
      }
      return [a * 360, s, n];
    }, o.HSBtoRGB = function(e, t, i) {
      isNaN(e) && (e = 0), e = (e % 360 + 360) % 360 / 360;
      var r = 0, n = 0, s = 0;
      if (t === 0)
        r = n = s = i;
      else {
        var a = (e - Math.floor(e)) * 6, l = a - Math.floor(a), c = i * (1 - t), d = i * (1 - t * l), u = i * (1 - t * (1 - l));
        switch (a >> 0) {
          case 0:
            r = i, n = u, s = c;
            break;
          case 1:
            r = d, n = i, s = c;
            break;
          case 2:
            r = c, n = i, s = u;
            break;
          case 3:
            r = c, n = d, s = i;
            break;
          case 4:
            r = u, n = c, s = i;
            break;
          case 5:
            r = i, n = c, s = d;
            break;
        }
      }
      return [r, n, s];
    }, o.prototype.derive = function(e, t, i, r) {
      var n = o.RGBtoHSB(this.r, this.g, this.b), s = n[2];
      s == 0 && i > 1 && (s = 0.05);
      var a = ((n[0] + e) % 360 + 360) % 360, l = Math.max(Math.min(n[1] * t, 1), 0);
      s = Math.max(Math.min(s * i, 1), 0);
      var c = Math.max(Math.min(this.a * r, 1), 0), d = o.HSBtoRGB(a, l, s);
      return d.push(c), o.fromArray(d);
    }, o.prototype.brighter = function() {
      return this.derive(0, 1, 1 / 0.7, 1);
    }, o.prototype.darker = function() {
      return this.derive(0, 1, 0.7, 1);
    }, o.interpolate = function(e, t) {
      var i = o.tryParseFromString(e), r = o.tryParseFromString(t);
      return function(n) {
        var s = function(l, c) {
          return l * (1 - n) + c * n;
        }, a = new o(s(i.r, r.r), s(i.g, r.g), s(i.b, r.b), s(i.a, r.a));
        return a.toString();
      };
    }, o.nameToHex = Object.freeze({
      aliceblue: "#F0F8FF",
      antiquewhite: "#FAEBD7",
      aqua: "#00FFFF",
      aquamarine: "#7FFFD4",
      azure: "#F0FFFF",
      beige: "#F5F5DC",
      bisque: "#FFE4C4",
      black: "#000000",
      blanchedalmond: "#FFEBCD",
      blue: "#0000FF",
      blueviolet: "#8A2BE2",
      brown: "#A52A2A",
      burlywood: "#DEB887",
      cadetblue: "#5F9EA0",
      chartreuse: "#7FFF00",
      chocolate: "#D2691E",
      coral: "#FF7F50",
      cornflowerblue: "#6495ED",
      cornsilk: "#FFF8DC",
      crimson: "#DC143C",
      cyan: "#00FFFF",
      darkblue: "#00008B",
      darkcyan: "#008B8B",
      darkgoldenrod: "#B8860B",
      darkgray: "#A9A9A9",
      darkgreen: "#006400",
      darkgrey: "#A9A9A9",
      darkkhaki: "#BDB76B",
      darkmagenta: "#8B008B",
      darkolivegreen: "#556B2F",
      darkorange: "#FF8C00",
      darkorchid: "#9932CC",
      darkred: "#8B0000",
      darksalmon: "#E9967A",
      darkseagreen: "#8FBC8F",
      darkslateblue: "#483D8B",
      darkslategray: "#2F4F4F",
      darkslategrey: "#2F4F4F",
      darkturquoise: "#00CED1",
      darkviolet: "#9400D3",
      deeppink: "#FF1493",
      deepskyblue: "#00BFFF",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1E90FF",
      firebrick: "#B22222",
      floralwhite: "#FFFAF0",
      forestgreen: "#228B22",
      fuchsia: "#FF00FF",
      gainsboro: "#DCDCDC",
      ghostwhite: "#F8F8FF",
      gold: "#FFD700",
      goldenrod: "#DAA520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#ADFF2F",
      grey: "#808080",
      honeydew: "#F0FFF0",
      hotpink: "#FF69B4",
      indianred: "#CD5C5C",
      indigo: "#4B0082",
      ivory: "#FFFFF0",
      khaki: "#F0E68C",
      lavender: "#E6E6FA",
      lavenderblush: "#FFF0F5",
      lawngreen: "#7CFC00",
      lemonchiffon: "#FFFACD",
      lightblue: "#ADD8E6",
      lightcoral: "#F08080",
      lightcyan: "#E0FFFF",
      lightgoldenrodyellow: "#FAFAD2",
      lightgray: "#D3D3D3",
      lightgreen: "#90EE90",
      lightgrey: "#D3D3D3",
      lightpink: "#FFB6C1",
      lightsalmon: "#FFA07A",
      lightseagreen: "#20B2AA",
      lightskyblue: "#87CEFA",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#B0C4DE",
      lightyellow: "#FFFFE0",
      lime: "#00FF00",
      limegreen: "#32CD32",
      linen: "#FAF0E6",
      magenta: "#FF00FF",
      maroon: "#800000",
      mediumaquamarine: "#66CDAA",
      mediumblue: "#0000CD",
      mediumorchid: "#BA55D3",
      mediumpurple: "#9370DB",
      mediumseagreen: "#3CB371",
      mediumslateblue: "#7B68EE",
      mediumspringgreen: "#00FA9A",
      mediumturquoise: "#48D1CC",
      mediumvioletred: "#C71585",
      midnightblue: "#191970",
      mintcream: "#F5FFFA",
      mistyrose: "#FFE4E1",
      moccasin: "#FFE4B5",
      navajowhite: "#FFDEAD",
      navy: "#000080",
      oldlace: "#FDF5E6",
      olive: "#808000",
      olivedrab: "#6B8E23",
      orange: "#FFA500",
      orangered: "#FF4500",
      orchid: "#DA70D6",
      palegoldenrod: "#EEE8AA",
      palegreen: "#98FB98",
      paleturquoise: "#AFEEEE",
      palevioletred: "#DB7093",
      papayawhip: "#FFEFD5",
      peachpuff: "#FFDAB9",
      peru: "#CD853F",
      pink: "#FFC0CB",
      plum: "#DDA0DD",
      powderblue: "#B0E0E6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#FF0000",
      rosybrown: "#BC8F8F",
      royalblue: "#4169E1",
      saddlebrown: "#8B4513",
      salmon: "#FA8072",
      sandybrown: "#F4A460",
      seagreen: "#2E8B57",
      seashell: "#FFF5EE",
      sienna: "#A0522D",
      silver: "#C0C0C0",
      skyblue: "#87CEEB",
      slateblue: "#6A5ACD",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#FFFAFA",
      springgreen: "#00FF7F",
      steelblue: "#4682B4",
      tan: "#D2B48C",
      teal: "#008080",
      thistle: "#D8BFD8",
      tomato: "#FF6347",
      transparent: "#00000000",
      turquoise: "#40E0D0",
      violet: "#EE82EE",
      wheat: "#F5DEB3",
      white: "#FFFFFF",
      whitesmoke: "#F5F5F5",
      yellow: "#FFFF00",
      yellowgreen: "#9ACD32"
    }), o;
  }()
), S0 = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Qg = Symbol("BREAK"), Hy = "__decorator_config";
function G1(o, e, t, i) {
  Object.getOwnPropertyDescriptor(o, Hy) == null && Object.defineProperty(o, Hy, { value: {} });
  var r = o[Hy];
  if (r[t] != null)
    return r[t];
  r[t] = { setters: [], getters: [] };
  var n = Object.getOwnPropertyDescriptor(o, e), s = n == null ? void 0 : n.set, a = n == null ? void 0 : n.get, l = function() {
    var d, u, h, p, f = a ? a.call(this) : this[i];
    try {
      for (var g = S0((p = (h = r[t]) === null || h === void 0 ? void 0 : h.getters) !== null && p !== void 0 ? p : []), v = g.next(); !v.done; v = g.next()) {
        var y = v.value;
        if (f = y(this, e, f), f === Qg)
          return;
      }
    } catch (m) {
      d = { error: m };
    } finally {
      try {
        v && !v.done && (u = g.return) && u.call(g);
      } finally {
        if (d)
          throw d.error;
      }
    }
    return f;
  }, c = function(d) {
    var u, h, p, f, g = (f = (p = r[t]) === null || p === void 0 ? void 0 : p.setters) !== null && f !== void 0 ? f : [], v;
    g.some(function(R) {
      return R.length > 2;
    }) && (v = a ? a.call(this) : this[i]);
    try {
      for (var y = S0(g), m = y.next(); !m.done; m = y.next()) {
        var C = m.value;
        if (d = C(this, e, d, v), d === Qg)
          return;
      }
    } catch (R) {
      u = { error: R };
    } finally {
      try {
        m && !m.done && (h = y.return) && h.call(y);
      } finally {
        if (u)
          throw u.error;
      }
    }
    s ? s.call(this, d) : this[i] = d;
  };
  return Object.defineProperty(o, e, {
    set: c,
    get: l,
    enumerable: !0,
    configurable: !1
  }), r[t];
}
function Pu(o, e) {
  return function(t, i) {
    var r = i.toString(), n = "__" + r, s = G1(t, i, r, n), a = s.getters, l = s.setters;
    l.push(o), e && a.splice(0, 0, e);
  };
}
function A(o) {
  return Pu(function(e, t, i) {
    var r, n, s;
    if (o(i, { target: e }))
      return i;
    var a = t.toString().replace(/^_*/, ""), l = (n = (r = e.constructor) === null || r === void 0 ? void 0 : r.className) !== null && n !== void 0 ? n : (s = e.constructor) === null || s === void 0 ? void 0 : s.name;
    (l == null ? void 0 : l.length) < 3 && (l = null);
    var c = l ? "of [" + l + "] " : "";
    return o.message ? pe.warn("Property [" + a + "] " + c + "cannot be set to [" + JSON.stringify(i) + "]; " + o.message + ", ignoring.") : pe.warn("Property [" + a + "] " + c + "cannot be set to [" + JSON.stringify(i) + "], ignoring."), Qg;
  });
}
function Ee(o, e) {
  return o.message = e, o;
}
var Ot = function(o, e, t) {
  return o === void 0 || t(o, e);
}, Ja = function(o, e) {
  return Ee(function(t, i) {
    return Array.isArray(t) && (o ? t.length === o : !0) && (e ? t.every(function(r) {
      return e(r, i);
    }) : !0);
  }, "expecting an Array");
}, Yb = function(o) {
  return Ee(function(e, t) {
    return Ot(e, t, Ja(o));
  }, "expecting an optional Array");
}, Os = function() {
  for (var o = [], e = 0; e < arguments.length; e++)
    o[e] = arguments[e];
  return Ee(function(t, i) {
    return o.every(function(r) {
      return r(t, i);
    });
  }, o.map(function(t) {
    return t.message;
  }).filter(function(t) {
    return t != null;
  }).join(" AND "));
}, k1 = function() {
  for (var o = [], e = 0; e < arguments.length; e++)
    o[e] = arguments[e];
  return Ee(function(t, i) {
    return o.some(function(r) {
      return r(t, i);
    });
  }, o.map(function(t) {
    return t.message;
  }).filter(function(t) {
    return t != null;
  }).join(" OR "));
}, Jg = function(o) {
  return o != null && !isNaN(o);
}, Vm = function(o) {
  return Ee(function(e, t) {
    return !Jg(e) || !Jg(t.target[o]) || e < t.target[o];
  }, "expected to be less than " + o);
}, ff = function(o) {
  return Ee(function(e, t) {
    return !Jg(e) || !Jg(t.target[o]) || e > t.target[o];
  }, "expected to be greater than " + o);
}, V1 = Ee(function(o) {
  return typeof o == "function";
}, "expecting a Function"), Pt = Ee(function(o, e) {
  return Ot(o, e, V1);
}, "expecting an optional Function"), ht = Ee(function(o) {
  return o === !0 || o === !1;
}, "expecting a Boolean"), _o = Ee(function(o, e) {
  return Ot(o, e, ht);
}, "expecting an optional Boolean"), Ri = Ee(function(o) {
  return typeof o == "string";
}, "expecting a String"), De = Ee(function(o, e) {
  return Ot(o, e, Ri);
}, "expecting an optional String"), fD = Ee(function(o) {
  return o instanceof Date && !isNaN(+o);
}, "expecting a Date object"), B1 = Ee(function(o, e) {
  return Ot(o, e, fD);
}, "expecting an optional Date");
Ee(Ja(void 0, fD), "expecting an Array of Date objects");
var H1 = le(0), W1 = Ee(function(o, e) {
  return Ot(o, e, H1);
}, "expecting an optional number"), b0 = k1(B1, W1), Bm = "A color string can be in one of the following formats to be valid: #rgb, #rrggbb, rgb(r, g, b), rgba(r, g, b, a) or a CSS color name such as 'white', 'orange', 'cyan', etc", Lr = Ee(function(o) {
  return typeof o != "string" ? !1 : Kt.validColorString(o);
}, "expecting a color String. " + Bm), St = Ee(function(o, e) {
  return Ot(o, e, Lr);
}, "expecting an optional color String. " + Bm), hp = Ee(Ja(void 0, Lr), "expecting an Array of color strings. " + Bm), j1 = Ee(function(o, e) {
  return Ot(o, e, hp);
}, "expecting an optional Array of color strings. " + Bm);
function le(o, e) {
  var t = "expecting a finite Number" + ((o !== void 0 ? ", more than or equal to " + o : "") + (e !== void 0 ? ", less than or equal to " + e : ""));
  return Ee(function(i) {
    return typeof i == "number" && Number.isFinite(i) && (o !== void 0 ? i >= o : !0) && (e !== void 0 ? i <= e : !0);
  }, t);
}
function lt(o, e) {
  var t = "expecting an optional finite Number" + ((o !== void 0 ? ", more than or equal to " + o : "") + (e !== void 0 ? ", less than or equal to " + e : ""));
  return Ee(function(i, r) {
    return Ot(i, r, le(o, e));
  }, t);
}
function Ca(o, e) {
  var t = "expecting a finite Number" + ((o !== void 0 ? ", more than or equal to " + o : "") + (e !== void 0 ? ", less than or equal to " + e : ""));
  return Ee(function(i) {
    return typeof i == "number" && (isNaN(i) || Number.isFinite(i) && (o !== void 0 ? i >= o : !0) && (e !== void 0 ? i <= e : !0));
  }, t);
}
var gD = Ee(Ja(void 0, le()), "expecting an Array of numbers"), vD = Ee(function(o, e) {
  return Ot(o, e, gD);
}, "expecting an optional Array of numbers"), mD = Ee(Ja(void 0, Ri), "expecting an Array of strings");
Ee(function(o, e) {
  return Ot(o, e, mD);
}, "expecting an optional Array of strings");
function yD() {
  for (var o = [], e = 0; e < arguments.length; e++)
    o[e] = arguments[e];
  var t = "expecting one of: " + o.join(", ");
  return Ee(function(i) {
    return typeof i == "string" && o.indexOf(i) >= 0;
  }, t);
}
var U1 = Ee(Ja(void 0, ht), "expecting an Array of boolean values");
Ee(function(o, e) {
  return Ot(o, e, U1);
}, "expecting an optional Array of boolean values");
var $1 = [
  "normal",
  "bold",
  "bolder",
  "lighter",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
], z1 = Ee(function(o) {
  return o === "normal" || o === "italic" || o === "oblique";
}, "expecting a font style keyword such as 'normal', 'italic' or 'oblique'"), fc = Ee(function(o, e) {
  return Ot(o, e, z1);
}, "expecting an optional font style keyword such as 'normal', 'italic' or 'oblique'"), K1 = Ee(function(o) {
  return $1.includes(o);
}, "expecting a font weight keyword such as 'normal', 'bold' or 'bolder' or a numeric value such as 100, 300 or 600"), gc = Ee(function(o, e) {
  return Ot(o, e, K1);
}, "expecting an optional font weight keyword such as 'normal', 'bold' or 'bolder' or a numeric value such as 100, 300 or 600"), Y1 = Ee(Ja(void 0, le(0)), "expecting an Array of numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels."), Au = Ee(function(o, e) {
  return Ot(o, e, Y1);
}, "expecting an optional Array of numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels."), X1 = ["butt", "round", "square"], Xb = Ee(function(o) {
  return X1.includes(o);
}, "expecting a line cap keyword such as 'butt', 'round' or 'square'");
Ee(function(o, e) {
  return Ot(o, e, Xb);
}, "expecting an optional line cap keyword such as 'butt', 'round' or 'square'");
var q1 = ["round", "bevel", "miter"], Z1 = Ee(function(o) {
  return q1.includes(o);
}, "expecting a line join keyword such as 'round', 'bevel' or 'miter'");
Ee(function(o, e) {
  return Ot(o, e, Z1);
}, "expecting an optional line join keyword such as 'round', 'bevel' or 'miter'");
var Q1 = ["top", "right", "bottom", "left"], CD = Ee(function(o) {
  return Q1.includes(o);
}, "expecting a position keyword such as 'top', 'right', 'bottom' or 'left"), J1 = ["exact", "nearest"], SD = Ee(function(o) {
  return typeof o == "number" && Number.isFinite(o) || J1.includes(o);
}, "expecting an interaction range of 'exact', 'nearest' or a number"), eB = ["never", "always", "hyphenate", "on-space"], qb = Ee(function(o) {
  return eB.includes(o);
}, "expecting a text wrap strategy keyword such as 'never', 'always', 'hyphenate', 'on-space'"), kt;
(function(o) {
  o[o.SERIES_BACKGROUND_ZINDEX = -10] = "SERIES_BACKGROUND_ZINDEX", o[o.AXIS_GRID_ZINDEX = 0] = "AXIS_GRID_ZINDEX", o[o.AXIS_ZINDEX = 20] = "AXIS_ZINDEX", o[o.SERIES_CROSSLINE_RANGE_ZINDEX = 30] = "SERIES_CROSSLINE_RANGE_ZINDEX", o[o.SERIES_LAYER_ZINDEX = 500] = "SERIES_LAYER_ZINDEX", o[o.SERIES_CROSSHAIR_ZINDEX = 1e3] = "SERIES_CROSSHAIR_ZINDEX", o[o.SERIES_LABEL_ZINDEX = 1500] = "SERIES_LABEL_ZINDEX", o[o.SERIES_CROSSLINE_LINE_ZINDEX = 2500] = "SERIES_CROSSLINE_LINE_ZINDEX", o[o.LEGEND_ZINDEX = 3e3] = "LEGEND_ZINDEX";
})(kt || (kt = {}));
var de;
(function(o) {
  o.X = "x", o.Y = "y";
})(de || (de = {}));
var Wy = (
  /** @class */
  function() {
    function o(e) {
      this.type = e, this.continuousDomain = [1 / 0, -1 / 0], this.discreteDomain = /* @__PURE__ */ new Set();
    }
    return o.prototype.extend = function(e) {
      this.type === "discrete" ? this.discreteDomain.add(e) : this.type === "continuous" && (this.continuousDomain[0] > e && (this.continuousDomain[0] = e), this.continuousDomain[1] < e && (this.continuousDomain[1] = e));
    }, o.prototype.getDomain = function() {
      if (this.type === "discrete")
        return this.discreteDomain;
      if (this.type === "continuous")
        return this.continuousDomain;
      throw new Error("AG Charts - Unsupported data domain type: " + this.type);
    }, o;
  }()
), tB = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function Xf(o, e) {
  var t, i;
  e === void 0 && (e = [1 / 0, -1 / 0]);
  try {
    for (var r = tB(o), n = r.next(); !n.done; n = r.next()) {
      var s = n.value;
      typeof s == "number" && (s < e[0] && (e[0] = s), s > e[1] && (e[1] = s));
    }
  } catch (a) {
    t = { error: a };
  } finally {
    try {
      n && !n.done && (i = r.return) && i.call(r);
    } finally {
      if (t)
        throw t.error;
    }
  }
  return e;
}
var Lt = function() {
  return Lt = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, Lt.apply(this, arguments);
}, xt = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, rt = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Wt = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
};
function iB(o) {
  return o.map(function(e) {
    return e == null || typeof e == "number" || typeof e == "string" || typeof e == "boolean" ? e : typeof e == "object" ? JSON.stringify(e) : e;
  }).join("-");
}
function rB(o) {
  var e = 1e4;
  return Number.isInteger(o) ? o : Math.abs(o) > e ? Math.trunc(o) : Math.round(o * e) / e;
}
function mg(o) {
  if (o === void 0)
    return [];
  var e = xt(o, 2), t = e[0], i = e[1];
  return t = +t, i = +i, t === 0 && i === 0 ? [0, 1] : t === 1 / 0 && i === -1 / 0 ? [] : (t === 1 / 0 && (t = 0), i === -1 / 0 && (i = 0), Dr(t) && Dr(i) ? [t, i] : []);
}
var kc = Symbol("invalid"), nB = (
  /** @class */
  function() {
    function o(e) {
      var t, i, r, n, s, a, l = this, c = e.props, d = !0;
      try {
        for (var u = rt(c), h = u.next(); !h.done; h = u.next()) {
          var p = h.value;
          if (p.type === "key" && !d)
            throw new Error("AG Charts - internal config error: keys must come before values.");
          p.type === "value" && d && (d = !1);
        }
      } catch (b) {
        t = { error: b };
      } finally {
        try {
          h && !h.done && (i = u.return) && i.call(u);
        } finally {
          if (t)
            throw t.error;
        }
      }
      this.opts = Lt({ dataVisible: !0 }, e), this.keys = c.filter(function(b) {
        return b.type === "key";
      }).map(function(b, T) {
        return Lt(Lt({}, b), { index: T, missing: 0 });
      }), this.values = c.filter(function(b) {
        return b.type === "value";
      }).map(function(b, T) {
        return Lt(Lt({}, b), { index: T, missing: 0 });
      }), this.aggregates = c.filter(function(b) {
        return b.type === "aggregate";
      }).map(function(b, T) {
        return Lt(Lt({}, b), { index: T });
      }), this.groupProcessors = c.filter(function(b) {
        return b.type === "group-value-processor";
      }).map(function(b, T) {
        return Lt(Lt({}, b), { index: T });
      }), this.propertyProcessors = c.filter(function(b) {
        return b.type === "property-value-processor";
      }).map(function(b, T) {
        return Lt(Lt({}, b), { index: T });
      }), this.reducers = c.filter(function(b) {
        return b.type === "reducer";
      }).map(function(b, T) {
        return Lt(Lt({}, b), { index: T });
      }), this.processors = c.filter(function(b) {
        return b.type === "processor";
      }).map(function(b, T) {
        return Lt(Lt({}, b), { index: T });
      });
      try {
        for (var f = rt(this.values), g = f.next(); !g.done; g = f.next()) {
          var v = g.value;
          if (v.property == null)
            throw new Error("AG Charts - internal config error: no properties specified for value definitions: " + JSON.stringify(v));
        }
      } catch (b) {
        r = { error: b };
      } finally {
        try {
          g && !g.done && (n = f.return) && n.call(f);
        } finally {
          if (r)
            throw r.error;
        }
      }
      var y = function(b) {
        var T, D, P = b.matchGroupIds, O = function(I) {
          if (!l.values.some(function(G) {
            return G.groupId === I;
          }))
            throw new Error("AG Charts - internal config error: matchGroupIds properties must match defined groups (" + I + ").");
        };
        try {
          for (var M = rt(P != null ? P : []), _ = M.next(); !_.done; _ = M.next()) {
            var F = _.value;
            O(F);
          }
        } catch (I) {
          T = { error: I };
        } finally {
          try {
            _ && !_.done && (D = M.return) && D.call(M);
          } finally {
            if (T)
              throw T.error;
          }
        }
      }, m = function(b) {
        var T, D, P = b.matchScopes, O = function(I) {
          if (!l.values.some(function(G) {
            var k;
            return (k = G.scopes) === null || k === void 0 ? void 0 : k.includes(I);
          }))
            throw new Error("AG Charts - internal config error: matchGroupIds properties must match defined groups (" + I + ").");
        };
        try {
          for (var M = rt(P != null ? P : []), _ = M.next(); !_.done; _ = M.next()) {
            var F = _.value;
            O(F);
          }
        } catch (I) {
          T = { error: I };
        } finally {
          try {
            _ && !_.done && (D = M.return) && D.call(M);
          } finally {
            if (T)
              throw T.error;
          }
        }
      }, C = function(b) {
        var T, D, P = b.matchIds, O = function(I) {
          if (!l.values.some(function(G) {
            return G.id === I;
          }))
            throw new Error("AG Charts - internal config error: matchGroupIds properties must match defined groups (" + I + ").");
        };
        try {
          for (var M = rt(P != null ? P : []), _ = M.next(); !_.done; _ = M.next()) {
            var F = _.value;
            O(F);
          }
        } catch (I) {
          T = { error: I };
        } finally {
          try {
            _ && !_.done && (D = M.return) && D.call(M);
          } finally {
            if (T)
              throw T.error;
          }
        }
      };
      try {
        for (var R = rt(Wt(Wt([], xt(this.groupProcessors)), xt(this.aggregates))), E = R.next(); !E.done; E = R.next()) {
          var v = E.value;
          C(v), y(v), m(v);
        }
      } catch (b) {
        s = { error: b };
      } finally {
        try {
          E && !E.done && (a = R.return) && a.call(R);
        } finally {
          if (s)
            throw s.error;
        }
      }
    }
    return o.prototype.resolveProcessedDataIndexById = function(e, t, i) {
      var r;
      i === void 0 && (i = "value");
      var n = (r = this.resolveProcessedDataDefById(e, t, i)) !== null && r !== void 0 ? r : {}, s = n.index, a = n.def;
      return { type: i, index: s, def: a };
    }, o.prototype.resolveProcessedDataIndicesById = function(e, t, i) {
      return i === void 0 && (i = "value"), this.resolveProcessedDataDefsById(e, t, i).map(function(r) {
        var n = r.index, s = r.def;
        return { type: i, index: n, def: s };
      });
    }, o.prototype.resolveProcessedDataDefById = function(e, t, i) {
      return i === void 0 && (i = "value"), this.resolveProcessedDataDefsById(e, t, i)[0];
    }, o.prototype.resolveProcessedDataDefsById = function(e, t, i) {
      var r, n;
      i === void 0 && (i = "value");
      var s = this, a = s.keys, l = s.values, c = s.aggregates, d = s.groupProcessors, u = s.reducers, h = function(m) {
        var C = m.id, R = m.scopes;
        return C == null || e != null && !(R != null && R.includes(e.id)) ? !1 : typeof t == "string" ? C === t : t.test(C);
      }, p = [
        a,
        l,
        c,
        d,
        u
      ], f = [];
      try {
        for (var g = rt(p), v = g.next(); !v.done; v = g.next()) {
          var y = v.value;
          f.push.apply(f, Wt([], xt(y.filter(h).map(function(m) {
            return { index: m.index, def: m };
          }))));
        }
      } catch (m) {
        r = { error: m };
      } finally {
        try {
          v && !v.done && (n = g.return) && n.call(g);
        } finally {
          if (r)
            throw r.error;
        }
      }
      if (f.length > 0)
        return f;
      throw new Error("AG Charts - didn't find property definition for [" + t + ", " + e.id + ", " + i + "]");
    }, o.prototype.getDomain = function(e, t, i, r) {
      var n, s, a, l, c, d;
      i === void 0 && (i = "value");
      var u;
      try {
        u = this.resolveProcessedDataIndicesById(e, t, i);
      } catch (m) {
        if (typeof t != "string" && /didn't find property definition/.test(m.message))
          return [];
        throw m;
      }
      var h;
      switch (i) {
        case "key":
          h = "keys";
          break;
        case "value":
          h = "values";
          break;
        case "aggregate":
          h = "aggValues";
          break;
        case "group-value-processor":
          h = "groups";
          break;
        default:
          return [];
      }
      var p = (l = (a = r.domain[h]) === null || a === void 0 ? void 0 : a[u[0].index]) !== null && l !== void 0 ? l : [];
      if (u.length === 1)
        return p;
      var f = Wt([], xt(p));
      try {
        for (var g = rt(u.slice(1)), v = g.next(); !v.done; v = g.next()) {
          var y = v.value;
          Xf((d = (c = r.domain[h]) === null || c === void 0 ? void 0 : c[y.index]) !== null && d !== void 0 ? d : [], f);
        }
      } catch (m) {
        n = { error: m };
      } finally {
        try {
          v && !v.done && (s = g.return) && s.call(g);
        } finally {
          if (n)
            throw n.error;
        }
      }
      return f;
    }, o.prototype.processData = function(e) {
      var t, i, r, n, s = this, a = s.opts, l = a.groupByKeys, c = a.groupByFn, d = s.aggregates, u = s.groupProcessors, h = s.reducers, p = s.processors, f = s.propertyProcessors, g = performance.now();
      try {
        for (var v = rt(Wt(Wt([], xt(this.keys)), xt(this.values))), y = v.next(); !y.done; y = v.next()) {
          var m = y.value;
          m.missing = 0;
        }
      } catch (T) {
        t = { error: T };
      } finally {
        try {
          y && !y.done && (i = v.return) && i.call(v);
        } finally {
          if (t)
            throw t.error;
        }
      }
      if (!(l && this.keys.length === 0)) {
        var C = this.extractData(e);
        l ? C = this.groupData(C) : c && (C = this.groupData(C, c(C))), u.length > 0 && this.postProcessGroups(C), d.length > 0 && this.aggregateData(C), f.length > 0 && this.postProcessProperties(C), h.length > 0 && this.reduceData(C), p.length > 0 && this.postProcessData(C);
        try {
          for (var R = rt(Wt(Wt([], xt(this.keys)), xt(this.values))), E = R.next(); !E.done; E = R.next()) {
            var m = E.value;
            e.length > 0 && m.missing >= e.length && pe.warnOnce("the key '" + m.property + "' was not found in any data element.");
          }
        } catch (T) {
          r = { error: T };
        } finally {
          try {
            E && !E.done && (n = R.return) && n.call(R);
          } finally {
            if (r)
              throw r.error;
          }
        }
        var b = performance.now();
        return C.time = b - g, o.DEBUG() && oB(C), C;
      }
    }, o.prototype.valueGroupIdxLookup = function(e) {
      var t = e.matchGroupIds, i = e.matchIds, r = e.matchScopes;
      return this.values.map(function(n, s) {
        return { def: n, index: s };
      }).filter(function(n) {
        var s = n.def;
        return !(t && (s.groupId == null || !t.includes(s.groupId)) || i && (s.id == null || !i.includes(s.id)) || r && (s.scopes == null || !r.some(function(a) {
          var l;
          return (l = s.scopes) === null || l === void 0 ? void 0 : l.includes(a);
        })));
      }).map(function(n) {
        var s = n.index;
        return s;
      });
    }, o.prototype.valueIdxLookup = function(e, t) {
      var i, r = e == null || e.length === 0, n = function(s) {
        var a = s == null;
        if (a)
          return !0;
        var l = s == null || s.length === 0;
        return r === l ? !0 : s == null ? void 0 : s.some(function(c) {
          return e.includes(c);
        });
      };
      if (typeof t == "string" ? i = this.values.findIndex(function(s) {
        return n(s.scopes) && s.property === t;
      }) : i = this.values.findIndex(function(s) {
        return n(s.scopes) && s.id === t.id;
      }), i >= 0)
        return i;
      throw new Error("AG Charts - configuration error, unknown property " + JSON.stringify(t) + " in scope(s) " + JSON.stringify(e));
    }, o.prototype.extractData = function(e) {
      var t, i, r, n, s, a, l, c, d, u = this, h = u.keys, p = u.values, f = u.opts.dataVisible, g = this.initDataDomainProcessor(), v = g.dataDomain, y = g.processValue, m = g.scopes, C = g.allScopesHaveSameDefs, R = new Array(f ? e.length : 0), E = 0, b = 0;
      try {
        for (var T = rt(e), D = T.next(); !D.done; D = T.next()) {
          var P = D.value, O = m.size > 0 ? new Set(m) : void 0, M = f ? new Array(h.length) : void 0, _ = 0, F = void 0;
          try {
            for (var I = (r = void 0, rt(h)), G = I.next(); !G.done; G = I.next()) {
              var k = G.value;
              if (F = y(k, P, F), F === kc)
                break;
              M && (M[_++] = F);
            }
          } catch (se) {
            r = { error: se };
          } finally {
            try {
              G && !G.done && (n = I.return) && n.call(I);
            } finally {
              if (r)
                throw r.error;
            }
          }
          if (F !== kc) {
            var N = f && p.length > 0 ? new Array(p.length) : void 0, W = 0, j = void 0;
            try {
              for (var K = (s = void 0, rt(p)), $ = K.next(); !$.done; $ = K.next()) {
                var k = $.value;
                if (j = y(k, P, j), j === kc) {
                  if (C)
                    break;
                  try {
                    for (var ae = (l = void 0, rt((d = k.scopes) !== null && d !== void 0 ? d : m)), ee = ae.next(); !ee.done; ee = ae.next()) {
                      var ne = ee.value;
                      O == null || O.delete(ne);
                    }
                  } catch (he) {
                    l = { error: he };
                  } finally {
                    try {
                      ee && !ee.done && (c = ae.return) && c.call(ae);
                    } finally {
                      if (l)
                        throw l.error;
                    }
                  }
                  if (W++, (O == null ? void 0 : O.size) === 0)
                    break;
                } else
                  N && (N[W++] = j);
              }
            } catch (se) {
              s = { error: se };
            } finally {
              try {
                $ && !$.done && (a = K.return) && a.call(K);
              } finally {
                if (s)
                  throw s.error;
              }
            }
            if (!(j === kc && C) && (O == null ? void 0 : O.size) !== 0 && f) {
              var Y = {
                datum: P,
                keys: M,
                values: N
              };
              !C && O && O.size < m.size && (b++, Y.validScopes = Wt([], xt(O))), R[E++] = Y;
            }
          }
        }
      } catch (se) {
        t = { error: se };
      } finally {
        try {
          D && !D.done && (i = T.return) && i.call(T);
        } finally {
          if (t)
            throw t.error;
        }
      }
      R.length = E;
      var te = function(se) {
        var he = v.get(se).getDomain();
        return Array.isArray(he) && he[0] > he[1] ? [] : Wt([], xt(he));
      };
      return {
        type: "ungrouped",
        data: R,
        domain: {
          keys: h.map(function(se) {
            return te(se);
          }),
          values: p.map(function(se) {
            return te(se);
          })
        },
        defs: {
          allScopesHaveSameDefs: C,
          keys: h,
          values: p
        },
        partialValidDataCount: b,
        time: 0
      };
    }, o.prototype.groupData = function(e, t) {
      var i, r, n, s, a, l, c, d, u = /* @__PURE__ */ new Map();
      try {
        for (var h = rt(e.data), p = h.next(); !p.done; p = h.next()) {
          var f = p.value, g = f.keys, v = f.values, y = f.datum, m = f.validScopes, C = t ? t(f) : g, R = iB(C);
          if (u.has(R)) {
            var E = u.get(R);
            if (E.values.push(v), E.datum.push(y), m != null)
              for (var b = function(G) {
                var k = (c = E.validScopes) === null || c === void 0 ? void 0 : c[G];
                if (m.some(function(N) {
                  return N === k;
                }))
                  return "continue";
                (d = E.validScopes) === null || d === void 0 || d.splice(G, 1);
              }, T = 0; T < ((l = (a = E.validScopes) === null || a === void 0 ? void 0 : a.length) !== null && l !== void 0 ? l : 0); T++)
                b(T);
          } else
            u.set(R, { keys: C, values: [v], datum: [y], validScopes: m });
        }
      } catch (G) {
        i = { error: G };
      } finally {
        try {
          p && !p.done && (r = h.return) && r.call(h);
        } finally {
          if (i)
            throw i.error;
        }
      }
      var D = new Array(u.size), P = new Array(u.size), O = 0;
      try {
        for (var M = rt(u.entries()), _ = M.next(); !_.done; _ = M.next()) {
          var F = xt(_.value, 2), I = F[1], g = I.keys, v = I.values, y = I.datum, m = I.validScopes;
          (m == null ? void 0 : m.length) !== 0 && (P[O] = g, D[O++] = {
            keys: g,
            values: v,
            datum: y,
            validScopes: m
          });
        }
      } catch (G) {
        n = { error: G };
      } finally {
        try {
          _ && !_.done && (s = M.return) && s.call(M);
        } finally {
          if (n)
            throw n.error;
        }
      }
      return Lt(Lt({}, e), { type: "grouped", data: D, domain: Lt(Lt({}, e.domain), { groups: P }) });
    }, o.prototype.aggregateData = function(e) {
      var t, i, r = this, n, s, a, l, c, d, u, h, p = this.aggregates;
      if (p) {
        var f = p.map(function() {
          return [1 / 0, -1 / 0];
        }), g = p.map(function(T) {
          return r.valueGroupIdxLookup(T);
        }), v = p.map(function(T) {
          return T.aggregateFunction;
        }), y = p.map(function(T) {
          return T.groupAggregateFunction;
        }), m = p.map(function(T) {
          return T.finalFunction;
        }), C = function(T) {
          var D, P, O, M, _ = T.values, F = T.validScopes;
          (n = T.aggValues) !== null && n !== void 0 || (T.aggValues = new Array(g.length)), e.type === "ungrouped" && (_ = [_]);
          var I = 0;
          try {
            for (var G = (D = void 0, rt(g)), k = G.next(); !k.done; k = G.next()) {
              var N = k.value, W = (s = F == null ? void 0 : F.some(function(Y) {
                var te;
                return (te = p[I].matchScopes) === null || te === void 0 ? void 0 : te.some(function(se) {
                  return Y === se;
                });
              })) !== null && s !== void 0 ? s : !0;
              if (!W) {
                I++;
                continue;
              }
              var j = (l = (a = y[I]) === null || a === void 0 ? void 0 : a.call(y)) !== null && l !== void 0 ? l : Xf([]), K = function(Y) {
                var te = N.map(function(he) {
                  return Y[he];
                }), se = v[I](te, T.keys);
                se && (j = (d = (c = y[I]) === null || c === void 0 ? void 0 : c.call(y, se, j)) !== null && d !== void 0 ? d : Xf(se, j));
              };
              try {
                for (var $ = (O = void 0, rt(_)), ae = $.next(); !ae.done; ae = $.next()) {
                  var ee = ae.value;
                  K(ee);
                }
              } catch (Y) {
                O = { error: Y };
              } finally {
                try {
                  ae && !ae.done && (M = $.return) && M.call($);
                } finally {
                  if (O)
                    throw O.error;
                }
              }
              var ne = ((h = (u = m[I]) === null || u === void 0 ? void 0 : u.call(m, j)) !== null && h !== void 0 ? h : j).map(function(Y) {
                return rB(Y);
              });
              Xf(ne, f[I]), T.aggValues[I++] = ne;
            }
          } catch (Y) {
            D = { error: Y };
          } finally {
            try {
              k && !k.done && (P = G.return) && P.call(G);
            } finally {
              if (D)
                throw D.error;
            }
          }
        };
        try {
          for (var R = rt(e.data), E = R.next(); !E.done; E = R.next()) {
            var b = E.value;
            C(b);
          }
        } catch (T) {
          t = { error: T };
        } finally {
          try {
            E && !E.done && (i = R.return) && i.call(R);
          } finally {
            if (t)
              throw t.error;
          }
        }
        e.domain.aggValues = f;
      }
    }, o.prototype.postProcessGroups = function(e) {
      var t, i, r, n, s, a, l, c, d, u, h, p, f, g, v, y, m, C = this.groupProcessors;
      if (C) {
        var R = /* @__PURE__ */ new Set(), E = /* @__PURE__ */ new Map(), b = /* @__PURE__ */ new Map(), T = /* @__PURE__ */ new Map();
        try {
          for (var D = rt(C), P = D.next(); !P.done; P = D.next()) {
            var O = P.value, M = this.valueGroupIdxLookup(O);
            b.set(O, M), T.set(O, O.adjust());
            try {
              for (var _ = (r = void 0, rt(M)), F = _.next(); !F.done; F = _.next()) {
                var I = F.value, G = this.values[I];
                R.add(I), E.set(I, new Wy(G.valueType === "category" ? "discrete" : "continuous"));
              }
            } catch (ye) {
              r = { error: ye };
            } finally {
              try {
                F && !F.done && (n = _.return) && n.call(_);
              } finally {
                if (r)
                  throw r.error;
              }
            }
          }
        } catch (ye) {
          t = { error: ye };
        } finally {
          try {
            P && !P.done && (i = D.return) && i.call(D);
          } finally {
            if (t)
              throw t.error;
          }
        }
        var k = function(ye) {
          var Xe, Je, We;
          try {
            for (var Ue = rt(R), J = Ue.next(); !J.done; J = Ue.next()) {
              var ge = J.value;
              (We = E.get(ge)) === null || We === void 0 || We.extend(ye[ge]);
            }
          } catch (Me) {
            Xe = { error: Me };
          } finally {
            try {
              J && !J.done && (Je = Ue.return) && Je.call(Ue);
            } finally {
              if (Xe)
                throw Xe.error;
            }
          }
        };
        try {
          for (var N = rt(e.data), W = N.next(); !W.done; W = N.next()) {
            var j = W.value, K = function(ye) {
              var Xe, Je, We = (g = (f = j.validScopes) === null || f === void 0 ? void 0 : f.some(function(At) {
                var di;
                return (di = ye.matchScopes) === null || di === void 0 ? void 0 : di.some(function(Rn) {
                  return At === Rn;
                });
              })) !== null && g !== void 0 ? g : !0;
              if (!We)
                return "continue";
              var Ue = (v = b.get(ye)) !== null && v !== void 0 ? v : [], J = (m = (y = T.get(ye)) === null || y === void 0 ? void 0 : y()) !== null && m !== void 0 ? m : function() {
              };
              if (e.type === "grouped") {
                try {
                  for (var ge = (Xe = void 0, rt(j.values)), Me = ge.next(); !Me.done; Me = ge.next()) {
                    var $e = Me.value;
                    $e && J($e, Ue);
                  }
                } catch (At) {
                  Xe = { error: At };
                } finally {
                  try {
                    Me && !Me.done && (Je = ge.return) && Je.call(ge);
                  } finally {
                    if (Xe)
                      throw Xe.error;
                  }
                }
                return "continue";
              }
              j.values && J(j.values, Ue);
            };
            try {
              for (var $ = (l = void 0, rt(C)), ae = $.next(); !ae.done; ae = $.next()) {
                var O = ae.value;
                K(O);
              }
            } catch (ye) {
              l = { error: ye };
            } finally {
              try {
                ae && !ae.done && (c = $.return) && c.call($);
              } finally {
                if (l)
                  throw l.error;
              }
            }
            if (e.type === "grouped")
              try {
                for (var ee = (d = void 0, rt(j.values)), ne = ee.next(); !ne.done; ne = ee.next()) {
                  var Y = ne.value;
                  k(Y);
                }
              } catch (ye) {
                d = { error: ye };
              } finally {
                try {
                  ne && !ne.done && (u = ee.return) && u.call(ee);
                } finally {
                  if (d)
                    throw d.error;
                }
              }
            else
              k(j.values);
          }
        } catch (ye) {
          s = { error: ye };
        } finally {
          try {
            W && !W.done && (a = N.return) && a.call(N);
          } finally {
            if (s)
              throw s.error;
          }
        }
        try {
          for (var te = rt(E), se = te.next(); !se.done; se = te.next()) {
            var he = xt(se.value, 2), I = he[0], be = he[1];
            e.domain.values[I] = Wt([], xt(be.getDomain()));
          }
        } catch (ye) {
          h = { error: ye };
        } finally {
          try {
            se && !se.done && (p = te.return) && p.call(te);
          } finally {
            if (h)
              throw h.error;
          }
        }
      }
    }, o.prototype.postProcessProperties = function(e) {
      var t, i, r = this.propertyProcessors;
      if (r)
        try {
          for (var n = rt(r), s = n.next(); !s.done; s = n.next()) {
            var a = s.value, l = a.adjust, c = a.property, d = a.scopes;
            l()(e, this.valueIdxLookup(d != null ? d : [], c));
          }
        } catch (u) {
          t = { error: u };
        } finally {
          try {
            s && !s.done && (i = n.return) && i.call(n);
          } finally {
            if (t)
              throw t.error;
          }
        }
    }, o.prototype.reduceData = function(e) {
      var t, i, r, n, s, a = this.reducers, l = a.map(function(v) {
        return v.scopes;
      }), c = a.map(function(v) {
        return v.reducer();
      }), d = a.map(function(v) {
        return v.initialValue;
      }), u = function(v) {
        var y, m, C = 0;
        try {
          for (var R = (y = void 0, rt(c)), E = R.next(); !E.done; E = R.next()) {
            var b = E.value, T = (n = (r = v.validScopes) === null || r === void 0 ? void 0 : r.some(function(D) {
              var P;
              return (P = l[C]) === null || P === void 0 ? void 0 : P.some(function(O) {
                return D === O;
              });
            })) !== null && n !== void 0 ? n : !0;
            if (!T) {
              C++;
              continue;
            }
            d[C] = b(d[C], v), C++;
          }
        } catch (D) {
          y = { error: D };
        } finally {
          try {
            E && !E.done && (m = R.return) && m.call(R);
          } finally {
            if (y)
              throw y.error;
          }
        }
      };
      try {
        for (var h = rt(e.data), p = h.next(); !p.done; p = h.next()) {
          var f = p.value;
          u(f);
        }
      } catch (v) {
        t = { error: v };
      } finally {
        try {
          p && !p.done && (i = h.return) && i.call(h);
        } finally {
          if (t)
            throw t.error;
        }
      }
      for (var g = 0; g < d.length; g++)
        (s = e.reduced) !== null && s !== void 0 || (e.reduced = {}), e.reduced[a[g].property] = d[g];
    }, o.prototype.postProcessData = function(e) {
      var t, i, r, n = this.processors;
      try {
        for (var s = rt(n), a = s.next(); !a.done; a = s.next()) {
          var l = a.value;
          (r = e.reduced) !== null && r !== void 0 || (e.reduced = {}), e.reduced[l.property] = l.calculate(e);
        }
      } catch (c) {
        t = { error: c };
      } finally {
        try {
          a && !a.done && (i = s.return) && i.call(s);
        } finally {
          if (t)
            throw t.error;
        }
      }
    }, o.prototype.initDataDomainProcessor = function() {
      var e, t, i, r, n, s = this, a = s.keys, l = s.values, c = /* @__PURE__ */ new Set();
      try {
        for (var d = rt(l), u = d.next(); !u.done; u = d.next()) {
          var h = u.value;
          try {
            for (var p = (i = void 0, rt((n = h.scopes) !== null && n !== void 0 ? n : [])), f = p.next(); !f.done; f = p.next()) {
              var g = f.value;
              c.add(g);
            }
          } catch (D) {
            i = { error: D };
          } finally {
            try {
              f && !f.done && (r = p.return) && r.call(p);
            } finally {
              if (i)
                throw i.error;
            }
          }
        }
      } catch (D) {
        e = { error: D };
      } finally {
        try {
          u && !u.done && (t = d.return) && t.call(d);
        } finally {
          if (e)
            throw e.error;
        }
      }
      var v = c.size, y = /* @__PURE__ */ new Map(), m = /* @__PURE__ */ new Map(), C = !0, R = function(D, P, O) {
        var M;
        O === void 0 && (O = y), P === "category" ? O.set(D, new Wy("discrete")) : (O.set(D, new Wy("continuous")), C && (C = ((M = D.scopes) !== null && M !== void 0 ? M : []).length === v));
      }, E = function() {
        a.forEach(function(D) {
          return R(D, D.valueType);
        }), l.forEach(function(D) {
          return R(D, D.valueType);
        });
      };
      E();
      var b = this.buildAccessors.apply(this, Wt(Wt([], xt(a)), xt(l))), T = function(D, P, O) {
        var M, _, F, I, G = D.property in b, k = !1, N;
        if (G) {
          try {
            N = b[D.property](P);
          } catch (K) {
          }
          k = N !== void 0;
        } else
          k = D.property in P, N = k ? P[D.property] : D.missingValue;
        var W = "missingValue" in D;
        if (!k && !W && D.missing++, y.has(D) || E(), k) {
          var j = (_ = (M = D.validation) === null || M === void 0 ? void 0 : M.call(D, N, P)) !== null && _ !== void 0 ? _ : !0;
          if (!j)
            if ("invalidValue" in D)
              N = D.invalidValue;
            else
              return kc;
        }
        return D.processor && (m.has(D) || m.set(D, D.processor()), N = (F = m.get(D)) === null || F === void 0 ? void 0 : F(N, O !== kc ? O : void 0)), (I = y.get(D)) === null || I === void 0 || I.extend(N), N;
      };
      return { dataDomain: y, processValue: T, initDataDomain: E, scopes: c, allScopesHaveSameDefs: C };
    }, o.prototype.buildAccessors = function() {
      for (var e, t, i = [], r = 0; r < arguments.length; r++)
        i[r] = arguments[r];
      var n = {};
      try {
        for (var s = rt(i), a = s.next(); !a.done; a = s.next()) {
          var l = a.value, c = l.property.indexOf(".") >= 0 || l.property.indexOf("[") >= 0;
          if (c) {
            var d = void 0;
            l.property.startsWith("[") ? d = "return datum" + l.property + ";" : d = "return datum." + l.property + ";", n[l.property] = new Function("datum", d);
          }
        }
      } catch (u) {
        e = { error: u };
      } finally {
        try {
          a && !a.done && (t = s.return) && t.call(s);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return n;
    }, o.DEBUG = function() {
      var e;
      return (e = [!0, "data-model"].includes(Fn("agChartsDebug"))) !== null && e !== void 0 ? e : !1;
    }, o;
  }()
);
function oB(o) {
  var e, t, i = function(n, s) {
    s.length > 0 && (console.log("DataModel.processData() - " + n), console.table(s));
  };
  if (console.log("DataModel.processData() - processedData", o), i("Key Domains", o.domain.keys), i("Group Domains", (e = o.domain.groups) !== null && e !== void 0 ? e : []), i("Value Domains", o.domain.values), i("Aggregate Domains", (t = o.domain.aggValues) !== null && t !== void 0 ? t : []), o.type === "grouped") {
    var r = o.data.reduce(function(n, s) {
      var a, l, c = (a = s.keys) !== null && a !== void 0 ? a : [], d = (l = s.aggValues) !== null && l !== void 0 ? l : [], u = s.keys.map(function() {
      }), h = d == null ? void 0 : d.map(function() {
      });
      return n.push.apply(n, Wt([], xt(s.values.map(function(p, f) {
        return Wt(Wt(Wt([], xt(f === 0 ? c : u)), xt(p != null ? p : [])), xt(f == 0 ? d : h));
      })))), n;
    }, []);
    i("Values", r);
  } else {
    var r = o.data.reduce(function(s, a) {
      var l, c = (l = a.aggValues) !== null && l !== void 0 ? l : [];
      return s.push(Wt(Wt(Wt([], xt(a.keys)), xt(a.values)), xt(c))), s;
    }, []);
    i("Values", r);
  }
}
function bD() {
  return function(o, e) {
    var t = ["Property [" + o + "] is deprecated.", e].filter(function(i) {
      return i != null;
    }).join(" ");
    pe.warnOnce(t);
  };
}
function sB(o, e) {
  var t = e == null ? void 0 : e.default, i = bD();
  return Pu(function(r, n, s) {
    return s !== t && i(n.toString(), o), s;
  });
}
function aB(o, e) {
  var t = bD();
  return Pu(function(i, r, n) {
    return n !== i[o] && (t(r.toString(), "Use [" + o + "] instead."), i[o] = e ? e(n) : n), Qg;
  }, function(i, r) {
    return t(r.toString(), "Use [" + o + "] instead."), i[o];
  });
}
var cs = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, lB = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, zi = "ag-chart-tooltip", cB = `
.` + zi + ` {
    transition: transform 0.1s ease;
    display: table;
    position: fixed;
    left: 0px;
    top: 0px;
    white-space: nowrap;
    z-index: 99999;
    font: 12px Verdana, sans-serif;
    color: black;
    background: rgb(244, 244, 244);
    border-radius: 5px;
    box-shadow: 0 0 1px rgba(3, 3, 3, 0.7), 0.5vh 0.5vh 1vh rgba(3, 3, 3, 0.25);
}

.` + zi + `-no-interaction {
    pointer-events: none;
    user-select: none;
}

.` + zi + `-no-animation {
    transition: none !important;
}

.` + zi + `-hidden {
    visibility: hidden;
}

.` + zi + `-title {
    font-weight: bold;
    padding: 7px;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
    color: white;
    background-color: #888888;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
}

.` + zi + `-content {
    padding: 7px;
    line-height: 1.7em;
    border-bottom-left-radius: 5px;
    border-bottom-right-radius: 5px;
    overflow: hidden;
}

.` + zi + `-content:empty {
    padding: 0;
    height: 7px;
}

.` + zi + `-arrow::before {
    content: "";

    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);

    border: 6px solid #989898;

    border-left-color: transparent;
    border-right-color: transparent;
    border-top-color: #989898;
    border-bottom-color: transparent;

    width: 0;
    height: 0;

    margin: 0 auto;
}

.` + zi + `-arrow::after {
    content: "";

    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);

    border: 5px solid black;

    border-left-color: transparent;
    border-right-color: transparent;
    border-top-color: rgb(244, 244, 244);
    border-bottom-color: transparent;

    width: 0;
    height: 0;

    margin: 0 auto;
}

.ag-chart-wrapper {
    box-sizing: border-box;
    overflow: hidden;
}
`;
function Ti(o, e) {
  var t, i, r, n;
  if (typeof o == "string")
    return o;
  e = e != null ? e : {};
  var s = o.content, a = s === void 0 ? (t = e.content) !== null && t !== void 0 ? t : "" : s, l = o.title, c = l === void 0 ? (i = e.title) !== null && i !== void 0 ? i : void 0 : l, d = o.color, u = d === void 0 ? (r = e.color) !== null && r !== void 0 ? r : "white" : d, h = o.backgroundColor, p = h === void 0 ? (n = e.backgroundColor) !== null && n !== void 0 ? n : "#888" : h, f = c ? '<div class="' + zi + `-title"
        style="color: ` + u + "; background-color: " + p + '">' + c + "</div>" : "";
  return f + '<div class="' + zi + '-content">' + a + "</div>";
}
var dB = ["pointer", "node"], uB = Ee(function(o) {
  return dB.includes(o);
}, "expecting a position type keyword such as 'pointer' or 'node'"), wD = (
  /** @class */
  function() {
    function o() {
      this.type = "pointer", this.xOffset = 0, this.yOffset = 0;
    }
    return cs([
      A(uB)
    ], o.prototype, "type", void 0), cs([
      A(le())
    ], o.prototype, "xOffset", void 0), cs([
      A(le())
    ], o.prototype, "yOffset", void 0), o;
  }()
), hB = (
  /** @class */
  function() {
    function o(e, t, i) {
      var r = this;
      this.enableInteraction = !1, this.enabled = !0, this.showArrow = void 0, this.class = void 0, this.lastClass = void 0, this.delay = 0, this.range = "nearest", this.position = new wD(), this.showTimeout = 0, this._showArrow = !0, this.tooltipRoot = i;
      var n = t.createElement("div");
      if (this.element = this.tooltipRoot.appendChild(n), this.element.classList.add(zi), this.canvasElement = e, window.IntersectionObserver) {
        var s = new IntersectionObserver(function(l) {
          var c, d;
          try {
            for (var u = lB(l), h = u.next(); !h.done; h = u.next()) {
              var p = h.value;
              p.target === r.canvasElement && p.intersectionRatio === 0 && r.toggle(!1);
            }
          } catch (f) {
            c = { error: f };
          } finally {
            try {
              h && !h.done && (d = u.return) && d.call(u);
            } finally {
              if (c)
                throw c.error;
            }
          }
        }, { root: this.tooltipRoot });
        s.observe(this.canvasElement), this.observer = s;
      }
      if (o.tooltipDocuments.indexOf(t) < 0) {
        var a = t.createElement("style");
        a.innerHTML = cB, t.head.insertBefore(a, t.head.querySelector("style")), o.tooltipDocuments.push(t);
      }
    }
    return o.prototype.destroy = function() {
      var e = this.element.parentNode;
      e && e.removeChild(this.element), this.observer && this.observer.unobserve(this.canvasElement);
    }, o.prototype.isVisible = function() {
      var e = this.element;
      return !e.classList.contains(zi + "-hidden");
    }, o.prototype.updateClass = function(e, t) {
      var i = this, r = i.element, n = i.class, s = i.lastClass, a = i.enableInteraction, l = this.isVisible(), c = function(d, u) {
        var h = zi + "-" + d;
        u ? r.classList.add(h) : r.classList.remove(h);
      };
      c("no-animation", !l && !!e), c("no-interaction", !a), c("hidden", !e), c("arrow", !!t), n !== s && (s && r.classList.remove(s), n && r.classList.add(n), this.lastClass = n);
    }, o.prototype.show = function(e, t, i) {
      var r = this, n, s, a, l, c, d, u;
      i === void 0 && (i = !1);
      var h = this, p = h.element, f = h.canvasElement;
      if (t !== void 0)
        p.innerHTML = t;
      else if (!p.innerHTML) {
        this.toggle(!1);
        return;
      }
      var g = function(F, I, G) {
        return Math.max(Math.min(I, G), F);
      }, v = (s = (n = e.position) === null || n === void 0 ? void 0 : n.xOffset) !== null && s !== void 0 ? s : 0, y = (l = (a = e.position) === null || a === void 0 ? void 0 : a.yOffset) !== null && l !== void 0 ? l : 0, m = f.getBoundingClientRect(), C = m.left + e.offsetX - p.clientWidth / 2 + v, R = m.top + e.offsetY - p.clientHeight - 8 + y, E = this.getWindowBoundingBox(), b = E.x + E.width - p.clientWidth - 1, T = E.y + E.height - p.clientHeight, D = g(E.x, C, b), P = g(E.y, R, T), O = D !== C || P !== R, M = !O && !v && !y, _ = (d = (c = e.showArrow) !== null && c !== void 0 ? c : this.showArrow) !== null && d !== void 0 ? d : M;
      if (this.updateShowArrow(_), p.style.transform = "translate(" + Math.round(D) + "px, " + Math.round(P) + "px)", this.enableInteraction = (u = e.enableInteraction) !== null && u !== void 0 ? u : !1, this.delay > 0 && !i) {
        this.toggle(!1), this.showTimeout = window.setTimeout(function() {
          r.toggle(!0);
        }, this.delay);
        return;
      }
      this.toggle(!0);
    }, o.prototype.getWindowBoundingBox = function() {
      return new nt(0, 0, window.innerWidth, window.innerHeight);
    }, o.prototype.toggle = function(e) {
      e || window.clearTimeout(this.showTimeout), this.updateClass(e, this._showArrow);
    }, o.prototype.pointerLeftOntoTooltip = function(e) {
      var t;
      if (!this.enableInteraction)
        return !1;
      var i = (t = e.sourceEvent.relatedTarget) === null || t === void 0 ? void 0 : t.classList, r = ["", "-title", "-content"], n = !!r.filter(function(s) {
        return i == null ? void 0 : i.contains("" + zi + s);
      });
      return i !== void 0 && n;
    }, o.prototype.updateShowArrow = function(e) {
      this._showArrow = e;
    }, o.tooltipDocuments = [], cs([
      A(ht)
    ], o.prototype, "enabled", void 0), cs([
      A(_o)
    ], o.prototype, "showArrow", void 0), cs([
      A(De)
    ], o.prototype, "class", void 0), cs([
      A(le(0))
    ], o.prototype, "delay", void 0), cs([
      aB("range", function(e) {
        return e ? "nearest" : "exact";
      })
    ], o.prototype, "tracking", void 0), cs([
      A(SD)
    ], o.prototype, "range", void 0), o;
  }()
), pB = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function ED(o, e) {
  var t, i;
  e === void 0 && (e = [0, 0]);
  try {
    for (var r = pB(o), n = r.next(); !n.done; n = r.next()) {
      var s = n.value;
      typeof s == "number" && (s < 0 && (e[0] += s), s > 0 && (e[1] += s));
    }
  } catch (a) {
    t = { error: a };
  } finally {
    try {
      n && !n.done && (i = r.return) && i.call(r);
    } finally {
      if (t)
        throw t.error;
    }
  }
  return e;
}
function fB(o, e, t) {
  return {
    id: e,
    scopes: [o.id],
    type: "aggregate",
    matchGroupIds: t ? [t] : void 0,
    aggregateFunction: function(i) {
      return ED(i);
    },
    groupAggregateFunction: function(i, r) {
      var n, s;
      return r === void 0 && (r = [0, 0]), r[0] += (n = i == null ? void 0 : i[0]) !== null && n !== void 0 ? n : 0, r[1] += (s = i == null ? void 0 : i[1]) !== null && s !== void 0 ? s : 0, r;
    }
  };
}
function w0(o, e) {
  return {
    id: e,
    scopes: [o.id],
    type: "aggregate",
    aggregateFunction: function() {
      return [0, 1];
    },
    groupAggregateFunction: function(t, i) {
      var r, n;
      return i === void 0 && (i = [0, 0]), i[0] += (r = t == null ? void 0 : t[0]) !== null && r !== void 0 ? r : 0, i[1] += (n = t == null ? void 0 : t[1]) !== null && n !== void 0 ? n : 0, i;
    }
  };
}
function gB(o, e, t) {
  var i = {
    id: e,
    scopes: [o.id],
    matchGroupIds: t ? [t] : void 0,
    type: "aggregate",
    aggregateFunction: function(r) {
      return ED(r);
    },
    groupAggregateFunction: function(r, n) {
      var s, a;
      return n === void 0 && (n = [0, 0, -1]), n[0] += (s = r == null ? void 0 : r[0]) !== null && s !== void 0 ? s : 0, n[1] += (a = r == null ? void 0 : r[1]) !== null && a !== void 0 ? a : 0, n[2]++, n;
    },
    finalFunction: function(r) {
      r === void 0 && (r = [0, 0, 0]);
      var n = r[0] + r[1];
      return n >= 0 ? [0, n / r[2]] : [n / r[2], 0];
    }
  };
  return i;
}
function E0(o, e, t, i) {
  var r = {
    id: e,
    scopes: [o.id],
    matchGroupIds: i ? [i] : void 0,
    type: "aggregate",
    aggregateFunction: function(n, s) {
      s === void 0 && (s = []);
      var a = s[1] - s[0];
      return t.aggregateFunction(n).map(function(l) {
        return l / a;
      });
    }
  };
  return t.groupAggregateFunction && (r.groupAggregateFunction = t.groupAggregateFunction), r;
}
function vB() {
  return function() {
    var o = 0;
    return function(e) {
      return typeof e != "number" || isNaN(e) ? e : (o += e, o);
    };
  };
}
var rh = /* @__PURE__ */ new Map();
function ev(o, e) {
  var t, i, r, n = JSON.stringify(o, null, 0);
  return rh.has(e) || rh.set(e, /* @__PURE__ */ new Map()), !((t = rh.get(e)) === null || t === void 0) && t.has(n) || (i = rh.get(e)) === null || i === void 0 || i.set(n, e(o)), (r = rh.get(e)) === null || r === void 0 ? void 0 : r.get(n);
}
var RD = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, mB = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, Xd = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, jy = {
  type: "reducer",
  property: "smallestKeyInterval",
  initialValue: 1 / 0,
  reducer: function() {
    var o = NaN;
    return function(e, t) {
      var i = t.keys[0], r = Math.abs(i - o);
      return o = i, !isNaN(r) && r > 0 && r < e ? r : e;
    };
  }
}, yB = {
  type: "processor",
  property: "sortedGroupDomain",
  calculate: function(o) {
    var e = o.domain.groups;
    if (e != null)
      return mB([], RD(e)).sort(function(t, i) {
        for (var r = 0; r < t.length; r++) {
          var n = t[r] - i[r];
          if (n !== 0)
            return n;
        }
        return 0;
      });
  }
};
function CB(o) {
  var e = o.normaliseTo, t = o.mode, i = function(r, n) {
    var s = r * e / n;
    return s >= 0 ? Math.min(e, s) : Math.max(-e, s);
  };
  return function() {
    return function() {
      return function(r, n) {
        var s, a, l, c, d = [0, 0];
        try {
          for (var u = Xd(n), h = u.next(); !h.done; h = u.next()) {
            var p = h.value, f = r[p], g = f < 0 ? 0 : 1;
            t === "sum" ? d[g] += f : g === 0 ? d[g] = Math.min(d[g], f) : d[g] = Math.max(d[g], f);
          }
        } catch (C) {
          s = { error: C };
        } finally {
          try {
            h && !h.done && (a = u.return) && a.call(u);
          } finally {
            if (s)
              throw s.error;
          }
        }
        var v = Math.max(Math.abs(d[0]), d[1]);
        try {
          for (var y = Xd(n), m = y.next(); !m.done; m = y.next()) {
            var p = m.value;
            r[p] = i(r[p], v);
          }
        } catch (C) {
          l = { error: C };
        } finally {
          try {
            m && !m.done && (c = y.return) && c.call(y);
          } finally {
            if (l)
              throw l.error;
          }
        }
      };
    };
  };
}
function UC(o, e, t, i) {
  return i === void 0 && (i = "sum"), {
    scopes: [o.id],
    type: "group-value-processor",
    matchGroupIds: e,
    adjust: ev({ normaliseTo: t, mode: i }, CB)
  };
}
function SB(o) {
  var e = o.normaliseTo, t = o.rangeMin, i = o.rangeMax, r = e[1] - e[0], n = function(s, a, l) {
    var c = e[0] + (s - a) / l * r;
    return l === 0 || c >= e[1] ? e[1] : c < e[0] ? e[0] : c;
  };
  return function() {
    return function(s, a) {
      var l, c, d, u, h = RD(s.domain.values[a], 2), p = h[0], f = h[1];
      t != null && (p = t), i != null && (f = i);
      var g = f - p;
      s.domain.values[a] = [e[0], e[1]];
      try {
        for (var v = Xd(s.data), y = v.next(); !y.done; y = v.next()) {
          var m = y.value, C = m.values;
          s.type === "ungrouped" && (C = [C]);
          try {
            for (var R = (d = void 0, Xd(C)), E = R.next(); !E.done; E = R.next()) {
              var b = E.value;
              b[a] = n(b[a], p, g);
            }
          } catch (T) {
            d = { error: T };
          } finally {
            try {
              E && !E.done && (u = R.return) && u.call(R);
            } finally {
              if (d)
                throw d.error;
            }
          }
        }
      } catch (T) {
        l = { error: T };
      } finally {
        try {
          y && !y.done && (c = v.return) && c.call(v);
        } finally {
          if (l)
            throw l.error;
        }
      }
    };
  };
}
function R0(o, e, t, i, r) {
  return {
    scopes: [o.id],
    type: "property-value-processor",
    property: e,
    adjust: ev({ normaliseTo: t, rangeMin: i, rangeMax: r }, SB)
  };
}
function bB(o) {
  return function() {
    return function() {
      return function(e, t) {
        var i, r, n = 0;
        try {
          for (var s = Xd(t), a = s.next(); !a.done; a = s.next()) {
            var l = a.value, c = e[l];
            typeof c != "number" || isNaN(c) || (o === "normal" && (n += c), e[l] = n, o === "trailing" && (n += c));
          }
        } catch (d) {
          i = { error: d };
        } finally {
          try {
            a && !a.done && (r = s.return) && r.call(s);
          } finally {
            if (i)
              throw i.error;
          }
        }
      };
    };
  };
}
function wB(o) {
  var e = o.mode, t = o.sum;
  return function() {
    var i = [], r = !0;
    return function() {
      return function(n, s) {
        var a, l, c = 0;
        try {
          for (var d = Xd(s), u = d.next(); !u.done; u = d.next()) {
            var h = u.value, p = n[h], f = r && t === "current" ? 0 : i[h];
            i[h] = p;
            var g = t === "current" ? p : f;
            if (typeof p != "number" || isNaN(p)) {
              n[h] = g;
              continue;
            }
            if (typeof f != "number" || isNaN(f)) {
              n[h] = g;
              continue;
            }
            e === "normal" && (c += g), n[h] = c, e === "trailing" && (c += g);
          }
        } catch (v) {
          a = { error: v };
        } finally {
          try {
            u && !u.done && (l = d.return) && l.call(d);
          } finally {
            if (a)
              throw a.error;
          }
        }
        r = !1;
      };
    };
  };
}
function EB(o, e, t, i) {
  var r;
  if (t.startsWith("window")) {
    var n = t.endsWith("-trailing") ? "trailing" : "normal";
    r = ev({ mode: n, sum: i }, wB);
  } else
    r = ev(t, bB);
  return {
    scopes: [o.id],
    type: "group-value-processor",
    matchGroupIds: [e],
    adjust: r
  };
}
function TD(o, e) {
  return e === void 0 && (e = !0), {
    type: "processor",
    property: "diff",
    calculate: function(t) {
      for (var i = {
        changed: !1,
        added: [],
        updated: [],
        removed: []
      }, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), a = "___", l = 0; l < Math.max(o.data.length, t.data.length); l++) {
        var c = o.data[l], d = t.data[l], u = c == null ? void 0 : c.keys.join(a), h = d == null ? void 0 : d.keys.join(a);
        if (u === h) {
          yg(c.values, d.values) || n.set(h, d);
          continue;
        }
        s.has(h) ? ((e || !yg(s.get(h).values, d.values)) && n.set(h, d), s.delete(h)) : d && r.set(h, d), r.has(u) ? ((e || !yg(r.get(u).values, c.values)) && n.set(u, c), r.delete(u)) : c && s.set(u, c);
      }
      return i.added = Array.from(r.values()).map(function(p) {
        return p.keys;
      }), i.updated = Array.from(n.values()).map(function(p) {
        return p.keys;
      }), i.removed = Array.from(s.values()).map(function(p) {
        return p.keys;
      }), i.changed = i.added.length > 0 || i.updated.length > 0 || i.removed.length > 0, i;
    }
  };
}
function yg(o, e) {
  if (o == null || e == null || o.length !== e.length)
    return !1;
  for (var t = 0; t < o.length; t++) {
    if (Array.isArray(o[t]) && Array.isArray(e[t]))
      return yg(o[t], e[t]);
    if (o[t] !== e[t])
      return !1;
  }
  return !0;
}
function qt(o, e) {
  return Pu(function(t, i, r) {
    return t[o][e != null ? e : i] = r, r;
  });
}
function lo(o) {
  var e = o.newValue, t = o.oldValue, i = o.changeValue;
  return Pu(function(r, n, s, a) {
    return s !== a && (a !== void 0 && (t == null || t.call(r, a)), s !== void 0 && (e == null || e.call(r, s)), i == null || i.call(r, s, a)), s;
  });
}
var Zb = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Ul = function() {
  return Ul = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, Ul.apply(this, arguments);
}, Ci = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, RB = function(o, e) {
  var t = {};
  for (var i in o)
    Object.prototype.hasOwnProperty.call(o, i) && e.indexOf(i) < 0 && (t[i] = o[i]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(o); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(o, i[r]) && (t[i[r]] = o[i[r]]);
  return t;
}, T0 = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Uy = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, TB = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, Zt;
(function(o) {
  o[o.EXACT_SHAPE_MATCH = 0] = "EXACT_SHAPE_MATCH", o[o.NEAREST_BY_MAIN_AXIS_FIRST = 1] = "NEAREST_BY_MAIN_AXIS_FIRST", o[o.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST = 2] = "NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST", o[o.NEAREST_NODE = 3] = "NEAREST_NODE";
})(Zt || (Zt = {}));
function Qb(o) {
  return up(o, !0) != null;
}
function xD(o) {
  return up(o, !1) != null;
}
function Jb(o, e, t, i) {
  i === void 0 && (i = {});
  var r = Ul({ scopes: [o.id], property: e, type: "key", valueType: t ? "range" : "category", validation: t ? Qb : xD }, i);
  return r;
}
function wi(o, e, t, i) {
  i === void 0 && (i = {});
  var r = Ul({ scopes: [o.id], property: e, type: "value", valueType: t ? "range" : "category", validation: t ? Qb : xD }, i);
  return r;
}
function xB(o, e, t) {
  t === void 0 && (t = {});
  var i = t.min, r = i === void 0 ? -1 / 0 : i, n = t.max, s = n === void 0 ? 1 / 0 : n, a = RB(t, ["min", "max"]);
  return Ul({ scopes: [o.id], type: "value", property: e, valueType: "range", validation: Qb, processor: function() {
    return function(l) {
      return typeof l != "number" || isNaN(l) ? l : Math.min(Math.max(l, r), s);
    };
  } }, a);
}
function DB(o, e, t, i) {
  i === void 0 && (i = {});
  var r = Ul(Ul({}, wi(o, e, t, i)), { processor: vB() });
  return r;
}
function bl(o, e, t, i, r, n) {
  return r === void 0 && (r = "current"), [wi(o, e, t, n), EB(o, n.groupId, i, r)];
}
var gf = (
  /** @class */
  function() {
    function o(e, t, i) {
      this.type = "nodeClick", this.event = e, this.datum = t.datum, this.seriesId = i.id;
    }
    return o;
  }()
), OB = (
  /** @class */
  function(o) {
    Zb(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e;
  }(gf)
), PB = (
  /** @class */
  function(o) {
    Zb(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.type = "nodeDoubleClick", t;
    }
    return e;
  }(gf)
), AB = (
  /** @class */
  function() {
    function o() {
      this.fill = "yellow", this.fillOpacity = void 0, this.stroke = void 0, this.strokeWidth = void 0;
    }
    return Ci([
      A(St)
    ], o.prototype, "fill", void 0), Ci([
      A(lt(0, 1))
    ], o.prototype, "fillOpacity", void 0), Ci([
      A(St)
    ], o.prototype, "stroke", void 0), Ci([
      A(lt(0))
    ], o.prototype, "strokeWidth", void 0), o;
  }()
), MB = (
  /** @class */
  function() {
    function o() {
      this.strokeWidth = void 0, this.dimOpacity = void 0, this.enabled = void 0;
    }
    return Ci([
      A(lt(0))
    ], o.prototype, "strokeWidth", void 0), Ci([
      A(lt(0, 1))
    ], o.prototype, "dimOpacity", void 0), Ci([
      A(_o)
    ], o.prototype, "enabled", void 0), o;
  }()
), _B = (
  /** @class */
  function() {
    function o() {
      this.color = "black";
    }
    return Ci([
      A(St)
    ], o.prototype, "color", void 0), o;
  }()
), ew = (
  /** @class */
  function() {
    function o() {
      this.item = new AB(), this.series = new MB(), this.text = new _B();
    }
    return o;
  }()
), vc = (
  /** @class */
  function() {
    function o() {
      this.enabled = !0, this.showArrow = void 0, this.interaction = new IB(), this.position = new wD();
    }
    return Ci([
      A(ht)
    ], o.prototype, "enabled", void 0), Ci([
      A(_o)
    ], o.prototype, "showArrow", void 0), o;
  }()
), IB = (
  /** @class */
  function() {
    function o() {
      this.enabled = !1;
    }
    return Ci([
      A(ht)
    ], o.prototype, "enabled", void 0), o;
  }()
), Hm = (
  /** @class */
  function(o) {
    Zb(e, o);
    function e(t) {
      var i, r = o.call(this) || this;
      r.id = Vs(r), r.rootGroup = new we({ name: "seriesRoot", isVirtual: !0 }), r.axes = (i = {}, i[de.X] = void 0, i[de.Y] = void 0, i), r.directions = [de.X, de.Y], r.nodeDataRefresh = !0, r._data = void 0, r._visible = !0, r.showInLegend = !0, r.cursor = "default", r.nodeClickRange = "exact", r.seriesGrouping = void 0, r._declarationOrder = -1, r.highlightStyle = new ew(), r.ctx = t.moduleCtx;
      var n = t.useLabelLayer, s = n === void 0 ? !1 : n, a = t.pickModes, l = a === void 0 ? [Zt.NEAREST_BY_MAIN_AXIS_FIRST] : a, c = t.directionKeys, d = c === void 0 ? {} : c, u = t.directionNames, h = u === void 0 ? {} : u, p = t.contentGroupVirtual, f = p === void 0 ? !0 : p, g = r.rootGroup;
      return r.directionKeys = d, r.directionNames = h, r.contentGroup = g.appendChild(new we({
        name: r.id + "-content",
        layer: !f,
        isVirtual: f,
        zIndex: kt.SERIES_LAYER_ZINDEX,
        zIndexSubOrder: r.getGroupZIndexSubOrder("data")
      })), r.highlightGroup = g.appendChild(new we({
        name: r.id + "-highlight",
        layer: !0,
        zIndex: kt.SERIES_LAYER_ZINDEX,
        zIndexSubOrder: r.getGroupZIndexSubOrder("highlight")
      })), r.highlightNode = r.highlightGroup.appendChild(new we({ name: "highlightNode" })), r.highlightLabel = r.highlightGroup.appendChild(new we({ name: "highlightLabel" })), r.highlightNode.zIndex = 0, r.highlightLabel.zIndex = 10, r.pickModes = l, s && (r.labelGroup = g.appendChild(new we({
        name: r.id + "-series-labels",
        layer: !0,
        zIndex: kt.SERIES_LABEL_ZINDEX
      }))), r;
    }
    return Object.defineProperty(e.prototype, "type", {
      get: function() {
        var t;
        return (t = this.constructor.type) !== null && t !== void 0 ? t : "";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "data", {
      get: function() {
        return this._data;
      },
      set: function(t) {
        this._data = t, this.nodeDataRefresh = !0;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.hasData = function() {
      var t = this.data;
      return t && (!Array.isArray(t) || t.length > 0);
    }, Object.defineProperty(e.prototype, "visible", {
      get: function() {
        return this._visible;
      },
      set: function(t) {
        this._visible = t, this.visibleChanged();
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.onSeriesGroupingChange = function(t, i) {
      var r = this, n = this, s = n.id, a = n.type, l = n.visible, c = n.rootGroup;
      t && this.ctx.seriesStateManager.deregisterSeries({ id: s, type: a }), i && this.ctx.seriesStateManager.registerSeries({ id: s, type: a, visible: l, seriesGrouping: i }), this.ctx.seriesLayerManager.changeGroup({
        id: s,
        type: a,
        rootGroup: c,
        getGroupZIndexSubOrder: function(d) {
          return r.getGroupZIndexSubOrder(d);
        },
        seriesGrouping: i,
        oldGrouping: t
      });
    }, e.prototype.getBandScalePadding = function() {
      return { inner: 1, outer: 0 };
    }, e.prototype.getGroupZIndexSubOrder = function(t, i) {
      var r = this;
      i === void 0 && (i = 0);
      var n = 0;
      switch (t) {
        case "data":
        case "paths":
          break;
        case "labels":
          n += 2e4;
          break;
        case "marker":
          n += 1e4;
          break;
        case "highlight":
          i += 15e3;
          break;
      }
      var s = function() {
        return r._declarationOrder + n;
      };
      return [s, i];
    }, e.prototype.addChartEventListeners = function() {
    }, e.prototype.destroy = function() {
      this.ctx.seriesStateManager.deregisterSeries(this), this.ctx.seriesLayerManager.releaseGroup(this);
    }, e.prototype.getDirectionValues = function(t, i) {
      var r = this, n = this.resolveKeyDirection(t), s = i == null ? void 0 : i[n], a = [], l = function() {
        for (var d, u, h = [], p = 0; p < arguments.length; p++)
          h[p] = arguments[p];
        try {
          for (var f = T0(h), g = f.next(); !g.done; g = f.next()) {
            var v = g.value;
            c(v);
          }
        } catch (y) {
          d = { error: y };
        } finally {
          try {
            g && !g.done && (u = f.return) && u.call(f);
          } finally {
            if (d)
              throw d.error;
          }
        }
      }, c = function(d) {
        Array.isArray(d) ? l.apply(void 0, TB([], Uy(d))) : typeof d == "object" ? l(Object.values(d)) : a.push(d);
      };
      return s && s.forEach(function(d) {
        var u = r[d];
        c(u);
      }), a;
    }, e.prototype.getKeys = function(t) {
      return this.getDirectionValues(t, this.directionKeys);
    }, e.prototype.getNames = function(t) {
      return this.getDirectionValues(t, this.directionNames);
    }, e.prototype.resolveKeyDirection = function(t) {
      return t;
    }, e.prototype.markNodeDataDirty = function() {
      this.nodeDataRefresh = !0;
    }, e.prototype.visibleChanged = function() {
      this.ctx.seriesStateManager.registerSeries(this);
    }, e.prototype.getOpacity = function(t) {
      var i = this.highlightStyle.series, r = i.dimOpacity, n = r === void 0 ? 1 : r, s = i.enabled, a = s === void 0 ? !0 : s, l = 1;
      if (a === !1 || n === l)
        return l;
      switch (this.isItemIdHighlighted(t)) {
        case "no-highlight":
        case "highlighted":
          return l;
        case "peer-highlighted":
        case "other-highlighted":
          return n;
      }
    }, e.prototype.getStrokeWidth = function(t, i) {
      var r = this.highlightStyle.series, n = r.strokeWidth, s = r.enabled, a = s === void 0 ? !0 : s;
      if (a === !1 || n === void 0)
        return t;
      switch (this.isItemIdHighlighted(i)) {
        case "highlighted":
          return n;
        case "no-highlight":
        case "other-highlighted":
        case "peer-highlighted":
          return t;
      }
    }, e.prototype.isItemIdHighlighted = function(t) {
      var i, r = (i = this.ctx.highlightManager) === null || i === void 0 ? void 0 : i.getActiveHighlight(), n = r != null ? r : {}, s = n.series, a = n.itemId, l = s != null;
      return l ? s !== this ? "other-highlighted" : a === void 0 ? "highlighted" : t && r !== t && a !== t.itemId ? "peer-highlighted" : "highlighted" : "no-highlight";
    }, e.prototype.pickNode = function(t, i) {
      var r, n, s = this, a = s.pickModes, l = s.visible, c = s.rootGroup;
      if (!(!l || !c.visible))
        try {
          for (var d = T0(a), u = d.next(); !u.done; u = d.next()) {
            var h = u.value;
            if (!(i && !i.includes(h))) {
              var p = void 0;
              switch (h) {
                case Zt.EXACT_SHAPE_MATCH:
                  p = this.pickNodeExactShape(t);
                  break;
                case Zt.NEAREST_BY_MAIN_AXIS_FIRST:
                case Zt.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST:
                  p = this.pickNodeMainAxisFirst(t, h === Zt.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST);
                  break;
                case Zt.NEAREST_NODE:
                  p = this.pickNodeClosestDatum(t);
                  break;
              }
              if (p)
                return { pickMode: h, match: p.datum, distance: p.distance };
            }
          }
        } catch (f) {
          r = { error: f };
        } finally {
          try {
            u && !u.done && (n = d.return) && n.call(d);
          } finally {
            if (r)
              throw r.error;
          }
        }
    }, e.prototype.pickNodeExactShape = function(t) {
      var i = this.contentGroup.pickNode(t.x, t.y);
      if (i)
        return {
          datum: i.datum,
          distance: 0
        };
    }, e.prototype.pickNodeClosestDatum = function(t) {
      throw new Error("AG Charts - Series.pickNodeClosestDatum() not implemented");
    }, e.prototype.pickNodeMainAxisFirst = function(t, i) {
      throw new Error("AG Charts - Series.pickNodeMainAxisFirst() not implemented");
    }, e.prototype.fireNodeClickEvent = function(t, i) {
      var r = this.getNodeClickEvent(t, i);
      this.fireEvent(r);
    }, e.prototype.fireNodeDoubleClickEvent = function(t, i) {
      var r = this.getNodeDoubleClickEvent(t, i);
      this.fireEvent(r);
    }, e.prototype.getNodeClickEvent = function(t, i) {
      return new OB(t, i, this);
    }, e.prototype.getNodeDoubleClickEvent = function(t, i) {
      return new PB(t, i, this);
    }, e.prototype.toggleSeriesItem = function(t, i) {
      this.visible = i, this.nodeDataRefresh = !0;
    }, e.prototype.isEnabled = function() {
      return this.visible;
    }, e.prototype.fixNumericExtent = function(t, i) {
      var r, n = mg(t);
      if (n.length === 0)
        return n;
      var s = Uy(n, 2), a = s[0], l = s[1];
      if (a === l) {
        var c = Uy((r = i == null ? void 0 : i.calculatePadding(a, l)) !== null && r !== void 0 ? r : [1, 1], 2), d = c[0], u = c[1];
        a -= d, l += u;
      }
      return [a, l];
    }, e.highlightedZIndex = 1e12, Ci([
      A(Ri)
    ], e.prototype, "id", void 0), Ci([
      A(ht)
    ], e.prototype, "_visible", void 0), Ci([
      A(ht)
    ], e.prototype, "showInLegend", void 0), Ci([
      A(Ri)
    ], e.prototype, "cursor", void 0), Ci([
      A(SD)
    ], e.prototype, "nodeClickRange", void 0), Ci([
      lo({
        changeValue: function(t, i) {
          this.onSeriesGroupingChange(i, t);
        }
      })
    ], e.prototype, "seriesGrouping", void 0), e;
  }(hD)
), qf = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, tv = (
  /** @class */
  function() {
    function o(e, t, i, r) {
      e === void 0 && (e = 0), t === void 0 && (t = e), i === void 0 && (i = e), r === void 0 && (r = t), this.top = e, this.right = t, this.bottom = i, this.left = r;
    }
    return o.prototype.clear = function() {
      this.top = this.right = this.bottom = this.left = 0;
    }, qf([
      A(le(0))
    ], o.prototype, "top", void 0), qf([
      A(le(0))
    ], o.prototype, "right", void 0), qf([
      A(le(0))
    ], o.prototype, "bottom", void 0), qf([
      A(le(0))
    ], o.prototype, "left", void 0), o;
  }()
), FB = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, x0 = (
  /** @class */
  function() {
    function o() {
    }
    return o.init = function() {
      var e = this, t = window.ResizeObserver;
      if (t)
        this.resizeObserver = new t(function(r) {
          var n, s;
          try {
            for (var a = FB(r), l = a.next(); !l.done; l = a.next()) {
              var c = l.value, d = c.contentRect, u = d.width, h = d.height;
              e.checkSize(e.elements.get(c.target), c.target, u, h);
            }
          } catch (p) {
            n = { error: p };
          } finally {
            try {
              l && !l.done && (s = a.return) && s.call(a);
            } finally {
              if (n)
                throw n.error;
            }
          }
        });
      else {
        var i = function() {
          e.elements.forEach(function(r, n) {
            e.checkClientSize(n, r);
          });
        };
        this.pollerHandler = window.setInterval(i, 100);
      }
      this.ready = !0;
    }, o.destroy = function() {
      var e;
      this.pollerHandler != null && (clearInterval(this.pollerHandler), this.pollerHandler = void 0), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), this.resizeObserver = void 0, this.ready = !1;
    }, o.checkSize = function(e, t, i, r) {
      e && (!e.size || i !== e.size.width || r !== e.size.height) && (e.size = { width: i, height: r }, e.cb(e.size, t));
    }, o.observe = function(e, t) {
      this.ready || this.init(), this.unobserve(e, !1), this.resizeObserver && this.resizeObserver.observe(e), this.elements.set(e, { cb: t }), this.checkClientSize(e, { cb: t });
    }, o.unobserve = function(e, t) {
      t === void 0 && (t = !0), this.resizeObserver && this.resizeObserver.unobserve(e), this.elements.delete(e), t && this.elements.size === 0 && this.destroy();
    }, o.checkClientSize = function(e, t) {
      var i = e.clientWidth ? e.clientWidth : 0, r = e.clientHeight ? e.clientHeight : 0;
      this.checkSize(t, e, i, r);
    }, o.elements = /* @__PURE__ */ new Map(), o.ready = !1, o;
  }()
);
function LB(o, e, t, i, r) {
  var n = o.x;
  o.x < e ? n = e : o.x > e + i && (n = e + i);
  var s = o.y;
  o.y < t ? s = t : o.y > t + r && (s = t + r);
  var a = o.x - n, l = o.y - s, c = Math.sqrt(a * a + l * l);
  return c <= o.size * 0.5;
}
function DD(o, e, t, i, r) {
  var n = o.x + o.width > e && o.x < e + i, s = o.y + o.height > t && o.y < t + r;
  return n && s;
}
function NB(o, e, t, i, r) {
  return e + i < o.x + o.width && e > o.x && t > o.y && t + r < o.y + o.height;
}
function GB(o) {
  return o != null && typeof o.point == "object" && typeof o.label == "object";
}
function kB(o, e, t) {
  t === void 0 && (t = 5);
  var i = [];
  o = o.map(function(d) {
    return d.slice().sort(function(u, h) {
      return h.point.size - u.point.size;
    });
  });
  for (var r = 0; r < o.length; r++) {
    var n = i[r] = [], s = o[r];
    if (s != null && s.length && s[0].label)
      for (var a = function(d, u) {
        var h = s[d], p = h.label, f = h.point.size * 0.5, g = h.point.x - p.width * 0.5, v = h.point.y - f - p.height - t, y = p.width, m = p.height, C = !e || NB(e, g, v, y, m);
        if (!C)
          return "continue";
        var R = o.some(function(b) {
          return b.some(function(T) {
            return LB(T.point, g, v, y, m);
          });
        });
        if (R)
          return "continue";
        var E = i.some(function(b) {
          return b.some(function(T) {
            return DD(T, g, v, y, m);
          });
        });
        if (E)
          return "continue";
        n.push({
          index: d,
          text: p.text,
          x: g,
          y: v,
          width: y,
          height: m,
          datum: h
        });
      }, l = 0, c = s.length; l < c; l++)
        a(l, c);
  }
  return i;
}
function VB(o, e) {
  for (var t = [], i = function(s) {
    var a = o[s], l = a.point, c = l.x, d = l.y, u = a.label.text, h = a.label, p = h.width, f = h.height;
    p += e != null ? e : 0, f += e != null ? e : 0;
    var g = t.some(function(v) {
      var y = DD(v, c, d, p, f);
      return y;
    });
    if (g)
      return { value: !0 };
    t.push({
      index: s,
      text: u,
      x: c,
      y: d,
      width: p,
      height: f,
      datum: a
    });
  }, r = 0; r < o.length; r++) {
    var n = i(r);
    if (typeof n == "object")
      return n.value;
  }
  return !1;
}
var BB = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, HB = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
};
function WB(o) {
  return OD(function(e, t) {
    return requestAnimationFrame(e);
  }, o);
}
function jB(o) {
  return OD(function(e, t) {
    return t === void 0 && (t = 0), setTimeout(e, t);
  }, o);
}
function OD(o, e) {
  var t = 0, i = !1, r, n, s = function() {
    return i;
  }, a = function() {
    i = !1, n == null || n(), n = void 0, r = void 0, t > 0 && o(l);
  }, l = function() {
    var c = t;
    t = 0, i = !0;
    var d = e({ count: c });
    if (!d) {
      a();
      return;
    }
    d.then(a).catch(a);
  };
  return {
    schedule: function(c) {
      t === 0 && !s() && o(l, c), t++;
    },
    await: function() {
      return BB(this, void 0, void 0, function() {
        return HB(this, function(c) {
          switch (c.label) {
            case 0:
              if (!s())
                return [
                  2
                  /*return*/
                ];
              r == null && (r = new Promise(function(d) {
                n = d;
              })), c.label = 1;
            case 1:
              return s() ? [4, r] : [3, 3];
            case 2:
              return c.sent(), [3, 1];
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
  };
}
function D0(o) {
  return new Promise(function(e) {
    setTimeout(function() {
      return e(void 0);
    }, o);
  });
}
var O0 = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, UB = (
  /** @class */
  function() {
    function o(e, t) {
      this.renderer = void 0, this.text = void 0, this.className = e, this.parentElement = t;
    }
    return o.prototype.show = function(e) {
      var t, i, r = this.element;
      if (r || (r = document.createElement("div"), r.className = this.className, this.element = r), r.style.position = "absolute", r.style.left = e.x + "px", r.style.top = e.y + "px", r.style.width = e.width + "px", r.style.height = e.height + "px", this.renderer)
        r.innerHTML = this.renderer();
      else {
        var n = document.createElement("div");
        n.style.alignItems = "center", n.style.boxSizing = "border-box", n.style.display = "flex", n.style.justifyContent = "center", n.style.margin = "8px", n.style.height = "100%", n.style.font = "12px Verdana, sans-serif", n.innerText = (t = this.text) !== null && t !== void 0 ? t : "No data to display", r.append(n);
      }
      (i = this.parentElement) === null || i === void 0 || i.append(r);
    }, o.prototype.hide = function() {
      var e;
      (e = this.element) === null || e === void 0 || e.remove(), this.element = void 0;
    }, O0([
      A(Pt)
    ], o.prototype, "renderer", void 0), O0([
      A(De)
    ], o.prototype, "text", void 0), o;
  }()
), $B = (
  /** @class */
  function() {
    function o(e) {
      this.noData = new UB("ag-chart-no-data-overlay", e);
    }
    return o;
  }()
), ds = function() {
  return ds = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, ds.apply(this, arguments);
}, sa = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, aa = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, PD = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function Sa(o, e) {
  var t, i, r = an(o), n = an(e);
  if (n === "array") {
    var s = e;
    return r !== "array" || o.length !== s.length ? aa([], sa(s)) : s.some(function(v, y) {
      var m;
      return Sa((m = o) === null || m === void 0 ? void 0 : m[y], v) != null;
    }) ? aa([], sa(s)) : null;
  }
  if (n === "primitive")
    return r !== "primitive" ? ds({}, e) : o !== e ? e : null;
  var a = o || {}, l = e || {}, c = new Set(aa(aa([], sa(Object.keys(a))), sa(Object.keys(l)))), d = 0, u = {}, h = function(v) {
    if (a[v] === l[v])
      return "continue";
    var y = function(E) {
      u[v] = E, d++;
    }, m = an(a[v]), C = an(l[v]);
    if (m !== C || C === "primitive" || C === null || C === "array" && a[v].length !== l[v].length || C === "class-instance" || C === "function" && a[v] !== l[v])
      return y(l[v]), "continue";
    var R = Sa(a[v], l[v]);
    R !== null && y(R);
  };
  try {
    for (var p = PD(c), f = p.next(); !f.done; f = p.next()) {
      var g = f.value;
      h(g);
    }
  } catch (v) {
    t = { error: v };
  } finally {
    try {
      f && !f.done && (i = p.return) && i.call(p);
    } finally {
      if (t)
        throw t.error;
    }
  }
  return d === 0 ? null : u;
}
var nn = Symbol("<delete-property>"), P0 = Symbol("<unspecified-property>");
function Ft(o, e) {
  var t, i, r, n = (r = e == null ? void 0 : e.avoidDeepClone) !== null && r !== void 0 ? r : [], s = o.map(function(f) {
    return an(f);
  });
  if (s.some(function(f) {
    return f === "array";
  })) {
    var a = o[o.length - 1];
    return a instanceof Array ? a.map(function(f) {
      var g = an(f);
      return g === "array" ? Ft([[], f], e) : g === "object" ? Ft([{}, f], e) : f;
    }) : a;
  }
  var l = {}, c = new Set(o.map(function(f) {
    return f != null ? Object.keys(f) : [];
  }).reduce(function(f, g) {
    return f.concat(g);
  }, [])), d = function(f) {
    var g = o.map(function(C) {
      return C != null && typeof C == "object" && f in C ? C[f] : P0;
    }).filter(function(C) {
      return C !== P0;
    });
    if (g.length === 0)
      return "continue";
    var v = g[g.length - 1];
    if (v === nn)
      return "continue";
    var y = g.map(function(C) {
      return an(C);
    }), m = y[0];
    if (y.some(function(C) {
      return C !== m;
    }))
      return l[f] = v, "continue";
    (m === "array" || m === "object") && !n.includes(f) ? l[f] = Ft(g, e) : m === "array" ? l[f] = aa([], sa(v)) : l[f] = v;
  };
  try {
    for (var u = PD(c), h = u.next(); !h.done; h = u.next()) {
      var p = h.value;
      d(p);
    }
  } catch (f) {
    t = { error: f };
  } finally {
    try {
      h && !h.done && (i = u.return) && i.call(u);
    } finally {
      if (t)
        throw t.error;
    }
  }
  return l;
}
function Td(o, e, t) {
  var i, r, n;
  t === void 0 && (t = {});
  var s = t.path, a = s === void 0 ? void 0 : s, l = t.matcherPath, c = l === void 0 ? a ? a.replace(/(\[[0-9+]+\])/i, "[]") : void 0 : l, d = t.skip, u = d === void 0 ? [] : d, h = t.constructors, p = h === void 0 ? {} : h, f = t.constructedArrays, g = f === void 0 ? /* @__PURE__ */ new WeakMap() : f, v = t.allowedTypes, y = v === void 0 ? {} : v, m = t.idx;
  if (o == null)
    throw new Error("AG Charts - target is uninitialised: " + (a != null ? a : "<root>"));
  if (e == null)
    return o;
  var C = o;
  m != null && "_declarationOrder" in C && (C._declarationOrder = m);
  var R = an(o), E = function(T) {
    var D = (c ? c + "." : "") + T;
    if (u.indexOf(D) >= 0)
      return "continue";
    var P = e[T], O = (a ? a + "." : "") + T, M = C.constructor, _ = C[T], F = (i = p[D]) !== null && i !== void 0 ? i : p[T];
    try {
      var I = an(_), G = an(P);
      if (R === "class-instance" && !(T in o || Object.prototype.hasOwnProperty.call(C, T)))
        return pe.warn("unable to set [" + O + "] in " + (M == null ? void 0 : M.name) + " - property is unknown"), "continue";
      var k = (r = y[D]) !== null && r !== void 0 ? r : [I];
      if (!(I === "class-instance" && G === "object")) {
        if (I != null && G != null && !k.includes(G))
          return pe.warn("unable to set [" + O + "] in " + (M == null ? void 0 : M.name) + " - can't apply type of [" + G + "], allowed types are: [" + k + "]"), "continue";
      }
      if (G === "array")
        if (F = (n = F != null ? F : g.get(_)) !== null && n !== void 0 ? n : p[D + "[]"], F != null) {
          var N = P;
          C[T] = N.map(function(W, j) {
            return Td(new F(), W, ds(ds({}, t), { path: O, matcherPath: D + "[]", idx: j }));
          });
        } else
          C[T] = P;
      else
        G === "class-instance" ? C[T] = P : G === "object" ? _ != null ? Td(_, P, ds(ds({}, t), { path: O, matcherPath: D, idx: void 0 })) : F != null ? C[T] = Td(new F(), P, ds(ds({}, t), { path: O, matcherPath: D, idx: void 0 })) : C[T] = P : C[T] = P;
    } catch (W) {
      return pe.warn("unable to set [" + O + "] in [" + (M == null ? void 0 : M.name) + "]; nested error is: " + W.message), "continue";
    }
  };
  for (var b in e)
    E(b);
  return o;
}
function $l(o, e, t) {
  for (var i, r = [], n = 3; n < arguments.length; n++)
    r[n - 3] = arguments[n];
  var s = an(o), a = (i = t.skip) !== null && i !== void 0 ? i : [];
  if (s === "array") {
    o.forEach(function(d, u) {
      $l.apply(void 0, aa([d, e, t], sa((r != null ? r : []).map(function(h) {
        return h == null ? void 0 : h[u];
      }))));
    });
    return;
  } else if (s !== "object")
    return;
  e.apply(void 0, aa([s, o], sa(r)));
  var l = function(d) {
    if (a.indexOf(d) >= 0)
      return "continue";
    var u = o[d], h = r == null ? void 0 : r.map(function(f) {
      return f == null ? void 0 : f[d];
    }), p = an(u);
    (p === "object" || p === "array") && $l.apply(void 0, aa([u, e, t], sa(h)));
  };
  for (var c in o)
    l(c);
}
var zB = typeof window != "undefined";
function an(o) {
  return o == null ? null : zB && o instanceof HTMLElement ? "primitive" : o instanceof Array ? "array" : o instanceof Date ? "primitive" : typeof o == "object" && o.constructor === Object ? "object" : typeof o == "function" ? "function" : typeof o == "object" && o.constructor != null ? "class-instance" : "primitive";
}
var $y = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Zf = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, Qf = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, $C = (
  /** @class */
  function() {
    function o() {
      this.registeredListeners = {};
    }
    return o.prototype.addListener = function(e, t) {
      var i, r = Symbol(e);
      return this.registeredListeners[e] || (this.registeredListeners[e] = []), (i = this.registeredListeners[e]) === null || i === void 0 || i.push({ symbol: r, handler: t }), r;
    }, o.prototype.dispatch = function(e) {
      for (var t, i, r, n = [], s = 1; s < arguments.length; s++)
        n[s - 1] = arguments[s];
      var a = (r = this.registeredListeners[e]) !== null && r !== void 0 ? r : [], l = [];
      try {
        for (var c = $y(a), d = c.next(); !d.done; d = c.next()) {
          var u = d.value;
          try {
            l.push(u.handler.apply(u, Qf([], Zf(n))));
          } catch (h) {
            pe.errorOnce(h), l.push(void 0);
          }
        }
      } catch (h) {
        t = { error: h };
      } finally {
        try {
          d && !d.done && (i = c.return) && i.call(c);
        } finally {
          if (t)
            throw t.error;
        }
      }
      return l;
    }, o.prototype.cancellableDispatch = function(e, t) {
      for (var i, r, n, s = [], a = 2; a < arguments.length; a++)
        s[a - 2] = arguments[a];
      var l = (n = this.registeredListeners[e]) !== null && n !== void 0 ? n : [], c = [];
      try {
        for (var d = $y(l), u = d.next(); !u.done; u = d.next()) {
          var h = u.value;
          if (t())
            break;
          c.push(h.handler.apply(h, Qf([], Zf(s))));
        }
      } catch (p) {
        i = { error: p };
      } finally {
        try {
          u && !u.done && (r = d.return) && r.call(d);
        } finally {
          if (i)
            throw i.error;
        }
      }
      return c;
    }, o.prototype.reduceDispatch = function(e, t) {
      for (var i, r, n, s = [], a = 2; a < arguments.length; a++)
        s[a - 2] = arguments[a];
      var l = (n = this.registeredListeners[e]) !== null && n !== void 0 ? n : [], c = void 0;
      try {
        for (var d = $y(l), u = d.next(); !u.done; u = d.next()) {
          var h = u.value;
          c = h.handler.apply(h, Qf([], Zf(s))), s = t.apply(void 0, Qf([c], Zf(s)));
        }
      } catch (p) {
        i = { error: p };
      } finally {
        try {
          u && !u.done && (r = d.return) && r.call(d);
        } finally {
          if (i)
            throw i.error;
        }
      }
      return c;
    }, o.prototype.removeListener = function(e) {
      for (var t in this.registeredListeners) {
        var i = this.registeredListeners[t], r = i == null ? void 0 : i.findIndex(function(n) {
          return n.symbol === e;
        });
        r != null && r >= 0 && (i == null || i.splice(r, 1)), r != null && (i == null ? void 0 : i.length) === 0 && delete this.registeredListeners[t];
      }
    }, o;
  }()
), vf = (
  /** @class */
  function() {
    function o() {
      this.listeners = new $C();
    }
    return o.prototype.addListener = function(e, t) {
      return this.listeners.addListener(e, t);
    }, o.prototype.removeListener = function(e) {
      this.listeners.removeListener(e);
    }, o;
  }()
);
function mh(o, e) {
  return o = +o, e = +e, function(t) {
    return o * (1 - t) + e * t;
  };
}
function AD(o, e) {
  if (typeof o == "string")
    try {
      o = Kt.fromString(o);
    } catch (s) {
      o = Kt.fromArray([0, 0, 0]);
    }
  if (typeof e == "string")
    try {
      e = Kt.fromString(e);
    } catch (s) {
      e = Kt.fromArray([0, 0, 0]);
    }
  var t = mh(o.r, e.r), i = mh(o.g, e.g), r = mh(o.b, e.b), n = mh(o.a, e.a);
  return function(s) {
    return Kt.fromArray([t(s), i(s), r(s), n(s)]).toRgbaString();
  };
}
function MD(o, e) {
  var t = typeof e, i;
  if (t === "number")
    return mh(o, e);
  if (t === "string")
    try {
      return i = Kt.fromString(e), e = i, AD(o, e);
    } catch (r) {
    }
  throw new Error("Unable to interpolate values");
}
function KB(o) {
  return function(e) {
    var t = e.from, i = e.to, r = MD(t, i);
    return function(n) {
      return r(o(n));
    };
  };
}
function _D(o) {
  var e = o.from, t = o.to;
  return MD(e, t);
}
var qd = KB(function(o) {
  return Math.sin(o * Math.PI / 2);
}), iv = function() {
  return iv = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, iv.apply(this, arguments);
}, rv;
(function(o) {
  o.Loop = "loop", o.Reverse = "reverse";
})(rv || (rv = {}));
function ID(o) {
  var e = o.driver, t = o.duration, i = o.from, r = o.to, n = o.autoplay, s = n === void 0 ? !0 : n, a = o.delay, l = a === void 0 ? 0 : a, c = o.ease, d = c === void 0 ? _D : c, u = o.repeat, h = u === void 0 ? 0 : u, p = o.repeatType, f = p === void 0 ? rv.Loop : p, g = o.onComplete, v = o.onPlay, y = o.onRepeat, m = o.onStop, C = o.onUpdate, R, E = 0, b = 0, T = 0, D = !0, P = !1, O = d({ from: i, to: r }), M = { isPlaying: !1, play: F, pause: I, stop: G, reset: k }, _ = e(j);
  function F() {
    return M.isPlaying = !0, _.start(), v == null || v(), M;
  }
  function I() {
    return M.isPlaying = !1, M;
  }
  function G() {
    return M.isPlaying = !1, _.stop(), m == null || m(), M;
  }
  function k() {
    return P = !1, b = 0, T = 0, _.reset(), M;
  }
  function N() {
    T++, f === rv.Reverse ? (D = T % 2 === 0, b = D ? b % t : t - b % t) : b = b % t, P = !1, y == null || y();
  }
  function W() {
    G(), g == null || g();
  }
  function j(K) {
    if (D || (K = -K), E >= l)
      b += K;
    else {
      E += K;
      return;
    }
    P || (R = O(Math.min(1, Math.max(0, b / t))), P = D ? b >= t : b <= 0), C == null || C(R), P && (T < h ? N() : W());
  }
  return s && F(), M;
}
function YB(o) {
  var e, t = iv(iv({}, o), { autoplay: !1, onUpdate: function(n) {
    e == null || e(n);
  } }), i = ID(t), r = {
    start: function(n) {
      return i.stop(), i.reset(), i.play(), e = n, r;
    },
    stop: function() {
      return i.stop(), r;
    }
  };
  return r;
}
var XB = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), en = function() {
  return en = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, en.apply(this, arguments);
}, qB = function(o, e) {
  var t = {};
  for (var i in o)
    Object.prototype.hasOwnProperty.call(o, i) && e.indexOf(i) < 0 && (t[i] = o[i]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(o); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(o, i[r]) && (t[i[r]] = o[i[r]]);
  return t;
}, ZB = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, A0 = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, QB = (
  /** @class */
  function(o) {
    XB(e, o);
    function e(t) {
      var i = o.call(this) || this;
      return i.controllers = {}, i.throttles = {}, i.throttleGroups = /* @__PURE__ */ new Set(), i.updaters = [], i.isPlaying = !1, i.readyToPlay = !1, i.defaultOptions = {}, i.skipAnimations = !1, i.debug = !1, i.interactionManager = t, window.addEventListener("DOMContentLoaded", function() {
        i.readyToPlay = !0;
      }), setTimeout(function() {
        i.readyToPlay = !0;
      }, 10), i;
    }
    return e.prototype.play = function() {
      if (!this.isPlaying) {
        this.isPlaying = !0, this.debug && pe.debug("AnimationManager.play()");
        for (var t in this.controllers)
          this.controllers[t].play();
        this.startAnimationCycle();
      }
    }, e.prototype.pause = function() {
      if (this.isPlaying) {
        this.isPlaying = !1, this.cancelAnimationFrame(), this.debug && pe.debug("AnimationManager.pause()");
        for (var t in this.controllers)
          this.controllers[t].pause();
      }
    }, e.prototype.stop = function() {
      this.isPlaying = !1, this.cancelAnimationFrame(), this.debug && pe.debug("AnimationManager.stop()");
      for (var t in this.controllers)
        this.controllers[t].stop();
    }, e.prototype.reset = function() {
      this.isPlaying ? (this.stop(), this.play()) : this.stop();
    }, e.prototype.animate = function(t, i) {
      var r, n, s = i.disableInteractions, a = s === void 0 ? !0 : s, l = qB(i, ["disableInteractions"]);
      if (this.skipAnimations) {
        (r = l.onUpdate) === null || r === void 0 || r.call(l, l.to);
        return;
      }
      var c = en(en({}, l), { autoplay: this.isPlaying ? l.autoplay : !1, driver: this.createDriver(t, a) });
      this.controllers[t] && this.controllers[t].stop();
      var d = ID(c);
      return this.controllers[t] = d, (n = l.onUpdate) === null || n === void 0 || n.call(l, l.from), d;
    }, e.prototype.animateMany = function(t, i, r) {
      var n, s, a;
      if (this.skipAnimations) {
        var l = i.map(function(T) {
          return T.to;
        });
        r.onUpdate(l), (a = r.onComplete) === null || a === void 0 || a.call(r);
        return;
      }
      var c = i.map(function(T) {
        return T.from;
      }), d = 0, u = 0, h = 0, p = 0, f = function(T) {
        return function(D) {
          var P;
          c[T] = D, ++h >= i.length && ((P = r.onUpdate) === null || P === void 0 || P.call(r, c), h = 0);
        };
      }, g = function() {
        var T;
        ++d >= i.length && ((T = r.onPlay) === null || T === void 0 || T.call(r));
      }, v = function() {
        var T;
        ++u >= i.length && ((T = r.onStop) === null || T === void 0 || T.call(r));
      }, y = function() {
        var T;
        ++p >= i.length && ((T = r.onComplete) === null || T === void 0 || T.call(r));
      }, m = 0;
      try {
        for (var C = ZB(i), R = C.next(); !R.done; R = C.next()) {
          var E = R.value, b = t + "-" + m;
          this.animate(b, en(en(en({}, r), E), { onUpdate: f(m), onPlay: g, onStop: v, onComplete: y })), m++;
        }
      } catch (T) {
        n = { error: T };
      } finally {
        try {
          R && !R.done && (s = C.return) && s.call(C);
        } finally {
          if (n)
            throw n.error;
        }
      }
    }, e.prototype.animateWithThrottle = function(t, i) {
      var r, n = (r = i.throttleId) !== null && r !== void 0 ? r : t;
      this.throttles[n] && i.duration && Date.now() - this.throttles[n] < i.duration && (i.delay = 0, i.duration = 1), this.throttles[t] = Date.now(), this.animate(t, en({}, i));
    }, e.prototype.animateManyWithThrottle = function(t, i, r) {
      var n = this, s, a = r.throttleGroup, l = (s = r.throttleId) !== null && s !== void 0 ? s : t, c = Date.now(), d = this.throttles[l] && r.duration && c - this.throttles[l] < r.duration, u = a && this.throttleGroups.has(a);
      d && !u && (r.delay = 0, r.duration = 1), !d && a && this.throttleGroups.add(a);
      var h = function() {
        var p;
        a && n.throttleGroups.delete(a), (p = r.onStop) === null || p === void 0 || p.call(r);
      };
      return this.throttles[l] = c, this.animateMany(t, i, en(en({}, r), { onStop: h }));
    }, e.prototype.tween = function(t) {
      var i = "tween-" + btoa(JSON.stringify(t)), r = en(en({}, t), { driver: this.createDriver(i) });
      return YB(r);
    }, e.prototype.createDriver = function(t, i) {
      var r = this;
      return function(n) {
        return {
          start: function() {
            r.updaters.push([t, n]), r.requestId == null && r.startAnimationCycle(), i && r.interactionManager.pause("animation_" + t);
          },
          stop: function() {
            delete r.controllers[t], r.updaters = r.updaters.filter(function(s) {
              var a = A0(s, 1), l = a[0];
              return l !== t;
            }), r.updaters.length <= 0 && r.cancelAnimationFrame(), i && r.interactionManager.resume("animation_" + t);
          },
          reset: function() {
          }
        };
      };
    }, e.prototype.startAnimationCycle = function() {
      var t = this;
      if (this.updaters.length !== 0) {
        var i = function(r) {
          if (t.requestId = requestAnimationFrame(i), !!t.readyToPlay) {
            t.lastTime === void 0 && (t.lastTime = r);
            var n = r - t.lastTime;
            t.lastTime = r, t.debug && pe.debug("AnimationManager - frame()", { updaterCount: t.updaters.length }), t.updaters.forEach(function(s) {
              var a = A0(s, 2);
              a[0];
              var l = a[1];
              return l(n);
            }), t.listeners.dispatch("animation-frame", { type: "animation-frame", deltaMs: n });
          }
        };
        this.requestId = requestAnimationFrame(i);
      }
    }, e.prototype.cancelAnimationFrame = function() {
      this.requestId && (cancelAnimationFrame(this.requestId), this.requestId = void 0, this.lastTime = void 0);
    }, e;
  }(vf)
), JB = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, eH = (
  /** @class */
  function() {
    function o(e) {
      this.states = {}, this.element = e;
    }
    return o.prototype.updateCursor = function(e, t) {
      delete this.states[e], t != null && (this.states[e] = { style: t }), this.applyStates();
    }, o.prototype.applyStates = function() {
      var e = "default";
      Object.entries(this.states).reverse().slice(0, 1).forEach(function(t) {
        var i = JB(t, 2);
        i[0];
        var r = i[1].style;
        return e = r;
      }), this.element.style.cursor = e;
    }, o;
  }()
), tH = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), iH = (
  /** @class */
  function(o) {
    tH(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.legendItemClick = function(t, i, r, n) {
      var s = {
        type: "legend-item-click",
        series: t,
        itemId: i,
        enabled: r,
        legendItemName: n
      };
      this.listeners.dispatch("legend-item-click", s);
    }, e.prototype.legendItemDoubleClick = function(t, i, r, n, s) {
      var a = {
        type: "legend-item-double-click",
        series: t,
        itemId: i,
        enabled: r,
        legendItemName: s,
        numVisibleItems: n
      };
      this.listeners.dispatch("legend-item-double-click", a);
    }, e.prototype.axisHover = function(t, i) {
      var r = {
        type: "axis-hover",
        axisId: t,
        direction: i
      };
      this.listeners.dispatch("axis-hover", r);
    }, e;
  }(vf)
), rH = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), nH = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
};
function oH(o, e) {
  return o === e ? !0 : !((o == null ? void 0 : o.series) !== (e == null ? void 0 : e.series) || (o == null ? void 0 : o.itemId) !== (e == null ? void 0 : e.itemId) || (o == null ? void 0 : o.datum) !== (e == null ? void 0 : e.datum));
}
var sH = (
  /** @class */
  function(o) {
    rH(e, o);
    function e() {
      var t = o.call(this) || this;
      return t.states = {}, t.activeHighlight = void 0, t;
    }
    return e.prototype.updateHighlight = function(t, i) {
      delete this.states[t], i != null && (this.states[t] = { highlightedDatum: i }), this.applyStates();
    }, e.prototype.getActiveHighlight = function() {
      return this.activeHighlight;
    }, e.prototype.applyStates = function() {
      var t = this.activeHighlight, i = void 0;
      Object.entries(this.states).reverse().slice(0, 1).forEach(function(s) {
        var a = nH(s, 2);
        a[0];
        var l = a[1].highlightedDatum;
        return i = l;
      }), this.activeHighlight = i;
      var r = !oH(t, this.activeHighlight);
      if (r) {
        var n = {
          type: "highlight-change",
          previousHighlight: t,
          currentHighlight: this.activeHighlight
        };
        this.listeners.dispatch("highlight-change", n);
      }
    }, e;
  }(vf)
), aH = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), pd = function() {
  return pd = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, pd.apply(this, arguments);
}, lH = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, cH = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, nh = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, M0 = ["pagehide", "mousemove", "mouseup", "wheel"], _0 = [
  "click",
  "dblclick",
  "contextmenu",
  "mousedown",
  "mouseout",
  "mouseenter",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel"
], dH = `
.ag-chart-wrapper {
    touch-action: none;
}
`, uH = (
  /** @class */
  function(o) {
    aH(e, o);
    function e(t, i) {
      var r, n, s, a;
      i === void 0 && (i = document);
      var l = o.call(this) || this;
      l.eventHandler = function(g) {
        return l.processEvent(g);
      }, l.mouseDown = !1, l.touchDown = !1, l.enabled = !0, l.pausers = [], l.rootElement = i.body, l.element = t;
      try {
        for (var c = nh(_0), d = c.next(); !d.done; d = c.next()) {
          var u = d.value;
          u.startsWith("touch") ? t.addEventListener(u, l.eventHandler, { passive: !0 }) : t.addEventListener(u, l.eventHandler);
        }
      } catch (g) {
        r = { error: g };
      } finally {
        try {
          d && !d.done && (n = c.return) && n.call(c);
        } finally {
          if (r)
            throw r.error;
        }
      }
      try {
        for (var h = nh(M0), p = h.next(); !p.done; p = h.next()) {
          var u = p.value;
          u === "wheel" ? window.addEventListener(u, l.eventHandler, { passive: !1 }) : window.addEventListener(u, l.eventHandler);
        }
      } catch (g) {
        s = { error: g };
      } finally {
        try {
          p && !p.done && (a = h.return) && a.call(h);
        } finally {
          if (s)
            throw s.error;
        }
      }
      if (e.interactionDocuments.indexOf(i) < 0) {
        var f = document.createElement("style");
        f.innerHTML = dH, document.head.insertBefore(f, document.head.querySelector("style")), e.interactionDocuments.push(i);
      }
      return l;
    }
    return e.prototype.destroy = function() {
      var t, i, r, n;
      try {
        for (var s = nh(M0), a = s.next(); !a.done; a = s.next()) {
          var l = a.value;
          window.removeEventListener(l, this.eventHandler);
        }
      } catch (u) {
        t = { error: u };
      } finally {
        try {
          a && !a.done && (i = s.return) && i.call(s);
        } finally {
          if (t)
            throw t.error;
        }
      }
      try {
        for (var c = nh(_0), d = c.next(); !d.done; d = c.next()) {
          var l = d.value;
          this.element.removeEventListener(l, this.eventHandler);
        }
      } catch (u) {
        r = { error: u };
      } finally {
        try {
          d && !d.done && (n = c.return) && n.call(c);
        } finally {
          if (r)
            throw r.error;
        }
      }
    }, e.prototype.resume = function(t) {
      return this.pausers = this.pausers.filter(function(i) {
        return i !== t;
      }), this.enabled = this.pausers.length <= 0, this.enabled;
    }, e.prototype.pause = function(t) {
      this.enabled = !1, this.pausers.push(t);
    }, e.prototype.processEvent = function(t) {
      var i = this.decideInteractionEventTypes(t);
      i.length > 0 && this.enabled && this.dispatchEvent(t, i).catch(function(r) {
        return pe.errorOnce(r);
      });
    }, e.prototype.dispatchEvent = function(t, i) {
      return lH(this, void 0, void 0, function() {
        var r, n, s, a, l, c, d, u;
        return cH(this, function(h) {
          if (r = this.calculateCoordinates(t), r == null)
            return [
              2
              /*return*/
            ];
          n = function(p) {
            var f = s.buildEvent(pd(pd({ event: t }, r), { type: p }));
            s.listeners.cancellableDispatch(p, function() {
              return f.consumed;
            }, f);
          }, s = this;
          try {
            for (a = nh(i), l = a.next(); !l.done; l = a.next())
              c = l.value, n(c);
          } catch (p) {
            d = { error: p };
          } finally {
            try {
              l && !l.done && (u = a.return) && u.call(a);
            } finally {
              if (d)
                throw d.error;
            }
          }
          return [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.decideInteractionEventTypes = function(t) {
      switch (t.type) {
        case "click":
          return ["click"];
        case "dblclick":
          return ["dblclick"];
        case "contextmenu":
          return ["contextmenu"];
        case "mousedown":
          return this.mouseDown = !0, this.dragStartElement = t.target, ["drag-start"];
        case "touchstart":
          return this.touchDown = !0, this.dragStartElement = t.target, ["drag-start"];
        case "touchmove":
        case "mousemove":
          return !this.mouseDown && !this.touchDown && !this.isEventOverElement(t) ? [] : this.mouseDown || this.touchDown ? ["drag"] : ["hover"];
        case "mouseup":
          return !this.mouseDown && !this.isEventOverElement(t) ? [] : (this.mouseDown = !1, this.dragStartElement = void 0, ["drag-end"]);
        case "touchend":
          return !this.touchDown && !this.isEventOverElement(t) ? [] : (this.touchDown = !1, this.dragStartElement = void 0, ["drag-end"]);
        case "mouseout":
        case "touchcancel":
          return ["leave"];
        case "mouseenter":
          var i = t instanceof MouseEvent && (t.buttons & 1) === 1;
          return this.mouseDown !== i ? (this.mouseDown = i, [i ? "drag-start" : "drag-end"]) : [];
        case "pagehide":
          return ["page-left"];
        case "wheel":
          return ["wheel"];
      }
      return [];
    }, e.prototype.isEventOverElement = function(t) {
      var i;
      return t.target === this.element || ((i = t.target) === null || i === void 0 ? void 0 : i.parentElement) === this.element;
    }, e.prototype.calculateCoordinates = function(t) {
      var i;
      if (t instanceof MouseEvent) {
        var r = t.clientX, n = t.clientY, s = t.pageX, a = t.pageY, l = t.offsetX, c = t.offsetY;
        return this.fixOffsets(t, { clientX: r, clientY: n, pageX: s, pageY: a, offsetX: l, offsetY: c });
      } else if (typeof TouchEvent != "undefined" && t instanceof TouchEvent) {
        var d = (i = t.touches[0]) !== null && i !== void 0 ? i : t.changedTouches[0], r = d.clientX, n = d.clientY, s = d.pageX, a = d.pageY;
        return pd(pd({}, e.NULL_COORDS), { clientX: r, clientY: n, pageX: s, pageY: a });
      } else if (t instanceof PageTransitionEvent)
        return t.persisted ? void 0 : e.NULL_COORDS;
    }, e.prototype.fixOffsets = function(t, i) {
      var r = function(a) {
        for (var l = 0, c = 0; a; )
          l += a.offsetLeft, c += a.offsetTop, a = a.offsetParent;
        return { x: l, y: c };
      };
      if (this.dragStartElement != null && t.target !== this.dragStartElement) {
        var n = r(this.dragStartElement), s = r(t.target);
        i.offsetX -= n.x - s.x, i.offsetY -= n.y - s.y;
      }
      return i;
    }, e.prototype.buildEvent = function(t) {
      var i = t.type, r = t.event, n = t.clientX, s = t.clientY, a = t.offsetX, l = t.offsetY, c = t.pageX, d = t.pageY;
      if (!Dr(a) || !Dr(l)) {
        var u = this.element.getBoundingClientRect();
        a = n - u.left, l = s - u.top;
      }
      if (!Dr(c) || !Dr(d)) {
        var h = this.rootElement.getBoundingClientRect();
        c = n - h.left, d = s - h.top;
      }
      var p = {
        type: i,
        offsetX: a,
        offsetY: l,
        pageX: c,
        pageY: d,
        sourceEvent: r,
        consumed: !1,
        consume: function() {
          return p.consumed = !0;
        }
      };
      return p;
    }, e.interactionDocuments = [], e.NULL_COORDS = {
      clientX: -1 / 0,
      clientY: -1 / 0,
      pageX: -1 / 0,
      pageY: -1 / 0,
      offsetX: -1 / 0,
      offsetY: -1 / 0
    }, e;
  }(vf)
), I0 = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, hH = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, pH = (
  /** @class */
  function() {
    function o(e, t) {
      var i = this;
      this.states = {}, this.exclusiveAreas = {}, this.destroyFns = [], this.tooltip = e;
      var r = t.addListener("hover", function(n) {
        return i.checkExclusiveRects(n);
      });
      this.destroyFns.push(function() {
        return t.removeListener(r);
      });
    }
    return o.prototype.updateTooltip = function(e, t, i) {
      var r;
      i == null && (i = (r = this.states[e]) === null || r === void 0 ? void 0 : r.content), this.states[e] = { content: i, meta: t }, this.applyStates();
    }, o.prototype.updateExclusiveRect = function(e, t) {
      t ? this.exclusiveAreas[e] = t : delete this.exclusiveAreas[e];
    }, o.prototype.removeTooltip = function(e) {
      delete this.states[e], this.applyStates();
    }, o.prototype.getTooltipMeta = function(e) {
      var t;
      return (t = this.states[e]) === null || t === void 0 ? void 0 : t.meta;
    }, o.prototype.destroy = function() {
      var e, t;
      try {
        for (var i = I0(this.destroyFns), r = i.next(); !r.done; r = i.next()) {
          var n = r.value;
          n();
        }
      } catch (s) {
        e = { error: s };
      } finally {
        try {
          r && !r.done && (t = i.return) && t.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
    }, o.prototype.checkExclusiveRects = function(e) {
      var t, i, r;
      try {
        for (var n = I0(Object.entries(this.exclusiveAreas)), s = n.next(); !s.done; s = n.next()) {
          var a = hH(s.value, 2), l = a[0], c = a[1];
          if (c.containsPoint(e.offsetX, e.offsetY)) {
            r = l;
            break;
          }
        }
      } catch (d) {
        t = { error: d };
      } finally {
        try {
          s && !s.done && (i = n.return) && i.call(n);
        } finally {
          if (t)
            throw t.error;
        }
      }
      r !== this.appliedExclusiveArea && (this.appliedExclusiveArea = r, this.applyStates());
    }, o.prototype.applyStates = function() {
      var e = this, t, i = this.appliedExclusiveArea ? [this.appliedExclusiveArea] : Object.keys(this.states), r = void 0, n = void 0;
      if (i.reverse(), i.slice(0, 1).forEach(function(a) {
        var l, c = (l = e.states[a]) !== null && l !== void 0 ? l : {}, d = c.content, u = c.meta;
        r = d, n = u;
      }), n === void 0 || r === void 0) {
        this.appliedState = void 0, this.tooltip.toggle(!1);
        return;
      }
      if (((t = this.appliedState) === null || t === void 0 ? void 0 : t.content) === r) {
        var s = this.tooltip.isVisible();
        this.tooltip.show(n, void 0, s);
      } else
        this.tooltip.show(n, r);
      this.appliedState = { content: r, meta: n };
    }, o;
  }()
), fH = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Zd = function() {
  return Zd = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, Zd.apply(this, arguments);
}, F0 = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, L0 = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, gH = (
  /** @class */
  function(o) {
    fH(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.axes = {}, t;
    }
    return e.prototype.updateAxes = function(t) {
      var i = this, r = new Set(Object.keys(this.axes));
      t.forEach(function(n) {
        var s, a, l;
        r.delete(n.id), (s = (a = i.axes)[l = n.id]) !== null && s !== void 0 || (a[l] = new vH(n));
      }), r.forEach(function(n) {
        delete i.axes[n];
      }), this.initialZoom && (this.updateZoom(this.initialZoom.callerId, this.initialZoom.newZoom), this.initialZoom = void 0);
    }, e.prototype.updateZoom = function(t, i) {
      if (Object.keys(this.axes).length === 0) {
        this.initialZoom = { callerId: t, newZoom: i };
        return;
      }
      Object.values(this.axes).forEach(function(r) {
        r.updateZoom(t, i == null ? void 0 : i[r.getDirection()]);
      }), this.applyStates();
    }, e.prototype.updateAxisZoom = function(t, i, r) {
      var n;
      (n = this.axes[i]) === null || n === void 0 || n.updateZoom(t, r), this.applyStates();
    }, e.prototype.getZoom = function() {
      var t, i;
      if (Object.values(this.axes).forEach(function(r) {
        r.getDirection() === de.X ? t = r.getZoom() : r.getDirection() === de.Y && (i = r.getZoom());
      }), t || i)
        return { x: t, y: i };
    }, e.prototype.getAxisZoom = function(t) {
      var i;
      return (i = this.axes[t]) === null || i === void 0 ? void 0 : i.getZoom();
    }, e.prototype.getAxisZooms = function() {
      var t, i, r = {};
      try {
        for (var n = F0(Object.entries(this.axes)), s = n.next(); !s.done; s = n.next()) {
          var a = L0(s.value, 2), l = a[0], c = a[1];
          r[l] = {
            direction: c.getDirection(),
            zoom: c.getZoom()
          };
        }
      } catch (d) {
        t = { error: d };
      } finally {
        try {
          s && !s.done && (i = n.return) && i.call(n);
        } finally {
          if (t)
            throw t.error;
        }
      }
      return r;
    }, e.prototype.applyStates = function() {
      var t, i, r = Object.values(this.axes).map(function(p) {
        return p.applyStates();
      }).some(Boolean);
      if (r) {
        var n = this.getZoom(), s = {};
        try {
          for (var a = F0(Object.entries(this.axes)), l = a.next(); !l.done; l = a.next()) {
            var c = L0(l.value, 2), d = c[0], u = c[1];
            s[d] = u.getZoom();
          }
        } catch (p) {
          t = { error: p };
        } finally {
          try {
            l && !l.done && (i = a.return) && i.call(a);
          } finally {
            if (t)
              throw t.error;
          }
        }
        var h = Zd(Zd({ type: "zoom-change" }, n != null ? n : {}), { axes: s });
        this.listeners.dispatch("zoom-change", h);
      }
    }, e;
  }(vf)
), vH = (
  /** @class */
  function() {
    function o(e) {
      this.states = {}, this.currentZoom = void 0, this.axis = e;
    }
    return o.prototype.getDirection = function() {
      return this.axis.direction;
    }, o.prototype.updateZoom = function(e, t) {
      delete this.states[e], t != null && (this.states[e] = Zd({}, t));
    }, o.prototype.getZoom = function() {
      return this.currentZoom;
    }, o.prototype.applyStates = function() {
      var e, t, i = this.currentZoom, r = Object.keys(this.states)[Object.keys(this.states).length - 1];
      this.currentZoom = Zd({}, this.states[r]);
      var n = (i == null ? void 0 : i.min) !== ((e = this.currentZoom) === null || e === void 0 ? void 0 : e.min) || (i == null ? void 0 : i.max) !== ((t = this.currentZoom) === null || t === void 0 ? void 0 : t.max);
      return n;
    }, o;
  }()
), nv = function() {
  return nv = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, nv.apply(this, arguments);
};
function mH(o) {
  return o !== "layout-complete";
}
function yH(o) {
  return o === "layout-complete";
}
var CH = (
  /** @class */
  function() {
    function o() {
      this.layoutProcessors = new $C(), this.listeners = new $C();
    }
    return o.prototype.addListener = function(e, t) {
      if (mH(e))
        return this.layoutProcessors.addListener(e, t);
      if (yH(e))
        return this.listeners.addListener(e, t);
      throw new Error("AG Charts - unsupported listener type: " + e);
    }, o.prototype.removeListener = function(e) {
      this.listeners.removeListener(e), this.layoutProcessors.removeListener(e);
    }, o.prototype.dispatchPerformLayout = function(e, t) {
      var i = this.layoutProcessors.reduceDispatch(e, function(r, n) {
        var s = r.shrinkRect;
        return [nv(nv({}, n), { shrinkRect: s })];
      }, t);
      return i != null ? i : t;
    }, o.prototype.dispatchLayoutComplete = function(e) {
      this.listeners.dispatch("layout-complete", e);
    }, o;
  }()
), SH = (
  /** @class */
  function() {
    function o(e) {
      this.getSeries = e;
    }
    return o;
  }()
), qe;
(function(o) {
  o[o.FULL = 0] = "FULL", o[o.PROCESS_DATA = 1] = "PROCESS_DATA", o[o.PERFORM_LAYOUT = 2] = "PERFORM_LAYOUT", o[o.SERIES_UPDATE = 3] = "SERIES_UPDATE", o[o.TOOLTIP_RECALCULATION = 4] = "TOOLTIP_RECALCULATION", o[o.SCENE_RENDER = 5] = "SCENE_RENDER", o[o.NONE = 6] = "NONE";
})(qe || (qe = {}));
var bH = (
  /** @class */
  function() {
    function o(e) {
      this.updateCallback = e;
    }
    return o.prototype.update = function(e, t) {
      e === void 0 && (e = qe.FULL);
      var i = t === void 0 ? {} : t, r = i.forceNodeDataRefresh, n = r === void 0 ? !1 : r;
      this.updateCallback(e, { forceNodeDataRefresh: n });
    }, o;
  }()
), wH = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, EH = (
  /** @class */
  function() {
    function o() {
      this.range = "tooltip";
    }
    return wH([
      A(yD("tooltip", "node"))
    ], o.prototype, "range", void 0), o;
  }()
), N0 = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, G0 = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, Et = (
  /** @class */
  function() {
    function o(e, t, i) {
      i === void 0 && (i = !0), this._nodes = [], this._data = [], this._datumNodeIndices = /* @__PURE__ */ new Map(), this._garbage = [], this._garbageCollection = !0, this._parent = e, this._factory = Object.prototype.isPrototypeOf.call(km, t) ? function() {
        return new t();
      } : t, this._garbageCollection = i;
    }
    return o.select = function(e, t, i) {
      return i === void 0 && (i = !0), new o(e, t, i);
    }, o.prototype.each = function(e) {
      return this._nodes.forEach(function(t, i) {
        return e(t, t.datum, i);
      }), this;
    }, o.prototype.update = function(e, t, i) {
      var r, n, s = this, a = this._data, l = this._parent, c = this._factory, d = /* @__PURE__ */ new Map();
      if (i ? e.forEach(function(m, C) {
        var R = i(m);
        if (d.set(R, C), !s._datumNodeIndices.has(R)) {
          var E = c(m);
          E.datum = m, t == null || t(E), l.appendChild(E), s._nodes.push(E), s._datumNodeIndices.set(R, s._nodes.length - 1);
        }
      }) : e.length > a.length ? e.slice(a.length).forEach(function(m) {
        var C = c(m);
        C.datum = m, t == null || t(C), l.appendChild(C), s._nodes.push(C);
      }) : e.length < a.length && this._nodes.splice(e.length).forEach(function(m) {
        l.removeChild(m);
      }), this._data = e.slice(0), i) {
        try {
          for (var u = N0(this._datumNodeIndices), h = u.next(); !h.done; h = u.next()) {
            var p = G0(h.value, 2), f = p[0], g = p[1], v = d.get(f);
            v !== void 0 ? this._nodes[g].datum = e[v] : this._garbage.push(f);
          }
        } catch (m) {
          r = { error: m };
        } finally {
          try {
            h && !h.done && (n = u.return) && n.call(u);
          } finally {
            if (r)
              throw r.error;
          }
        }
        this._garbageCollection && this.cleanup();
      } else
        for (var y = 0; y < e.length; y++)
          this._nodes[y].datum = this._data[y];
      return this;
    }, o.prototype.clear = function() {
      return this.update([]), this;
    }, o.prototype.cleanup = function() {
      var e, t, i = this;
      if (this._garbage.length !== 0) {
        this._garbage.forEach(function(h) {
          var p = i._datumNodeIndices.get(h);
          if (p !== void 0) {
            var f = i._nodes[p];
            delete i._nodes[p], i._datumNodeIndices.delete(h), f && i._parent.removeChild(f);
          }
        });
        var r = 0, n = this._datumNodeIndices.entries(), s = /* @__PURE__ */ new Map();
        try {
          for (var a = N0(n), l = a.next(); !l.done; l = a.next()) {
            var c = G0(l.value, 2), d = c[0], u = c[1];
            s.set(u, d);
          }
        } catch (h) {
          e = { error: h };
        } finally {
          try {
            l && !l.done && (t = a.return) && t.call(a);
          } finally {
            if (e)
              throw e.error;
          }
        }
        this._nodes = this._nodes.filter(function(h, p) {
          if (h === void 0)
            return !1;
          var f = s.get(p);
          return i._datumNodeIndices.set(f, r), r++, !0;
        }), this._garbage = [];
      }
    }, o.selectAll = function(e, t) {
      var i = [], r = function(n) {
        t(n) && i.push(n), n.children.forEach(r);
      };
      return r(e), i;
    }, o.selectByClass = function(e, t) {
      return o.selectAll(e, function(i) {
        return i instanceof t;
      });
    }, o.selectByTag = function(e, t) {
      return o.selectAll(e, function(i) {
        return i.tag === t;
      });
    }, o.prototype.select = function(e) {
      return o.selectAll(this._parent, e);
    }, o.prototype.selectByClass = function(e) {
      return this.select(function(t) {
        return t instanceof e;
      });
    }, o.prototype.selectByTag = function(e) {
      return this.select(function(t) {
        return t.tag === e;
      });
    }, o.prototype.nodes = function() {
      return this._nodes;
    }, o;
  }()
);
function RH(o, e) {
  var t = -e / o;
  return o !== 0 && t >= 0 && t <= 1 ? [t] : [];
}
function TH(o, e, t) {
  if (o === 0)
    return RH(e, t);
  var i = e * e - 4 * o * t, r = [];
  if (i === 0) {
    var n = -e / (2 * o);
    n >= 0 && n <= 1 && r.push(n);
  } else if (i > 0) {
    var s = Math.sqrt(i), a = (-e - s) / (2 * o), l = (-e + s) / (2 * o);
    a >= 0 && a <= 1 && r.push(a), l >= 0 && l <= 1 && r.push(l);
  }
  return r;
}
function xH(o, e, t, i) {
  if (o === 0)
    return TH(e, t, i);
  var r = e / o, n = t / o, s = i / o, a = (3 * n - r * r) / 9, l = (9 * r * n - 27 * s - 2 * r * r * r) / 54, c = a * a * a + l * l, d = 1 / 3, u = [];
  if (c >= 0) {
    var h = Math.sqrt(c), p = Math.sign(l + h) * Math.pow(Math.abs(l + h), d), f = Math.sign(l - h) * Math.pow(Math.abs(l - h), d), g = Math.abs(Math.sqrt(3) * (p - f) / 2), v = -d * r + (p + f);
    if (v >= 0 && v <= 1 && u.push(v), g === 0) {
      var y = -d * r - (p + f) / 2;
      y >= 0 && y <= 1 && u.push(y);
    }
  } else {
    var m = Math.acos(l / Math.sqrt(-a * a * a)), C = d * r, R = 2 * Math.sqrt(-a), E = R * Math.cos(d * m) - C, b = R * Math.cos(d * (m + 2 * Math.PI)) - C, T = R * Math.cos(d * (m + 4 * Math.PI)) - C;
    E >= 0 && E <= 1 && u.push(E), b >= 0 && b <= 1 && u.push(b), T >= 0 && T <= 1 && u.push(T);
  }
  return u;
}
var DH = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function xh(o, e, t, i, r, n, s, a) {
  var l = (t - o) * (a - n) - (i - e) * (s - r);
  if (l === 0)
    return null;
  var c = ((s - r) * (e - n) - (o - r) * (a - n)) / l, d = ((t - o) * (e - n) - (i - e) * (o - r)) / l;
  return c >= 0 && c <= 1 && d >= 0 && d <= 1 ? {
    x: o + c * (t - o),
    y: e + c * (i - e)
  } : null;
}
function OH(o, e, t, i, r, n, s, a, l, c, d, u) {
  var h, p, f = [], g = c - u, v = d - l, y = l * (u - c) - c * (d - l), m = k0(o, t, r, s), C = k0(e, i, n, a), R = g * m[0] + v * C[0], E = g * m[1] + v * C[1], b = g * m[2] + v * C[2], T = g * m[3] + v * C[3] + y, D = xH(R, E, b, T);
  try {
    for (var P = DH(D), O = P.next(); !O.done; O = P.next()) {
      var M = O.value, _ = M * M, F = M * _, I = m[0] * F + m[1] * _ + m[2] * M + m[3], G = C[0] * F + C[1] * _ + C[2] * M + C[3], k = void 0;
      l !== d ? k = (I - l) / (d - l) : k = (G - c) / (u - c), k >= 0 && k <= 1 && f.push({ x: I, y: G });
    }
  } catch (N) {
    h = { error: N };
  } finally {
    try {
      O && !O.done && (p = P.return) && p.call(P);
    } finally {
      if (h)
        throw h.error;
    }
  }
  return f;
}
function k0(o, e, t, i) {
  return [
    // Bézier expressed as matrix operations:
    -o + 3 * e - 3 * t + i,
    3 * o - 6 * e + 3 * t,
    -3 * o + 3 * e,
    o
    //                 | 1  0  0  0| |P4|
  ];
}
function FD(o, e, t, i, r, n, s, a, l, c) {
  var d = (c - a) / (l - s), u = a - d * s, h = Math.pow(d, 2) + 1, p = 2 * (d * (u - e) - o), f = Math.pow(o, 2) + Math.pow(u - e, 2) - Math.pow(t, 2), g = Math.pow(p, 2) - 4 * h * f;
  if (g < 0)
    return [];
  var v = (-p + Math.sqrt(g)) / 2 / h, y = (-p - Math.sqrt(g)) / 2 / h, m = [];
  return [v, y].forEach(function(C) {
    var R = C >= Math.min(s, l) && C <= Math.max(s, l);
    if (R) {
      var E = d * C, b = Vi(n ? r : i), T = Vi(n ? i : r), D = Vi(Math.atan2(E, C));
      T <= b && (T += 2 * Math.PI), D < b && (D += 2 * Math.PI), D >= b && D <= T && m.push({ x: C, y: E });
    }
  }), m;
}
var PH = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, hi;
(function(o) {
  o[o.Move = 0] = "Move", o[o.Line = 1] = "Line", o[o.Arc = 2] = "Arc", o[o.Curve = 3] = "Curve", o[o.ClosePath = 4] = "ClosePath";
})(hi || (hi = {}));
var zC = (
  /** @class */
  function() {
    function o() {
      this.previousCommands = [], this.previousParams = [], this.previousClosedPath = !1, this.commands = [], this.params = [], this._closedPath = !1;
    }
    return o.prototype.isDirty = function() {
      if (this._closedPath !== this.previousClosedPath || this.previousCommands.length !== this.commands.length || this.previousParams.length !== this.params.length)
        return !0;
      for (var e = 0; e < this.commands.length; e++)
        if (this.commands[e] !== this.previousCommands[e])
          return !0;
      for (var e = 0; e < this.params.length; e++)
        if (this.params[e] !== this.previousParams[e])
          return !0;
      return !1;
    }, o.prototype.draw = function(e) {
      var t, i, r = this.commands, n = this.params, s = 0;
      e.beginPath();
      try {
        for (var a = PH(r), l = a.next(); !l.done; l = a.next()) {
          var c = l.value;
          switch (c) {
            case hi.Move:
              e.moveTo(n[s++], n[s++]);
              break;
            case hi.Line:
              e.lineTo(n[s++], n[s++]);
              break;
            case hi.Curve:
              e.bezierCurveTo(n[s++], n[s++], n[s++], n[s++], n[s++], n[s++]);
              break;
            case hi.Arc:
              e.arc(n[s++], n[s++], n[s++], n[s++], n[s++], n[s++] === 1);
              break;
            case hi.ClosePath:
              e.closePath();
              break;
          }
        }
      } catch (d) {
        t = { error: d };
      } finally {
        try {
          l && !l.done && (i = a.return) && i.call(a);
        } finally {
          if (t)
            throw t.error;
        }
      }
      r.length === 0 && e.closePath();
    }, o.prototype.moveTo = function(e, t) {
      this.xy ? (this.xy[0] = e, this.xy[1] = t) : this.xy = [e, t], this.commands.push(hi.Move), this.params.push(e, t);
    }, o.prototype.lineTo = function(e, t) {
      this.xy ? (this.commands.push(hi.Line), this.params.push(e, t), this.xy[0] = e, this.xy[1] = t) : this.moveTo(e, t);
    }, o.prototype.rect = function(e, t, i, r) {
      this.moveTo(e, t), this.lineTo(e + i, t), this.lineTo(e + i, t + r), this.lineTo(e, t + r), this.closePath();
    }, o.prototype.arc = function(e, t, i, r, n, s) {
      s === void 0 && (s = !1);
      var a = e + i * Math.cos(n), l = t + i * Math.sin(n);
      this.xy ? (this.xy[0] = a, this.xy[1] = l) : this.xy = [a, l], this.commands.push(hi.Arc), this.params.push(e, t, i, r, n, s ? 1 : 0);
    }, o.prototype.cubicCurveTo = function(e, t, i, r, n, s) {
      this.xy || this.moveTo(e, t), this.commands.push(hi.Curve), this.params.push(e, t, i, r, n, s), this.xy && (this.xy[0] = n, this.xy[1] = s);
    }, Object.defineProperty(o.prototype, "closedPath", {
      get: function() {
        return this._closedPath;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.closePath = function() {
      this.xy && (this.xy = void 0, this.commands.push(hi.ClosePath), this._closedPath = !0);
    }, o.prototype.clear = function(e) {
      var t = e === void 0 ? { trackChanges: !1 } : e, i = t.trackChanges;
      i ? (this.previousCommands = this.commands, this.previousParams = this.params, this.previousClosedPath = this._closedPath, this.commands = [], this.params = []) : (this.commands.length = 0, this.params.length = 0), this.xy = void 0, this._closedPath = !1;
    }, o.prototype.isPointInPath = function(e, t) {
      for (var i = this.commands, r = this.params, n = i.length, s = -1e4, a = -1e4, l = NaN, c = NaN, d = 0, u = 0, h = 0, p = 0, f = 0; p < n; p++)
        switch (i[p]) {
          case hi.Move:
            isNaN(l) || xh(l, c, d, u, s, a, e, t) && h++, d = r[f++], l = d, u = r[f++], c = u;
            break;
          case hi.Line:
            xh(d, u, r[f++], r[f++], s, a, e, t) && h++, d = r[f - 2], u = r[f - 1];
            break;
          case hi.Curve:
            h += OH(d, u, r[f++], r[f++], r[f++], r[f++], r[f++], r[f++], s, a, e, t).length, d = r[f - 2], u = r[f - 1];
            break;
          case hi.Arc:
            h += FD(r[f++], r[f++], r[f++], r[f++], r[f++], !!r[f++], s, a, e, t).length, d = r[f - 2], u = r[f - 1];
            break;
          case hi.ClosePath:
            isNaN(l) || xh(l, c, d, u, s, a, e, t) && h++;
            break;
        }
      return h % 2 === 1;
    }, o;
  }()
), AH = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), V0 = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
function yt(o) {
  var e = o != null ? o : {}, t = e.redraw, i = t === void 0 ? oe.MAJOR : t, r = e.changeCb, n = e.convertor;
  return ve({ redraw: i, type: "path", convertor: n, changeCb: r });
}
var Zi = (
  /** @class */
  function(o) {
    AH(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.path = new zC(), t._dirtyPath = !0, t;
    }
    return Object.defineProperty(e.prototype, "dirtyPath", {
      get: function() {
        return this._dirtyPath;
      },
      set: function(t) {
        this._dirtyPath !== t && (this._dirtyPath = t, t && this.markDirty(this, oe.MAJOR));
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.checkPathDirty = function() {
      var t, i;
      this._dirtyPath || (this.dirtyPath = this.path.isDirty() || ((i = (t = this.fillShadow) === null || t === void 0 ? void 0 : t.isDirty()) !== null && i !== void 0 ? i : !1));
    }, e.prototype.isPointInPath = function(t, i) {
      var r = this.transformPoint(t, i);
      return this.path.closedPath && this.path.isPointInPath(r.x, r.y);
    }, e.prototype.isDirtyPath = function() {
      return !1;
    }, e.prototype.updatePath = function() {
    }, e.prototype.render = function(t) {
      var i, r, n = t.ctx, s = t.forceRender, a = t.stats;
      if (this.dirty === oe.NONE && !s) {
        a && (a.nodesSkipped += this.nodeCount.count);
        return;
      }
      if (this.computeTransformMatrix(), this.matrix.toContext(n), (this.dirtyPath || this.isDirtyPath()) && (this.updatePath(), this.dirtyPath = !1), this.clipPath) {
        if (n.save(), this.clipMode === "normal" && (this.clipPath.draw(n), n.clip()), this.path.draw(n), this.fillStroke(n), this.clipMode === "punch-out") {
          this.clipPath.draw(n), n.clip();
          var l = (i = this.computeBBox()) !== null && i !== void 0 ? i : {}, c = l.x, d = c === void 0 ? -1e4 : c, u = l.y, h = u === void 0 ? -1e4 : u, p = l.width, f = p === void 0 ? 2e4 : p, g = l.height, v = g === void 0 ? 2e4 : g;
          n.clearRect(d, h, f, v);
        }
        n.restore();
      } else
        this.path.draw(n), this.fillStroke(n);
      (r = this.fillShadow) === null || r === void 0 || r.markClean(), o.prototype.render.call(this, t);
    }, e.className = "Path", V0([
      yt()
    ], e.prototype, "clipPath", void 0), V0([
      yt()
    ], e.prototype, "clipMode", void 0), e;
  }(Mo)
), MH = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), zy = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, _H = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, el = (
  /** @class */
  function(o) {
    MH(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.x = 0, t.y = 0, t.size = 12, t;
    }
    return e.prototype.computeBBox = function() {
      var t = this, i = t.x, r = t.y, n = t.size, s = n / 2;
      return new nt(i - s, r - s, n, n);
    }, e.prototype.applyPath = function(t, i) {
      var r, n, s = this.path, a = this, l = a.x, c = a.y;
      s.clear();
      try {
        for (var d = _H(i), u = d.next(); !u.done; u = d.next()) {
          var h = u.value, p = h.x, f = h.y, g = h.t;
          l += p * t, c += f * t, g === "move" ? s.moveTo(l, c) : s.lineTo(l, c);
        }
      } catch (v) {
        r = { error: v };
      } finally {
        try {
          u && !u.done && (n = d.return) && n.call(d);
        } finally {
          if (r)
            throw r.error;
        }
      }
      s.closePath();
    }, zy([
      yt()
    ], e.prototype, "x", void 0), zy([
      yt()
    ], e.prototype, "y", void 0), zy([
      yt({ convertor: Math.abs })
    ], e.prototype, "size", void 0), e;
  }(Zi)
), IH = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Dh = (
  /** @class */
  function(o) {
    IH(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.updatePath = function() {
      var t = this, i = t.path, r = t.x, n = t.y, s = this.size / 2;
      i.clear(), i.moveTo(this.align(r - s), this.align(n - s)), i.lineTo(this.align(r + s), this.align(n - s)), i.lineTo(this.align(r + s), this.align(n + s)), i.lineTo(this.align(r - s), this.align(n + s)), i.closePath();
    }, e.className = "Square", e;
  }(el)
), FH = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Dn = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, B0 = (
  /** @class */
  function(o) {
    FH(e, o);
    function e() {
      var t = o.call(this, { name: "markerLabelGroup" }) || this;
      t.label = new ut(), t._marker = new Dh(), t._markerSize = 15, t._spacing = 8;
      var i = t.label;
      return i.textBaseline = "middle", i.fontSize = 12, i.fontFamily = "Verdana, sans-serif", i.fill = "black", i.y = It.has.textMetrics ? 1 : 0, t.append([t.marker, i]), t.update(), t;
    }
    return Object.defineProperty(e.prototype, "marker", {
      get: function() {
        return this._marker;
      },
      set: function(t) {
        this._marker !== t && (this.removeChild(this._marker), this._marker = t, this.appendChild(t), this.update());
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "markerSize", {
      get: function() {
        return this._markerSize;
      },
      set: function(t) {
        this._markerSize !== t && (this._markerSize = t, this.update());
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "spacing", {
      get: function() {
        return this._spacing;
      },
      set: function(t) {
        this._spacing !== t && (this._spacing = t, this.update());
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.update = function() {
      var t = this.marker, i = this.markerSize;
      t.size = i, this.label.x = i / 2 + this.spacing;
    }, e.prototype.render = function(t) {
      this.marker.opacity = this.opacity, this.label.opacity = this.opacity, o.prototype.render.call(this, t);
    }, e.className = "MarkerLabel", Dn([
      qt("label")
    ], e.prototype, "text", void 0), Dn([
      qt("label")
    ], e.prototype, "fontStyle", void 0), Dn([
      qt("label")
    ], e.prototype, "fontWeight", void 0), Dn([
      qt("label")
    ], e.prototype, "fontSize", void 0), Dn([
      qt("label")
    ], e.prototype, "fontFamily", void 0), Dn([
      qt("label", "fill")
    ], e.prototype, "color", void 0), Dn([
      qt("marker", "fill")
    ], e.prototype, "markerFill", void 0), Dn([
      qt("marker", "stroke")
    ], e.prototype, "markerStroke", void 0), Dn([
      qt("marker", "strokeWidth")
    ], e.prototype, "markerStrokeWidth", void 0), Dn([
      qt("marker", "fillOpacity")
    ], e.prototype, "markerFillOpacity", void 0), Dn([
      qt("marker", "strokeOpacity")
    ], e.prototype, "markerStrokeOpacity", void 0), e;
  }(we)
), LH = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), pp = (
  /** @class */
  function(o) {
    LH(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.updatePath = function() {
      var t = this, i = t.x, r = t.y, n = t.path, s = t.size, a = s / 2;
      n.clear(), n.arc(i, r, a, 0, Math.PI * 2), n.closePath();
    }, e.className = "Circle", e;
  }(el)
), NH = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), GH = (
  /** @class */
  function(o) {
    NH(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.updatePath = function() {
      var t = this.size / 4.2;
      o.prototype.applyPath.call(this, t, e.moves);
    }, e.className = "Cross", e.moves = [
      { x: -1, y: 0, t: "move" },
      { x: -1, y: -1 },
      { x: 1, y: -1 },
      { x: 1, y: 1 },
      { x: 1, y: -1 },
      { x: 1, y: 1 },
      { x: -1, y: 1 },
      { x: 1, y: 1 },
      { x: -1, y: 1 },
      { x: -1, y: -1 },
      { x: -1, y: 1 },
      { x: -1, y: -1 }
    ], e;
  }(el)
), kH = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), LD = (
  /** @class */
  function(o) {
    kH(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.updatePath = function() {
      var t = this.size / 2;
      o.prototype.applyPath.call(this, t, e.moves);
    }, e.className = "Diamond", e.moves = [
      { x: 0, y: -1, t: "move" },
      { x: 1, y: 1 },
      { x: -1, y: 1 },
      { x: -1, y: -1 },
      { x: 1, y: -1 }
    ], e;
  }(el)
), VH = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), BH = (
  /** @class */
  function(o) {
    VH(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.rad = function(t) {
      return t / 180 * Math.PI;
    }, e.prototype.updatePath = function() {
      var t = this, i = t.x, r = t.path, n = t.size, s = t.rad, a = n / 4, l = this.y + a / 2;
      r.clear(), r.arc(i - a, l - a, a, s(130), s(330)), r.arc(i + a, l - a, a, s(220), s(50)), r.lineTo(i, l + a), r.closePath();
    }, e.className = "Heart", e;
  }(el)
), HH = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), WH = (
  /** @class */
  function(o) {
    HH(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.updatePath = function() {
      var t = this.size / 3;
      o.prototype.applyPath.call(this, t, e.moves);
    }, e.className = "Plus", e.moves = [
      { x: -0.5, y: -0.5, t: "move" },
      { x: 0, y: -1 },
      { x: 1, y: 0 },
      { x: 0, y: 1 },
      { x: 1, y: 0 },
      { x: 0, y: 1 },
      { x: -1, y: 0 },
      { x: 0, y: 1 },
      { x: -1, y: 0 },
      { x: 0, y: -1 },
      { x: -1, y: 0 },
      { x: 0, y: -1 }
    ], e;
  }(el)
), jH = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Oh = (
  /** @class */
  function(o) {
    jH(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.updatePath = function() {
      var t = this.size * 1.1;
      o.prototype.applyPath.call(this, t, e.moves);
    }, e.className = "Triangle", e.moves = [
      { x: 0, y: -0.48, t: "move" },
      { x: 0.5, y: 0.87 },
      { x: -1, y: 0 }
    ], e;
  }(el)
);
function Mu(o) {
  if (o === void 0 && (o = Dh), typeof o == "string")
    switch (o) {
      case "circle":
        return pp;
      case "cross":
        return GH;
      case "diamond":
        return LD;
      case "heart":
        return BH;
      case "plus":
        return WH;
      case "triangle":
        return Oh;
      default:
        return Dh;
    }
  return typeof o == "function" ? o : Dh;
}
var UH = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function $H(o) {
  for (var e = o.orientation, t = o.bboxes, i = o.maxHeight, r = o.maxWidth, n = o.itemPaddingY, s = n === void 0 ? 0 : n, a = o.itemPaddingX, l = a === void 0 ? 0 : a, c = o.forceResult, d = c === void 0 ? !1 : c, u = e === "horizontal", h = {
    max: u ? r : i,
    fn: u ? function(m) {
      return m.width;
    } : function(m) {
      return m.height;
    },
    padding: u ? l : s
  }, p = {
    max: u ? i : r,
    fn: u ? function(m) {
      return m.height;
    } : function(m) {
      return m.width;
    },
    padding: u ? s : l
  }, f = 0, g = []; f < t.length; ) {
    var v = t.slice(f), y = zH(v, f, h, p, d);
    if (!y)
      return;
    f += y.processedBBoxCount, g.push(y.pageIndices);
  }
  return YH(g, e, t, s, l);
}
function zH(o, e, t, i, r) {
  var n = 1, s = qH(o, t);
  if (s < n) {
    if (!r)
      return;
    s = n;
  }
  for (var a = s; a >= n; a--) {
    var l = KH(o, e, a, t, i, r);
    if (l == null && a <= n)
      return;
    if (l != null) {
      if (typeof l == "number") {
        if (l <= n)
          return;
        a = l < a && l > n ? l : a;
        continue;
      }
      var c = l.length * l[0].length;
      return { processedBBoxCount: c, pageIndices: l };
    }
  }
}
function KH(o, e, t, i, r, n) {
  for (var s, a = [], l = 0, c = 0, d = [], u = [], h = 0; h < o.length; h++) {
    var p = (h + t) % t;
    p === 0 && (l += c, c = 0, d.length > 0 && a.push(d), d = []);
    var f = i.fn(o[h]) + i.padding;
    u[p] = Math.max((s = u[p]) !== null && s !== void 0 ? s : 0, f), c = Math.max(c, r.fn(o[h]) + r.padding);
    var g = l + c, v = !n || a.length > 0;
    if (g > r.max && v) {
      d = [];
      break;
    }
    var y = u.reduce(function(m, C) {
      return m + C;
    }, 0);
    if (y > i.max && !n)
      return u.length < t ? u.length : void 0;
    d.push(h + e);
  }
  return d.length > 0 && a.push(d), a.length > 0 ? a : void 0;
}
function YH(o, e, t, i, r) {
  var n = 0, s = 0, a = o.map(function(l) {
    e === "horizontal" && (l = XH(l));
    var c = 0, d = l.map(function(p) {
      var f = p.map(function(y) {
        return c = Math.max(y, c), t[y];
      }), g = 0, v = 0;
      return f.forEach(function(y) {
        g += y.height + i, v = Math.max(v, y.width + r);
      }), {
        indices: p,
        bboxes: f,
        columnHeight: g,
        columnWidth: v
      };
    }), u = 0, h = 0;
    return d.forEach(function(p) {
      u += p.columnWidth, h = Math.max(h, p.columnHeight);
    }), n = Math.max(u, n), s = Math.max(h, s), {
      columns: d,
      startIndex: l[0][0],
      endIndex: c,
      pageWidth: u,
      pageHeight: h
    };
  });
  return { pages: a, maxPageWidth: n, maxPageHeight: s };
}
function XH(o) {
  var e, t, i = [];
  try {
    for (var r = UH(o[0]), n = r.next(); !n.done; n = r.next()) {
      var s = n.value;
      i.push([]);
    }
  } catch (a) {
    e = { error: a };
  } finally {
    try {
      n && !n.done && (t = r.return) && t.call(r);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return o.forEach(function(a, l) {
    a.forEach(function(c, d) {
      i[d][l] = c;
    });
  }), i;
}
function qH(o, e) {
  for (var t = o.length, i = 0, r = 0; r < t; r++)
    if (i += e.fn(o[r]) + e.padding, i > e.max) {
      var n = t / r;
      return n < 2 ? Math.ceil(t / 2) : r;
    }
  return t;
}
var Sr = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, ZH = (
  /** @class */
  function() {
    function o() {
      this.color = "black", this.fontStyle = void 0, this.fontWeight = void 0, this.fontSize = 12, this.fontFamily = "Verdana, sans-serif";
    }
    return Sr([
      A(Lr)
    ], o.prototype, "color", void 0), Sr([
      A(fc)
    ], o.prototype, "fontStyle", void 0), Sr([
      A(gc)
    ], o.prototype, "fontWeight", void 0), Sr([
      A(le(0))
    ], o.prototype, "fontSize", void 0), Sr([
      A(Ri)
    ], o.prototype, "fontFamily", void 0), o;
  }()
), Ky = (
  /** @class */
  function() {
    function o() {
      this.size = 15, this.fill = void 0, this.fillOpacity = void 0, this.stroke = void 0, this.strokeWidth = 1, this.strokeOpacity = 1;
    }
    return Sr([
      A(le(0))
    ], o.prototype, "size", void 0), Sr([
      A(St)
    ], o.prototype, "fill", void 0), Sr([
      A(lt(0, 1))
    ], o.prototype, "fillOpacity", void 0), Sr([
      A(St)
    ], o.prototype, "stroke", void 0), Sr([
      A(le(0))
    ], o.prototype, "strokeWidth", void 0), Sr([
      A(le(0, 1))
    ], o.prototype, "strokeOpacity", void 0), o;
  }()
), QH = (
  /** @class */
  function() {
    function o() {
      this.size = 15, this._shape = Oh, this.padding = 8;
    }
    return Object.defineProperty(o.prototype, "shape", {
      get: function() {
        return this._shape;
      },
      set: function(e) {
        var t;
        this._shape = e, (t = this.parent) === null || t === void 0 || t.onMarkerShapeChange();
      },
      enumerable: !1,
      configurable: !0
    }), Sr([
      A(le(0))
    ], o.prototype, "size", void 0), Sr([
      A(le(0))
    ], o.prototype, "padding", void 0), o;
  }()
), JH = (
  /** @class */
  function() {
    function o(e, t, i, r) {
      var n = this;
      this.chartUpdateCallback = e, this.pageUpdateCallback = t, this.interactionManager = i, this.cursorManager = r, this.id = Vs(this), this.group = new we({ name: "pagination" }), this.labelNode = new ut(), this.marker = new QH(), this.activeStyle = new Ky(), this.inactiveStyle = new Ky(), this.highlightStyle = new Ky(), this.label = new ZH(), this.totalPages = 0, this.currentPage = 0, this.translationX = 0, this.translationY = 0, this.nextButtonDisabled = !1, this.previousButtonDisabled = !1, this._visible = !0, this._enabled = !0, this._orientation = "vertical", this._nextButton = new Oh(), this._previousButton = new Oh();
      var s = this.labelNode;
      s.textBaseline = "middle", s.fontSize = 12, s.fontFamily = "Verdana, sans-serif", s.fill = "black", s.y = It.has.textMetrics ? 1 : 0, this.group.append([this.nextButton, this.previousButton, s]), this.interactionManager.addListener("click", function(a) {
        return n.onPaginationClick(a);
      }), this.interactionManager.addListener("hover", function(a) {
        return n.onPaginationMouseMove(a);
      }), this.marker.parent = this, this.update(), this.updateMarkers();
    }
    return Object.defineProperty(o.prototype, "visible", {
      get: function() {
        return this._visible;
      },
      set: function(e) {
        this._visible = e, this.updateGroupVisibility();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "enabled", {
      get: function() {
        return this._enabled;
      },
      set: function(e) {
        this._enabled = e, this.updateGroupVisibility();
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.updateGroupVisibility = function() {
      this.group.visible = this.enabled && this.visible;
    }, Object.defineProperty(o.prototype, "orientation", {
      get: function() {
        return this._orientation;
      },
      set: function(e) {
        switch (this._orientation = e, e) {
          case "horizontal": {
            this.previousButton.rotation = -Math.PI / 2, this.nextButton.rotation = Math.PI / 2;
            break;
          }
          case "vertical":
          default:
            this.previousButton.rotation = 0, this.nextButton.rotation = Math.PI;
        }
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "nextButton", {
      get: function() {
        return this._nextButton;
      },
      set: function(e) {
        this._nextButton !== e && (this.group.removeChild(this._nextButton), this._nextButton = e, this.group.appendChild(e));
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "previousButton", {
      get: function() {
        return this._previousButton;
      },
      set: function(e) {
        this._previousButton !== e && (this.group.removeChild(this._previousButton), this._previousButton = e, this.group.appendChild(e));
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.update = function() {
      this.updateLabel(), this.updatePositions(), this.enableOrDisableButtons();
    }, o.prototype.updatePositions = function() {
      this.group.translationX = this.translationX, this.group.translationY = this.translationY, this.updateLabelPosition(), this.updateNextButtonPosition();
    }, o.prototype.updateLabelPosition = function() {
      var e = this.marker, t = e.size, i = e.padding;
      this.nextButton.size = t, this.previousButton.size = t, this.labelNode.x = t / 2 + i;
    }, o.prototype.updateNextButtonPosition = function() {
      var e = this.labelNode.computeBBox();
      this.nextButton.translationX = e.x + e.width + this.marker.size / 2 + this.marker.padding;
    }, o.prototype.updateLabel = function() {
      var e = this, t = e.currentPage, i = e.totalPages, r = e.labelNode, n = e.label, s = n.color, a = n.fontStyle, l = n.fontWeight, c = n.fontSize, d = n.fontFamily;
      r.text = t + 1 + " / " + i, r.fill = s, r.fontStyle = a, r.fontWeight = l, r.fontSize = c, r.fontFamily = d;
    }, o.prototype.updateMarkers = function() {
      var e = this, t = e.nextButton, i = e.previousButton, r = e.nextButtonDisabled, n = e.previousButtonDisabled, s = e.activeStyle, a = e.inactiveStyle, l = e.highlightStyle, c = e.highlightActive, d = function(u, h) {
        return h ? a : u === c ? l : s;
      };
      this.updateMarker(t, d("next", r)), this.updateMarker(i, d("previous", n));
    }, o.prototype.updateMarker = function(e, t) {
      var i, r = this.marker.size;
      e.size = r, e.fill = t.fill, e.fillOpacity = (i = t.fillOpacity) !== null && i !== void 0 ? i : 1, e.stroke = t.stroke, e.strokeWidth = t.strokeWidth, e.strokeOpacity = t.strokeOpacity;
    }, o.prototype.enableOrDisableButtons = function() {
      var e = this, t = e.currentPage, i = e.totalPages, r = i === 0, n = t === i - 1, s = t === 0;
      this.nextButtonDisabled = n || r, this.previousButtonDisabled = s || r;
    }, o.prototype.nextButtonContainsPoint = function(e, t) {
      return !this.nextButtonDisabled && this.nextButton.containsPoint(e, t);
    }, o.prototype.previousButtonContainsPoint = function(e, t) {
      return !this.previousButtonDisabled && this.previousButton.containsPoint(e, t);
    }, o.prototype.onPaginationClick = function(e) {
      var t = e.offsetX, i = e.offsetY;
      this.nextButtonContainsPoint(t, i) ? (this.incrementPage(), this.onPaginationChanged(), e.consume()) : this.previousButtonContainsPoint(t, i) && (this.decrementPage(), this.onPaginationChanged(), e.consume());
    }, o.prototype.onPaginationMouseMove = function(e) {
      var t = e.offsetX, i = e.offsetY;
      this.nextButtonContainsPoint(t, i) ? (this.cursorManager.updateCursor(this.id, "pointer"), this.highlightActive = "next") : this.previousButtonContainsPoint(t, i) ? (this.cursorManager.updateCursor(this.id, "pointer"), this.highlightActive = "previous") : (this.cursorManager.updateCursor(this.id), this.highlightActive = void 0), this.updateMarkers(), this.chartUpdateCallback(qe.SCENE_RENDER);
    }, o.prototype.onPaginationChanged = function() {
      this.pageUpdateCallback(this.currentPage);
    }, o.prototype.incrementPage = function() {
      this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);
    }, o.prototype.decrementPage = function() {
      this.currentPage = Math.max(this.currentPage - 1, 0);
    }, o.prototype.onMarkerShapeChange = function() {
      var e = Mu(this.marker.shape || Oh);
      this.previousButton = new e(), this.nextButton = new e(), this.updatePositions(), this.updateMarkers(), this.chartUpdateCallback(qe.SCENE_RENDER);
    }, o.prototype.attachPagination = function(e) {
      e.append(this.group);
    }, o.prototype.computeBBox = function() {
      return this.group.computeBBox();
    }, o.className = "Pagination", o;
  }()
), Mt = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, dl = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, Vc = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, H0 = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, eW = ["horizontal", "vertical"], tW = Ee(function(o, e) {
  return Ot(o, e, function(t) {
    return eW.includes(t);
  });
}, "expecting an orientation keyword such as 'horizontal' or 'vertical'"), iW = (
  /** @class */
  function() {
    function o() {
      this.maxLength = void 0, this.color = "black", this.fontStyle = void 0, this.fontWeight = void 0, this.fontSize = 12, this.fontFamily = "Verdana, sans-serif", this.formatter = void 0;
    }
    return Mt([
      A(lt(0))
    ], o.prototype, "maxLength", void 0), Mt([
      A(Lr)
    ], o.prototype, "color", void 0), Mt([
      A(fc)
    ], o.prototype, "fontStyle", void 0), Mt([
      A(gc)
    ], o.prototype, "fontWeight", void 0), Mt([
      A(le(0))
    ], o.prototype, "fontSize", void 0), Mt([
      A(Ri)
    ], o.prototype, "fontFamily", void 0), Mt([
      A(Pt)
    ], o.prototype, "formatter", void 0), o;
  }()
), rW = (
  /** @class */
  function() {
    function o() {
      this.size = 15, this._shape = void 0, this.padding = 8, this.strokeWidth = 1;
    }
    return Object.defineProperty(o.prototype, "shape", {
      get: function() {
        return this._shape;
      },
      set: function(e) {
        var t;
        this._shape = e, (t = this.parent) === null || t === void 0 || t.onMarkerShapeChange();
      },
      enumerable: !1,
      configurable: !0
    }), Mt([
      A(le(0))
    ], o.prototype, "size", void 0), Mt([
      A(le(0))
    ], o.prototype, "padding", void 0), Mt([
      A(le(0))
    ], o.prototype, "strokeWidth", void 0), o;
  }()
), nW = (
  /** @class */
  function() {
    function o() {
      this.marker = new rW(), this.label = new iW(), this.maxWidth = void 0, this.paddingX = 16, this.paddingY = 8, this.toggleSeriesVisible = !0;
    }
    return Mt([
      A(lt(0))
    ], o.prototype, "maxWidth", void 0), Mt([
      A(le(0))
    ], o.prototype, "paddingX", void 0), Mt([
      A(le(0))
    ], o.prototype, "paddingY", void 0), Mt([
      A(ht)
    ], o.prototype, "toggleSeriesVisible", void 0), o;
  }()
), oW = (
  /** @class */
  function() {
    function o() {
      this.legendItemClick = void 0, this.legendItemDoubleClick = void 0;
    }
    return Mt([
      A(Pt)
    ], o.prototype, "legendItemClick", void 0), o;
  }()
), sW = (
  /** @class */
  function() {
    function o(e) {
      var t, i = this;
      this.ctx = e, this.id = Vs(this), this.group = new we({ name: "legend", layer: !0, zIndex: kt.LEGEND_ZINDEX }), this.itemSelection = Et.select(this.group, B0), this.oldSize = [0, 0], this.pages = [], this.maxPageSize = [0, 0], this.paginationTrackingIndex = 0, this.item = new nW(), this.listeners = new oW(), this.truncatedItems = /* @__PURE__ */ new Set(), this._data = [], this._enabled = !0, this.position = "bottom", this.maxWidth = void 0, this.maxHeight = void 0, this.reverseOrder = void 0, this.destroyFns = [], this.spacing = 20, this.characterWidths = /* @__PURE__ */ new Map(), this.size = [0, 0], this._visible = !0, this.item.marker.parent = this, this.pagination = new JH(function(s) {
        return e.updateService.update(s);
      }, function(s) {
        return i.updatePageNumber(s);
      }, e.interactionManager, e.cursorManager), this.pagination.attachPagination(this.group), this.item.marker.parent = this;
      var r = [
        e.interactionManager.addListener("click", function(s) {
          return i.checkLegendClick(s);
        }),
        e.interactionManager.addListener("dblclick", function(s) {
          return i.checkLegendDoubleClick(s);
        }),
        e.interactionManager.addListener("hover", function(s) {
          return i.handleLegendMouseMove(s);
        })
      ], n = [
        e.layoutService.addListener("start-layout", function(s) {
          return i.positionLegend(s.shrinkRect);
        })
      ];
      (t = this.destroyFns).push.apply(t, Vc(Vc(Vc([], dl(r.map(function(s) {
        return function() {
          return e.interactionManager.removeListener(s);
        };
      }))), dl(n.map(function(s) {
        return function() {
          return e.layoutService.removeListener(s);
        };
      }))), [function() {
        return i.detachLegend();
      }]));
    }
    return Object.defineProperty(o.prototype, "data", {
      get: function() {
        return this._data;
      },
      set: function(e) {
        this._data = e, this.updateGroupVisibility();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "enabled", {
      get: function() {
        return this._enabled;
      },
      set: function(e) {
        this._enabled = e, this.updateGroupVisibility();
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.getOrientation = function() {
      if (this.orientation !== void 0)
        return this.orientation;
      switch (this.position) {
        case "right":
        case "left":
          return "vertical";
        case "bottom":
        case "top":
          return "horizontal";
      }
    }, o.prototype.destroy = function() {
      this.destroyFns.forEach(function(e) {
        return e();
      });
    }, o.prototype.onMarkerShapeChange = function() {
      this.itemSelection.clear(), this.group.markDirty(this.group, oe.MINOR);
    }, o.prototype.getCharacterWidths = function(e) {
      var t = this.characterWidths;
      if (t.has(e))
        return t.get(e);
      var i = {
        "...": It.getTextSize("...", e).width
      };
      return t.set(e, i), i;
    }, Object.defineProperty(o.prototype, "visible", {
      get: function() {
        return this._visible;
      },
      set: function(e) {
        this._visible = e, this.updateGroupVisibility();
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.updateGroupVisibility = function() {
      this.group.visible = this.enabled && this.visible && this.data.length > 0;
    }, o.prototype.attachLegend = function(e) {
      e.append(this.group);
    }, o.prototype.detachLegend = function() {
      var e;
      (e = this.group.parent) === null || e === void 0 || e.removeChild(this.group);
    }, o.prototype.getItemLabel = function(e) {
      var t = this.ctx.callbackCache, i = this.item.label.formatter;
      return i ? t.call(i, {
        itemId: e.itemId,
        value: e.label.text,
        seriesId: e.seriesId
      }) : e.label.text;
    }, o.prototype.performLayout = function(e, t) {
      var i = this, r = this.item, n = r.paddingX, s = r.paddingY, a = r.label, l = r.maxWidth, c = r.marker, d = c.size, u = c.padding, h = c.shape, p = r.label, f = p.maxLength, g = f === void 0 ? 1 / 0 : f, v = p.fontStyle, y = p.fontWeight, m = p.fontSize, C = p.fontFamily, R = Vc([], dl(this.data));
      this.reverseOrder && R.reverse(), this.itemSelection.update(R);
      var E = [], b = jl(a), T = 0.8, D = l != null ? l : e * T, P = d + u + n;
      if (this.itemSelection.each(function(W, j) {
        var K, $ = Mu(h != null ? h : j.marker.shape);
        W.marker && W.marker instanceof $ || (W.marker = new $()), W.markerSize = d, W.spacing = u, W.fontStyle = v, W.fontWeight = y, W.fontSize = m, W.fontFamily = C;
        var ae = (K = j.itemId) !== null && K !== void 0 ? K : j.id, ee = i.getItemLabel(j), ne = (ee != null ? ee : "<unknown>").replace(/\r?\n/g, " ");
        W.text = i.truncate(ne, g, D, P, b, ae), E.push(W.computeBBox());
      }), e = Math.max(1, e), t = Math.max(1, t), !isFinite(e))
        return !1;
      var O = this.size, M = this.oldSize;
      O[0] = e, O[1] = t, (O[0] !== M[0] || O[1] !== M[1]) && (M[0] = O[0], M[1] = O[1]);
      var _ = this.updatePagination(E, e, t), F = _.pages, I = _.maxPageHeight, G = _.maxPageWidth;
      this.pages = F, this.maxPageSize = [G - n, I - s];
      var k = this.pagination.currentPage, N = this.pages[k];
      if (this.pages.length < 1 || !N) {
        this.visible = !1;
        return;
      }
      this.visible = !0, this.updatePositions(k), this.update();
    }, o.prototype.truncate = function(e, t, i, r, n, s) {
      var a, l, c = "...", d = e.split(""), u = !1;
      e.length > t && (e = "" + e.substring(0, t), u = !0);
      var h = Math.floor(r + It.getTextSize(e, n).width);
      if (h > i) {
        var p = "", f = this.getCharacterWidths(n), g = r + f[c];
        try {
          for (var v = H0(d), y = v.next(); !y.done; y = v.next()) {
            var m = y.value;
            if (f[m] || (f[m] = It.getTextSize(m, n).width), g += f[m], g > i)
              break;
            p += m;
          }
        } catch (C) {
          a = { error: C };
        } finally {
          try {
            y && !y.done && (l = v.return) && l.call(v);
          } finally {
            if (a)
              throw a.error;
          }
        }
        e = p, u = !0;
      }
      return u ? (e += c, this.truncatedItems.add(s)) : this.truncatedItems.delete(s), e;
    }, o.prototype.updatePagination = function(e, t, i) {
      var r = this.getOrientation(), n = Math.min(this.paginationTrackingIndex, e.length);
      this.pagination.orientation = r, this.pagination.translationX = 0, this.pagination.translationY = 0;
      var s = this.calculatePagination(e, t, i), a = s.pages, l = s.maxPageHeight, c = s.maxPageWidth, d = s.paginationBBox, u = s.paginationVertical, h = a.findIndex(function(E) {
        return E.endIndex >= n;
      });
      this.pagination.currentPage = Math.min(Math.max(h, 0), a.length - 1);
      var p = this.item, f = p.paddingX, g = p.paddingY, v = 8, y = c - f, m = l - g, C = 0, R = -d.y - this.item.marker.size / 2;
      return u ? R += m + v : (C += -d.x + y + v, R += (m - d.height) / 2), this.pagination.translationX = C, this.pagination.translationY = R, this.pagination.update(), this.pagination.updateMarkers(), {
        maxPageHeight: l,
        maxPageWidth: c,
        pages: a
      };
    }, o.prototype.calculatePagination = function(e, t, i) {
      var r, n, s, a = this.item, l = a.paddingX, c = a.paddingY, d = this.getOrientation(), u = ["left", "right"].includes(this.position), h = this.pagination.computeBBox(), p = new nt(0, 0, 0, 0), f = [], g = 0, v = 0, y = 0, m = function(D) {
        var P = D.width, O = D.height;
        return P === h.width && O === h.height;
      }, C = this.maxWidth !== void 0 || this.maxHeight !== void 0;
      do {
        if (y++ > 10) {
          pe.warn("unable to find stable legend layout.");
          break;
        }
        h = p;
        var R = t - (u ? 0 : h.width), E = i - (u ? h.height : 0), b = $H({
          orientation: d,
          bboxes: e,
          maxHeight: E,
          maxWidth: R,
          itemPaddingY: c,
          itemPaddingX: l,
          forceResult: C
        });
        f = (r = b == null ? void 0 : b.pages) !== null && r !== void 0 ? r : [], g = (n = b == null ? void 0 : b.maxPageWidth) !== null && n !== void 0 ? n : 0, v = (s = b == null ? void 0 : b.maxPageHeight) !== null && s !== void 0 ? s : 0;
        var T = f.length;
        if (this.pagination.visible = T > 1, this.pagination.totalPages = T, this.pagination.update(), p = this.pagination.computeBBox(), !this.pagination.visible)
          break;
      } while (!m(p));
      return { maxPageWidth: g, maxPageHeight: v, pages: f, paginationBBox: h, paginationVertical: u };
    }, o.prototype.updatePositions = function(e) {
      e === void 0 && (e = 0);
      var t = this, i = t.item.paddingY, r = t.itemSelection, n = t.pages;
      if (!(n.length < 1 || !n[e])) {
        var s = n[e], a = s.columns, l = s.startIndex, c = s.endIndex, d = 0, u = 0, h = a.length, p = a[0].indices.length, f = this.getOrientation() === "horizontal", g = a[0].bboxes[0].height + i, v = [];
        r.each(function(y, m, C) {
          var R, E;
          if (C < l || C > c) {
            y.visible = !1;
            return;
          }
          var b = C - l, T = 0, D = 0;
          f ? (T = b % h, D = Math.floor(b / h)) : (T = Math.floor(b / p), D = b % p), y.visible = !0;
          var P = a[T];
          P && (u = g * D, d = (R = v[D]) !== null && R !== void 0 ? R : 0, v[D] = ((E = v[D]) !== null && E !== void 0 ? E : 0) + P.columnWidth, y.translationX = Math.floor(d), y.translationY = Math.floor(u));
        });
      }
    }, o.prototype.updatePageNumber = function(e) {
      var t = this.pages, i = t[e], r = i.startIndex, n = i.endIndex;
      r === 0 ? this.paginationTrackingIndex = 0 : e === t.length - 1 ? this.paginationTrackingIndex = n : this.paginationTrackingIndex = Math.floor((r + n) / 2), this.pagination.update(), this.pagination.updateMarkers(), this.updatePositions(e), this.ctx.updateService.update(qe.SCENE_RENDER);
    }, o.prototype.update = function() {
      var e = this.item, t = e.marker.strokeWidth, i = e.label.color;
      this.itemSelection.each(function(r, n) {
        var s = n.marker;
        r.markerFill = s.fill, r.markerStroke = s.stroke, r.markerStrokeWidth = t, r.markerFillOpacity = s.fillOpacity, r.markerStrokeOpacity = s.strokeOpacity, r.opacity = n.enabled ? 1 : 0.5, r.color = i;
      });
    }, o.prototype.getDatumForPoint = function(e, t) {
      var i, r, n = [], s = { dist: 1 / 0, datum: void 0 };
      try {
        for (var a = H0(this.group.children), l = a.next(); !l.done; l = a.next()) {
          var c = l.value;
          if (c.visible && c instanceof B0) {
            var d = c.computeBBox();
            if (d.grow(this.item.paddingX / 2, "horizontal"), d.grow(this.item.paddingY / 2, "vertical"), d.containsPoint(e, t))
              return c.datum;
            var u = e - d.x - this.item.paddingX / 2, h = t - d.y - this.item.paddingY / 2, p = Math.pow(u, 2) + Math.pow(h, 2), f = u >= 0 && h >= 0;
            f && p < s.dist && (s.dist = p, s.datum = c.datum), n.push(d);
          }
        }
      } catch (v) {
        i = { error: v };
      } finally {
        try {
          l && !l.done && (r = a.return) && r.call(a);
        } finally {
          if (i)
            throw i.error;
        }
      }
      var g = nt.merge(n);
      if (g.containsPoint(e, t))
        return s.datum;
    }, o.prototype.computeBBox = function() {
      return this.group.computeBBox();
    }, o.prototype.computePagedBBox = function() {
      var e = this.group.computeBBox();
      if (this.pages.length <= 1)
        return e;
      var t = dl(this.maxPageSize, 2), i = t[0], r = t[1];
      return e.height = Math.max(r, e.height), e.width = Math.max(i, e.width), e;
    }, o.prototype.checkLegendClick = function(e) {
      var t = this, i = t.listeners.legendItemClick, r = t.ctx, n = r.dataService, s = r.highlightManager, a = t.item.toggleSeriesVisible, l = e.offsetX, c = e.offsetY, d = this.computeBBox(), u = this.group.visible && d.containsPoint(l, c), h = this.getDatumForPoint(l, c);
      if (!(!u || !h)) {
        var p = h.id, f = h.itemId, g = h.enabled, v = n.getSeries(), y = v.find(function(C) {
          return C.id === p;
        });
        if (y) {
          e.consume();
          var m = g;
          a && (m = !g, this.ctx.chartEventManager.legendItemClick(y, f, m, h.legendItemName)), m ? s.updateHighlight(this.id, {
            series: y,
            itemId: f,
            datum: void 0
          }) : s.updateHighlight(this.id), this.ctx.updateService.update(qe.PROCESS_DATA, { forceNodeDataRefresh: !0 }), i == null || i({ type: "click", enabled: m, itemId: f, seriesId: y.id });
        }
      }
    }, o.prototype.checkLegendDoubleClick = function(e) {
      var t, i = this, r = i.listeners.legendItemDoubleClick, n = i.ctx.dataService, s = i.item.toggleSeriesVisible, a = e.offsetX, l = e.offsetY;
      if (this.ctx.mode !== "integrated") {
        var c = this.computeBBox(), d = this.group.visible && c.containsPoint(a, l), u = this.getDatumForPoint(a, l);
        if (!(!d || !u)) {
          var h = u.id, p = u.itemId, f = u.seriesId, g = n.getSeries(), v = g.find(function(R) {
            return R.id === h;
          });
          if (v) {
            if (e.consume(), s) {
              var y = g.reduce(function(R, E) {
                return Vc(Vc([], dl(R)), dl(E.getLegendData().filter(function(b) {
                  return b.legendType === "category";
                })));
              }, []), m = {};
              y.forEach(function(R) {
                var E, b;
                (E = m[b = R.seriesId]) !== null && E !== void 0 || (m[b] = 0), R.enabled && m[R.seriesId]++;
              });
              var C = y.find(function(R) {
                return R.itemId === p && R.seriesId === f;
              });
              this.ctx.chartEventManager.legendItemDoubleClick(v, p, (t = C == null ? void 0 : C.enabled) !== null && t !== void 0 ? t : !1, m, C == null ? void 0 : C.legendItemName);
            }
            this.ctx.updateService.update(qe.PROCESS_DATA, { forceNodeDataRefresh: !0 }), r == null || r({ type: "dblclick", enabled: !0, itemId: p, seriesId: v.id });
          }
        }
      }
    }, o.prototype.handleLegendMouseMove = function(e) {
      var t, i = this, r = i.enabled, n = i.item.toggleSeriesVisible, s = i.listeners;
      if (r) {
        var a = this.computeBBox(), l = e.pageX, c = e.pageY, d = e.offsetX, u = e.offsetY, h = this.group.visible && a.containsPoint(d, u);
        if (!h) {
          this.ctx.cursorManager.updateCursor(this.id), this.ctx.highlightManager.updateHighlight(this.id), this.ctx.tooltipManager.removeTooltip(this.id);
          return;
        }
        e.consume();
        var p = this.getDatumForPoint(d, u), f = h && p !== void 0;
        if (!f) {
          this.ctx.cursorManager.updateCursor(this.id), this.ctx.highlightManager.updateHighlight(this.id);
          return;
        }
        var g = p ? this.ctx.dataService.getSeries().find(function(y) {
          return y.id === (p == null ? void 0 : p.id);
        }) : void 0;
        if (p && this.truncatedItems.has((t = p.itemId) !== null && t !== void 0 ? t : p.id)) {
          var v = this.getItemLabel(p);
          this.ctx.tooltipManager.updateTooltip(this.id, { pageX: l, pageY: c, offsetX: d, offsetY: u, event: e, showArrow: !1 }, Ti({ content: v }));
        } else
          this.ctx.tooltipManager.removeTooltip(this.id);
        (n || s.legendItemClick != null || s.legendItemDoubleClick != null) && this.ctx.cursorManager.updateCursor(this.id, "pointer"), p != null && p.enabled && g ? this.ctx.highlightManager.updateHighlight(this.id, {
          series: g,
          itemId: p == null ? void 0 : p.itemId,
          datum: void 0
        }) : this.ctx.highlightManager.updateHighlight(this.id);
      }
    }, o.prototype.positionLegend = function(e) {
      var t = this, i = e.clone();
      if (!this.enabled || !this.data.length)
        return { shrinkRect: i };
      var r = dl(this.calculateLegendDimensions(e), 2), n = r[0], s = r[1];
      this.group.translationX = 0, this.group.translationY = 0, this.performLayout(n, s);
      var a = this.computePagedBBox(), l = function() {
        switch (t.position) {
          case "top":
            return 0;
          case "bottom":
            return e.height - a.height;
          case "left":
            return 0;
          case "right":
          default:
            return e.width - a.width;
        }
      };
      if (this.visible) {
        var c = void 0, d = void 0;
        switch (this.position) {
          case "top":
          case "bottom":
            c = (e.width - a.width) / 2, d = l(), i.shrink(a.height, this.position);
            break;
          case "left":
          case "right":
          default:
            c = l(), d = (e.height - a.height) / 2, i.shrink(a.width, this.position);
        }
        this.group.translationX = Math.floor(-a.x + e.x + c), this.group.translationY = Math.floor(-a.y + e.y + d);
      }
      if (this.visible && this.enabled && this.data.length) {
        var u = this.spacing;
        i.shrink(u, this.position);
        var h = a.clone();
        h.x += this.group.translationX, h.y += this.group.translationY, this.ctx.tooltipManager.updateExclusiveRect(this.id, h);
      } else
        this.ctx.tooltipManager.updateExclusiveRect(this.id);
      return { shrinkRect: i };
    }, o.prototype.calculateLegendDimensions = function(e) {
      var t = e.width, i = e.height, r = t / i, n = 0.5, s = 0.2, a = 0.25, l = 0, c = 0;
      switch (this.position) {
        case "top":
        case "bottom":
          var d = r < 1 ? Math.min(n, s * (1 / r)) : s;
          l = this.maxWidth ? Math.min(this.maxWidth, t) : t, c = this.maxHeight ? Math.min(this.maxHeight, i) : Math.round(i * d);
          break;
        case "left":
        case "right":
        default:
          var u = r > 1 ? Math.min(n, a * r) : a;
          l = this.maxWidth ? Math.min(this.maxWidth, t) : Math.round(t * u), c = this.maxHeight ? Math.min(this.maxHeight, i) : i;
      }
      return [l, c];
    }, o.className = "Legend", Mt([
      A(ht)
    ], o.prototype, "_enabled", void 0), Mt([
      A(CD)
    ], o.prototype, "position", void 0), Mt([
      A(lt(0))
    ], o.prototype, "maxWidth", void 0), Mt([
      A(lt(0))
    ], o.prototype, "maxHeight", void 0), Mt([
      A(_o)
    ], o.prototype, "reverseOrder", void 0), Mt([
      A(tW)
    ], o.prototype, "orientation", void 0), Mt([
      A(le(0))
    ], o.prototype, "spacing", void 0), o;
  }()
), ov = {
  category: sW
};
function aW(o, e) {
  if (ov[o])
    throw new Error("AG Charts - already registered legend type: " + o);
  ov[o] = e;
}
function lW(o, e) {
  if (ov[o])
    return new ov[o](e);
  throw new Error("AG Charts - unknown legend type: " + o);
}
var cW = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, dW = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, uW = (
  /** @class */
  function() {
    function o() {
      this.cache = /* @__PURE__ */ new Map();
    }
    return o.prototype.call = function(e) {
      for (var t = [], i = 1; i < arguments.length; i++)
        t[i - 1] = arguments[i];
      var r, n = this.cache.get(e), s = function() {
        try {
          var a = e.apply(void 0, dW([], cW(t)));
          return n && r != null && n.set(r, a), a;
        } catch (l) {
          pe.warnOnce("User callback errored, ignoring", l);
          return;
        }
      };
      try {
        r = JSON.stringify(t);
      } catch (a) {
        return s();
      }
      return n == null && (n = /* @__PURE__ */ new Map(), this.cache.set(e, n)), n.has(r) ? n.get(r) : s();
    }, o.prototype.invalidateCache = function() {
      this.cache = /* @__PURE__ */ new Map();
    }, o;
  }()
), fd = function() {
  return fd = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, fd.apply(this, arguments);
}, W0 = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, j0 = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, Yy = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, U0 = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, $0 = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, hW = (
  /** @class */
  function() {
    function o() {
      this.requested = [], this.status = "setup";
    }
    return o.prototype.request = function(e, t, i) {
      return W0(this, void 0, void 0, function() {
        var r = this;
        return j0(this, function(n) {
          if (this.status !== "setup")
            throw new Error("AG Charts - data request after data setup phase.");
          return [2, new Promise(function(s, a) {
            r.requested.push({
              id: e,
              opts: i,
              data: t,
              resultCb: s,
              reject: a
            });
          })];
        });
      });
    }, o.prototype.execute = function() {
      return W0(this, void 0, void 0, function() {
        var e, t, i, r, n, s, a, l, c, d, u, h, p;
        return j0(this, function(f) {
          if (this.status !== "setup")
            throw new Error("AG Charts - data request after data setup phase.");
          this.status = "executed", o.DEBUG() && pe.debug("DataController.execute() - requested", this.requested), e = this.mergeRequested(), o.DEBUG() && pe.debug("DataController.execute() - merged", e), t = function(g, v, y, m, C) {
            try {
              var R = new nB(g), E = R.processData(v);
              E && E.partialValidDataCount === 0 ? y.forEach(function(b) {
                return b({ dataModel: R, processedData: E });
              }) : E ? i.splitResult(R, E, C, y) : m.forEach(function(b) {
                return b(new Error("AG Charts - no processed data generated"));
              });
            } catch (b) {
              m.forEach(function(T) {
                return T(b);
              });
            }
          }, i = this;
          try {
            for (r = Yy(e), n = r.next(); !n.done; n = r.next())
              s = n.value, a = s.opts, l = s.data, c = s.resultCbs, d = s.rejects, u = s.ids, t(a, l, c, d, u);
          } catch (g) {
            h = { error: g };
          } finally {
            try {
              n && !n.done && (p = r.return) && p.call(r);
            } finally {
              if (h)
                throw h.error;
            }
          }
          return [
            2
            /*return*/
          ];
        });
      });
    }, o.prototype.mergeRequested = function() {
      var e, t, i = [], r = function(p) {
        return p.filter(function(f) {
          return f.type === "key";
        }).map(function(f) {
          return f.property;
        }).join(";");
      }, n = function(p) {
        var f = p.opts, g = p.data;
        return function(v) {
          return v[0].data === g && v[0].opts.groupByKeys === f.groupByKeys && v[0].opts.dataVisible === f.dataVisible && v[0].opts.groupByFn === f.groupByFn && r(v[0].opts.props) === r(f.props);
        };
      }, s = function(p) {
        return function(f) {
          var g;
          if (f.type !== p.type || f.id !== p.id)
            return !1;
          var v = (g = Sa(f, p)) !== null && g !== void 0 ? g : {};
          return delete v.scopes, Object.keys(v).length === 0;
        };
      }, a = function(p) {
        return fd(fd({}, p[0]), { props: p.reduce(function(f, g) {
          var v, y, m, C, R, E;
          try {
            for (var b = Yy(g.props), T = b.next(); !T.done; T = b.next()) {
              var D = T.value, P = f.find(s(D));
              if (P) {
                (C = P.scopes) !== null && C !== void 0 || (P.scopes = []), (m = P.scopes).push.apply(m, $0($0([], U0((R = D.scopes) !== null && R !== void 0 ? R : [])), U0((E = g.scopes) !== null && E !== void 0 ? E : [])));
                continue;
              }
              f.push(D);
            }
          } catch (O) {
            v = { error: O };
          } finally {
            try {
              T && !T.done && (y = b.return) && y.call(b);
            } finally {
              if (v)
                throw v.error;
            }
          }
          return f;
        }, []) });
      }, l = function(p) {
        return {
          ids: p.map(function(f) {
            var g = f.id;
            return g;
          }),
          resultCbs: p.map(function(f) {
            var g = f.resultCb;
            return g;
          }),
          rejects: p.map(function(f) {
            var g = f.reject;
            return g;
          }),
          data: p[0].data,
          opts: a(p.map(function(f) {
            var g = f.opts;
            return g;
          }))
        };
      };
      try {
        for (var c = Yy(this.requested), d = c.next(); !d.done; d = c.next()) {
          var u = d.value, h = i.find(n(u));
          h ? h.push(u) : i.push([u]);
        }
      } catch (p) {
        e = { error: p };
      } finally {
        try {
          d && !d.done && (t = c.return) && t.call(c);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return i.map(l);
    }, o.prototype.splitResult = function(e, t, i, r) {
      for (var n = function(a) {
        var l = i[a], c = r[a];
        c({
          dataModel: e,
          processedData: fd(fd({}, t), { data: t.data.filter(function(d) {
            var u = d.validScopes;
            return u == null || u.some(function(h) {
              return h === l;
            });
          }) })
        });
      }, s = 0; s < i.length; s++)
        n(s);
    }, o.DEBUG = function() {
      var e;
      return (e = [!0, "data-model"].includes(Fn("agChartsDebug"))) !== null && e !== void 0 ? e : !1;
    }, o;
  }()
), Xy = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, pW = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, fW = (
  /** @class */
  function() {
    function o() {
      this.groups = {};
    }
    return o.prototype.registerSeries = function(e) {
      var t, i, r = e.id, n = e.seriesGrouping, s = e.visible, a = e.type;
      n && ((t = (i = this.groups)[a]) !== null && t !== void 0 || (i[a] = {}), this.groups[a][r] = { grouping: n, visible: s });
    }, o.prototype.deregisterSeries = function(e) {
      var t = e.id, i = e.type;
      this.groups[i] && delete this.groups[i][t], this.groups[i] && Object.keys(this.groups[i]).length === 0 && delete this.groups[i];
    }, o.prototype.getVisiblePeerGroupIndex = function(e) {
      var t, i = e.type, r = e.seriesGrouping;
      if (!r)
        return { visibleGroupCount: 1, index: 0 };
      var n = pW([], Xy(Object.entries((t = this.groups[i]) !== null && t !== void 0 ? t : {}).filter(function(s) {
        var a = Xy(s, 2);
        a[0];
        var l = a[1];
        return l.visible;
      }).reduce(function(s, a) {
        var l = Xy(a, 2);
        l[0];
        var c = l[1];
        return c.visible && s.add(c.grouping.groupIndex), s;
      }, /* @__PURE__ */ new Set()).values()));
      return n.sort(function(s, a) {
        return s - a;
      }), { visibleGroupCount: n.length, index: n.indexOf(r.groupIndex) };
    }, o;
  }()
), z0 = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, gW = (
  /** @class */
  function() {
    function o(e) {
      this.groups = {}, this.series = {}, this.rootGroup = e;
    }
    return o.prototype.requestGroup = function(e) {
      var t, i, r, n, s = e.id, a = e.type, l = e.rootGroup, c = e.seriesGrouping, d = (c != null ? c : {}).groupIndex, u = d === void 0 ? s : d;
      if (this.series[s] != null)
        throw new Error("AG Charts - series already has an allocated layer: " + this.series[s]);
      (t = (r = this.groups)[a]) !== null && t !== void 0 || (r[a] = {});
      var h = this.groups[a][u];
      return h || (h = (i = (n = this.groups[a])[u]) !== null && i !== void 0 ? i : n[u] = {
        seriesIds: [],
        group: this.rootGroup.appendChild(new we({
          name: a + "-content",
          layer: !0,
          zIndex: kt.SERIES_LAYER_ZINDEX,
          zIndexSubOrder: e.getGroupZIndexSubOrder("data")
        }))
      }), this.series[s] = { layerState: h, seriesConfig: e }, h.seriesIds.push(s), h.group.appendChild(l), h.group;
    }, o.prototype.changeGroup = function(e) {
      var t, i, r = e.id, n = e.seriesGrouping, s = e.type, a = e.rootGroup, l = e.oldGrouping, c = (n != null ? n : {}).groupIndex, d = c === void 0 ? r : c;
      !((i = (t = this.groups[s]) === null || t === void 0 ? void 0 : t[d]) === null || i === void 0) && i.seriesIds.includes(r) || (this.series[r] != null && this.releaseGroup({ id: r, seriesGrouping: l, type: s, rootGroup: a }), this.requestGroup(e));
    }, o.prototype.releaseGroup = function(e) {
      var t, i, r, n, s, a = e.id, l = e.seriesGrouping, c = e.rootGroup, d = e.type, u = (l != null ? l : {}).groupIndex, h = u === void 0 ? a : u;
      if (this.series[a] == null)
        throw new Error("AG Charts - series doesn't have an allocated layer: " + a);
      var p = (i = (t = this.groups[d]) === null || t === void 0 ? void 0 : t[h]) !== null && i !== void 0 ? i : (r = this.series[a]) === null || r === void 0 ? void 0 : r.layerState;
      if (p && (p.seriesIds = p.seriesIds.filter(function(g) {
        return g !== a;
      }), p.group.removeChild(c)), (p == null ? void 0 : p.seriesIds.length) === 0)
        this.rootGroup.removeChild(p.group), delete this.groups[d][h], delete this.groups[d][a];
      else if ((p == null ? void 0 : p.seriesIds.length) > 0) {
        var f = (s = this.series[(n = p == null ? void 0 : p.seriesIds) === null || n === void 0 ? void 0 : n[0]]) === null || s === void 0 ? void 0 : s.seriesConfig;
        p.group.zIndexSubOrder = f == null ? void 0 : f.getGroupZIndexSubOrder("data");
      }
      delete this.series[a];
    }, o.prototype.destroy = function() {
      var e, t, i, r;
      try {
        for (var n = z0(Object.values(this.groups)), s = n.next(); !s.done; s = n.next()) {
          var a = s.value;
          try {
            for (var l = (i = void 0, z0(Object.values(a))), c = l.next(); !c.done; c = l.next()) {
              var d = c.value;
              this.rootGroup.removeChild(d.group);
            }
          } catch (u) {
            i = { error: u };
          } finally {
            try {
              c && !c.done && (r = l.return) && r.call(l);
            } finally {
              if (i)
                throw i.error;
            }
          }
        }
      } catch (u) {
        e = { error: u };
      } finally {
        try {
          s && !s.done && (t = n.return) && t.call(n);
        } finally {
          if (e)
            throw e.error;
        }
      }
      this.groups = {}, this.series = {};
    }, o;
  }()
), vW = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Js = function() {
  return Js = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, Js.apply(this, arguments);
}, no = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, zs = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, Ks = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, Bc = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, Hc = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Jf = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, tw = (
  /** @class */
  function(o) {
    vW(e, o);
    function e(t, i, r) {
      t === void 0 && (t = window.document);
      var n, s = o.call(this) || this;
      s.id = Vs(s), s.processedOptions = {}, s.userOptions = {}, s.queuedUserOptions = [], s.seriesRoot = new we({ name: s.id + "-Series-root" }), s.extraDebugStats = {}, s.container = void 0, s.data = [], s.padding = new tv(20), s.seriesAreaPadding = new tv(0), s.title = void 0, s.subtitle = void 0, s.footnote = void 0, s.mode = "standalone", s._destroyed = !1, s.modules = {}, s.legendModules = {}, s._pendingFactoryUpdates = [], s._performUpdateNoRenderCount = 0, s._performUpdateType = qe.NONE, s.seriesToUpdate = /* @__PURE__ */ new Set(), s.performUpdateTrigger = jB(function(u) {
        var h = u.count;
        return zs(s, void 0, void 0, function() {
          var p;
          return Ks(this, function(f) {
            switch (f.label) {
              case 0:
                if (this._destroyed)
                  return [
                    2
                    /*return*/
                  ];
                f.label = 1;
              case 1:
                return f.trys.push([1, 3, , 4]), [4, this.performUpdate(h)];
              case 2:
                return f.sent(), [3, 4];
              case 3:
                return p = f.sent(), this._lastPerformUpdateError = p, pe.error("update error", p), [3, 4];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }), s._axes = [], s._series = [], s.applyLegendOptions = void 0, s.lastInteractionEvent = void 0, s.pointerScheduler = WB(function() {
        s.lastInteractionEvent && s.handlePointer(s.lastInteractionEvent), s.lastInteractionEvent = void 0;
      }), s.onSeriesNodeClick = function(u) {
        var h = Js(Js({}, u), { type: "seriesNodeClick" });
        Object.defineProperty(h, "series", {
          enumerable: !1,
          // Should display the deprecation warning
          get: function() {
            return u.series;
          }
        }), s.fireEvent(h);
      }, s.onSeriesNodeDoubleClick = function(u) {
        var h = Js(Js({}, u), { type: "seriesNodeDoubleClick" });
        s.fireEvent(h);
      };
      var a = r == null ? void 0 : r.scene, l = (n = r == null ? void 0 : r.element) !== null && n !== void 0 ? n : t.createElement("div"), c = r == null ? void 0 : r.container, d = new we({ name: "root" });
      return d.visible = !1, d.append(s.seriesRoot), s.axisGroup = new we({ name: "Axes", layer: !0, zIndex: kt.AXIS_ZINDEX }), d.appendChild(s.axisGroup), s.element = l, l.classList.add("ag-chart-wrapper"), l.style.position = "relative", s.scene = a != null ? a : new zb({ document: t, overrideDevicePixelRatio: i }), s.scene.debug.consoleLog = !1, s.scene.root = d, s.scene.container = l, s.autoSize = !0, s.chartEventManager = new iH(), s.cursorManager = new eH(l), s.highlightManager = new sH(), s.interactionManager = new uH(l), s.zoomManager = new gH(), s.dataService = new SH(function() {
        return s.series;
      }), s.layoutService = new CH(), s.updateService = new bH(function(u, h) {
        u === void 0 && (u = qe.FULL);
        var p = h.forceNodeDataRefresh;
        return s.update(u, { forceNodeDataRefresh: p });
      }), s.seriesStateManager = new fW(), s.seriesLayerManager = new gW(s.seriesRoot), s.callbackCache = new uW(), s.animationManager = new QB(s.interactionManager), s.animationManager.skipAnimations = !0, s.animationManager.play(), s.tooltip = new hB(s.scene.canvas.element, t, t.body), s.tooltipManager = new pH(s.tooltip, s.interactionManager), s.overlays = new $B(s.element), s.highlight = new EH(), s.container = c, s.debug = !1, x0.observe(s.element, function(u) {
        var h, p = u.width, f = u.height;
        if (s.autoSize && !(p === 0 && f === 0)) {
          var g = Bc((h = s._lastAutoSize) !== null && h !== void 0 ? h : [], 2), v = g[0], y = v === void 0 ? 0 : v, m = g[1], C = m === void 0 ? 0 : m;
          y === p && C === f || (s._lastAutoSize = [p, f], s.resize());
        }
      }), s.layoutService.addListener("start-layout", function(u) {
        return s.positionPadding(u.shrinkRect);
      }), s.layoutService.addListener("start-layout", function(u) {
        return s.positionCaptions(u.shrinkRect);
      }), s.interactionManager.addListener("click", function(u) {
        return s.onClick(u);
      }), s.interactionManager.addListener("dblclick", function(u) {
        return s.onDoubleClick(u);
      }), s.interactionManager.addListener("hover", function(u) {
        return s.onMouseMove(u);
      }), s.interactionManager.addListener("leave", function(u) {
        return s.onLeave(u);
      }), s.interactionManager.addListener("page-left", function() {
        return s.destroy();
      }), s.interactionManager.addListener("wheel", function() {
        return s.disablePointer();
      }), s.animationManager.addListener("animation-frame", function(u) {
        s.update(qe.SCENE_RENDER);
      }), s.highlightManager.addListener("highlight-change", function(u) {
        return s.changeHighlightDatum(u);
      }), s.zoomManager.addListener("zoom-change", function(u) {
        return s.update(qe.PROCESS_DATA, { forceNodeDataRefresh: !0 });
      }), s.attachLegend("category"), s;
    }
    return e.prototype.getOptions = function() {
      var t, i = this.queuedUserOptions, r = (t = i[i.length - 1]) !== null && t !== void 0 ? t : this.userOptions;
      return Ft([r]);
    }, e.prototype.autoSizeChanged = function(t) {
      var i = this.element.style;
      if (t) {
        if (i.display = "block", i.width = "100%", i.height = "100%", !this._lastAutoSize)
          return;
        this.resize();
      } else
        i.display = "inline-block", i.width = "auto", i.height = "auto";
    }, e.prototype.download = function(t, i) {
      this.scene.download(t, i);
    }, Object.defineProperty(e.prototype, "destroyed", {
      get: function() {
        return this._destroyed;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.addModule = function(t) {
      if (this.modules[t.optionsKey] != null)
        throw new Error("AG Charts - module already initialised: " + t.optionsKey);
      var i = new t.instanceConstructor(this.getModuleContext());
      this.modules[t.optionsKey] = { instance: i }, this[t.optionsKey] = i;
    }, e.prototype.removeModule = function(t) {
      var i, r;
      (r = (i = this.modules[t.optionsKey]) === null || i === void 0 ? void 0 : i.instance) === null || r === void 0 || r.destroy(), delete this.modules[t.optionsKey], delete this[t.optionsKey];
    }, e.prototype.isModuleEnabled = function(t) {
      return this.modules[t.optionsKey] != null;
    }, e.prototype.getModuleContext = function() {
      var t = this, i = t.scene, r = t.animationManager, n = t.chartEventManager, s = t.cursorManager, a = t.highlightManager, l = t.interactionManager, c = t.tooltipManager, d = t.zoomManager, u = t.dataService, h = t.layoutService, p = t.updateService, f = t.seriesStateManager, g = t.seriesLayerManager, v = t.mode, y = t.callbackCache;
      return {
        scene: i,
        animationManager: r,
        chartEventManager: n,
        cursorManager: s,
        highlightManager: a,
        interactionManager: l,
        tooltipManager: c,
        zoomManager: d,
        dataService: u,
        layoutService: h,
        updateService: p,
        mode: v,
        seriesStateManager: f,
        seriesLayerManager: g,
        callbackCache: y
      };
    }, e.prototype.destroy = function(t) {
      var i, r, n;
      if (!this._destroyed) {
        var s = t == null ? void 0 : t.keepTransferableResources, a = void 0;
        this._performUpdateType = qe.NONE, this._pendingFactoryUpdates.splice(0), this.tooltipManager.destroy(), this.tooltip.destroy(), (n = this.legend) === null || n === void 0 || n.destroy(), this.overlays.noData.hide(), x0.unobserve(this.element);
        try {
          for (var l = Hc(Object.entries(this.modules)), c = l.next(); !c.done; c = l.next()) {
            var d = Bc(c.value, 2), u = d[0], h = d[1];
            h.instance.destroy(), delete this.modules[u], delete this[u];
          }
        } catch (p) {
          i = { error: p };
        } finally {
          try {
            c && !c.done && (r = l.return) && r.call(l);
          } finally {
            if (i)
              throw i.error;
          }
        }
        return this.interactionManager.destroy(), this.animationManager.stop(), s ? (this.scene.strip(), a = { container: this.container, scene: this.scene, element: this.element }) : (this.scene.destroy(), this.container = void 0), this.removeAllSeries(), this.seriesLayerManager.destroy(), this.axes.forEach(function(p) {
          return p.destroy();
        }), this.axes = [], this.callbackCache.invalidateCache(), this._destroyed = !0, a;
      }
    }, e.prototype.log = function() {
      for (var t = [], i = 0; i < arguments.length; i++)
        t[i] = arguments[i];
      this.debug && pe.debug.apply(pe, Jf([], Bc(t)));
    }, e.prototype.disablePointer = function(t) {
      t === void 0 && (t = !1), t || this.tooltipManager.removeTooltip(this.id), this.highlightManager.updateHighlight(this.id), this.lastInteractionEvent && (this.lastInteractionEvent = void 0);
    }, e.prototype.requestFactoryUpdate = function(t) {
      var i = this._pendingFactoryUpdates, r = i.length;
      r === 0 ? (i.push(t), this._processCallbacks().catch(function(n) {
        return pe.errorOnce(n);
      })) : i.splice(1, r - 1, t);
    }, e.prototype._processCallbacks = function() {
      return zs(this, void 0, void 0, function() {
        var t, i;
        return Ks(this, function(r) {
          switch (r.label) {
            case 0:
              t = this._pendingFactoryUpdates, r.label = 1;
            case 1:
              return t.length > 0 ? this.updatePending ? [4, D0(1)] : [3, 3] : [3, 7];
            case 2:
              return r.sent(), [3, 1];
            case 3:
              return r.trys.push([3, 5, , 6]), [4, t[0]()];
            case 4:
              return r.sent(), this.callbackCache.invalidateCache(), [3, 6];
            case 5:
              return i = r.sent(), pe.error("update error", i), [3, 6];
            case 6:
              return t.shift(), [3, 1];
            case 7:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, Object.defineProperty(e.prototype, "performUpdateType", {
      get: function() {
        return this._performUpdateType;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "updatePending", {
      get: function() {
        return this._performUpdateType !== qe.NONE || this.lastInteractionEvent != null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "lastPerformUpdateError", {
      get: function() {
        return this._lastPerformUpdateError;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.awaitUpdateCompletion = function() {
      return zs(this, void 0, void 0, function() {
        return Ks(this, function(t) {
          switch (t.label) {
            case 0:
              return [4, this.performUpdateTrigger.await()];
            case 1:
              return t.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.update = function(t, i) {
      var r, n;
      t === void 0 && (t = qe.FULL);
      var s = i != null ? i : {}, a = s.forceNodeDataRefresh, l = a === void 0 ? !1 : a, c = s.seriesToUpdate, d = c === void 0 ? this.series : c;
      l && this.series.forEach(function(f) {
        return f.markNodeDataDirty();
      });
      try {
        for (var u = Hc(d), h = u.next(); !h.done; h = u.next()) {
          var p = h.value;
          this.seriesToUpdate.add(p);
        }
      } catch (f) {
        r = { error: f };
      } finally {
        try {
          h && !h.done && (n = u.return) && n.call(u);
        } finally {
          if (r)
            throw r.error;
        }
      }
      t < this._performUpdateType && (this._performUpdateType = t, this.performUpdateTrigger.schedule());
    }, e.prototype.performUpdate = function(t) {
      var i;
      return zs(this, void 0, void 0, function() {
        var r, n, s, a, l, c, d, u, h;
        return Ks(this, function(p) {
          switch (p.label) {
            case 0:
              switch (r = this, n = r._performUpdateType, s = r.extraDebugStats, this.log("Chart.performUpdate() - start", qe[n]), a = [performance.now()], l = n, l) {
                case qe.FULL:
                  return [3, 1];
                case qe.PROCESS_DATA:
                  return [3, 1];
                case qe.PERFORM_LAYOUT:
                  return [3, 3];
                case qe.SERIES_UPDATE:
                  return [3, 5];
                case qe.TOOLTIP_RECALCULATION:
                  return [3, 7];
                case qe.SCENE_RENDER:
                  return [3, 8];
                case qe.NONE:
                  return [3, 10];
              }
              return [3, 11];
            case 1:
              return [4, this.processData()];
            case 2:
              p.sent(), this.disablePointer(!0), a.push(performance.now()), p.label = 3;
            case 3:
              return this.checkFirstAutoSize() ? [4, this.performLayout()] : [3, 11];
            case 4:
              p.sent(), this.handleOverlays(), this.log("Chart.performUpdate() - seriesRect", this.seriesRect), a.push(performance.now()), p.label = 5;
            case 5:
              return c = this.seriesRect, d = Jf([], Bc(this.seriesToUpdate)).map(function(f) {
                return f.update({ seriesRect: c });
              }), this.seriesToUpdate.clear(), [4, Promise.all(d)];
            case 6:
              p.sent(), a.push(performance.now()), p.label = 7;
            case 7:
              u = this.tooltipManager.getTooltipMeta(this.id), n < qe.SERIES_UPDATE && ((i = u == null ? void 0 : u.event) === null || i === void 0 ? void 0 : i.type) === "hover" && this.handlePointer(u.event), p.label = 8;
            case 8:
              return [4, this.scene.render({ debugSplitTimes: a, extraDebugStats: s })];
            case 9:
              p.sent(), this.extraDebugStats = {}, p.label = 10;
            case 10:
              this._performUpdateType = qe.NONE, p.label = 11;
            case 11:
              return h = performance.now(), this.log("Chart.performUpdate() - end", {
                chart: this,
                durationMs: Math.round((h - a[0]) * 100) / 100,
                count: t,
                performUpdateType: qe[n]
              }), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.checkFirstAutoSize = function() {
      if (this.autoSize && !this._lastAutoSize) {
        var t = this._performUpdateNoRenderCount++, i = (t ^ 2) * 10;
        if (t < 5)
          return this._performUpdateType = qe.PERFORM_LAYOUT, this.performUpdateTrigger.schedule(i), this.log("Chart.checkFirstAutoSize() - backing off until first size update", i), !1;
        this.log("Chart.checkFirstAutoSize() - timeout for first size update.");
      }
      return this._performUpdateNoRenderCount = 0, !0;
    }, Object.defineProperty(e.prototype, "axes", {
      get: function() {
        return this._axes;
      },
      set: function(t) {
        var i = this, r = /* @__PURE__ */ new Set();
        this._axes.forEach(function(n) {
          n.detachAxis(i.axisGroup), r.add(n);
        }), this._axes = t.filter(function(n) {
          return !n.linkedTo;
        }).concat(t.filter(function(n) {
          return n.linkedTo;
        })), this._axes.forEach(function(n) {
          n.attachAxis(i.axisGroup), r.delete(n);
        }), this.zoomManager.updateAxes(this._axes), r.forEach(function(n) {
          return n.destroy();
        });
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "series", {
      get: function() {
        return this._series;
      },
      set: function(t) {
        var i = this;
        this.removeAllSeries(), t.forEach(function(r) {
          return i.addSeries(r);
        });
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.addSeries = function(t) {
      var i = this.series, r = i.indexOf(t) < 0;
      return r ? (i.push(t), t.rootGroup.parent == null && this.seriesLayerManager.requestGroup(t), this.initSeries(t), !0) : !1;
    }, e.prototype.initSeries = function(t) {
      t.chart = this, t.data || (t.data = this.data), this.addSeriesListeners(t), t.addChartEventListeners();
    }, e.prototype.removeAllSeries = function() {
      var t = this;
      this.series.forEach(function(i) {
        i.removeEventListener("nodeClick", t.onSeriesNodeClick), i.removeEventListener("nodeDoubleClick", t.onSeriesNodeDoubleClick), i.destroy(), i.chart = void 0;
      }), this._series = [];
    }, e.prototype.addSeriesListeners = function(t) {
      this.hasEventListener("seriesNodeClick") && t.addEventListener("nodeClick", this.onSeriesNodeClick), this.hasEventListener("seriesNodeDoubleClick") && t.addEventListener("nodeDoubleClick", this.onSeriesNodeDoubleClick);
    }, e.prototype.updateAllSeriesListeners = function() {
      var t = this;
      this.series.forEach(function(i) {
        i.removeEventListener("nodeClick", t.onSeriesNodeClick), i.removeEventListener("nodeDoubleClick", t.onSeriesNodeDoubleClick), t.addSeriesListeners(i);
      });
    }, e.prototype.assignSeriesToAxes = function() {
      var t = this;
      this.axes.forEach(function(i) {
        i.boundSeries = t.series.filter(function(r) {
          var n = r.axes[i.direction];
          return n === i;
        });
      });
    }, e.prototype.assignAxesToSeries = function() {
      var t = this, i = {};
      this.axes.forEach(function(r) {
        var n, s = r.direction, a = (n = i[s]) !== null && n !== void 0 ? n : i[s] = [];
        a.push(r);
      }), this.series.forEach(function(r) {
        r.directions.forEach(function(n) {
          var s = i[n];
          if (!s) {
            pe.warn("no available axis for direction [" + n + "]; check series and axes configuration.");
            return;
          }
          var a = r.getKeys(n), l = t.findMatchingAxis(s, r.getKeys(n));
          if (!l) {
            pe.warn("no matching axis for direction [" + n + "] and keys [" + a + "]; check series and axes configuration.");
            return;
          }
          r.axes[n] = l;
        });
      });
    }, e.prototype.findMatchingAxis = function(t, i) {
      var r, n, s, a;
      try {
        for (var l = Hc(t), c = l.next(); !c.done; c = l.next()) {
          var d = c.value, u = d.keys;
          if (!u.length)
            return d;
          if (i)
            try {
              for (var h = (s = void 0, Hc(i)), p = h.next(); !p.done; p = h.next()) {
                var f = p.value;
                if (u.indexOf(f) >= 0)
                  return d;
              }
            } catch (g) {
              s = { error: g };
            } finally {
              try {
                p && !p.done && (a = h.return) && a.call(h);
              } finally {
                if (s)
                  throw s.error;
              }
            }
        }
      } catch (g) {
        r = { error: g };
      } finally {
        try {
          c && !c.done && (n = l.return) && n.call(l);
        } finally {
          if (r)
            throw r.error;
        }
      }
    }, e.prototype.resize = function(t, i) {
      var r, n, s, a;
      t != null || (t = (r = this.width) !== null && r !== void 0 ? r : this.autoSize ? (n = this._lastAutoSize) === null || n === void 0 ? void 0 : n[0] : this.scene.canvas.width), i != null || (i = (s = this.height) !== null && s !== void 0 ? s : this.autoSize ? (a = this._lastAutoSize) === null || a === void 0 ? void 0 : a[1] : this.scene.canvas.height), this.log("Chart.resize()", { width: t, height: i }), !(!t || !i || !Number.isFinite(t) || !Number.isFinite(i)) && this.scene.resize(t, i) && (this.disablePointer(), this.update(qe.PERFORM_LAYOUT, { forceNodeDataRefresh: !0 }));
    }, e.prototype.processData = function() {
      return zs(this, void 0, void 0, function() {
        var t, i;
        return Ks(this, function(r) {
          switch (r.label) {
            case 0:
              return this.axes.length > 0 && (this.assignAxesToSeries(), this.assignSeriesToAxes()), t = new hW(), i = this.series.map(function(n) {
                return n.processData(t);
              }), [4, t.execute()];
            case 1:
              return r.sent(), [4, Promise.all(i)];
            case 2:
              return r.sent(), [4, this.updateLegend()];
            case 3:
              return r.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.placeLabels = function() {
      var t, i, r = [], n = [];
      try {
        for (var s = Hc(this.series), a = s.next(); !a.done; a = s.next()) {
          var l = a.value;
          if (l.visible) {
            var c = l.getLabelData();
            c && GB(c[0]) && (n.push(c), r.push(l));
          }
        }
      } catch (h) {
        t = { error: h };
      } finally {
        try {
          a && !a.done && (i = s.return) && i.call(s);
        } finally {
          if (t)
            throw t.error;
        }
      }
      var d = this.seriesRect, u = d && n.length > 0 ? kB(n, { x: 0, y: 0, width: d.width, height: d.height }) : [];
      return new Map(u.map(function(h, p) {
        return [r[p], h];
      }));
    }, e.prototype.attachLegend = function(t) {
      var i;
      if (this.legendType === t && this.legend)
        return this.legend;
      (i = this.legend) === null || i === void 0 || i.destroy(), this.legend = void 0;
      var r = this.getModuleContext(), n = lW(t, r);
      return n.attachLegend(this.scene.root), this.legend = n, this.legendType = t, n;
    }, e.prototype.setLegendInit = function(t) {
      this.applyLegendOptions = t;
    }, e.prototype.updateLegend = function() {
      var t;
      return zs(this, void 0, void 0, function() {
        var i, r, n;
        return Ks(this, function(s) {
          return i = [], this.series.filter(function(a) {
            return a.showInLegend;
          }).forEach(function(a) {
            var l = a.getLegendData();
            i.push.apply(i, Jf([], Bc(l)));
          }), r = i.length > 0 ? i[0].legendType : "category", n = this.attachLegend(r), (t = this.applyLegendOptions) === null || t === void 0 || t.call(this, n), r === "category" && this.validateLegendData(i), n.data = i, [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.validateLegendData = function(t) {
      var i = this, r = {};
      t.forEach(function(n) {
        var s, a, l, c, d, u, h = (a = i.series.find(function(f) {
          return f.id === n.seriesId;
        })) === null || a === void 0 ? void 0 : a.type;
        if (h) {
          var p = n;
          (l = r[h]) !== null && l !== void 0 || (r[h] = (s = {}, s[p.label.text] = /* @__PURE__ */ new Set(), s)), (c = (d = r[h])[u = p.label.text]) !== null && c !== void 0 || (d[u] = /* @__PURE__ */ new Set()), p.marker.fill != null && r[h][p.label.text].add(p.marker.fill);
        }
      }), Object.keys(r).forEach(function(n) {
        Object.keys(r[n]).forEach(function(s) {
          var a = r[n][s];
          a.size > 1 && pe.warnOnce("legend item '" + s + "' has multiple fill colors, this may cause unexpected behaviour.");
        });
      });
    }, e.prototype.performLayout = function() {
      return zs(this, void 0, void 0, function() {
        var t, i, r, n;
        return Ks(this, function(s) {
          return this.scene.root != null && (this.scene.root.visible = !0), t = this.scene, i = t.width, r = t.height, n = new nt(0, 0, i, r), n = this.layoutService.dispatchPerformLayout("start-layout", { shrinkRect: n }).shrinkRect, n = this.layoutService.dispatchPerformLayout("before-series", { shrinkRect: n }).shrinkRect, [2, n];
        });
      });
    }, e.prototype.positionPadding = function(t) {
      var i = this.padding;
      return t.shrink(i.left, "left"), t.shrink(i.top, "top"), t.shrink(i.right, "right"), t.shrink(i.bottom, "bottom"), { shrinkRect: t };
    }, e.prototype.positionCaptions = function(t) {
      var i, r = this, n = r.title, s = r.subtitle, a = r.footnote, l = t.clone(), c = function(h) {
        var p, f = t.height / 10, g = (p = h.lineHeight) !== null && p !== void 0 ? p : h.fontSize * ut.defaultLineHeightRatio, v = t.width, y = Math.max(g, f);
        h.computeTextWrap(v, y);
      }, d = function(h) {
        var p, f = l.y;
        h.node.x = l.x + l.width / 2, h.node.y = f, h.node.textBaseline = "top", c(h);
        var g = h.node.computeBBox(), v = Math.ceil(g.y - f + g.height + ((p = h.spacing) !== null && p !== void 0 ? p : 0));
        l.shrink(v, "top");
      }, u = function(h) {
        var p, f = l.y + l.height;
        h.node.x = l.x + l.width / 2, h.node.y = f, h.node.textBaseline = "bottom", c(h);
        var g = h.node.computeBBox(), v = Math.ceil(f - g.y + ((p = h.spacing) !== null && p !== void 0 ? p : 0));
        l.shrink(v, "bottom");
      };
      return n && (n.node.visible = n.enabled, n.node.visible && d(n)), s && (s.node.visible = (i = (n == null ? void 0 : n.enabled) && s.enabled) !== null && i !== void 0 ? i : !1, s.node.visible && d(s)), a && (a.node.visible = a.enabled, a.node.visible && u(a)), { shrinkRect: l };
    }, e.prototype.getSeriesRect = function() {
      return this.seriesRect;
    }, e.prototype.pickSeriesNode = function(t, i, r) {
      var n, s, a, l, c = performance.now(), d = i ? [Zt.EXACT_SHAPE_MATCH] : void 0, u = Jf([], Bc(this.series)).reverse(), h = void 0;
      try {
        for (var p = Hc(u), f = p.next(); !f.done; f = p.next()) {
          var g = f.value;
          if (!(!g.visible || !g.rootGroup.visible)) {
            var v = (a = g.pickNode(t, d)) !== null && a !== void 0 ? a : {}, y = v.match, m = v.distance;
            if (!(!y || m == null) && ((!h || h.distance > m) && m <= (r != null ? r : 1 / 0) && (h = { series: g, distance: m, datum: y }), m === 0))
              break;
          }
        }
      } catch (C) {
        n = { error: C };
      } finally {
        try {
          f && !f.done && (s = p.return) && s.call(p);
        } finally {
          if (n)
            throw n.error;
        }
      }
      return this.extraDebugStats.pickSeriesNode = Math.round(((l = this.extraDebugStats.pickSeriesNode) !== null && l !== void 0 ? l : 0) + (performance.now() - c)), h;
    }, e.prototype.onMouseMove = function(t) {
      this.lastInteractionEvent = t, this.pointerScheduler.schedule(), this.extraDebugStats.mouseX = t.offsetX, this.extraDebugStats.mouseY = t.offsetY, this.update(qe.SCENE_RENDER);
    }, e.prototype.onLeave = function(t) {
      this.tooltip.pointerLeftOntoTooltip(t) || this.disablePointer();
    }, e.prototype.handlePointer = function(t) {
      var i = this, r = this, n = r.lastPick, s = r.hoverRect, a = t.offsetX, l = t.offsetY, c = function(d) {
        d === void 0 && (d = !1), n && i.disablePointer(d);
      };
      if (!(s != null && s.containsPoint(a, l))) {
        c();
        return;
      }
      this.handlePointerTooltip(t, c), this.handlePointerNode(t);
    }, e.prototype.handlePointerTooltip = function(t, i) {
      var r, n, s = this, a = s.lastPick, l = s.tooltip, c = l.range, d = t.pageX, u = t.pageY, h = t.offsetX, p = t.offsetY, f;
      typeof c == "number" && Number.isFinite(c) && (f = c);
      var g = this.pickSeriesNode({ x: h, y: p }, c === "exact", f);
      if (!g) {
        this.tooltipManager.updateTooltip(this.id), this.highlight.range === "tooltip" && i(!0);
        return;
      }
      var v = this.highlight.range === "node" || !a || a.datum !== g.datum, y;
      v ? (y = g.series.getTooltipHtml(g.datum), this.highlight.range === "tooltip" && this.highlightManager.updateHighlight(this.id, g.datum)) : a && (a.event = t.sourceEvent);
      var m = f != null, C = this.tooltip.enabled && g.series.tooltip.enabled, R = c === "exact" && g.distance === 0, E = c === "nearest" || m || R, b = C && E && (!v || y !== void 0), T = {
        xOffset: g.datum.series.tooltip.position.xOffset,
        yOffset: g.datum.series.tooltip.position.yOffset
      }, D = this.mergePointerDatum({ pageX: d, pageY: u, offsetX: h, offsetY: p, event: t, showArrow: g.series.tooltip.showArrow, position: T }, g.datum);
      D.enableInteraction = (n = (r = g.series.tooltip.interaction) === null || r === void 0 ? void 0 : r.enabled) !== null && n !== void 0 ? n : !1, b && this.tooltipManager.updateTooltip(this.id, D, y);
    }, e.prototype.handlePointerNode = function(t) {
      var i = this, r = this.checkSeriesNodeRange(t, function(n, s) {
        (n.hasEventListener("nodeClick") || n.hasEventListener("nodeDoubleClick")) && i.cursorManager.updateCursor("chart", "pointer"), i.highlight.range === "node" && i.highlightManager.updateHighlight(i.id, s);
      });
      r || (this.cursorManager.updateCursor("chart"), this.highlight.range === "node" && this.highlightManager.updateHighlight(this.id));
    }, e.prototype.onClick = function(t) {
      if (this.checkSeriesNodeClick(t)) {
        this.update(qe.SERIES_UPDATE);
        return;
      }
      this.fireEvent({
        type: "click",
        event: t.sourceEvent
      });
    }, e.prototype.onDoubleClick = function(t) {
      if (this.checkSeriesNodeDoubleClick(t)) {
        this.update(qe.SERIES_UPDATE);
        return;
      }
      this.fireEvent({
        type: "doubleClick",
        event: t.sourceEvent
      });
    }, e.prototype.checkSeriesNodeClick = function(t) {
      return this.checkSeriesNodeRange(t, function(i, r) {
        return i.fireNodeClickEvent(t.sourceEvent, r);
      });
    }, e.prototype.checkSeriesNodeDoubleClick = function(t) {
      return this.checkSeriesNodeRange(t, function(i, r) {
        return i.fireNodeDoubleClickEvent(t.sourceEvent, r);
      });
    }, e.prototype.checkSeriesNodeRange = function(t, i) {
      var r = this.pickSeriesNode({ x: t.offsetX, y: t.offsetY }, !1), n = r == null ? void 0 : r.datum, s = n == null ? void 0 : n.series.nodeClickRange;
      if (n && s === "nearest")
        return i(n.series, n), !0;
      var a;
      typeof s == "number" && Number.isFinite(s) && (a = s);
      var l = this.pickSeriesNode({ x: t.offsetX, y: t.offsetY }, s === "exact", a);
      if (!l)
        return !1;
      var c = a != null, d = s === "exact" && l.distance === 0;
      return c || d ? (i(l.series, l.datum), !0) : !1;
    }, e.prototype.mergePointerDatum = function(t, i) {
      var r = i.series.tooltip.position.type;
      if (r === "node" && i.nodeMidPoint) {
        var n = i.nodeMidPoint, s = n.x, a = n.y, l = this.scene.canvas, c = i.series.contentGroup.inverseTransformPoint(s, a), d = l.element.getBoundingClientRect();
        return Js(Js({}, t), { pageX: Math.round(d.left + window.scrollX + c.x), pageY: Math.round(d.top + window.scrollY + c.y), offsetX: Math.round(c.x), offsetY: Math.round(c.y) });
      }
      return t;
    }, e.prototype.changeHighlightDatum = function(t) {
      var i, r, n = /* @__PURE__ */ new Set(), s = (i = t.currentHighlight) !== null && i !== void 0 ? i : {}, a = s.series, l = a === void 0 ? void 0 : a, c = s.datum, d = (r = t.previousHighlight) !== null && r !== void 0 ? r : {}, u = d.series, h = u === void 0 ? void 0 : u, p = d.datum;
      h && n.add(h), l && n.add(l), h != null && h.cursor && p && this.cursorManager.updateCursor(h.id), l != null && l.cursor && c && this.cursorManager.updateCursor(l.id, l.cursor), this.lastPick = t.currentHighlight ? { datum: t.currentHighlight } : void 0;
      var f = l == null || h == null;
      f ? this.update(qe.SERIES_UPDATE) : this.update(qe.SERIES_UPDATE, { seriesToUpdate: n });
    }, e.prototype.waitForUpdate = function(t) {
      return t === void 0 && (t = 5e3), zs(this, void 0, void 0, function() {
        var i;
        return Ks(this, function(r) {
          switch (r.label) {
            case 0:
              i = performance.now(), r.label = 1;
            case 1:
              if (!(this._pendingFactoryUpdates.length > 0 || this.updatePending))
                return [3, 3];
              if (performance.now() - i > t)
                throw new Error("waitForUpdate() timeout reached.");
              return [4, D0(5)];
            case 2:
              return r.sent(), [3, 1];
            case 3:
              return [4, this.awaitUpdateCompletion()];
            case 4:
              return r.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.handleOverlays = function() {
      this.handleNoDataOverlay();
    }, e.prototype.handleNoDataOverlay = function() {
      var t = !this.series.some(function(r) {
        return r.hasData();
      }), i = this.getSeriesRect();
      t && i ? this.overlays.noData.show(i) : this.overlays.noData.hide();
    }, no([
      lo({
        newValue: function(t) {
          this.scene.debug.consoleLog = t, this.animationManager && (this.animationManager.debug = t);
        }
      })
    ], e.prototype, "debug", void 0), no([
      lo({
        newValue: function(t) {
          this.destroyed || t.appendChild(this.element);
        },
        oldValue: function(t) {
          t.removeChild(this.element);
        }
      })
    ], e.prototype, "container", void 0), no([
      lo({
        newValue: function(t) {
          var i;
          (i = this.series) === null || i === void 0 || i.forEach(function(r) {
            return r.data = t;
          });
        }
      })
    ], e.prototype, "data", void 0), no([
      lo({
        newValue: function(t) {
          this.resize(t);
        }
      })
    ], e.prototype, "width", void 0), no([
      lo({
        newValue: function(t) {
          this.resize(void 0, t);
        }
      })
    ], e.prototype, "height", void 0), no([
      lo({
        changeValue: function(t) {
          this.autoSizeChanged(t);
        }
      }),
      A(ht)
    ], e.prototype, "autoSize", void 0), no([
      lo({
        newValue: function(t) {
          var i;
          (i = this.scene.root) === null || i === void 0 || i.appendChild(t.node);
        },
        oldValue: function(t) {
          var i;
          (i = this.scene.root) === null || i === void 0 || i.removeChild(t.node);
        }
      })
    ], e.prototype, "title", void 0), no([
      lo({
        newValue: function(t) {
          var i;
          (i = this.scene.root) === null || i === void 0 || i.appendChild(t.node);
        },
        oldValue: function(t) {
          var i;
          (i = this.scene.root) === null || i === void 0 || i.removeChild(t.node);
        }
      })
    ], e.prototype, "subtitle", void 0), no([
      lo({
        newValue: function(t) {
          var i;
          (i = this.scene.root) === null || i === void 0 || i.appendChild(t.node);
        },
        oldValue: function(t) {
          var i;
          (i = this.scene.root) === null || i === void 0 || i.removeChild(t.node);
        }
      })
    ], e.prototype, "footnote", void 0), no([
      A(yD("standalone", "integrated"))
    ], e.prototype, "mode", void 0), e;
  }(hD)
), mW = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
};
function qy(o, e, t) {
  return Math.max(e, Math.min(t, o));
}
var $n = (
  /** @class */
  function() {
    function o() {
      this.type = "band", this.cache = null, this.cacheProps = ["_domain", "range", "_paddingInner", "_paddingOuter", "round", "interval"], this.index = /* @__PURE__ */ new Map(), this.ordinalRange = [], this._domain = [], this.range = [0, 1], this._bandwidth = 1, this._rawBandwidth = 1, this._paddingInner = 0, this._paddingOuter = 0, this.round = !1;
    }
    return o.prototype.didChange = function() {
      var e = this, t = this.cache, i = !t || this.cacheProps.some(function(r) {
        return e[r] !== t[r];
      });
      return i ? (this.cache = {}, this.cacheProps.forEach(function(r) {
        return e.cache[r] = e[r];
      }), !0) : !1;
    }, o.prototype.refresh = function() {
      this.didChange() && this.update();
    }, Object.defineProperty(o.prototype, "domain", {
      get: function() {
        return this._domain;
      },
      set: function(e) {
        var t = [];
        this.index = /* @__PURE__ */ new Map();
        var i = this.index;
        e.forEach(function(r) {
          i.get(r) === void 0 && i.set(r, t.push(r) - 1);
        }), this._domain = t;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.ticks = function() {
      this.refresh();
      var e = this.interval, t = e === void 0 ? 1 : e, i = Math.abs(Math.round(t));
      return this._domain.filter(function(r, n) {
        return n % i === 0;
      });
    }, o.prototype.convert = function(e) {
      this.refresh();
      var t = this.index.get(e);
      if (t === void 0)
        return NaN;
      var i = this.ordinalRange[t];
      return i === void 0 ? NaN : i;
    }, o.prototype.invert = function(e) {
      this.refresh();
      var t = this.ordinalRange.findIndex(function(i) {
        return i === e;
      });
      return this.domain[t];
    }, Object.defineProperty(o.prototype, "bandwidth", {
      get: function() {
        return this.refresh(), this._bandwidth;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "rawBandwidth", {
      get: function() {
        return this.refresh(), this._rawBandwidth;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "padding", {
      get: function() {
        return this._paddingInner;
      },
      set: function(e) {
        e = qy(e, 0, 1), this._paddingInner = e, this._paddingOuter = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "paddingInner", {
      get: function() {
        return this._paddingInner;
      },
      set: function(e) {
        this._paddingInner = qy(e, 0, 1);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "paddingOuter", {
      get: function() {
        return this._paddingOuter;
      },
      set: function(e) {
        this._paddingOuter = qy(e, 0, 1);
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.update = function() {
      var e = this._domain.length;
      if (e !== 0) {
        for (var t = this.round, i = this._paddingInner, r = this._paddingOuter, n = mW(this.range, 2), s = n[0], a = n[1], l = a - s, c = l / Math.max(1, e + 2 * r - i), d = t ? Math.floor(c) : c, u = d * (e - i), h = s + (l - u) / 2, p = t ? Math.round(h) : h, f = d * (1 - i), g = t ? Math.round(f) : f, v = c * (1 - i), y = [], m = 0; m < e; m++)
          y.push(p + d * m);
        this._bandwidth = g, this._rawBandwidth = v, this.ordinalRange = y;
      }
    }, o;
  }()
), yW = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), eg = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, Qt = (
  /** @class */
  function(o) {
    yW(e, o);
    function e() {
      var t = o.call(this) || this;
      return t.x1 = 0, t.y1 = 0, t.x2 = 0, t.y2 = 0, t.restoreOwnStyles(), t;
    }
    return e.prototype.computeBBox = function() {
      return new nt(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);
    }, e.prototype.isPointInPath = function(t, i) {
      return !1;
    }, e.prototype.render = function(t) {
      var i, r = t.ctx, n = t.forceRender, s = t.stats;
      if (this.dirty === oe.NONE && !n) {
        s && (s.nodesSkipped += this.nodeCount.count);
        return;
      }
      this.computeTransformMatrix(), this.matrix.toContext(r);
      var a = this.x1, l = this.y1, c = this.x2, d = this.y2;
      if (a === c) {
        var u = Math.round(a) + Math.floor(this.strokeWidth) % 2 / 2;
        a = u, c = u;
      } else if (l === d) {
        var h = Math.round(l) + Math.floor(this.strokeWidth) % 2 / 2;
        l = h, d = h;
      }
      r.beginPath(), r.moveTo(a, l), r.lineTo(c, d), this.fillStroke(r), (i = this.fillShadow) === null || i === void 0 || i.markClean(), o.prototype.render.call(this, t);
    }, e.className = "Line", e.defaultStyles = Object.assign({}, Mo.defaultStyles, {
      fill: void 0,
      strokeWidth: 1
    }), eg([
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "x1", void 0), eg([
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "y1", void 0), eg([
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "x2", void 0), eg([
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "y2", void 0), e;
  }(Mo)
), Qr = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, xd = (
  /** @class */
  function() {
    function o() {
      this.node = new ut(), this.enabled = !1, this.text = void 0, this.fontSize = 10, this.fontFamily = "sans-serif", this.spacing = o.PADDING, this.lineHeight = void 0, this.maxWidth = void 0, this.maxHeight = void 0, this.wrapping = "always";
      var e = this.node;
      e.textAlign = "center", e.pointerEvents = ki.None;
    }
    return o.prototype.computeTextWrap = function(e, t) {
      var i, r, n = this, s = n.text, a = n.wrapping, l = Math.min((i = this.maxWidth) !== null && i !== void 0 ? i : 1 / 0, e), c = (r = this.maxHeight) !== null && r !== void 0 ? r : t;
      if (!isFinite(l) && !isFinite(c)) {
        this.node.text = s;
        return;
      }
      var d = ut.wrap(s != null ? s : "", l, c, this, a);
      this.node.text = d;
    }, o.PADDING = 10, Qr([
      A(ht)
    ], o.prototype, "enabled", void 0), Qr([
      A(De),
      qt("node")
    ], o.prototype, "text", void 0), Qr([
      A(fc),
      qt("node")
    ], o.prototype, "fontStyle", void 0), Qr([
      A(gc),
      qt("node")
    ], o.prototype, "fontWeight", void 0), Qr([
      A(le(0)),
      qt("node")
    ], o.prototype, "fontSize", void 0), Qr([
      A(Ri),
      qt("node")
    ], o.prototype, "fontFamily", void 0), Qr([
      A(St),
      qt("node", "fill")
    ], o.prototype, "color", void 0), Qr([
      A(lt(0))
    ], o.prototype, "spacing", void 0), Qr([
      A(lt(0))
    ], o.prototype, "lineHeight", void 0), Qr([
      A(lt(0))
    ], o.prototype, "maxWidth", void 0), Qr([
      A(lt(0))
    ], o.prototype, "maxHeight", void 0), Qr([
      A(qb)
    ], o.prototype, "wrapping", void 0), o;
  }()
);
function CW(o, e) {
  return o.length === e.length && o.every(function(t, i) {
    return Number(t) === Number(e[i]);
  });
}
var tg = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, ct = (
  /** @class */
  function() {
    function o(e, t) {
      this.domain = e, this.range = t, this.nice = !1, this.tickCount = o.defaultTickCount, this.minTickCount = 0, this.maxTickCount = 1 / 0, this.niceDomain = null, this.strictClampByDefault = !1, this.cache = null, this.cacheProps = ["domain", "range", "nice", "tickCount", "minTickCount", "maxTickCount"];
    }
    return o.prototype.transform = function(e) {
      return e;
    }, o.prototype.transformInvert = function(e) {
      return e;
    }, o.prototype.fromDomain = function(e) {
      return typeof e == "number" ? e : e instanceof Date ? e.getTime() : NaN;
    }, o.prototype.getDomain = function() {
      return this.nice && (this.refresh(), this.niceDomain) ? this.niceDomain : this.domain;
    }, o.prototype.convert = function(e, t) {
      var i = this, r;
      if (!this.domain || this.domain.length < 2)
        return NaN;
      this.refresh();
      var n = (r = t == null ? void 0 : t.strict) !== null && r !== void 0 ? r : this.strictClampByDefault, s = this.getDomain().map(function(f) {
        return i.transform(f);
      }), a = tg(s, 2), l = a[0], c = a[1], d = this.range, u = tg(d, 2), h = u[0], p = u[1];
      return e = this.transform(e), e < l ? n ? NaN : h : e > c ? n ? NaN : p : l === c ? (h + p) / 2 : e === l ? h : e === c ? p : h + (this.fromDomain(e) - this.fromDomain(l)) / (this.fromDomain(c) - this.fromDomain(l)) * (p - h);
    }, o.prototype.invert = function(e) {
      var t = this;
      this.refresh();
      var i = this.getDomain().map(function(g) {
        return t.transform(g);
      }), r = tg(i, 2), n = r[0], s = r[1], a = this.range, l = tg(a, 2), c = l[0], d = l[1], u = c > d, h = u ? d : c, p = u ? c : d, f;
      return e < h ? u ? s : n : e > p ? u ? n : s : (c === d ? f = this.toDomain((this.fromDomain(n) + this.fromDomain(s)) / 2) : f = this.toDomain(this.fromDomain(n) + (e - c) / (d - c) * (this.fromDomain(s) - this.fromDomain(n))), this.transformInvert(f));
    }, o.prototype.didChange = function() {
      var e = this, t = this.cache, i = !t || this.cacheProps.some(function(r) {
        return e[r] !== t[r];
      });
      return i ? (this.cache = {}, this.cacheProps.forEach(function(r) {
        return e.cache[r] = e[r];
      }), !0) : !1;
    }, o.prototype.refresh = function() {
      this.didChange() && this.update();
    }, o.prototype.isDenseInterval = function(e) {
      var t = e.start, i = e.stop, r = e.interval, n = e.count, s = this.range, a = i - t, l = Math.min(s[0], s[1]), c = Math.max(s[0], s[1]), d = c - l, u = typeof r == "number" ? r : 1;
      return n != null || (n = a / u), n >= d ? (pe.warn("the configured tick interval results in more than 1 tick per pixel, ignoring. Supply a larger tick interval or omit this configuration."), !0) : !1;
    }, o.defaultTickCount = 5, o.defaultMaxTickCount = 6, o;
  }()
), SW = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}();
function Wm(o, e, t, i, r) {
  if (t < 2)
    return sv(o, e, e - o);
  var n = fp(o, e, t, i, r);
  return isNaN(n) ? new iw(0) : (o = Math.ceil(o / n) * n, e = Math.floor(e / n) * n, sv(o, e, n));
}
var ND = [1, 2, 5, 10];
function fp(o, e, t, i, r) {
  i === void 0 && (i = 0), r === void 0 && (r = 1 / 0);
  var n = (e - o) / t, s = Math.floor(Math.log10(n)), a = Math.pow(10, s), l = ND.map(function(c) {
    var d = c * a, u = Math.ceil((e - o) / d), h = u >= i && u <= r, p = Math.abs(u - t);
    return { multiplier: c, isWithinBounds: h, diffCount: p };
  }).sort(function(c, d) {
    return c.isWithinBounds !== d.isWithinBounds ? c.isWithinBounds ? -1 : 1 : c.diffCount - d.diffCount;
  })[0].multiplier;
  return !l || isNaN(l) ? NaN : l * a;
}
function bW(o, e) {
  var t = Math.floor(Math.log10(e - o)), i = Math.pow(10, t);
  return ND.map(function(r) {
    var n = r * i, s = Math.floor(o / n) * n, a = Math.ceil(e / n) * n, l = 1 - (e - o) / (a - s), c = [s, a];
    return { error: l, domain: c };
  }).sort(function(r, n) {
    return r.error - n.error;
  })[0].domain;
}
var iw = (
  /** @class */
  function(o) {
    SW(e, o);
    function e(t, i) {
      var r = o.call(this) || this;
      if (i)
        for (var n = 0, s = i.length; n < s; n++)
          r[n] = i[n];
      return r.fractionDigits = t, r;
    }
    return e;
  }(Array)
);
function sv(o, e, t) {
  for (var i = function(d) {
    var u, h, p = d.split("e");
    return Math.max(((h = (u = p[0].split(".")[1]) === null || u === void 0 ? void 0 : u.length) !== null && h !== void 0 ? h : 0) - Number(p[1]), 0);
  }, r = i((t % 1).toExponential()), n = Math.pow(10, r), s = Math.ceil((e - o) / t), a = new iw(r), l = 0; l <= s; l++) {
    var c = o + t * l;
    a.push(Math.round(c * n) / n);
  }
  return a;
}
var ig = {
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
};
function rw(o, e) {
  e === void 0 && (e = new Date(o.getFullYear(), 0, 1));
  var t = o.getTimezoneOffset() - e.getTimezoneOffset(), i = o.getTime() - e.getTime() + t * 6e4, r = 36e5 * 24;
  return Math.floor(i / r);
}
function K0(o, e) {
  var t = new Date(o.getFullYear(), 0, 1), i = t.getDay(), r = (e - i + 7) % 7, n = new Date(o.getFullYear(), 0, r + 1);
  return n <= o ? Math.floor(rw(o, n) / 7) + 1 : 0;
}
var wW = 0, GD = 1, Y0 = 4;
function kD(o, e) {
  e === void 0 && (e = o.getFullYear());
  var t = new Date(e, 0, 1), i = t.getDay(), r = (Y0 - i + 7) % 7, n = new Date(e, 0, r - (Y0 - GD) + 1);
  return n <= o ? Math.floor(rw(o, n) / 7) + 1 : kD(o, e - 1);
}
function EW(o) {
  var e = o.getTimezoneOffset(), t = Math.abs(e), i = e > 0 ? "-" : "+";
  return "" + i + pi(Math.floor(t / 60), 2, "0") + pi(Math.floor(t % 60), 2, "0");
}
var RW = {
  a: function(o) {
    return ig.shortDays[o.getDay()];
  },
  A: function(o) {
    return ig.days[o.getDay()];
  },
  b: function(o) {
    return ig.shortMonths[o.getMonth()];
  },
  B: function(o) {
    return ig.months[o.getMonth()];
  },
  c: "%x, %X",
  d: function(o, e) {
    return pi(o.getDate(), 2, e != null ? e : "0");
  },
  e: "%_d",
  f: function(o, e) {
    return pi(o.getMilliseconds() * 1e3, 6, e != null ? e : "0");
  },
  H: function(o, e) {
    return pi(o.getHours(), 2, e != null ? e : "0");
  },
  I: function(o, e) {
    var t = o.getHours() % 12;
    return t === 0 ? "12" : pi(t, 2, e != null ? e : "0");
  },
  j: function(o, e) {
    return pi(rw(o) + 1, 3, e != null ? e : "0");
  },
  m: function(o, e) {
    return pi(o.getMonth() + 1, 2, e != null ? e : "0");
  },
  M: function(o, e) {
    return pi(o.getMinutes(), 2, e != null ? e : "0");
  },
  L: function(o, e) {
    return pi(o.getMilliseconds(), 3, e != null ? e : "0");
  },
  p: function(o) {
    return o.getHours() < 12 ? "AM" : "PM";
  },
  Q: function(o) {
    return String(o.getTime());
  },
  s: function(o) {
    return String(Math.floor(o.getTime() / 1e3));
  },
  S: function(o, e) {
    return pi(o.getSeconds(), 2, e != null ? e : "0");
  },
  u: function(o) {
    var e = o.getDay();
    return e < 1 && (e += 7), String(e % 7);
  },
  U: function(o, e) {
    return pi(K0(o, wW), 2, e != null ? e : "0");
  },
  V: function(o, e) {
    return pi(kD(o), 2, e != null ? e : "0");
  },
  w: function(o, e) {
    return pi(o.getDay(), 2, e != null ? e : "0");
  },
  W: function(o, e) {
    return pi(K0(o, GD), 2, e != null ? e : "0");
  },
  x: "%-m/%-d/%Y",
  X: "%-I:%M:%S %p",
  y: function(o, e) {
    return pi(o.getFullYear() % 100, 2, e != null ? e : "0");
  },
  Y: function(o, e) {
    return pi(o.getFullYear(), 4, e != null ? e : "0");
  },
  Z: function(o) {
    return EW(o);
  },
  "%": function() {
    return "%";
  }
}, TW = {
  _: " ",
  0: "0",
  "-": ""
};
function pi(o, e, t) {
  var i = String(Math.floor(o));
  return i.length >= e ? i : "" + t.repeat(e - i.length) + i;
}
function av(o) {
  for (var e = []; o.length > 0; ) {
    var t = o.indexOf("%");
    if (t !== 0) {
      var i = t > 0 ? o.substring(0, t) : o;
      e.push(i);
    }
    if (t < 0)
      break;
    var r = o[t + 1], n = TW[r];
    n != null && t++;
    var s = o[t + 1], a = RW[s];
    if (typeof a == "function")
      e.push([a, n]);
    else if (typeof a == "string") {
      var l = av(a);
      e.push([l, n]);
    } else
      e.push("" + (n != null ? n : "") + s);
    o = o.substring(t + 2);
  }
  return function(c) {
    var d = typeof c == "number" ? new Date(c) : c;
    return e.map(function(u) {
      return typeof u == "string" ? u : u[0](d, u[1]);
    }).join("");
  };
}
var xW = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), DW = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, oo = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, ul = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, On, st;
(function(o) {
  o[o.MILLISECOND = 0] = "MILLISECOND", o[o.SECOND = 1] = "SECOND", o[o.MINUTE = 2] = "MINUTE", o[o.HOUR = 3] = "HOUR", o[o.WEEK_DAY = 4] = "WEEK_DAY", o[o.SHORT_MONTH = 5] = "SHORT_MONTH", o[o.MONTH = 6] = "MONTH", o[o.SHORT_YEAR = 7] = "SHORT_YEAR", o[o.YEAR = 8] = "YEAR";
})(st || (st = {}));
var hl = (On = {}, On[st.MILLISECOND] = ".%L", On[st.SECOND] = ":%S", On[st.MINUTE] = "%I:%M", On[st.HOUR] = "%I %p", On[st.WEEK_DAY] = "%a", On[st.SHORT_MONTH] = "%b %d", On[st.MONTH] = "%B", On[st.SHORT_YEAR] = "%y", On[st.YEAR] = "%Y", On);
function Pn(o) {
  return o instanceof Date ? o.getTime() : o;
}
var nw = (
  /** @class */
  function(o) {
    xW(e, o);
    function e() {
      var t = o.call(this, [new Date(2022, 11, 7), new Date(2022, 11, 8)], [0, 1]) || this;
      return t.type = "time", t.cacheProps = [
        "domain",
        "range",
        "nice",
        "tickCount",
        "interval",
        "minTickCount",
        "maxTickCount"
      ], t.year = t1, t.month = QV, t.week = XV, t.day = YV, t.hour = $V, t.minute = WV, t.second = VV, t.millisecond = NV, t.tickIntervals = [
        [t.second, 1, El],
        [t.second, 5, 5 * El],
        [t.second, 15, 15 * El],
        [t.second, 30, 30 * El],
        [t.minute, 1, Er],
        [t.minute, 5, 5 * Er],
        [t.minute, 15, 15 * Er],
        [t.minute, 30, 30 * Er],
        [t.hour, 1, yo],
        [t.hour, 3, 3 * yo],
        [t.hour, 6, 6 * yo],
        [t.hour, 12, 12 * yo],
        [t.day, 1, ua],
        [t.day, 2, 2 * ua],
        [t.week, 1, vh],
        [t.week, 2, 2 * vh],
        [t.week, 3, 3 * vh],
        [t.month, 1, th],
        [t.month, 2, 2 * th],
        [t.month, 3, 3 * th],
        [t.month, 4, 4 * th],
        [t.month, 6, 6 * th],
        [t.year, 1, zf]
      ], t;
    }
    return e.prototype.toDomain = function(t) {
      return new Date(t);
    }, e.prototype.calculateDefaultTickFormat = function(t) {
      var i, r;
      t === void 0 && (t = []);
      var n = st.YEAR, s = function(v) {
        v < n && (n = v);
      };
      try {
        for (var a = DW(t), l = a.next(); !l.done; l = a.next()) {
          var c = l.value, d = this.getLowestGranularityFormat(c);
          s(d);
        }
      } catch (v) {
        i = { error: v };
      } finally {
        try {
          l && !l.done && (r = a.return) && r.call(a);
        } finally {
          if (i)
            throw i.error;
        }
      }
      var u = Pn(t[0]), h = Pn(t[t.length - 1]), p = new Date(u).getFullYear(), f = new Date(h).getFullYear(), g = f - p > 0;
      return this.buildFormatString(n, g);
    }, e.prototype.buildFormatString = function(t, i) {
      var r = [hl[t]], n = 0, s = this.getDomain(), a = Math.min.apply(Math, ul([], oo(s.map(Pn)))), l = Math.max.apply(Math, ul([], oo(s.map(Pn)))), c = l - a;
      switch (t) {
        case st.SECOND:
          c / Er > 1 && r.push(hl[st.MINUTE]);
        case st.MINUTE:
          c / yo > 1 && r.push(hl[st.HOUR]);
        case st.HOUR:
          n = r.length, c / ua > 1 && r.push(hl[st.WEEK_DAY]);
        case st.WEEK_DAY:
          if (c / vh > 1 || i) {
            var d = r.indexOf(hl[st.WEEK_DAY]);
            d > -1 && r.splice(d, 1, hl[st.SHORT_MONTH]);
          }
        case st.SHORT_MONTH:
        case st.MONTH:
          (c / zf > 1 || i) && r.push(hl[st.YEAR]);
      }
      return n < r.length && (r = ul(ul([], oo(r.slice(0, n))), [
        r.slice(n).join(" ")
      ])), n > 0 && (r = ul(ul([], oo(r.slice(0, n).reverse())), oo(r.slice(n))), n < r.length && r.splice(n, 0, " ")), r.join("");
    }, e.prototype.getLowestGranularityFormat = function(t) {
      return this.second.floor(t) < t ? st.MILLISECOND : this.minute.floor(t) < t ? st.SECOND : this.hour.floor(t) < t ? st.MINUTE : this.day.floor(t) < t ? st.HOUR : this.month.floor(t) < t ? this.week.floor(t) < t ? st.WEEK_DAY : st.SHORT_MONTH : this.year.floor(t) < t ? st.MONTH : st.YEAR;
    }, e.prototype.defaultTickFormat = function(t) {
      var i = this.calculateDefaultTickFormat(t);
      return function(r) {
        return av(i)(r);
      };
    }, e.prototype.getTickInterval = function(t) {
      for (var i, r = t.start, n = t.stop, s = t.count, a = t.minCount, l = t.maxCount, c = this.tickIntervals, d, u, h = s != null ? s : ct.defaultTickCount, p = Math.abs(n - r) / Math.max(h, 1), f = 0; f < c.length && p > c[f][2]; )
        f++;
      if (f === 0)
        u = Math.max(fp(r, n, h, a, l), 1), d = this.millisecond;
      else if (f === c.length) {
        var g = r / zf, v = n / zf;
        u = fp(g, v, h, a, l), d = this.year;
      } else {
        var y = p - c[f - 1][2], m = c[f][2] - p, C = y < m ? f - 1 : f;
        i = oo(c[C], 2), d = i[0], u = i[1];
      }
      return d.every(u);
    }, e.prototype.invert = function(t) {
      return new Date(o.prototype.invert.call(this, t));
    }, e.prototype.ticks = function() {
      if (!this.domain || this.domain.length < 2)
        return [];
      this.refresh();
      var t = oo(this.getDomain().map(Pn), 2), i = t[0], r = t[1];
      if (this.interval !== void 0)
        return this.getTicksForInterval({ start: i, stop: r });
      if (this.nice) {
        var n = this.tickCount;
        if (n === 2)
          return this.niceDomain;
        if (n === 1)
          return this.niceDomain.slice(0, 1);
      }
      return this.getDefaultTicks({ start: i, stop: r });
    }, e.prototype.getDefaultTicks = function(t) {
      var i = t.start, r = t.stop, n = this.getTickInterval({
        start: i,
        stop: r,
        count: this.tickCount,
        minCount: this.minTickCount,
        maxCount: this.maxTickCount
      });
      return n ? n.range(new Date(i), new Date(r)) : [];
    }, e.prototype.getTicksForInterval = function(t) {
      var i = t.start, r = t.stop, n = this, s = n.interval, a = n.tickIntervals;
      if (!s)
        return [];
      if (s instanceof Yd) {
        var l = s.range(new Date(i), new Date(r));
        return this.isDenseInterval({ start: i, stop: r, interval: s, count: l.length }) ? this.getDefaultTicks({ start: i, stop: r }) : l;
      }
      var c = Math.abs(s);
      if (this.isDenseInterval({ start: i, stop: r, interval: c }))
        return this.getDefaultTicks({ start: i, stop: r });
      var d = ul([], oo(a));
      d.reverse();
      var u = d.find(function(v) {
        return c % v[2] === 0;
      });
      if (u) {
        var h = u[0].every(c / (u[2] / u[1]));
        return h.range(new Date(i), new Date(r));
      }
      for (var p = new Date(i), f = new Date(r), g = []; p <= f; )
        g.push(p), p = new Date(p), p.setMilliseconds(p.getMilliseconds() + c);
      return g;
    }, e.prototype.tickFormat = function(t) {
      var i = t.ticks, r = t.specifier;
      return r == null ? this.defaultTickFormat(i) : av(r);
    }, e.prototype.update = function() {
      !this.domain || this.domain.length < 2 || this.nice && this.updateNiceDomain();
    }, e.prototype.updateNiceDomain = function() {
      for (var t = 4, i = oo(this.domain, 2), r = i[0], n = i[1], s = 0; s < t; s++) {
        this.updateNiceDomainIteration(r, n);
        var a = oo(this.niceDomain, 2), l = a[0], c = a[1];
        if (Pn(r) === Pn(l) && Pn(n) === Pn(c))
          break;
        r = l, n = c;
      }
    }, e.prototype.updateNiceDomainIteration = function(t, i) {
      var r = Pn(t), n = Pn(i), s = this.interval, a;
      if (s instanceof Yd)
        a = s;
      else {
        var l = typeof s == "number" ? (n - r) / Math.max(s, 1) : this.tickCount;
        a = this.getTickInterval({
          start: r,
          stop: n,
          count: l,
          minCount: this.minTickCount,
          maxCount: this.maxTickCount
        });
      }
      if (a) {
        var c = a.range(t, i, !0), d = c[0], u = c[c.length - 1];
        this.niceDomain = [d, u];
      }
    }, e;
  }(ct)
), lv = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, X0 = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, Xt, Dd = function(o) {
  return "(" + o + ")";
}, ls = function(o) {
  return Dd(o) + "?";
}, q0 = function(o) {
  return ls("?:" + o);
}, OW = function() {
  var o = ".", e = "[<>=^]", t = "[+\\-( ]", i = "[$€£¥₣₹#]", r = "0", n = "\\d+", s = ",", a = "\\d+", l = "~", c = "[%a-z]";
  return new RegExp([
    "^",
    q0("" + ls(o) + Dd(e)),
    ls(t),
    ls(i),
    ls(r),
    ls(n),
    ls(s),
    q0("\\." + Dd(a)),
    ls(l),
    ls(c),
    "$"
  ].join(""), "i");
}(), PW = function() {
  var o = ".*?", e = ".+?", t = ".*?";
  return new RegExp(["^", Dd(o), "#\\{" + Dd(e) + "\\}", Dd(t), "$"].join(""));
}();
function VD(o) {
  var e, t, i, r = PW.exec(o);
  r && (e = lv(r, 4), t = e[1], o = e[2], i = e[3]);
  var n = OW.exec(o);
  if (!n)
    throw new Error("The number formatter is invalid: " + o);
  var s = lv(n, 11), a = s[1], l = s[2], c = s[3], d = s[4], u = s[5], h = s[6], p = s[7], f = s[8], g = s[9], v = s[10];
  return {
    fill: a,
    align: l,
    sign: c,
    symbol: d,
    zero: u,
    width: parseInt(h),
    comma: p,
    precision: parseInt(f),
    trim: !!g,
    type: v,
    prefix: t,
    suffix: i
  };
}
function BD(o) {
  var e = typeof o == "string" ? VD(o) : o, t = e.fill, i = e.align, r = e.sign, n = r === void 0 ? "-" : r, s = e.symbol, a = e.zero, l = e.width, c = e.comma, d = e.type, u = e.prefix, h = u === void 0 ? "" : u, p = e.suffix, f = p === void 0 ? "" : p, g = e.precision, v = e.trim, y = g === void 0 || isNaN(g), m;
  if (!d)
    m = Cr.g, v = !0;
  else if (d in Cr && d in gd)
    m = y ? gd[d] : Cr[d];
  else if (d in Cr)
    m = Cr[d];
  else if (d in gd)
    m = gd[d];
  else
    throw new Error("The number formatter type is invalid: " + d);
  var C;
  return g == null || y ? C = d ? 6 : 12 : C = g, function(R) {
    var E = m(R, C);
    return v && (E = AW(E)), c && (E = MW(E, c)), E = LW(R, E, n), s && s !== "#" && (E = "" + s + E), s === "#" && d === "x" && (E = "0x" + E), d === "s" && (E = "" + E + _W(R)), (d === "%" || d === "p") && (E = E + "%"), l != null && !isNaN(l) && (E = NW(E, l, t != null ? t : a, i)), E = "" + h + E + f, E;
  };
}
var rg = function(o) {
  return Math.floor(Math.abs(o));
}, gd = {
  b: function(o) {
    return rg(o).toString(2);
  },
  c: function(o) {
    return String.fromCharCode(o);
  },
  d: function(o) {
    return Math.round(Math.abs(o)).toFixed(0);
  },
  o: function(o) {
    return rg(o).toString(8);
  },
  x: function(o) {
    return rg(o).toString(16);
  },
  X: function(o) {
    return gd.x(o).toUpperCase();
  },
  n: function(o) {
    return gd.d(o);
  },
  "%": function(o) {
    return "" + rg(o * 100).toFixed(0);
  }
}, Cr = {
  e: function(o, e) {
    return Math.abs(o).toExponential(e);
  },
  E: function(o, e) {
    return Cr.e(o, e).toUpperCase();
  },
  f: function(o, e) {
    return Math.abs(o).toFixed(e);
  },
  F: function(o, e) {
    return Cr.f(o, e).toUpperCase();
  },
  g: function(o, e) {
    if (o === 0)
      return "0";
    var t = Math.abs(o), i = Math.floor(Math.log10(t));
    return i >= -4 && i < e ? t.toFixed(e - 1 - i) : t.toExponential(e - 1);
  },
  G: function(o, e) {
    return Cr.g(o, e).toUpperCase();
  },
  n: function(o, e) {
    return Cr.g(o, e);
  },
  p: function(o, e) {
    return Cr.r(o * 100, e);
  },
  r: function(o, e) {
    if (o === 0)
      return "0";
    var t = Math.abs(o), i = Math.floor(Math.log10(t)), r = i - (e - 1);
    if (r <= 0)
      return t.toFixed(-r);
    var n = Math.pow(10, r);
    return (Math.round(t / n) * n).toFixed();
  },
  s: function(o, e) {
    var t = HD(o);
    return Cr.r(o / Math.pow(10, t), e);
  },
  "%": function(o, e) {
    return Cr.f(o * 100, e);
  }
};
function AW(o) {
  return o.replace(/\.0+$/, "").replace(/(\.[1-9])0+$/, "$1");
}
function MW(o, e) {
  var t = o.indexOf(".");
  t < 0 && (t = o.length);
  for (var i = o.substring(0, t).split(""), r = o.substring(t), n = i.length - 3; n > 0; n -= 3)
    i.splice(n, 0, e);
  return "" + i.join("") + r;
}
function _W(o) {
  return IW[HD(o)];
}
function HD(o) {
  var e = Math.log10(Math.abs(o)), t = Math.floor(e / 3) * 3;
  return Math.max(WD, Math.min(jD, t));
}
var WD = -24, jD = 24, IW = (Xt = {}, Xt[WD] = "y", Xt[-21] = "z", Xt[-18] = "a", Xt[-15] = "f", Xt[-12] = "p", Xt[-9] = "n", Xt[-6] = "µ", Xt[-3] = "m", Xt[0] = "", Xt[3] = "k", Xt[6] = "M", Xt[9] = "G", Xt[12] = "T", Xt[15] = "P", Xt[18] = "E", Xt[21] = "Z", Xt[jD] = "Y", Xt), FW = "−";
function LW(o, e, t) {
  if (t === void 0 && (t = ""), t === "(")
    return o >= 0 ? e : "(" + e + ")";
  var i = t === "+" ? "+" : "";
  return "" + (o >= 0 ? i : FW) + e;
}
function NW(o, e, t, i) {
  t === void 0 && (t = " "), i === void 0 && (i = ">");
  var r = o;
  if (i === ">" || !i)
    r = r.padStart(e, t);
  else if (i === "<")
    r = r.padEnd(e, t);
  else if (i === "^") {
    var n = Math.max(0, e - r.length), s = Math.ceil(n / 2), a = Math.floor(n / 2);
    r = r.padStart(s + r.length, t), r = r.padEnd(a + r.length, t);
  }
  return r;
}
function UD(o, e) {
  var t = VD(e != null ? e : ",f"), i = t.precision;
  (i == null || isNaN(i)) && (t.type === "f" || t.type === "%" ? t.precision = Math.max.apply(Math, X0([], lv(o.map(function(n) {
    if (typeof n != "number" || n === 0)
      return 0;
    var s = Math.floor(Math.log10(Math.abs(n))), a = t.type ? 6 : 12, l = n.toExponential(a - 1).replace(/\.?0+e/, "e"), c = l.indexOf(".");
    if (c < 0)
      return s >= 0 ? 0 : -s;
    var d = l.indexOf("e") - c;
    return Math.max(0, d - s - 1);
  })))) : (!t.type || t.type in Cr) && (t.precision = Math.max.apply(Math, X0([], lv(o.map(function(n) {
    if (typeof n != "number")
      return 0;
    var s = n.toExponential((t.type ? 6 : 12) - 1).replace(/\.?0+e/, "e");
    return s.substring(0, s.indexOf("e")).replace(".", "").length;
  }))))));
  var r = BD(t);
  return function(n) {
    return r(Number(n));
  };
}
var GW = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), kW = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, ng = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, Z0 = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, Q0 = function(o) {
  return o;
}, $D = (
  /** @class */
  function(o) {
    GW(e, o);
    function e() {
      var t = o.call(this, [1, 10], [0, 1]) || this;
      return t.type = "log", t.base = 10, t.cacheProps = ["domain", "range", "nice", "tickCount", "base"], t.baseLog = Q0, t.basePow = Q0, t.log = function(i) {
        return t.domain[0] >= 0 ? t.baseLog(i) : -t.baseLog(-i);
      }, t.pow = function(i) {
        return t.domain[0] >= 0 ? t.basePow(i) : -t.basePow(-i);
      }, t;
    }
    return e.prototype.toDomain = function(t) {
      return t;
    }, e.prototype.transform = function(t) {
      return this.domain[0] >= 0 ? Math.log(t) : -Math.log(-t);
    }, e.prototype.transformInvert = function(t) {
      return this.domain[0] >= 0 ? Math.exp(t) : -Math.exp(-t);
    }, e.prototype.update = function() {
      !this.domain || this.domain.length < 2 || (this.updateLogFn(), this.updatePowFn(), this.nice && this.updateNiceDomain());
    }, e.prototype.updateLogFn = function() {
      var t = this.base, i;
      if (t === 10)
        i = Math.log10;
      else if (t === Math.E)
        i = Math.log;
      else if (t === 2)
        i = Math.log2;
      else {
        var r = Math.log(t);
        i = function(n) {
          return Math.log(n) / r;
        };
      }
      this.baseLog = i;
    }, e.prototype.updatePowFn = function() {
      var t = this.base, i;
      t === 10 ? i = e.pow10 : t === Math.E ? i = Math.exp : i = function(r) {
        return Math.pow(t, r);
      }, this.basePow = i;
    }, e.prototype.updateNiceDomain = function() {
      var t = ng(this.domain, 2), i = t[0], r = t[1], n = this.pow(Math.floor(this.log(i))), s = this.pow(Math.ceil(this.log(r)));
      this.niceDomain = [n, s];
    }, e.pow10 = function(t) {
      return t >= 0 ? Math.pow(10, t) : 1 / Math.pow(10, -t);
    }, e.prototype.ticks = function() {
      var t = this, i, r = (i = this.tickCount) !== null && i !== void 0 ? i : 10;
      if (!this.domain || this.domain.length < 2 || r < 1)
        return [];
      this.refresh();
      var n = this.base, s = ng(this.getDomain(), 2), a = s[0], l = s[1], c = this.log(a), d = this.log(l);
      if (this.interval) {
        var u = Math.abs(this.interval), h = Math.abs(d - c), p = sv(c, d, Math.min(h, u)).map(function(G) {
          return t.pow(G);
        }).filter(function(G) {
          return G >= a && G <= l;
        });
        if (!this.isDenseInterval({ start: a, stop: l, interval: u, count: p.length }))
          return p;
      }
      var f = n % 1 === 0, g = d - c >= r;
      if (!f || g)
        return Wm(c, d, Math.min(d - c, r)).map(function(G) {
          return t.pow(G);
        });
      var v = [], y = a > 0;
      c = Math.floor(c) - 1, d = Math.round(d) + 1;
      for (var m = Math.min.apply(Math, Z0([], ng(this.range))), C = Math.max.apply(Math, Z0([], ng(this.range))), R = (C - m) / r, E = 1 / 0, b = c; b <= d; b++)
        for (var T = this.convert(this.pow(b + 1)), D = 1; D < n; D++) {
          var P = y ? D : n - D + 1, O = this.pow(b) * P, M = this.convert(O), _ = Math.abs(E - M), F = Math.abs(M - T), I = _ >= R && F >= R;
          O >= a && O <= l && (D === 1 || I) && (v.push(O), E = M);
        }
      return v;
    }, e.prototype.tickFormat = function(t) {
      var i = t.count, r = t.ticks, n = t.specifier, s = this.base;
      return n == null && (n = s === 10 ? ".0e" : ","), typeof n == "string" && (n = BD(n)), i === 1 / 0 ? n : (r == null && this.ticks(), function(a) {
        return n(a);
      });
    }, kW([
      A(le(0))
    ], e.prototype, "base", void 0), e;
  }(ct)
);
function Uo(o) {
  var e = o.length;
  if (e !== 0) {
    for (var t = 1 / 0, i = -1 / 0, r = 0; r < e; r++) {
      var n = o[r];
      n instanceof Date && (n = n.getTime()), typeof n == "number" && (n < t && (t = n), n > i && (i = n));
    }
    var s = [t, i];
    if (!s.some(function(a) {
      return !isFinite(a);
    }))
      return s;
  }
}
function zD(o, e, t) {
  var i;
  return o.length > 2 && (o = (i = Uo(o)) !== null && i !== void 0 ? i : [NaN, NaN]), isNaN(e) || (o = [e, o[1]]), isNaN(t) || (o = [o[0], t]), o[0] > o[1] && (o = []), o;
}
var Wc = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, qn = (
  /** @class */
  function() {
    function o() {
      this.enabled = !0, this.fontSize = 12, this.fontFamily = "Verdana, sans-serif", this.fontStyle = void 0, this.fontWeight = void 0, this.color = "rgba(70, 70, 70, 1)";
    }
    return o.prototype.getFont = function() {
      return jl(this);
    }, Wc([
      A(ht)
    ], o.prototype, "enabled", void 0), Wc([
      A(le(0))
    ], o.prototype, "fontSize", void 0), Wc([
      A(Ri)
    ], o.prototype, "fontFamily", void 0), Wc([
      A(fc)
    ], o.prototype, "fontStyle", void 0), Wc([
      A(gc)
    ], o.prototype, "fontWeight", void 0), Wc([
      A(Lr)
    ], o.prototype, "color", void 0), o;
  }()
);
function ow(o) {
  var e = o.parallelFlipRotation, t = e === void 0 ? 0 : e, i = o.regularFlipRotation, r = i === void 0 ? 0 : i, n = o.rotation ? Vi(xr(o.rotation)) : 0, s = !n && t >= 0 && t <= Math.PI ? -1 : 1, a = !n && r >= 0 && r <= Math.PI ? -1 : 1, l = 0;
  return o.parallel ? l = s * Math.PI / 2 : a === -1 && (l = Math.PI), { configuredRotation: n, defaultRotation: l, parallelFlipFlag: s, regularFlipFlag: a };
}
function VW(o, e) {
  return isNaN(o) ? e ? 0 : 10 : o;
}
function BW(o, e, t, i) {
  return o && !e ? t * i === -1 ? "hanging" : "bottom" : "middle";
}
function Zy(o, e, t, i, r) {
  var n = e > 0 && e <= Math.PI, s = t > 0 && t <= Math.PI, a = n || s ? -1 : 1;
  if (o)
    if (e || t) {
      if (i * a === -1)
        return "end";
    } else
      return "center";
  else if (i * r === -1)
    return "end";
  return "start";
}
function HW(o, e, t, i, r) {
  var n = e.width, s = e.height, a = new nt(t, i, 0, 0);
  r.transformBBox(a, e);
  var l = e.x, c = l === void 0 ? 0 : l, d = e.y, u = d === void 0 ? 0 : d;
  return e.width = n, e.height = s, {
    point: {
      x: c,
      y: u,
      size: 0
    },
    label: {
      width: n,
      height: s,
      text: o
    }
  };
}
function ba(o, e) {
  return e === void 0 && (e = [void 0]), Pu(function(t, i, r) {
    return e.includes(r) ? o : r;
  });
}
var ni = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, KD = (
  /** @class */
  function() {
    function o() {
      this.enabled = !0, this.autoWrap = !1, this.maxWidth = void 0, this.maxHeight = void 0, this.fontStyle = void 0, this.fontWeight = void 0, this.fontSize = 12, this.fontFamily = "Verdana, sans-serif", this.padding = 5, this.minSpacing = NaN, this.color = "rgba(87, 87, 87, 1)", this.rotation = void 0, this.autoRotate = void 0, this.autoRotateAngle = 335, this.avoidCollisions = !0, this.mirrored = !1, this.parallel = !1, this.formatter = void 0, this.format = void 0;
    }
    return o.prototype.getSideFlag = function() {
      return this.mirrored ? 1 : -1;
    }, o.prototype.getFont = function() {
      return jl(this);
    }, ni([
      A(ht)
    ], o.prototype, "enabled", void 0), ni([
      A(_o)
    ], o.prototype, "autoWrap", void 0), ni([
      A(lt(0))
    ], o.prototype, "maxWidth", void 0), ni([
      A(lt(0))
    ], o.prototype, "maxHeight", void 0), ni([
      A(fc)
    ], o.prototype, "fontStyle", void 0), ni([
      A(gc)
    ], o.prototype, "fontWeight", void 0), ni([
      A(le(1))
    ], o.prototype, "fontSize", void 0), ni([
      A(Ri)
    ], o.prototype, "fontFamily", void 0), ni([
      A(le(0))
    ], o.prototype, "padding", void 0), ni([
      A(Ca()),
      ba(NaN)
    ], o.prototype, "minSpacing", void 0), ni([
      A(St)
    ], o.prototype, "color", void 0), ni([
      A(lt(-360, 360))
    ], o.prototype, "rotation", void 0), ni([
      A(_o)
    ], o.prototype, "autoRotate", void 0), ni([
      A(le(-360, 360))
    ], o.prototype, "autoRotateAngle", void 0), ni([
      A(ht)
    ], o.prototype, "avoidCollisions", void 0), ni([
      A(ht)
    ], o.prototype, "mirrored", void 0), ni([
      A(ht)
    ], o.prototype, "parallel", void 0), ni([
      A(De)
    ], o.prototype, "format", void 0), o;
  }()
), J0 = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, YD = (
  /** @class */
  function() {
    function o() {
      this.width = 1, this.color = "rgba(195, 195, 195, 1)";
    }
    return J0([
      A(le(0))
    ], o.prototype, "width", void 0), J0([
      A(St)
    ], o.prototype, "color", void 0), o;
  }()
), Ys = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, WW = Ee(function(o, e) {
  return le(0)(o, e) || o instanceof Yd;
}, "expecting a tick count Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'"), jW = Ee(function(o, e) {
  return Ot(o, e, WW);
}, "expecting an optional tick count Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'"), UW = Ee(function(o, e) {
  return Ot(o, e, function(t, i) {
    return t !== 0 && le(0)(t, i) || t instanceof Yd;
  });
}, "expecting an optional non-zero positive Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'"), sw = (
  /** @class */
  function() {
    function o() {
      this.enabled = !0, this.width = 1, this.size = 6, this.color = "rgba(195, 195, 195, 1)", this.count = void 0, this.interval = void 0, this.values = void 0, this.minSpacing = NaN;
    }
    return Ys([
      A(ht)
    ], o.prototype, "enabled", void 0), Ys([
      A(le(0))
    ], o.prototype, "width", void 0), Ys([
      A(le(0))
    ], o.prototype, "size", void 0), Ys([
      A(St)
    ], o.prototype, "color", void 0), Ys([
      A(jW),
      sB("Use tick.interval or tick.minSpacing and tick.maxSpacing instead")
    ], o.prototype, "count", void 0), Ys([
      A(UW)
    ], o.prototype, "interval", void 0), Ys([
      A(Yb())
    ], o.prototype, "values", void 0), Ys([
      A(Os(Ca(1), Vm("maxSpacing"))),
      ba(NaN)
    ], o.prototype, "minSpacing", void 0), o;
  }()
), aw = (
  /** @class */
  function() {
    function o(e, t) {
      this.state = e, this.states = t, o.DEBUG() && pe.debug("%c" + this.constructor.name + " | init -> " + e, "color: green");
    }
    return o.prototype.transition = function(e, t) {
      var i, r, n, s, a, l = this.states[this.state], c = (i = l == null ? void 0 : l.on) === null || i === void 0 ? void 0 : i[e];
      if (!c) {
        o.DEBUG() && pe.debug("%c" + this.constructor.name + " | " + this.state + " -> " + e + " -> " + this.state, "color: grey");
        return;
      }
      var d = c.target, u = this.states[d];
      return o.DEBUG() && pe.debug("%c" + this.constructor.name + " | " + this.state + " -> " + e + " -> " + d, "color: green"), c.action(t), (n = (r = l == null ? void 0 : l.actions) === null || r === void 0 ? void 0 : r.onExit) === null || n === void 0 || n.call(r), (a = (s = u == null ? void 0 : u.actions) === null || s === void 0 ? void 0 : s.onEnter) === null || a === void 0 || a.call(s), this.state = d, this.state;
    }, o.DEBUG = function() {
      var e;
      return (e = [!0, "animation"].includes(Fn("agChartsDebug"))) !== null && e !== void 0 ? e : !1;
    }, o;
  }()
), $W = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), wl = function() {
  return wl = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, wl.apply(this, arguments);
}, Qy = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, zW = function(o, e) {
  var t = {};
  for (var i in o)
    Object.prototype.hasOwnProperty.call(o, i) && e.indexOf(i) < 0 && (t[i] = o[i]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(o); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(o, i[r]) && (t[i[r]] = o[i[r]]);
  return t;
}, og = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, rs = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, jc = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, KW = ["stroke", "lineDash"], YW = Ee(Ja(void 0, function(o) {
  for (var e in o)
    if (!KW.includes(e))
      return !1;
  return !0;
}), "expecting an Array of objects with gridline style properties such as 'stroke' and 'lineDash'"), Ph;
(function(o) {
  o[o.TickLine = 0] = "TickLine", o[o.TickLabel = 1] = "TickLabel", o[o.GridLine = 2] = "GridLine", o[o.GridArc = 3] = "GridArc", o[o.AxisLine = 4] = "AxisLine";
})(Ph || (Ph = {}));
var _n;
(function(o) {
  o[o.CREATE = 0] = "CREATE", o[o.CREATE_SECONDARY = 1] = "CREATE_SECONDARY", o[o.FILTER = 2] = "FILTER", o[o.VALUES = 3] = "VALUES";
})(_n || (_n = {}));
var XW = (
  /** @class */
  function(o) {
    $W(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e;
  }(aw)
), XD = (
  /** @class */
  function() {
    function o(e, t) {
      var i = this;
      this.moduleCtx = e, this.id = Vs(this), this.nice = !0, this.dataDomain = [], this.keys = [], this.boundSeries = [], this.includeInvisibleDomains = !1, this.axisGroup = new we({ name: this.id + "-axis", zIndex: kt.AXIS_ZINDEX }), this.lineNode = this.axisGroup.appendChild(new Qt()), this.tickLineGroup = this.axisGroup.appendChild(new we({ name: this.id + "-Axis-tick-lines", zIndex: kt.AXIS_ZINDEX })), this.tickLabelGroup = this.axisGroup.appendChild(new we({ name: this.id + "-Axis-tick-labels", zIndex: kt.AXIS_ZINDEX })), this.crossLineGroup = new we({ name: this.id + "-CrossLines" }), this.gridGroup = new we({ name: this.id + "-Axis-grid" }), this.gridLineGroup = this.gridGroup.appendChild(new we({
        name: this.id + "-gridLines",
        zIndex: kt.AXIS_GRID_ZINDEX
      })), this.tickLineGroupSelection = Et.select(this.tickLineGroup, Qt, !1), this.tickLabelGroupSelection = Et.select(this.tickLabelGroup, ut, !1), this.gridLineGroupSelection = Et.select(this.gridLineGroup, Qt, !1), this.line = new YD(), this.tick = this.createTick(), this.label = new KD(), this.translation = { x: 0, y: 0 }, this.rotation = 0, this.layout = {
        label: {
          fractionDigits: 0,
          padding: this.label.padding,
          format: this.label.format
        }
      }, this.modules = {}, this.destroyFns = [], this.range = [0, 1], this.visibleRange = [0, 1], this.title = void 0, this._titleCaption = new xd(), this._gridLength = 0, this.gridStyle = [
        {
          stroke: "rgba(219, 219, 219, 1)",
          lineDash: [4, 2]
        }
      ], this.fractionDigits = 0, this.gridPadding = 0, this.seriesAreaPadding = 0, this.maxThickness = 1 / 0, this._scale = t, this.refreshScale(), this._titleCaption.node.rotation = -Math.PI / 2, this.axisGroup.appendChild(this._titleCaption.node);
      var r = e.interactionManager.addListener("hover", function(n) {
        return i.checkAxisHover(n);
      });
      this.destroyFns.push(function() {
        return e.interactionManager.removeListener(r);
      }), this.animationManager = e.animationManager, this.animationState = new XW("empty", {
        empty: {
          on: {
            update: {
              target: "align",
              action: function() {
                return i.resetSelectionNodes();
              }
            }
          }
        },
        align: {
          on: {
            update: {
              target: "ready",
              action: function() {
                return i.resetSelectionNodes();
              }
            }
          }
        },
        ready: {
          on: {
            update: {
              target: "ready",
              action: function(n) {
                return i.animateReadyUpdate(n);
              }
            }
          }
        }
      }), this._crossLines = [], this.assignCrossLineArrayConstructor(this._crossLines);
    }
    return Object.defineProperty(o.prototype, "scale", {
      get: function() {
        return this._scale;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "type", {
      get: function() {
        var e;
        return (e = this.constructor.type) !== null && e !== void 0 ? e : "";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "crossLines", {
      get: function() {
        return this._crossLines;
      },
      set: function(e) {
        var t = this, i, r;
        (i = this._crossLines) === null || i === void 0 || i.forEach(function(n) {
          return t.detachCrossLine(n);
        }), e && this.assignCrossLineArrayConstructor(e), this._crossLines = e, (r = this._crossLines) === null || r === void 0 || r.forEach(function(n) {
          t.attachCrossLine(n), t.initCrossLine(n);
        });
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.attachCrossLine = function(e) {
      this.crossLineGroup.appendChild(e.group);
    }, o.prototype.detachCrossLine = function(e) {
      this.crossLineGroup.removeChild(e.group);
    }, o.prototype.destroy = function() {
      var e, t;
      try {
        for (var i = og(Object.entries(this.modules)), r = i.next(); !r.done; r = i.next()) {
          var n = rs(r.value, 2), s = n[0], a = n[1];
          a.instance.destroy(), delete this.modules[s], delete this[s];
        }
      } catch (l) {
        e = { error: l };
      } finally {
        try {
          r && !r.done && (t = i.return) && t.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      this.destroyFns.forEach(function(l) {
        return l();
      });
    }, o.prototype.refreshScale = function() {
      var e = this, t;
      this.range = this.scale.range.slice(), (t = this.crossLines) === null || t === void 0 || t.forEach(function(i) {
        e.initCrossLine(i);
      });
    }, o.prototype.updateRange = function() {
      var e, t = this, i = t.range, r = t.visibleRange, n = t.scale, s = (i[1] - i[0]) / (r[1] - r[0]), a = s * r[0], l = i[0] - a;
      n.range = [l, l + s], (e = this.crossLines) === null || e === void 0 || e.forEach(function(c) {
        c.clippedRange = [i[0], i[1]];
      });
    }, o.prototype.setCrossLinesVisible = function(e) {
      this.crossLineGroup.visible = e;
    }, o.prototype.attachAxis = function(e) {
      e.appendChild(this.gridGroup), e.appendChild(this.axisGroup), e.appendChild(this.crossLineGroup);
    }, o.prototype.detachAxis = function(e) {
      e.removeChild(this.gridGroup), e.removeChild(this.axisGroup), e.removeChild(this.crossLineGroup);
    }, o.prototype.inRange = function(e, t, i) {
      return t === void 0 && (t = 0), i === void 0 && (i = 0), this.inRangeEx(e, t, i) === 0;
    }, o.prototype.inRangeEx = function(e, t, i) {
      t === void 0 && (t = 0), i === void 0 && (i = 0);
      var r = this.range, n = Math.min(r[0], r[1]), s = Math.max(r[0], r[1]);
      return e + t < n - i ? -1 : e > s + i ? 1 : 0;
    }, o.prototype.onLabelFormatChange = function(e, t) {
      var i = this, r = i.scale, n = i.fractionDigits, s = r instanceof $D, a = !s && n > 0 ? function(l) {
        return typeof l == "number" ? l.toFixed(n) : String(l);
      } : function(l) {
        return String(l);
      };
      if (t && r && r.tickFormat)
        try {
          this.labelFormatter = r.tickFormat({
            ticks: e,
            specifier: t
          });
        } catch (l) {
          this.labelFormatter = a, pe.warnOnce("the axis label format string " + t + " is invalid. No formatting will be applied");
        }
      else
        this.labelFormatter = a;
    }, o.prototype.setDomain = function() {
      var e, t = this, i = t.scale, r = t.dataDomain, n = t.tick.values;
      if (n && i instanceof ct) {
        var s = rs((e = Uo(n)) !== null && e !== void 0 ? e : [1 / 0, -1 / 0], 2), a = s[0], l = s[1], c = Math.min(i.fromDomain(r[0]), a), d = Math.max(i.fromDomain(r[1]), l);
        i.domain = [i.toDomain(c), i.toDomain(d)];
      } else
        i.domain = r;
    }, o.prototype.setTickInterval = function(e) {
      var t;
      this.scale.interval = (t = this.tick.interval) !== null && t !== void 0 ? t : e;
    }, o.prototype.setTickCount = function(e, t, i) {
      var r = this.scale;
      if (e && r instanceof ct) {
        if (typeof e == "number") {
          r.tickCount = e, r.minTickCount = t != null ? t : 0, r.maxTickCount = i != null ? i : 1 / 0;
          return;
        }
        r instanceof nw && this.setTickInterval(e);
      }
    }, Object.defineProperty(o.prototype, "gridLength", {
      get: function() {
        return this._gridLength;
      },
      set: function(e) {
        var t = this, i;
        (this._gridLength && !e || !this._gridLength && e) && (this.gridLineGroupSelection = this.gridLineGroupSelection.clear()), this._gridLength = e, (i = this.crossLines) === null || i === void 0 || i.forEach(function(r) {
          t.initCrossLine(r);
        });
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.createTick = function() {
      return new sw();
    }, o.prototype.checkAxisHover = function(e) {
      var t = this.computeBBox(), i = t.containsPoint(e.offsetX, e.offsetY);
      i && this.moduleCtx.chartEventManager.axisHover(this.id, this.direction);
    }, o.prototype.update = function(e) {
      var t = this.tickLabelGroupSelection.nodes().map(function(v) {
        return v.datum.tickId;
      }), i = this.calculateRotations(), r = i.rotation, n = i.parallelFlipRotation, s = i.regularFlipRotation, a = this.label.getSideFlag(), l = a * (this.tick.size + this.label.padding + this.seriesAreaPadding);
      this.updateScale(), this.updatePosition({ rotation: r, sideFlag: a }), this.updateLine();
      var c = this.generateTicks({
        primaryTickCount: e,
        parallelFlipRotation: n,
        regularFlipRotation: s,
        labelX: l,
        sideFlag: a
      }), d = c.tickData, u = c.combinedRotation, h = c.textBaseline, p = c.textAlign, f = zW(c, ["tickData", "combinedRotation", "textBaseline", "textAlign"]);
      if (this.updateSelections(d.ticks), this.animationManager.skipAnimations)
        this.resetSelectionNodes();
      else {
        var g = this.calculateUpdateDiff(t, d);
        this.animationState.transition("update", g);
      }
      return this.updateLabels({
        tickLabelGroupSelection: this.tickLabelGroupSelection,
        combinedRotation: u,
        textBaseline: h,
        textAlign: p,
        labelX: l
      }), this.updateVisibility(), this.updateGridLines(a), this.updateTickLines(a), this.updateTitle({ anyTickVisible: d.ticks.length > 0, sideFlag: a }), this.updateCrossLines({ rotation: r, parallelFlipRotation: n, regularFlipRotation: s, sideFlag: a }), this.updateLayoutState(), e = f.primaryTickCount, e;
    }, o.prototype.updateLayoutState = function() {
      this.layout.label = {
        fractionDigits: this.fractionDigits,
        padding: this.label.padding,
        format: this.label.format
      };
    }, o.prototype.updateScale = function() {
      this.updateRange(), this.calculateDomain(), this.setDomain(), this.setTickInterval(this.tick.interval);
      var e = this, t = e.scale, i = e.nice;
      t instanceof ct && (this.setTickCount(this.tick.count), t.nice = i, t.update());
    }, o.prototype.calculateRotations = function() {
      var e = xr(this.rotation), t = Vi(e), i = Vi(e - Math.PI / 2);
      return { rotation: e, parallelFlipRotation: t, regularFlipRotation: i };
    }, o.prototype.generateTicks = function(e) {
      for (var t, i, r, n, s = e.primaryTickCount, a = e.parallelFlipRotation, l = e.regularFlipRotation, c = e.labelX, d = e.sideFlag, u = this, h = u.scale, p = u.tick, f = u.label, g = f.parallel, v = f.rotation, y = f.fontFamily, m = f.fontSize, C = f.fontStyle, R = f.fontWeight, E = s !== void 0, b = ow({
        rotation: v,
        parallel: g,
        regularFlipRotation: l,
        parallelFlipRotation: a
      }), T = b.defaultRotation, D = b.configuredRotation, P = b.parallelFlipFlag, O = b.regularFlipFlag, M = D + T, _ = new Cl(), F = this.estimateTickCount({
        minSpacing: p.minSpacing,
        maxSpacing: (n = p.maxSpacing) !== null && n !== void 0 ? n : NaN
      }).maxTickCount, I = h instanceof ct, G = p.count || !I || isNaN(F) ? 10 : F, k = Zy(g, D, 0, d, O), N = BW(g, D, d, P), W = {
        fontFamily: y,
        fontSize: m,
        fontStyle: C,
        fontWeight: R,
        textBaseline: N,
        textAlign: k
      }, j = {
        rawTicks: [],
        ticks: [],
        labelCount: 0
      }, K = 0, $ = 0, ae = !0, ee = !1; ae && K <= G && !ee; ) {
        $ = 0, k = Zy(g, D, 0, d, O);
        var ne = this.getTickStrategies({ secondaryAxis: E, index: K });
        try {
          for (var Y = (t = void 0, og(ne)), te = Y.next(); !te.done; te = Y.next()) {
            var se = te.value;
            r = se({
              index: K,
              tickData: j,
              textProps: W,
              labelOverlap: ae,
              terminate: ee,
              primaryTickCount: s
            }), j = r.tickData, K = r.index, $ = r.autoRotation, ee = r.terminate;
            var he = j.ticks;
            k = Zy(g, D, $, d, O);
            var be = D !== 0 || $ !== 0, ye = M + $;
            ae = this.checkLabelOverlap(ye, be, _, he, c, wl(wl({}, W), { textAlign: k }));
          }
        } catch (Je) {
          t = { error: Je };
        } finally {
          try {
            te && !te.done && (i = Y.return) && i.call(Y);
          } finally {
            if (t)
              throw t.error;
          }
        }
      }
      var Xe = T + D + $;
      return !E && j.rawTicks.length > 0 && (s = j.rawTicks.length), { tickData: j, primaryTickCount: s, combinedRotation: Xe, textBaseline: N, textAlign: k };
    }, o.prototype.getTickStrategies = function(e) {
      var t = this, i = e.index, r = e.secondaryAxis, n = this, s = n.scale, a = n.label, l = n.tick, c = s instanceof ct, d = a.enabled && a.avoidCollisions, u = !(c && this.tick.count === void 0) && i !== 0 && d, h = a.autoRotate === !0 && a.rotation === void 0, p = [], f;
      this.tick.values ? f = _n.VALUES : r ? f = _n.CREATE_SECONDARY : u ? f = _n.FILTER : f = _n.CREATE;
      var g = function(C) {
        var R = C.index, E = C.tickData, b = C.primaryTickCount, T = C.terminate;
        return t.createTickData(f, R, E, T, b);
      };
      if (p.push(g), !c && !isNaN(l.minSpacing)) {
        var v = function(C) {
          var R = C.index, E = C.tickData, b = C.primaryTickCount, T = C.terminate;
          return t.createTickData(_n.FILTER, R, E, T, b);
        };
        p.push(v);
      }
      if (!d)
        return p;
      if (a.autoWrap) {
        var y = function(C) {
          var R = C.index, E = C.tickData, b = C.textProps;
          return t.wrapLabels(E, R, b);
        };
        p.push(y);
      } else if (h) {
        var m = function(C) {
          var R = C.index, E = C.tickData, b = C.labelOverlap, T = C.terminate;
          return {
            index: R,
            tickData: E,
            autoRotation: t.getAutoRotation(b),
            terminate: T
          };
        };
        p.push(m);
      }
      return p;
    }, o.prototype.createTickData = function(e, t, i, r, n) {
      for (var s, a, l, c = this, d = c.scale, u = c.tick, h = this.estimateTickCount({
        minSpacing: u.minSpacing,
        maxSpacing: (s = u.maxSpacing) !== null && s !== void 0 ? s : NaN
      }), p = h.maxTickCount, f = h.minTickCount, g = h.defaultTickCount, v = d instanceof ct, y = u.count || !v || isNaN(p) ? 10 : p, m = (a = u.count) !== null && a !== void 0 ? a : v ? Math.max(g - t, f) : p, C = u.interval === void 0 && u.values === void 0 && u.count === void 0 && m > f && (v || e === _n.FILTER), R = !0; R && t <= y; ) {
        var E = i.rawTicks;
        m = (l = u.count) !== null && l !== void 0 ? l : v ? Math.max(g - t, f) : p;
        var b = this.getTicks({
          tickGenerationType: e,
          previousTicks: E,
          tickCount: m,
          minTickCount: f,
          maxTickCount: p,
          primaryTickCount: n
        }), T = b.rawTicks, D = b.ticks, P = b.labelCount;
        i.rawTicks = T, i.ticks = D, i.labelCount = P, R = C ? CW(T, E) : !1, t++;
      }
      var O = u.interval !== void 0 || u.values !== void 0;
      return r || (r = O), { tickData: i, index: t, autoRotation: 0, terminate: r };
    }, o.prototype.checkLabelOverlap = function(e, t, i, r, n, s) {
      Cl.updateTransformMatrix(i, 1, 1, e, 0, 0);
      var a = this.createLabelData(r, n, s, i), l = VW(this.label.minSpacing, t);
      return VB(a, l);
    }, o.prototype.createLabelData = function(e, t, i, r) {
      var n, s, a = [];
      try {
        for (var l = og(e), c = l.next(); !c.done; c = l.next()) {
          var d = c.value, u = d.tickLabel, h = d.translationY;
          if (!(u === "" || u == null)) {
            var p = uD(u), f = L1(p, t, h, i), g = f.width, v = f.height, y = new nt(t, h, g, v), m = HW(u, y, t, h, r);
            a.push(m);
          }
        }
      } catch (C) {
        n = { error: C };
      } finally {
        try {
          c && !c.done && (s = l.return) && s.call(l);
        } finally {
          if (n)
            throw n.error;
        }
      }
      return a;
    }, o.prototype.getAutoRotation = function(e) {
      return e ? Vi(xr(this.label.autoRotateAngle)) : 0;
    }, o.prototype.getTicks = function(e) {
      var t, i = e.tickGenerationType, r = e.previousTicks, n = e.tickCount, s = e.minTickCount, a = e.maxTickCount, l = e.primaryTickCount, c = this.scale, d = [];
      switch (i) {
        case _n.VALUES:
          d = this.tick.values;
          break;
        case _n.CREATE_SECONDARY:
          d = this.updateSecondaryAxisTicks(l);
          break;
        case _n.FILTER:
          d = this.filterTicks(r, n);
          break;
        default:
          d = this.createTicks(n, s, a);
          break;
      }
      this.onLabelFormatChange(d, this.label.format), this.fractionDigits = d.fractionDigits >= 0 ? d.fractionDigits : 0;
      for (var u = ((t = this.scale.bandwidth) !== null && t !== void 0 ? t : 0) / 2, h = [], p = 0, f = /* @__PURE__ */ new Map(), g = 0; g < d.length; g++) {
        var v = d[g], y = c.convert(v) + u, m = this.formatTick(v, g), C = m;
        if (f.has(C)) {
          var R = f.get(C);
          f.set(C, R + 1), C = C + "_" + R;
        } else
          f.set(C, 1);
        h.push({ tick: v, tickId: C, tickLabel: m, translationY: y }), !(m === "" || m == null) && p++;
      }
      return { rawTicks: d, ticks: h, labelCount: p };
    }, o.prototype.filterTicks = function(e, t) {
      var i, r = !isNaN(this.tick.minSpacing) || !isNaN((i = this.tick.maxSpacing) !== null && i !== void 0 ? i : NaN), n = r ? Math.ceil(e.length / t) : 2;
      return e.filter(function(s, a) {
        return a % n === 0;
      });
    }, o.prototype.createTicks = function(e, t, i) {
      var r, n, s;
      return this.setTickCount(e, t, i), (s = (n = (r = this.scale).ticks) === null || n === void 0 ? void 0 : n.call(r)) !== null && s !== void 0 ? s : [];
    }, o.prototype.estimateTickCount = function(e) {
      var t = e.minSpacing, i = e.maxSpacing, r = this.calculateAvailableRange(), n = Math.max(o.defaultTickMinSpacing, r / ct.defaultMaxTickCount);
      isNaN(t) && isNaN(i) ? (t = n, i = r, t > i && (i = t)) : isNaN(t) ? (t = n, t > i && (t = i)) : isNaN(i) && (i = r, t > i && (i = t));
      var s = Math.max(1, Math.floor(r / t)), a = Math.min(s, Math.ceil(r / i)), l = ct.defaultTickCount;
      return l > s ? l = s : l < a && (l = a), { minTickCount: a, maxTickCount: s, defaultTickCount: l };
    }, o.prototype.updateVisibility = function() {
      var e = this.range, t = Math.min.apply(Math, jc([], rs(e))), i = Math.max.apply(Math, jc([], rs(e))), r = function(c) {
        var d = Math.floor(t), u = Math.ceil(i);
        if (d === u) {
          c.visible = !1;
          return;
        }
        c.translationY >= d - 1 && c.translationY < d && (c.translationY = d), c.translationY > u && c.translationY <= u + 1 && (c.translationY = u);
        var h = c.translationY >= d && c.translationY <= u;
        c.visible = h;
      }, n = this, s = n.gridLineGroupSelection, a = n.tickLineGroupSelection, l = n.tickLabelGroupSelection;
      s.each(r), a.each(r), l.each(r), this.tickLineGroup.visible = this.tick.enabled, this.tickLabelGroup.visible = this.label.enabled;
    }, o.prototype.updateCrossLines = function(e) {
      var t = this, i, r = e.rotation, n = e.parallelFlipRotation, s = e.regularFlipRotation, a = e.sideFlag, l = this.isAnySeriesActive();
      (i = this.crossLines) === null || i === void 0 || i.forEach(function(c) {
        var d;
        c.sideFlag = -a, c.direction = r === -Math.PI / 2 ? de.X : de.Y, c.label.parallel = (d = c.label.parallel) !== null && d !== void 0 ? d : t.label.parallel, c.parallelFlipRotation = n, c.regularFlipRotation = s, c.update(l);
      });
    }, o.prototype.updateTickLines = function(e) {
      var t = this.tick;
      this.tickLineGroupSelection.each(function(i) {
        i.strokeWidth = t.width, i.stroke = t.color, i.x1 = e * t.size, i.x2 = 0, i.y1 = 0, i.y2 = 0;
      });
    }, o.prototype.calculateAvailableRange = function() {
      var e = this.range, t = Math.min.apply(Math, jc([], rs(e))), i = Math.max.apply(Math, jc([], rs(e)));
      return i - t;
    }, o.prototype.calculateDomain = function() {
      var e, t, i, r = this, n = r.direction, s = r.boundSeries, a = r.includeInvisibleDomains;
      if (this.linkedTo)
        this.dataDomain = this.linkedTo.dataDomain;
      else {
        var l = [], c = s.filter(function(f) {
          return a || f.isEnabled();
        });
        try {
          for (var d = og(c), u = d.next(); !u.done; u = d.next()) {
            var h = u.value;
            l.push(h.getDomain(n));
          }
        } catch (f) {
          e = { error: f };
        } finally {
          try {
            u && !u.done && (t = d.return) && t.call(d);
          } finally {
            if (e)
              throw e.error;
          }
        }
        var p = (i = new Array()).concat.apply(i, jc([], rs(l)));
        this.dataDomain = this.normaliseDataDomain(p);
      }
    }, o.prototype.updatePosition = function(e) {
      var t = e.rotation, i = e.sideFlag, r = this, n = r.crossLineGroup, s = r.axisGroup, a = r.gridGroup, l = r.translation, c = r.gridLineGroupSelection, d = r.gridPadding, u = r.gridLength, h = Math.floor(l.x), p = Math.floor(l.y);
      n.translationX = h, n.translationY = p, n.rotation = t, s.translationX = h, s.translationY = p, s.rotation = t, a.translationX = h, a.translationY = p, a.rotation = t, c.each(function(f) {
        f.x1 = d, f.x2 = -i * u + d, f.y1 = 0, f.y2 = 0;
      });
    }, o.prototype.updateSecondaryAxisTicks = function(e) {
      throw new Error("AG Charts - unexpected call to updateSecondaryAxisTicks() - check axes configuration.");
    }, o.prototype.updateSelections = function(e) {
      var t = this.gridLength ? e : [], i = this.gridLineGroupSelection.update(t, function(s) {
        var a = new Qt();
        a.tag = Ph.GridLine, s.append(a);
      }, function(s) {
        return s.tickId;
      }), r = this.tickLineGroupSelection.update(e, function(s) {
        var a = new Qt();
        a.tag = Ph.TickLine, s.appendChild(a);
      }, function(s) {
        return s.tickId;
      }), n = this.tickLabelGroupSelection.update(e, function(s) {
        var a = new ut();
        a.tag = Ph.TickLabel, s.appendChild(a);
      }, function(s) {
        return s.tickId;
      });
      this.tickLineGroupSelection = r, this.tickLabelGroupSelection = n, this.gridLineGroupSelection = i;
    }, o.prototype.updateGridLines = function(e) {
      var t = this, i = t.gridStyle, r = t.tick, n = t.gridPadding, s = t.gridLength;
      if (!(s === 0 || i.length === 0)) {
        var a = i.length;
        this.gridLineGroupSelection.each(function(l, c, d) {
          var u = i[d % a];
          l.x1 = n, l.x2 = -e * s + n, l.y1 = 0, l.y2 = 0, l.stroke = u.stroke, l.strokeWidth = r.width, l.lineDash = u.lineDash, l.fill = void 0;
        });
      }
    }, o.prototype.updateLabels = function(e) {
      var t = e.tickLabelGroupSelection, i = e.combinedRotation, r = e.textBaseline, n = e.textAlign, s = e.labelX, a = this, l = a.label, c = a.label.enabled;
      c && t.each(function(d, u) {
        var h = u.tickLabel;
        d.fontStyle = l.fontStyle, d.fontWeight = l.fontWeight, d.fontSize = l.fontSize, d.fontFamily = l.fontFamily, d.fill = l.color, d.text = h;
        var p = d.text === "" || d.text == null;
        if (p) {
          d.visible = !1;
          return;
        }
        d.textBaseline = r, d.textAlign = n, d.x = s, d.rotationCenterX = s, d.rotation = i, d.visible = !0;
      });
    }, o.prototype.wrapLabels = function(e, t, i) {
      var r = this.label, n = r.parallel, s = r.maxWidth, a = r.maxHeight, l = n ? Math.round(this.calculateAvailableRange() / e.labelCount) : this.maxThickness, c = s != null ? s : l, d = n ? this.maxThickness : Math.round(this.calculateAvailableRange() / e.labelCount), u = a != null ? a : d;
      return e.ticks.forEach(function(h) {
        var p = h.tickLabel, f = "hyphenate", g = ut.wrap(p, c, u, i, f);
        h.tickLabel = g;
      }), { tickData: e, index: t, autoRotation: 0, terminate: !0 };
    }, o.prototype.updateLine = function() {
      var e = this, t = e.lineNode, i = e.range;
      t.x1 = 0, t.x2 = 0, t.y1 = i[0], t.y2 = i[1], t.strokeWidth = this.line.width, t.stroke = this.line.color, t.visible = !0;
    }, o.prototype.updateTitle = function(e) {
      var t, i = e.anyTickVisible, r = e.sideFlag, n = function(P) {
        return P.defaultValue;
      }, s = this, a = s.rotation, l = s.title, c = s._titleCaption, d = s.lineNode, u = s.range, h = s.tickLineGroup, p = s.tickLabelGroup, f = s.moduleCtx.callbackCache, g = ((t = this.title) !== null && t !== void 0 ? t : {}).formatter, v = g === void 0 ? n : g;
      if (!l) {
        c.enabled = !1;
        return;
      }
      c.enabled = l.enabled, c.fontFamily = l.fontFamily, c.fontSize = l.fontSize, c.fontStyle = l.fontStyle, c.fontWeight = l.fontWeight, c.color = l.color, c.wrapping = l.wrapping;
      var y = !1, m = c.node;
      if (l.enabled && d.visible) {
        y = !0;
        var C = Vi(a), R = xd.PADDING, E = r === -1 && C > Math.PI && C < Math.PI * 2 ? -1 : 1;
        m.rotation = E * r * Math.PI / 2, m.x = Math.floor(E * r * (u[0] + u[1]) / 2);
        var b = 0;
        if (i) {
          var T = we.computeBBox([h, p]), D = a === 0 ? T.width : T.height;
          Math.abs(D) < 1 / 0 && (b += D);
        }
        r === -1 ? m.y = Math.floor(E * (-R - b)) : m.y = Math.floor(-R - b), m.textBaseline = E === 1 ? "bottom" : "top", m.text = f.call(v, this.getTitleFormatterParams());
      }
      m.visible = y;
    }, o.prototype.formatTick = function(e, t) {
      var i, r, n = this, s = n.label, a = n.labelFormatter, l = n.fractionDigits, c = n.moduleCtx.callbackCache;
      if (s.formatter) {
        var d = l > 0 ? e : String(e);
        return (i = c.call(s.formatter, {
          value: d,
          index: t,
          fractionDigits: l,
          formatter: a
        })) !== null && i !== void 0 ? i : d;
      } else if (a)
        return (r = c.call(a, e)) !== null && r !== void 0 ? r : String(e);
      return String(e);
    }, o.prototype.formatDatum = function(e) {
      return String(e);
    }, o.prototype.computeBBox = function() {
      return this.axisGroup.computeBBox();
    }, o.prototype.initCrossLine = function(e) {
      e.scale = this.scale, e.gridLength = this.gridLength;
    }, o.prototype.isAnySeriesActive = function() {
      var e = this;
      return this.boundSeries.some(function(t) {
        return e.includeInvisibleDomains || t.isEnabled();
      });
    }, o.prototype.clipTickLines = function(e, t, i, r) {
      this.tickLineGroup.setClipRectInGroupCoordinateSpace(new nt(e, t, i, r));
    }, o.prototype.clipGrid = function(e, t, i, r) {
      this.gridGroup.setClipRectInGroupCoordinateSpace(new nt(e, t, i, r));
    }, o.prototype.calculatePadding = function(e, t) {
      return [Math.abs(e * 0.01), Math.abs(e * 0.01)];
    }, o.prototype.getTitleFormatterParams = function() {
      var e = this, t, i = this.boundSeries.reduce(function(r, n) {
        for (var s = n.getKeys(e.direction), a = n.getNames(e.direction), l = 0; l < s.length; l++)
          r.push({
            key: s[l],
            name: a[l]
          });
        return r;
      }, []);
      return {
        direction: this.direction,
        boundSeries: i,
        defaultValue: (t = this.title) === null || t === void 0 ? void 0 : t.text
      };
    }, o.prototype.normaliseDataDomain = function(e) {
      return e;
    }, o.prototype.getLayoutState = function() {
      return wl({ rect: this.computeBBox(), gridPadding: this.gridPadding, seriesAreaPadding: this.seriesAreaPadding, tickSize: this.tick.size }, this.layout);
    }, o.prototype.createAxisContext = function() {
      var e = this, t = function() {
        return e.boundSeries.map(function(i) {
          return i.getKeys(e.direction);
        }).reduce(function(i, r) {
          return i.push.apply(i, jc([], rs(r))), i;
        }, []);
      };
      return {
        axisId: this.id,
        direction: this.direction,
        continuous: this.scale instanceof ct,
        keys: t,
        scaleValueFormatter: function(i) {
          var r, n, s;
          return (s = (n = (r = e.scale).tickFormat) === null || n === void 0 ? void 0 : n.call(r, { specifier: i })) !== null && s !== void 0 ? s : void 0;
        },
        scaleBandwidth: function() {
          var i;
          return (i = e.scale.bandwidth) !== null && i !== void 0 ? i : 0;
        },
        scaleConvert: function(i) {
          return e.scale.convert(i);
        },
        scaleInvert: function(i) {
          var r, n, s;
          return (s = (n = (r = e.scale).invert) === null || n === void 0 ? void 0 : n.call(r, i)) !== null && s !== void 0 ? s : void 0;
        }
      };
    }, o.prototype.addModule = function(e) {
      if (this.modules[e.optionsKey] != null)
        throw new Error("AG Charts - module already initialised: " + e.optionsKey);
      this.axisContext == null && (this.axisContext = this.createAxisContext());
      var t = new e.instanceConstructor(wl(wl({}, this.moduleCtx), { parent: this.axisContext }));
      this.modules[e.optionsKey] = { instance: t }, this[e.optionsKey] = t;
    }, o.prototype.removeModule = function(e) {
      var t, i;
      (i = (t = this.modules[e.optionsKey]) === null || t === void 0 ? void 0 : t.instance) === null || i === void 0 || i.destroy(), delete this.modules[e.optionsKey], delete this[e.optionsKey];
    }, o.prototype.isModuleEnabled = function(e) {
      return this.modules[e.optionsKey] != null;
    }, o.prototype.animateReadyUpdate = function(e) {
      var t = this, i, r;
      if (!e.changed) {
        this.resetSelectionNodes();
        return;
      }
      var n = this, s = n.gridLineGroupSelection, a = n.tickLineGroupSelection, l = n.tickLabelGroupSelection, c = Object.keys(e.added).length, d = Object.keys(e.removed).length;
      if (d === e.tickCount) {
        this.resetSelectionNodes();
        return;
      }
      var u = (r = (i = this.animationManager) === null || i === void 0 ? void 0 : i.defaultOptions.duration) !== null && r !== void 0 ? r : 1e3, h = Math.floor(u / 2);
      c > 0 && d > 0 && (h = Math.floor(u / 3));
      var p = {
        delay: d > 0 ? h : 0,
        duration: h
      }, f = this.id + "_" + Math.random();
      l.each(function(g, v) {
        t.animateSelectionNode(l, e, p, g, v, f);
      }), s.each(function(g, v) {
        t.animateSelectionNode(s, e, p, g, v, f);
      }), a.each(function(g, v) {
        t.animateSelectionNode(a, e, p, g, v, f);
      });
    }, o.prototype.animateSelectionNode = function(e, t, i, r, n, s) {
      var a = Math.round(n.translationY), l = { from: r.translationY, to: a }, c = { from: 1, to: 1 }, d = i.duration, u = i.delay, h = n.tickLabel;
      t.added[h] ? (l = { from: a, to: a }, c = { from: 0, to: 1 }, u += d) : t.removed[h] && (c = { from: 1, to: 0 }, u = 0);
      var p = [l, c];
      this.animationManager.animateManyWithThrottle(this.id + "_ready-update_" + r.id, p, {
        disableInteractions: !1,
        delay: u,
        duration: d,
        ease: qd,
        throttleId: this.id,
        throttleGroup: s,
        onUpdate: function(f) {
          var g = rs(f, 2), v = g[0], y = g[1];
          r.translationY = v, r.opacity = y;
        },
        onComplete: function() {
          e.cleanup();
        }
      });
    }, o.prototype.resetSelectionNodes = function() {
      var e = this, t = e.gridLineGroupSelection, i = e.tickLineGroupSelection, r = e.tickLabelGroupSelection;
      t.cleanup(), i.cleanup(), r.cleanup();
      var n = function(s) {
        s.translationY = Math.round(s.datum.translationY), s.opacity = 1;
      };
      t.each(n), i.each(n), r.each(n);
    }, o.prototype.calculateUpdateDiff = function(e, t) {
      for (var i, r = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), s = Math.max(e.length, t.ticks.length), a = 0; a < s; a++) {
        var l = e[a], c = (i = t.ticks[a]) === null || i === void 0 ? void 0 : i.tickId;
        l !== c && (n.has(c) ? n.delete(c) : c && r.add(c), r.has(l) ? r.delete(l) : l && n.add(l));
      }
      var d = {}, u = {};
      return r.forEach(function(h) {
        d[h] = !0;
      }), n.forEach(function(h) {
        u[h] = !0;
      }), {
        changed: r.size > 0 || n.size > 0,
        tickCount: s,
        added: d,
        removed: u
      };
    }, o.defaultTickMinSpacing = 50, Qy([
      A(ht)
    ], o.prototype, "nice", void 0), Qy([
      A(mD)
    ], o.prototype, "keys", void 0), Qy([
      A(YW)
    ], o.prototype, "gridStyle", void 0), o;
  }()
), ns = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, qW = (
  /** @class */
  function() {
    function o() {
      this.enabled = !1, this.text = void 0, this.fontStyle = void 0, this.fontWeight = void 0, this.fontSize = 10, this.fontFamily = "sans-serif", this.color = void 0, this.wrapping = "always", this.formatter = void 0;
    }
    return ns([
      A(ht)
    ], o.prototype, "enabled", void 0), ns([
      A(De)
    ], o.prototype, "text", void 0), ns([
      A(fc)
    ], o.prototype, "fontStyle", void 0), ns([
      A(gc)
    ], o.prototype, "fontWeight", void 0), ns([
      A(le(0))
    ], o.prototype, "fontSize", void 0), ns([
      A(Ri)
    ], o.prototype, "fontFamily", void 0), ns([
      A(St)
    ], o.prototype, "color", void 0), ns([
      A(qb)
    ], o.prototype, "wrapping", void 0), ns([
      A(Pt)
    ], o.prototype, "formatter", void 0), o;
  }()
), ZW = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), oh = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, KC = (
  /** @class */
  function(o) {
    ZW(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.enabled = !0, t.color = "rgba(0, 0, 0, 0.5)", t.xOffset = 0, t.yOffset = 0, t.blur = 5, t;
    }
    return oh([
      A(ht),
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "enabled", void 0), oh([
      A(Lr),
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "color", void 0), oh([
      A(le()),
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "xOffset", void 0), oh([
      A(le()),
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "yOffset", void 0), oh([
      A(le(0)),
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "blur", void 0), e;
  }($b)
), QW = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Jy = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, ri = (
  /** @class */
  function(o) {
    QW(e, o);
    function e() {
      var t = o.call(this, [0, 1], [0, 1]) || this;
      return t.type = "linear", t;
    }
    return e.prototype.toDomain = function(t) {
      return t;
    }, e.prototype.ticks = function() {
      var t, i = (t = this.tickCount) !== null && t !== void 0 ? t : ct.defaultTickCount;
      if (!this.domain || this.domain.length < 2 || i < 1 || this.domain.some(function(c) {
        return !isFinite(c);
      }))
        return [];
      this.refresh();
      var r = Jy(this.getDomain(), 2), n = r[0], s = r[1], a = this.interval;
      if (a) {
        var l = Math.abs(a);
        if (!this.isDenseInterval({ start: n, stop: s, interval: l }))
          return sv(n, s, l);
      }
      return Wm(n, s, i, this.minTickCount, this.maxTickCount);
    }, e.prototype.update = function() {
      !this.domain || this.domain.length < 2 || this.nice && this.updateNiceDomain();
    }, e.prototype.updateNiceDomain = function() {
      var t, i, r = (t = this.tickCount) !== null && t !== void 0 ? t : ct.defaultTickCount, n = Jy(this.domain, 2), s = n[0], a = n[1];
      if (r < 1) {
        this.niceDomain = [s, a];
        return;
      }
      if (r === 1) {
        this.niceDomain = bW(s, a);
        return;
      }
      for (var l = 4, c = s, d = a, u = 0; u < l; u++) {
        var h = (i = this.interval) !== null && i !== void 0 ? i : fp(s, a, r, this.minTickCount, this.maxTickCount), p = Jy(this.domain, 2), f = p[0], g = p[1];
        if (h >= 1)
          s = Math.floor(f / h) * h, a = Math.ceil(g / h) * h;
        else {
          var v = 1 / h;
          s = Math.floor(f * v) / v, a = Math.ceil(g * v) / v;
        }
        if (s === c && a === d)
          break;
        c = s, d = a;
      }
      this.niceDomain = [s, a];
    }, e.prototype.tickFormat = function(t) {
      var i = t.ticks, r = t.specifier;
      return UD(i != null ? i : this.ticks(), r);
    }, e;
  }(ct)
);
function jm(o, e, t) {
  return t === void 0 && (t = 1e-10), Math.abs(o - e) < t;
}
function lw(o, e) {
  e === void 0 && (e = 2);
  var t = Math.floor(Math.log(Math.abs(o)) / Math.LN10);
  return t >= 0 || !isFinite(t) ? o.toFixed(e) : o.toFixed(Math.abs(t) - 1 + e);
}
function JW(o, e) {
  return o >= 0 ? Math.floor(o % e) : Math.floor(o % e + e);
}
function qD(o, e, t) {
  var i = Math.sqrt(Math.pow(o, 2) + Math.pow(e, 2)), r = t.innerRadius, n = t.outerRadius;
  if (i < Math.min(r, n) || i > Math.max(r, n))
    return !1;
  var s = Math.atan2(e, o);
  s < -Math.PI / 2 && (s += 2 * Math.PI);
  var a = t.startAngle, l = t.endAngle;
  return l === -Math.PI / 2 ? s < a : a === 3 * Math.PI / 2 ? s > l : s <= l && s >= a;
}
function eE(o, e) {
  var t = e.startAngle, i = e.endAngle, r = e.innerRadius, n = e.outerRadius, s = { x: n * Math.cos(t), y: n * Math.sin(t) }, a = { x: n * Math.cos(i), y: n * Math.sin(i) }, l = r === 0 ? { x: 0, y: 0 } : { x: r * Math.cos(t), y: r * Math.sin(t) }, c = r === 0 ? { x: 0, y: 0 } : { x: r * Math.cos(i), y: r * Math.sin(i) };
  return xh(o.start.x, o.start.y, o.end.x, o.end.y, s.x, s.y, l.x, l.y) != null || xh(o.start.x, o.start.y, o.end.x, o.end.y, a.x, a.y, c.x, c.y) != null || FD(0, 0, n, t, i, !0, o.start.x, o.start.y, o.end.x, o.end.y).length > 0;
}
function ej(o, e) {
  var t = { x: o.x, y: o.y }, i = { x: o.x + o.width, y: o.y }, r = { x: o.x, y: o.y + o.height }, n = { x: o.x + o.width, y: o.y + o.height };
  return eE({ start: t, end: i }, e) || eE({ start: r, end: n }, e);
}
var tj = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), pl = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, ZD = (
  /** @class */
  function(o) {
    tj(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.centerX = 0, t.centerY = 0, t.innerRadius = 10, t.outerRadius = 20, t.startAngle = 0, t.endAngle = Math.PI * 2, t.angleOffset = 0, t;
    }
    return e.prototype.computeBBox = function() {
      var t = this.outerRadius;
      return new nt(this.centerX - t, this.centerY - t, t * 2, t * 2);
    }, e.prototype.updatePath = function() {
      var t = this.path, i = this.angleOffset, r = this.startAngle + i, n = this.endAngle + i, s = Math.min(this.innerRadius, this.outerRadius), a = Math.max(this.innerRadius, this.outerRadius), l = jm(Vi(this.startAngle), Vi(this.endAngle)), c = this.centerX, d = this.centerY;
      t.clear(), l ? (t.arc(c, d, a, r, n), s > 0 && (t.moveTo(c + s * Math.cos(n), d + s * Math.sin(n)), t.arc(c, d, s, n, r, !0))) : (t.moveTo(c + s * Math.cos(r), d + s * Math.sin(r)), t.arc(c, d, a, r, n), s > 0 ? t.arc(c, d, s, n, r, !0) : t.lineTo(c, d)), t.closePath(), this.dirtyPath = !1;
    }, e.prototype.isPointInPath = function(t, i) {
      var r = this.angleOffset, n = this.startAngle + r, s = this.endAngle + r, a = Math.min(this.innerRadius, this.outerRadius), l = Math.max(this.innerRadius, this.outerRadius), c = this.transformPoint(t, i);
      return qD(c.x, c.y, { startAngle: n, endAngle: s, innerRadius: a, outerRadius: l });
    }, e.className = "Sector", pl([
      yt()
    ], e.prototype, "centerX", void 0), pl([
      yt()
    ], e.prototype, "centerY", void 0), pl([
      yt()
    ], e.prototype, "innerRadius", void 0), pl([
      yt()
    ], e.prototype, "outerRadius", void 0), pl([
      yt()
    ], e.prototype, "startAngle", void 0), pl([
      yt()
    ], e.prototype, "endAngle", void 0), pl([
      yt()
    ], e.prototype, "angleOffset", void 0), e;
  }(Zi)
), ij = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), QD = (
  /** @class */
  function(o) {
    ij(e, o);
    function e(t) {
      var i, r, n = t.moduleCtx, s = t.useLabelLayer, a = s === void 0 ? !1 : s, l = t.pickModes, c = l === void 0 ? [Zt.EXACT_SHAPE_MATCH] : l, d = o.call(this, {
        moduleCtx: n,
        useLabelLayer: a,
        pickModes: c,
        contentGroupVirtual: !1,
        directionKeys: (i = {}, i[de.X] = ["angleKey"], i[de.Y] = ["radiusKey"], i),
        directionNames: (r = {}, r[de.X] = ["angleName"], r[de.Y] = ["radiusName"], r)
      }) || this;
      return d.centerX = 0, d.centerY = 0, d.radius = 0, d;
    }
    return e.prototype.getLabelData = function() {
      return [];
    }, e.prototype.computeLabelsBBox = function(t, i) {
      return null;
    }, e;
  }(Hm)
), $o = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Fi = function() {
  return Fi = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, Fi.apply(this, arguments);
}, Ge = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, Uc = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, $c = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, sh = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, tE = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, JD = (
  /** @class */
  function(o) {
    $o(e, o);
    function e(t, i, r, n, s, a, l) {
      var c = o.call(this, s, a, l) || this;
      return c.angleKey = t, c.calloutLabelKey = i, c.sectorLabelKey = r, c.radiusKey = n, c;
    }
    return e;
  }(gf)
), rj = (
  /** @class */
  function(o) {
    $o(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.type = "nodeClick", t;
    }
    return e;
  }(JD)
), nj = (
  /** @class */
  function(o) {
    $o(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.type = "nodeDoubleClick", t;
    }
    return e;
  }(JD)
), In;
(function(o) {
  o[o.Sector = 0] = "Sector", o[o.Callout = 1] = "Callout", o[o.Label = 2] = "Label";
})(In || (In = {}));
var oj = (
  /** @class */
  function(o) {
    $o(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.offset = 3, t.minAngle = 0, t.formatter = void 0, t.minSpacing = 4, t.maxCollisionOffset = 50, t.avoidCollisions = !0, t;
    }
    return Ge([
      A(le(0))
    ], e.prototype, "offset", void 0), Ge([
      A(le(0))
    ], e.prototype, "minAngle", void 0), Ge([
      A(Pt)
    ], e.prototype, "formatter", void 0), Ge([
      A(le(0))
    ], e.prototype, "minSpacing", void 0), Ge([
      A(le(0))
    ], e.prototype, "maxCollisionOffset", void 0), Ge([
      A(ht)
    ], e.prototype, "avoidCollisions", void 0), e;
  }(qn)
), sj = (
  /** @class */
  function(o) {
    $o(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.positionOffset = 0, t.positionRatio = 0.5, t.formatter = void 0, t;
    }
    return Ge([
      A(le())
    ], e.prototype, "positionOffset", void 0), Ge([
      A(le(0, 1))
    ], e.prototype, "positionRatio", void 0), Ge([
      A(Pt)
    ], e.prototype, "formatter", void 0), e;
  }(qn)
), aj = (
  /** @class */
  function() {
    function o() {
      this.colors = void 0, this.length = 10, this.strokeWidth = 1;
    }
    return Ge([
      A(j1)
    ], o.prototype, "colors", void 0), Ge([
      A(le(0))
    ], o.prototype, "length", void 0), Ge([
      A(le(0))
    ], o.prototype, "strokeWidth", void 0), o;
  }()
), lj = (
  /** @class */
  function(o) {
    $o(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.renderer = void 0, t;
    }
    return Ge([
      A(Pt)
    ], e.prototype, "renderer", void 0), e;
  }(vc)
), cj = (
  /** @class */
  function(o) {
    $o(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.showInLegend = !1, t;
    }
    return Ge([
      A(ht)
    ], e.prototype, "showInLegend", void 0), e;
  }(xd)
), dj = (
  /** @class */
  function(o) {
    $o(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.text = "", t.margin = 2, t;
    }
    return Ge([
      A(Ri)
    ], e.prototype, "text", void 0), Ge([
      A(le())
    ], e.prototype, "margin", void 0), e;
  }(qn)
), uj = (
  /** @class */
  function() {
    function o() {
      this.fill = "transparent", this.fillOpacity = 1;
    }
    return Ge([
      A(Lr)
    ], o.prototype, "fill", void 0), Ge([
      A(lt(0, 1))
    ], o.prototype, "fillOpacity", void 0), o;
  }()
), hj = (
  /** @class */
  function(o) {
    $o(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e;
  }(aw)
), eO = (
  /** @class */
  function(o) {
    $o(e, o);
    function e(t) {
      var i, r, n, s = o.call(this, { moduleCtx: t, useLabelLayer: !0 }) || this;
      s.radiusScale = new ri(), s.groupSelection = Et.select(s.contentGroup, we), s.highlightSelection = Et.select(s.highlightGroup, we), s.nodeData = [], s.seriesItemEnabled = [], s.title = void 0, s.calloutLabel = new oj(), s.sectorLabel = new sj(), s.calloutLine = new aj(), s.tooltip = new lj(), s.angleKey = "", s.angleName = "", s.innerLabels = [], s.innerCircle = void 0, s.radiusKey = void 0, s.radiusName = void 0, s.radiusMin = void 0, s.radiusMax = void 0, s.calloutLabelKey = void 0, s.calloutLabelName = void 0, s.sectorLabelKey = void 0, s.sectorLabelName = void 0, s.legendItemKey = void 0, s.fills = ["#c16068", "#a2bf8a", "#ebcc87", "#80a0c3", "#b58dae", "#85c0d1"], s.strokes = ["#874349", "#718661", "#a48f5f", "#5a7088", "#7f637a", "#5d8692"], s.fillOpacity = 1, s.strokeOpacity = 1, s.lineDash = [0], s.lineDashOffset = 0, s.formatter = void 0, s.rotation = 0, s.outerRadiusOffset = 0, s.outerRadiusRatio = 1, s.innerRadiusOffset = 0, s.innerRadiusRatio = 1, s.strokeWidth = 1, s.shadow = void 0, s.highlightStyle = new ew(), s.surroundingRadius = void 0, s.angleScale = new ri(), s.angleScale.domain = [0, 1], s.angleScale.range = [-Math.PI, Math.PI].map(function(d) {
        return d + Math.PI / 2;
      }), s.backgroundGroup = s.rootGroup.appendChild(new we({
        name: s.id + "-background",
        layer: !0,
        zIndex: kt.SERIES_BACKGROUND_ZINDEX
      }));
      var a = new we({ name: "pieCalloutLabels" }), l = new we({ name: "pieSectorLabels" }), c = new we({ name: "innerLabels" });
      return (i = s.labelGroup) === null || i === void 0 || i.append(a), (r = s.labelGroup) === null || r === void 0 || r.append(l), (n = s.labelGroup) === null || n === void 0 || n.append(c), s.calloutLabelSelection = Et.select(a, we), s.sectorLabelSelection = Et.select(l, ut), s.innerLabelsSelection = Et.select(c, ut), s.animationState = new hj("empty", {
        empty: {
          on: {
            update: {
              target: "ready",
              action: function() {
                return s.animateEmptyUpdateReady();
              }
            }
          }
        },
        ready: {
          on: {
            update: {
              target: "ready",
              action: function() {
                return s.animateReadyUpdateReady();
              }
            }
          }
        }
      }), s;
    }
    return Object.defineProperty(e.prototype, "data", {
      get: function() {
        return this._data;
      },
      set: function(t) {
        this._data = t, this.processSeriesItemEnabled();
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.addChartEventListeners = function() {
      var t = this, i;
      (i = this.ctx.chartEventManager) === null || i === void 0 || i.addListener("legend-item-click", function(r) {
        return t.onLegendItemClick(r);
      });
    }, e.prototype.visibleChanged = function() {
      this.processSeriesItemEnabled();
    }, e.prototype.processSeriesItemEnabled = function() {
      var t, i = this, r = i.data, n = i.visible;
      this.seriesItemEnabled = (t = r == null ? void 0 : r.map(function() {
        return n;
      })) !== null && t !== void 0 ? t : [];
    }, e.prototype.getDomain = function(t) {
      return t === de.X ? this.angleScale.domain : this.radiusScale.domain;
    }, e.prototype.processData = function(t) {
      var i, r;
      return Uc(this, void 0, void 0, function() {
        var n, s, a, l, c, d, u, h, p, f, g, v, y;
        return $c(this, function(m) {
          switch (m.label) {
            case 0:
              return n = this.data, s = n === void 0 ? [] : n, a = this, l = a.angleKey, c = a.radiusKey, d = a.calloutLabelKey, u = a.sectorLabelKey, h = a.legendItemKey, p = a.seriesItemEnabled, l ? (f = [], c && (f.push(
                xB(this, c, {
                  id: "radiusValue",
                  min: (i = this.radiusMin) !== null && i !== void 0 ? i : 0,
                  max: this.radiusMax
                }),
                wi(this, c, !0, { id: "radiusRaw" }),
                // Raw value pass-through.
                R0(this, { id: "radiusValue" }, [0, 1], (r = this.radiusMin) !== null && r !== void 0 ? r : 0, this.radiusMax)
              ), f.push()), d && f.push(wi(this, d, !1, { id: "calloutLabelValue" })), u && f.push(wi(this, u, !1, { id: "sectorLabelValue" })), h && f.push(wi(this, h, !1, { id: "legendItemValue" })), s = s.map(function(C, R) {
                var E;
                return p[R] ? C : Fi(Fi({}, C), (E = {}, E[l] = 0, E));
              }), [4, t.request(this.id, s, {
                props: tE([
                  DB(this, l, !0, { id: "angleValue" }),
                  wi(this, l, !0, { id: "angleRaw" }),
                  R0(this, { id: "angleValue" }, [0, 1], 0)
                ], sh(f))
              })]) : [
                2
                /*return*/
              ];
            case 1:
              return g = m.sent(), v = g.dataModel, y = g.processedData, this.dataModel = v, this.processedData = y, [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.maybeRefreshNodeData = function() {
      if (this.nodeDataRefresh) {
        var t = sh(this._createNodeData(), 1), i = t[0], r = i === void 0 ? {} : i, n = r.nodeData, s = n === void 0 ? [] : n;
        this.nodeData = s, this.nodeDataRefresh = !1;
      }
    }, e.prototype.createNodeData = function() {
      return Uc(this, void 0, void 0, function() {
        return $c(this, function(t) {
          return [2, this._createNodeData()];
        });
      });
    }, e.prototype.getProcessedDataIndexes = function(t) {
      var i = t.resolveProcessedDataIndexById(this, "angleValue").index, r = this.radiusKey ? t.resolveProcessedDataIndexById(this, "radiusValue").index : -1, n = this.calloutLabelKey ? t.resolveProcessedDataIndexById(this, "calloutLabelValue").index : -1, s = this.sectorLabelKey ? t.resolveProcessedDataIndexById(this, "sectorLabelValue").index : -1, a = this.legendItemKey ? t.resolveProcessedDataIndexById(this, "legendItemValue").index : -1;
      return { angleIdx: i, radiusIdx: r, calloutLabelIdx: n, sectorLabelIdx: s, legendItemIdx: a };
    }, e.prototype._createNodeData = function() {
      var t = this, i = this, r = i.id, n = i.processedData, s = i.dataModel, a = i.rotation, l = i.angleScale;
      if (!n || !s || n.type !== "ungrouped")
        return [];
      var c = this.getProcessedDataIndexes(s), d = c.angleIdx, u = c.radiusIdx, h = c.calloutLabelIdx, p = c.sectorLabelIdx, f = c.legendItemIdx, g = 0, v = n.data.map(function(y, m) {
        var C, R = y.datum, E = y.values, b = E[d], T = l.convert(g) + xr(a);
        g = b;
        var D = l.convert(g) + xr(a), P = Math.abs(D - T), O = T + P / 2, M = E[d + 1], _ = u >= 0 && (C = E[u]) !== null && C !== void 0 ? C : 1, F = u >= 0 ? E[u + 1] : void 0, I = f >= 0 ? E[f] : void 0, G = t.getLabels(R, O, P, !0, b, F, E[h], E[p], I), k = t.getSectorFormat(R, m, m, !1);
        return Fi({ itemId: m, series: t, datum: R, index: m, angleValue: M, midAngle: O, midCos: Math.cos(O), midSin: Math.sin(O), startAngle: T, endAngle: D, sectorFormat: k, radius: _, radiusValue: F, legendItemValue: I }, G);
      });
      return [
        {
          itemId: r,
          nodeData: v,
          labelData: v
        }
      ];
    }, e.prototype.getLabels = function(t, i, r, n, s, a, l, c, d) {
      var u = this, h = u.calloutLabel, p = u.sectorLabel, f = u.legendItemKey, g = u.ctx.callbackCache, v = !n || h.enabled ? this.calloutLabelKey : void 0, y = !n || p.enabled ? this.sectorLabelKey : void 0;
      if (!v && !y && !f)
        return {};
      var m = this.getLabelFormatterParams(t, s, a, l, c), C;
      if (v) {
        var R = xr(h.minAngle), E = r > R;
        E ? h.formatter ? C = g.call(h.formatter, m) : C = String(l) : C = void 0;
      }
      var b;
      return y && (p.formatter ? b = g.call(p.formatter, m) : b = String(c)), Fi(Fi(Fi({}, C != null ? {
        calloutLabel: Fi(Fi({}, this.getTextAlignment(i)), { text: C, hidden: !1, collisionTextAlign: void 0, collisionOffsetY: 0, box: void 0 })
      } : {}), b != null ? { sectorLabel: { text: b } } : {}), f != null && d != null ? { legendItem: { key: f, text: d } } : {});
    }, e.prototype.getLabelFormatterParams = function(t, i, r, n, s) {
      var a = this, l = a.id, c = a.radiusKey, d = a.radiusName, u = a.angleKey, h = a.angleName, p = a.calloutLabelKey, f = a.calloutLabelName, g = a.sectorLabelKey, v = a.sectorLabelName;
      return {
        datum: t,
        angleKey: u,
        angleValue: i,
        angleName: h,
        radiusKey: c,
        radiusValue: r,
        radiusName: d,
        calloutLabelKey: p,
        calloutLabelValue: n,
        calloutLabelName: f,
        sectorLabelKey: g,
        sectorLabelValue: s,
        sectorLabelName: v,
        seriesId: l
      };
    }, e.prototype.getTextAlignment = function(t) {
      var i = [
        { textAlign: "center", textBaseline: "bottom" },
        { textAlign: "left", textBaseline: "middle" },
        { textAlign: "center", textBaseline: "hanging" },
        { textAlign: "right", textBaseline: "middle" }
      ], r = aD(t), n = -3 * Math.PI / 4, s = r - n, a = Math.floor(s / (Math.PI / 2)), l = JW(a, i.length);
      return i[l];
    }, e.prototype.getSectorFormat = function(t, i, r, n) {
      var s, a, l, c, d, u, h, p, f = this, g = f.angleKey, v = f.radiusKey, y = f.fills, m = f.strokes, C = f.fillOpacity, R = f.formatter, E = f.id, b = f.ctx, T = b.callbackCache, D = b.highlightManager, P = D == null ? void 0 : D.getActiveHighlight(), O = n && (P == null ? void 0 : P.series) === this && i === P.itemId, M = O ? this.highlightStyle.item : null, _ = (s = M == null ? void 0 : M.fill) !== null && s !== void 0 ? s : y[r % y.length], F = (a = M == null ? void 0 : M.fillOpacity) !== null && a !== void 0 ? a : C, I = (l = M == null ? void 0 : M.stroke) !== null && l !== void 0 ? l : m[r % m.length], G = (c = M == null ? void 0 : M.strokeWidth) !== null && c !== void 0 ? c : this.getStrokeWidth(this.strokeWidth), k;
      return R && (k = T.call(R, {
        datum: t,
        angleKey: g,
        radiusKey: v,
        fill: _,
        stroke: I,
        strokeWidth: G,
        highlighted: O,
        seriesId: E
      })), {
        fill: (d = k == null ? void 0 : k.fill) !== null && d !== void 0 ? d : _,
        fillOpacity: (u = k == null ? void 0 : k.fillOpacity) !== null && u !== void 0 ? u : F,
        stroke: (h = k == null ? void 0 : k.stroke) !== null && h !== void 0 ? h : I,
        strokeWidth: (p = k == null ? void 0 : k.strokeWidth) !== null && p !== void 0 ? p : G
      };
    }, e.prototype.getInnerRadius = function() {
      var t = this, i = t.radius, r = t.innerRadiusRatio, n = t.innerRadiusOffset, s = i * (r != null ? r : 1) + (n || 0);
      return s === i || s < 0 ? 0 : s;
    }, e.prototype.getOuterRadius = function() {
      var t = this, i = t.radius, r = t.outerRadiusRatio, n = t.outerRadiusOffset, s = i * (r != null ? r : 1) + (n || 0);
      return s < 0 ? 0 : s;
    }, e.prototype.updateRadiusScale = function() {
      var t = this.getInnerRadius(), i = this.getOuterRadius();
      this.radiusScale.range = [t, i];
    }, e.prototype.getTitleTranslationY = function() {
      var t, i, r = Math.max(0, this.radiusScale.range[1]);
      if (r === 0)
        return NaN;
      var n = (i = (t = this.title) === null || t === void 0 ? void 0 : t.spacing) !== null && i !== void 0 ? i : 0, s = 2 + n, a = Math.max(0, -r);
      return -r - s - a;
    }, e.prototype.update = function(t) {
      var i = t.seriesRect;
      return Uc(this, void 0, void 0, function() {
        var r, n, s;
        return $c(this, function(a) {
          switch (a.label) {
            case 0:
              return r = this.title, this.maybeRefreshNodeData(), this.updateTitleNodes(), this.updateRadiusScale(), this.updateInnerCircleNodes(), this.contentGroup.translationX = this.centerX, this.contentGroup.translationY = this.centerY, this.highlightGroup.translationX = this.centerX, this.highlightGroup.translationY = this.centerY, this.backgroundGroup.translationX = this.centerX, this.backgroundGroup.translationY = this.centerY, this.labelGroup && (this.labelGroup.translationX = this.centerX, this.labelGroup.translationY = this.centerY), r && (n = this.getTitleTranslationY(), s = r.node.computeBBox(), r.node.visible = r.enabled && isFinite(n) && !this.bboxIntersectsSurroundingSeries(s, 0, n), r.node.translationY = isFinite(n) ? n : 0), this.updateNodeMidPoint(), [4, this.updateSelections()];
            case 1:
              return a.sent(), [4, this.updateNodes(i)];
            case 2:
              return a.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.updateTitleNodes = function() {
      var t, i, r = this, n = r.title, s = r.oldTitle;
      s !== n && (s && ((t = this.labelGroup) === null || t === void 0 || t.removeChild(s.node)), n && (n.node.textBaseline = "bottom", (i = this.labelGroup) === null || i === void 0 || i.appendChild(n.node)), this.oldTitle = n);
    }, e.prototype.updateInnerCircleNodes = function() {
      var t, i = this, r = i.innerCircle, n = i.oldInnerCircle, s = i.innerCircleNode;
      if (n !== r) {
        var a = void 0;
        s && this.backgroundGroup.removeChild(s), r && (a = new pp(), a.fill = r.fill, a.fillOpacity = (t = r.fillOpacity) !== null && t !== void 0 ? t : 1, this.backgroundGroup.appendChild(a)), this.oldInnerCircle = r, this.innerCircleNode = a;
      }
    }, e.prototype.updateNodeMidPoint = function() {
      var t = this;
      this.nodeData.forEach(function(i) {
        var r = t.radiusScale.convert(i.radius);
        i.nodeMidPoint = {
          x: i.midCos * Math.max(0, r / 2),
          y: i.midSin * Math.max(0, r / 2)
        };
      });
    }, e.prototype.updateSelections = function() {
      return Uc(this, void 0, void 0, function() {
        return $c(this, function(t) {
          switch (t.label) {
            case 0:
              return [4, this.updateGroupSelection()];
            case 1:
              return t.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.updateGroupSelection = function() {
      return Uc(this, void 0, void 0, function() {
        var t, i, r, n, s, a, l, c = this;
        return $c(this, function(d) {
          return t = this, i = t.groupSelection, r = t.highlightSelection, n = t.calloutLabelSelection, s = t.sectorLabelSelection, a = t.innerLabelsSelection, l = function(u) {
            return u.update(c.nodeData, function(h) {
              var p = new ZD();
              p.tag = In.Sector, h.appendChild(p);
            });
          }, this.groupSelection = l(i), this.highlightSelection = l(r), n.update(this.nodeData, function(u) {
            var h = new Qt();
            h.tag = In.Callout, h.pointerEvents = ki.None, u.appendChild(h);
            var p = new ut();
            p.tag = In.Label, p.pointerEvents = ki.None, u.appendChild(p);
          }), s.update(this.nodeData, function(u) {
            u.pointerEvents = ki.None;
          }), a.update(this.innerLabels, function(u) {
            u.pointerEvents = ki.None;
          }), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.updateNodes = function(t) {
      var i;
      return Uc(this, void 0, void 0, function() {
        var r, n, s, a, l, c = this;
        return $c(this, function(d) {
          return r = (i = this.ctx.highlightManager) === null || i === void 0 ? void 0 : i.getActiveHighlight(), n = this.seriesItemEnabled.indexOf(!0) >= 0, this.rootGroup.visible = n, this.backgroundGroup.visible = n, this.contentGroup.visible = n, this.highlightGroup.visible = n && (r == null ? void 0 : r.series) === this, this.labelGroup && (this.labelGroup.visible = n), this.contentGroup.opacity = this.getOpacity(), this.updateInnerCircle(), s = this.radiusScale, a = s.convert(0), l = function(u, h, p, f) {
            var g = s.convert(h.radius), v = u.parent, y = v == null ? void 0 : v.parent;
            f && v && y && (y.removeChild(v), y.appendChild(v)), u.innerRadius = Math.max(0, a), u.outerRadius = Math.max(0, g), f && (u.startAngle = h.startAngle, u.endAngle = h.endAngle);
            var m = c.getSectorFormat(h.datum, h.itemId, p, f);
            u.fill = m.fill, u.stroke = m.stroke, u.strokeWidth = m.strokeWidth, u.fillOpacity = m.fillOpacity, u.strokeOpacity = c.strokeOpacity, u.lineDash = c.lineDash, u.lineDashOffset = c.lineDashOffset, u.fillShadow = c.shadow, u.lineJoin = "round", u.visible = c.seriesItemEnabled[p];
          }, this.groupSelection.selectByTag(In.Sector).forEach(function(u, h) {
            return l(u, u.datum, h, !1);
          }), this.highlightSelection.selectByTag(In.Sector).forEach(function(u, h) {
            var p = (r == null ? void 0 : r.series) === c && u.datum.itemId === r.itemId;
            p ? l(u, u.datum, h, p) : u.visible = !1;
          }), this.animationState.transition("update"), this.updateCalloutLineNodes(), this.updateCalloutLabelNodes(t), this.updateSectorLabelNodes(), this.updateInnerLabelNodes(), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.updateCalloutLineNodes = function() {
      var t, i = this, r = i.radiusScale, n = i.calloutLine, s = n.length, a = n.strokeWidth, l = (t = n.colors) !== null && t !== void 0 ? t : this.strokes, c = this.calloutLabel.offset;
      this.calloutLabelSelection.selectByTag(In.Callout).forEach(function(d, u) {
        var h = d.datum, p = r.convert(h.radius), f = Math.max(0, p), g = h.calloutLabel;
        if (g != null && g.text && !g.hidden && f !== 0) {
          d.visible = !0, d.strokeWidth = a, d.stroke = l[u % l.length], d.fill = void 0;
          var v = h.midCos * f, y = h.midSin * f, m = h.midCos * (f + s), C = h.midSin * (f + s), R = g.collisionTextAlign || g.collisionOffsetY !== 0;
          if (R && g.box != null) {
            var E = g.box, b = m, T = C;
            m < E.x ? b = E.x : m > E.x + E.width && (b = E.x + E.width), C < E.y ? T = E.y : C > E.y + E.height && (T = E.y + E.height);
            var D = b - m, P = T - C, O = Math.sqrt(Math.pow(D, 2) + Math.pow(P, 2)), M = O - c;
            M > 0 && (m = m + D * M / O, C = C + P * M / O);
          }
          d.x1 = v, d.y1 = y, d.x2 = m, d.y2 = C;
        } else
          d.visible = !1;
      });
    }, e.prototype.getLabelOverflow = function(t, i, r) {
      var n = r.x - this.centerX, s = r.x + r.width - this.centerX, a = r.y - this.centerY, l = r.y + r.height - this.centerY, c = 1, d = 1;
      i.x + c < n ? d = (i.x + i.width - n) / i.width : i.x + i.width - c > s && (d = (s - i.x) / i.width);
      var u = i.y + c < a || i.y + i.height - c > l, h = d === 1 ? t.length : Math.floor(t.length * d) - 1, p = this.bboxIntersectsSurroundingSeries(i);
      return { textLength: h, hasVerticalOverflow: u, hasSurroundingSeriesOverflow: p };
    }, e.prototype.bboxIntersectsSurroundingSeries = function(t, i, r) {
      i === void 0 && (i = 0), r === void 0 && (r = 0);
      var n = this.surroundingRadius;
      if (n == null)
        return !1;
      var s = [
        { x: t.x + i, y: t.y + r },
        { x: t.x + t.width + i, y: t.y + r },
        { x: t.x + t.width + i, y: t.y + t.height + r },
        { x: t.x + i, y: t.y + t.height + r }
      ], a = Math.pow(n, 2);
      return s.some(function(l) {
        return Math.pow(l.x, 2) + Math.pow(l.y, 2) > a;
      });
    }, e.prototype.computeCalloutLabelCollisionOffsets = function() {
      var t = this, i = this, r = i.radiusScale, n = i.calloutLabel, s = i.calloutLine, a = n.offset, l = n.minSpacing, c = r.convert(0), d = function(b) {
        var T = b.calloutLabel, D = r.convert(b.radius), P = Math.max(0, D);
        return !T || P === 0;
      }, u = this.nodeData, h = this.nodeData.filter(function(b) {
        return !d(b);
      });
      if (h.forEach(function(b) {
        var T = b.calloutLabel;
        T != null && (T.hidden = !1, T.collisionTextAlign = void 0, T.collisionOffsetY = 0);
      }), !(h.length <= 1)) {
        var p = h.filter(function(b) {
          return b.midCos < 0;
        }).sort(function(b, T) {
          return b.midSin - T.midSin;
        }), f = h.filter(function(b) {
          return b.midCos >= 0;
        }).sort(function(b, T) {
          return b.midSin - T.midSin;
        }), g = h.filter(function(b) {
          var T;
          return b.midSin < 0 && ((T = b.calloutLabel) === null || T === void 0 ? void 0 : T.textAlign) === "center";
        }).sort(function(b, T) {
          return b.midCos - T.midCos;
        }), v = h.filter(function(b) {
          var T;
          return b.midSin >= 0 && ((T = b.calloutLabel) === null || T === void 0 ? void 0 : T.textAlign) === "center";
        }).sort(function(b, T) {
          return b.midCos - T.midCos;
        }), y = new ut(), m = function(b) {
          var T, D = b.calloutLabel;
          if (D == null)
            return new nt(0, 0, 0, 0);
          var P = r.convert(b.radius), O = Math.max(0, P), M = O + s.length + a, _ = b.midCos * M, F = b.midSin * M + D.collisionOffsetY;
          return y.text = D.text, y.x = _, y.y = F, y.setFont(t.calloutLabel), y.setAlign({
            textAlign: (T = D.collisionTextAlign) !== null && T !== void 0 ? T : D.textAlign,
            textBaseline: D.textBaseline
          }), y.computeBBox();
        }, C = function(b, T, D) {
          var P = m(b).grow(l / 2), O = m(T).grow(l / 2), M = P.x < O.x + O.width && P.x + P.width > O.x && (D === "to-top" ? P.y < O.y + O.height : P.y + P.height > O.y);
          if (M) {
            var _ = D === "to-top" ? P.y - O.y - O.height : P.y + P.height - O.y;
            T.calloutLabel.collisionOffsetY = _;
          }
        }, R = function(b) {
          for (var T = b.slice().sort(function(_, F) {
            return Math.abs(_.midSin) - Math.abs(F.midSin);
          })[0], D = b.indexOf(T), P = D - 1; P >= 0; P--) {
            var O = b[P + 1], M = b[P];
            C(O, M, "to-top");
          }
          for (var P = D + 1; P < b.length; P++) {
            var O = b[P - 1], M = b[P];
            C(O, M, "to-bottom");
          }
        }, E = function(b) {
          for (var T = h.some(function(N) {
            return N.calloutLabel.collisionOffsetY !== 0;
          }), D = b.map(function(N) {
            return m(N);
          }), P = D.map(function(N) {
            return N.clone().grow(l / 2);
          }), O = !1, M = 0; M < P.length && !O; M++)
            for (var _ = P[M], F = M + 1; F < b.length; F++) {
              var I = P[F];
              if (_.collidesBBox(I)) {
                O = !0;
                break;
              }
            }
          var G = u.map(function(N) {
            var W = N.startAngle, j = N.endAngle, K = r.convert(N.radius), $ = Math.max(0, K);
            return { startAngle: W, endAngle: j, innerRadius: c, outerRadius: $ };
          }), k = D.some(function(N) {
            return G.some(function(W) {
              return ej(N, W);
            });
          });
          !O && !T && !k || b.filter(function(N) {
            return N.calloutLabel.textAlign === "center";
          }).forEach(function(N) {
            var W = N.calloutLabel;
            N.midCos < 0 ? W.collisionTextAlign = "right" : N.midCos > 0 ? W.collisionTextAlign = "left" : W.collisionTextAlign = "center";
          });
        };
        R(p), R(f), E(g), E(v);
      }
    }, e.prototype.updateCalloutLabelNodes = function(t) {
      var i = this, r = this, n = r.radiusScale, s = r.calloutLabel, a = r.calloutLine, l = a.length, c = s.offset, d = s.color, u = new ut();
      this.calloutLabelSelection.selectByTag(In.Label).forEach(function(h) {
        var p, f = h.datum, g = f.calloutLabel, v = n.convert(f.radius), y = Math.max(0, v);
        if (!(g != null && g.text) || y === 0 || g.hidden) {
          h.visible = !1;
          return;
        }
        var m = y + l + c, C = f.midCos * m, R = f.midSin * m + g.collisionOffsetY, E = { textAlign: (p = g.collisionTextAlign) !== null && p !== void 0 ? p : g.textAlign, textBaseline: g.textBaseline };
        u.text = g.text, u.x = C, u.y = R, u.setFont(i.calloutLabel), u.setAlign(E);
        var b = u.computeBBox(), T = g.text, D = !0;
        if (s.avoidCollisions) {
          var P = i.getLabelOverflow(g.text, b, t), O = P.textLength, M = P.hasVerticalOverflow;
          T = g.text.length === O ? g.text : g.text.substring(0, O) + "…", D = !M;
        }
        h.text = T, h.x = C, h.y = R, h.setFont(i.calloutLabel), h.setAlign(E), h.fill = d, h.visible = D;
      });
    }, e.prototype.computeLabelsBBox = function(t, i) {
      var r = this, n, s = this, a = s.radiusScale, l = s.calloutLabel, c = s.calloutLine, d = c.length, u = l.offset, h = l.maxCollisionOffset, p = l.minSpacing;
      if (!l.avoidCollisions)
        return null;
      this.maybeRefreshNodeData(), this.updateRadiusScale(), this.computeCalloutLabelCollisionOffsets();
      var f = [], g = new ut(), v;
      if (!((n = this.title) === null || n === void 0) && n.text && this.title.enabled) {
        var y = this.getTitleTranslationY();
        isFinite(y) && (g.text = this.title.text, g.x = 0, g.y = y, g.setFont(this.title), g.setAlign({
          textBaseline: "bottom",
          textAlign: "center"
        }), v = g.computeBBox(), f.push(v));
      }
      return this.nodeData.forEach(function(m) {
        var C, R = m.calloutLabel, E = a.convert(m.radius), b = Math.max(0, E);
        if (!R || b === 0)
          return null;
        var T = b + d + u, D = m.midCos * T, P = m.midSin * T + R.collisionOffsetY;
        g.text = R.text, g.x = D, g.y = P, g.setFont(r.calloutLabel), g.setAlign({ textAlign: (C = R.collisionTextAlign) !== null && C !== void 0 ? C : R.textAlign, textBaseline: R.textBaseline });
        var O = g.computeBBox();
        if (R.box = O, Math.abs(R.collisionOffsetY) > h) {
          R.hidden = !0;
          return;
        }
        if (v) {
          var M = i.y - r.centerY, _ = new nt(v.x - p, M, v.width + 2 * p, v.y + v.height + p - M);
          if (O.collidesBBox(_)) {
            R.hidden = !0;
            return;
          }
        }
        if (t.hideWhenNecessary) {
          var F = r.getLabelOverflow(R.text, O, i), I = F.textLength, G = F.hasVerticalOverflow, k = F.hasSurroundingSeriesOverflow, N = R.text.length > 2 && I < 2;
          if (G || N || k) {
            R.hidden = !0;
            return;
          }
        }
        R.hidden = !1, f.push(O);
      }), f.length === 0 ? null : nt.merge(f);
    }, e.prototype.updateSectorLabelNodes = function() {
      var t = this.radiusScale, i = t.convert(0), r = this.sectorLabel, n = r.fontSize, s = r.fontStyle, a = r.fontWeight, l = r.fontFamily, c = r.positionOffset, d = r.positionRatio, u = r.color, h = i > 0, p = this.seriesItemEnabled.filter(Boolean).length === 1;
      this.sectorLabelSelection.each(function(f, g) {
        var v = g.sectorLabel, y = t.convert(g.radius), m = Math.max(0, y), C = !1;
        if (v && m !== 0) {
          var R = i * (1 - d) + y * d + c;
          f.fill = u, f.fontStyle = s, f.fontWeight = a, f.fontSize = n, f.fontFamily = l, f.text = v.text;
          var E = !h && p;
          E ? (f.x = 0, f.y = 0) : (f.x = g.midCos * R, f.y = g.midSin * R), f.textAlign = "center", f.textBaseline = "middle";
          var b = f.computeBBox(), T = [
            [b.x, b.y],
            [b.x + b.width, b.y],
            [b.x + b.width, b.y + b.height],
            [b.x, b.y + b.height]
          ], D = g.startAngle, P = g.endAngle, O = { startAngle: D, endAngle: P, innerRadius: i, outerRadius: m };
          T.every(function(M) {
            var _ = sh(M, 2), F = _[0], I = _[1];
            return qD(F, I, O);
          }) && (C = !0);
        }
        f.visible = C;
      });
    }, e.prototype.updateInnerCircle = function() {
      var t = this.innerCircleNode;
      if (t) {
        var i = this.getInnerRadius();
        if (i === 0)
          t.size = 0;
        else {
          var r = Math.min(i, this.getOuterRadius()), n = 1;
          t.size = Math.ceil(r * 2 + n);
        }
      }
    }, e.prototype.updateInnerLabelNodes = function() {
      var t = [], i = [];
      this.innerLabelsSelection.each(function(v, y) {
        var m = y.fontStyle, C = y.fontWeight, R = y.fontSize, E = y.fontFamily, b = y.color;
        v.fontStyle = m, v.fontWeight = C, v.fontSize = R, v.fontFamily = E, v.text = y.text, v.x = 0, v.y = 0, v.fill = b, v.textAlign = "center", v.textBaseline = "alphabetic", t.push(v.computeBBox()), i.push(y.margin);
      });
      for (var r = function(v) {
        return v === 0 ? 0 : i[v];
      }, n = function(v) {
        return v === i.length - 1 ? 0 : i[v];
      }, s = t.reduce(function(v, y, m) {
        return v + y.height + r(m) + n(m);
      }, 0), a = Math.max.apply(Math, tE([], sh(t.map(function(v) {
        return v.width;
      })))), l = this.getInnerRadius(), c = Math.sqrt(Math.pow(a / 2, 2) + Math.pow(s / 2, 2)), d = c <= (l > 0 ? l : this.getOuterRadius()), u = [], h = 0, p = -s / 2; h < t.length; h++) {
        var f = t[h], g = f.height + p + r(h);
        u.push(g), p = g + n(h);
      }
      this.innerLabelsSelection.each(function(v, y, m) {
        v.y = u[m], v.visible = d;
      });
    }, e.prototype.getNodeClickEvent = function(t, i) {
      return new rj(this.angleKey, this.calloutLabelKey, this.sectorLabelKey, this.radiusKey, t, i, this);
    }, e.prototype.getNodeDoubleClickEvent = function(t, i) {
      return new nj(this.angleKey, this.calloutLabelKey, this.sectorLabelKey, this.radiusKey, t, i, this);
    }, e.prototype.getTooltipHtml = function(t) {
      var i, r = this.angleKey;
      if (!r)
        return "";
      var n = this, s = n.tooltip, a = n.angleName, l = n.radiusKey, c = n.radiusName, d = n.calloutLabelKey, u = n.sectorLabelKey, h = n.calloutLabelName, p = n.sectorLabelName, f = n.id, g = s.renderer, v = t.datum, y = t.angleValue, m = t.radiusValue, C = t.sectorFormat.fill, R = t.calloutLabel, E = R === void 0 ? {} : R, b = E.text, T = b === void 0 ? "" : b, D = typeof y == "number" ? lw(y) : String(y), P = (i = this.title) === null || i === void 0 ? void 0 : i.text, O = (T ? T + ": " : "") + D, M = {
        title: P,
        backgroundColor: C,
        content: O
      };
      return g ? Ti(g({
        datum: v,
        angleKey: r,
        angleValue: y,
        angleName: a,
        radiusKey: l,
        radiusValue: m,
        radiusName: c,
        calloutLabelKey: d,
        calloutLabelName: h,
        sectorLabelKey: u,
        sectorLabelName: p,
        title: P,
        color: C,
        seriesId: f
      }), M) : Ti(M);
    }, e.prototype.getLegendData = function() {
      var t, i, r, n = this, s = n.processedData, a = n.calloutLabelKey, l = n.legendItemKey, c = n.id, d = n.dataModel;
      if (!d || !s || s.data.length === 0)
        return [];
      if (!l && !a)
        return [];
      for (var u = this.getProcessedDataIndexes(d), h = u.angleIdx, p = u.radiusIdx, f = u.calloutLabelIdx, g = u.sectorLabelIdx, v = u.legendItemIdx, y = ((t = this.title) === null || t === void 0 ? void 0 : t.showInLegend) && this.title.text, m = [], C = 0; C < s.data.length; C++) {
        var R = s.data[C], E = R.datum, b = R.values, T = [];
        y && T.push(y);
        var D = this.getLabels(E, 2 * Math.PI, 2 * Math.PI, !1, b[h], b[p], b[f], b[g], b[v]);
        if (l && D.legendItem !== void 0 ? T.push(D.legendItem.text) : a && ((i = D.calloutLabel) === null || i === void 0 ? void 0 : i.text) !== void 0 && T.push((r = D.calloutLabel) === null || r === void 0 ? void 0 : r.text), T.length !== 0) {
          var P = this.getSectorFormat(E, C, C, !1);
          m.push({
            legendType: "category",
            id: c,
            itemId: C,
            seriesId: c,
            enabled: this.seriesItemEnabled[C],
            label: {
              text: T.join(" - ")
            },
            marker: {
              fill: P.fill,
              stroke: P.stroke,
              fillOpacity: this.fillOpacity,
              strokeOpacity: this.strokeOpacity
            }
          });
        }
      }
      return m;
    }, e.prototype.onLegendItemClick = function(t) {
      var i = t.enabled, r = t.itemId, n = t.series;
      n.id === this.id ? this.toggleSeriesItem(r, i) : n.type === "pie" && this.toggleOtherSeriesItems(n, r, i);
    }, e.prototype.toggleSeriesItem = function(t, i) {
      this.seriesItemEnabled[t] = i, this.nodeDataRefresh = !0;
    }, e.prototype.toggleOtherSeriesItems = function(t, i, r) {
      var n = this, s, a, l = this, c = l.legendItemKey, d = l.dataModel;
      if (!(!c || !d)) {
        var u = t.legendItemKey && ((s = t.data) === null || s === void 0 ? void 0 : s.find(function(p, f) {
          return f === i;
        })[t.legendItemKey]);
        if (u) {
          var h = d.resolveProcessedDataIndexById(this, "legendItemValue").index;
          (a = this.processedData) === null || a === void 0 || a.data.forEach(function(p, f) {
            var g = p.values;
            g[h] === u && n.toggleSeriesItem(f, r);
          });
        }
      }
    }, e.prototype.animateEmptyUpdateReady = function() {
      var t = this, i, r, n = (r = (i = this.ctx.animationManager) === null || i === void 0 ? void 0 : i.defaultOptions.duration) !== null && r !== void 0 ? r : 1e3, s = 200, a = Math.PI / -2 + xr(this.rotation);
      this.groupSelection.selectByTag(In.Sector).forEach(function(c) {
        var d, u = c.datum;
        (d = t.ctx.animationManager) === null || d === void 0 || d.animateMany(t.id + "_empty-update-ready_" + c.id, [
          { from: a, to: u.startAngle },
          { from: a, to: u.endAngle }
        ], {
          duration: n,
          ease: qd,
          onUpdate: function(h) {
            var p = sh(h, 2), f = p[0], g = p[1];
            c.startAngle = f, c.endAngle = g;
          }
        });
      });
      var l = {
        from: 0,
        to: 1,
        delay: n,
        duration: s
      };
      this.calloutLabelSelection.each(function(c) {
        var d;
        (d = t.ctx.animationManager) === null || d === void 0 || d.animate(t.id + "_empty-update-ready_" + c.id, Fi(Fi({}, l), { onUpdate: function(u) {
          c.opacity = u;
        } }));
      }), this.sectorLabelSelection.each(function(c) {
        var d;
        (d = t.ctx.animationManager) === null || d === void 0 || d.animate(t.id + "_empty-update-ready_" + c.id, Fi(Fi({}, l), { onUpdate: function(u) {
          c.opacity = u;
        } }));
      }), this.innerLabelsSelection.each(function(c) {
        var d;
        (d = t.ctx.animationManager) === null || d === void 0 || d.animate(t.id + "_empty-update-ready_" + c.id, Fi(Fi({}, l), { onUpdate: function(u) {
          c.opacity = u;
        } }));
      });
    }, e.prototype.animateReadyUpdateReady = function() {
      this.groupSelection.selectByTag(In.Sector).forEach(function(t) {
        var i = t.datum;
        t.startAngle = i.startAngle, t.endAngle = i.endAngle;
      });
    }, e.className = "PieSeries", e.type = "pie", Ge([
      A(Ri)
    ], e.prototype, "angleKey", void 0), Ge([
      A(Ri)
    ], e.prototype, "angleName", void 0), Ge([
      A(De)
    ], e.prototype, "radiusKey", void 0), Ge([
      A(De)
    ], e.prototype, "radiusName", void 0), Ge([
      A(lt(0))
    ], e.prototype, "radiusMin", void 0), Ge([
      A(lt(0))
    ], e.prototype, "radiusMax", void 0), Ge([
      A(De)
    ], e.prototype, "calloutLabelKey", void 0), Ge([
      A(De)
    ], e.prototype, "calloutLabelName", void 0), Ge([
      A(De)
    ], e.prototype, "sectorLabelKey", void 0), Ge([
      A(De)
    ], e.prototype, "sectorLabelName", void 0), Ge([
      A(De)
    ], e.prototype, "legendItemKey", void 0), Ge([
      A(hp)
    ], e.prototype, "fills", void 0), Ge([
      A(hp)
    ], e.prototype, "strokes", void 0), Ge([
      A(le(0, 1))
    ], e.prototype, "fillOpacity", void 0), Ge([
      A(le(0, 1))
    ], e.prototype, "strokeOpacity", void 0), Ge([
      A(Au)
    ], e.prototype, "lineDash", void 0), Ge([
      A(le(0))
    ], e.prototype, "lineDashOffset", void 0), Ge([
      A(Pt)
    ], e.prototype, "formatter", void 0), Ge([
      A(le(-360, 360))
    ], e.prototype, "rotation", void 0), Ge([
      A(le())
    ], e.prototype, "outerRadiusOffset", void 0), Ge([
      A(le(0))
    ], e.prototype, "outerRadiusRatio", void 0), Ge([
      A(le())
    ], e.prototype, "innerRadiusOffset", void 0), Ge([
      A(le(0))
    ], e.prototype, "innerRadiusRatio", void 0), Ge([
      A(le(0))
    ], e.prototype, "strokeWidth", void 0), e;
  }(QD)
), Ah = function() {
  return Ah = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, Ah.apply(this, arguments);
}, gp = {
  constructors: {},
  constructedArrays: /* @__PURE__ */ new WeakMap()
};
function pj(o, e) {
  var t;
  (t = gp.constructedArrays) === null || t === void 0 || t.set(o, e);
}
var iE = {
  constructors: {
    title: xd,
    subtitle: xd,
    footnote: xd,
    shadow: KC,
    innerCircle: uj,
    "axes[].title": qW,
    "series[].innerLabels[]": dj
  },
  allowedTypes: {
    "legend.pagination.marker.shape": ["primitive", "function"],
    "series[].marker.shape": ["primitive", "function"],
    "axis[].tick.count": ["primitive", "class-instance"]
  }
};
function tO() {
  return {
    constructors: Ah(Ah({}, iE.constructors), gp.constructors),
    constructedArrays: gp.constructedArrays,
    allowedTypes: Ah({}, iE.allowedTypes)
  };
}
var fj = {
  top: { xTranslationDirection: 0, yTranslationDirection: -1 },
  bottom: { xTranslationDirection: 0, yTranslationDirection: 1 },
  left: { xTranslationDirection: -1, yTranslationDirection: 0 },
  right: { xTranslationDirection: 1, yTranslationDirection: 0 },
  topLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },
  topRight: { xTranslationDirection: -1, yTranslationDirection: -1 },
  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },
  bottomRight: { xTranslationDirection: -1, yTranslationDirection: 1 },
  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },
  insideLeft: { xTranslationDirection: 1, yTranslationDirection: 0 },
  insideRight: { xTranslationDirection: -1, yTranslationDirection: 0 },
  insideTop: { xTranslationDirection: 0, yTranslationDirection: 1 },
  insideBottom: { xTranslationDirection: 0, yTranslationDirection: -1 },
  insideTopLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },
  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },
  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: 1 },
  insideBottomRight: { xTranslationDirection: -1, yTranslationDirection: -1 }
}, gj = {
  top: { xTranslationDirection: 1, yTranslationDirection: 0 },
  bottom: { xTranslationDirection: -1, yTranslationDirection: 0 },
  left: { xTranslationDirection: 0, yTranslationDirection: -1 },
  right: { xTranslationDirection: 0, yTranslationDirection: 1 },
  topLeft: { xTranslationDirection: -1, yTranslationDirection: -1 },
  topRight: { xTranslationDirection: -1, yTranslationDirection: 1 },
  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },
  bottomRight: { xTranslationDirection: 1, yTranslationDirection: 1 },
  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },
  insideLeft: { xTranslationDirection: 0, yTranslationDirection: 1 },
  insideRight: { xTranslationDirection: 0, yTranslationDirection: -1 },
  insideTop: { xTranslationDirection: -1, yTranslationDirection: 0 },
  insideBottom: { xTranslationDirection: 1, yTranslationDirection: 0 },
  insideTopLeft: { xTranslationDirection: -1, yTranslationDirection: 1 },
  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },
  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: -1 },
  insideBottomRight: { xTranslationDirection: 1, yTranslationDirection: -1 }
};
function vj(o) {
  var e = o.yDirection, t = o.padding, i = t === void 0 ? 0 : t, r = o.position, n = r === void 0 ? "top" : r, s = o.bbox, a = e ? fj : gj, l = a[n], c = l.xTranslationDirection, d = l.yTranslationDirection, u = e ? s.width : s.height, h = e ? s.height : s.width, p = c * (i + u / 2), f = d * (i + h / 2), g = {
    xTranslation: p,
    yTranslation: f
  };
  return g;
}
function mj(o) {
  var e = o.yDirection, t = o.bbox, i = o.padding, r = i === void 0 ? 0 : i, n = o.position, s = n === void 0 ? "top" : n, a = {};
  return s.startsWith("inside") || (s === "top" && !e ? a.top = r + t.height : s === "bottom" && !e ? a.bottom = r + t.height : s === "left" && e ? a.left = r + t.width : s === "right" && e && (a.right = r + t.width)), a;
}
var YC = function(o) {
  var e = o.yDirection, t = o.xEnd, i = o.yStart, r = o.yEnd;
  return e ? { x: t / 2, y: i } : { x: t, y: isNaN(r) ? i : (i + r) / 2 };
}, rE = function(o) {
  var e = o.yDirection, t = o.xStart, i = o.xEnd, r = o.yStart, n = o.yEnd;
  return e ? { x: t, y: isNaN(n) ? r : (r + n) / 2 } : { x: i / 2, y: r };
}, nE = function(o) {
  var e = o.yDirection, t = o.xEnd, i = o.yStart, r = o.yEnd;
  return e ? { x: t, y: isNaN(r) ? i : (i + r) / 2 } : { x: t / 2, y: isNaN(r) ? i : r };
}, oE = function(o) {
  var e = o.yDirection, t = o.xStart, i = o.xEnd, r = o.yStart, n = o.yEnd;
  return e ? { x: i / 2, y: isNaN(n) ? r : n } : { x: t, y: isNaN(n) ? r : (r + n) / 2 };
}, yj = function(o) {
  var e = o.xEnd, t = o.yStart, i = o.yEnd;
  return { x: e / 2, y: isNaN(i) ? t : (t + i) / 2 };
}, sE = function(o) {
  var e = o.yDirection, t = o.xStart, i = o.xEnd, r = o.yStart;
  return e ? { x: t / 2, y: r } : { x: i, y: r };
}, aE = function(o) {
  var e = o.yDirection, t = o.xStart, i = o.yStart, r = o.yEnd;
  return e ? { x: t, y: isNaN(r) ? i : r } : { x: t, y: i };
}, lE = function(o) {
  var e = o.yDirection, t = o.xEnd, i = o.yStart, r = o.yEnd;
  return e ? { x: t, y: i } : { x: t, y: isNaN(r) ? i : r };
}, cE = function(o) {
  var e = o.yDirection, t = o.xStart, i = o.xEnd, r = o.yStart, n = o.yEnd;
  return e ? { x: i, y: isNaN(n) ? r : n } : { x: t, y: isNaN(n) ? r : n };
}, Cj = {
  top: { c: YC },
  bottom: { c: oE },
  left: { c: rE },
  right: { c: nE },
  topLeft: { c: sE },
  topRight: { c: lE },
  bottomLeft: { c: aE },
  bottomRight: { c: cE },
  inside: { c: yj },
  insideLeft: { c: rE },
  insideRight: { c: nE },
  insideTop: { c: YC },
  insideBottom: { c: oE },
  insideTopLeft: { c: sE },
  insideBottomLeft: { c: aE },
  insideTopRight: { c: lE },
  insideBottomRight: { c: cE }
}, Sj = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), cv = function() {
  return cv = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, cv.apply(this, arguments);
}, fl = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, bj = (
  /** @class */
  function(o) {
    Sj(e, o);
    function e() {
      var t = o.call(this) || this;
      return t.x1 = 0, t.y1 = 0, t.x2 = 0, t.y2 = 0, t.startLine = !1, t.endLine = !1, t.isRange = !1, t.restoreOwnStyles(), t;
    }
    return e.prototype.computeBBox = function() {
      return new nt(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);
    }, e.prototype.isPointInPath = function(t, i) {
      return !1;
    }, e.prototype.render = function(t) {
      var i, r = t.ctx, n = t.forceRender, s = t.stats;
      if (this.dirty === oe.NONE && !n) {
        s && (s.nodesSkipped += this.nodeCount.count);
        return;
      }
      this.computeTransformMatrix(), this.matrix.toContext(r);
      var a = this, l = a.x1, c = a.y1, d = a.x2, u = a.y2;
      l = this.align(l), c = this.align(c), d = this.align(d), u = this.align(u);
      var h = this, p = h.fill, f = h.opacity, g = h.isRange, v = !!(g && p);
      if (v) {
        var y = this.fillOpacity;
        r.fillStyle = p, r.globalAlpha = f * y, r.beginPath(), r.moveTo(l, c), r.lineTo(d, c), r.lineTo(d, u), r.lineTo(l, u), r.closePath(), r.fill();
      }
      var m = this, C = m.stroke, R = m.strokeWidth, E = m.startLine, b = m.endLine, T = !!((E || b) && C && R);
      if (T) {
        var D = this, P = D.strokeOpacity, O = D.lineDash, M = D.lineDashOffset, _ = D.lineCap, F = D.lineJoin;
        r.strokeStyle = C, r.globalAlpha = f * P, r.lineWidth = R, O && r.setLineDash(O), M && (r.lineDashOffset = M), _ && (r.lineCap = _), F && (r.lineJoin = F), r.beginPath(), E && (r.moveTo(l, c), r.lineTo(d, c)), b && (r.moveTo(d, u), r.lineTo(l, u)), r.stroke();
      }
      (i = this.fillShadow) === null || i === void 0 || i.markClean(), o.prototype.render.call(this, t);
    }, e.className = "Range", e.defaultStyles = cv(cv({}, Mo.defaultStyles), { strokeWidth: 1 }), fl([
      ve({ redraw: oe.MINOR })
    ], e.prototype, "x1", void 0), fl([
      ve({ redraw: oe.MINOR })
    ], e.prototype, "y1", void 0), fl([
      ve({ redraw: oe.MINOR })
    ], e.prototype, "x2", void 0), fl([
      ve({ redraw: oe.MINOR })
    ], e.prototype, "y2", void 0), fl([
      ve({ redraw: oe.MINOR })
    ], e.prototype, "startLine", void 0), fl([
      ve({ redraw: oe.MINOR })
    ], e.prototype, "endLine", void 0), fl([
      ve({ redraw: oe.MINOR })
    ], e.prototype, "isRange", void 0), e;
  }(Mo)
), jt = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, os = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, dE = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, wj = [
  "top",
  "left",
  "right",
  "bottom",
  "topLeft",
  "topRight",
  "bottomLeft",
  "bottomRight",
  "inside",
  "insideLeft",
  "insideRight",
  "insideTop",
  "insideBottom",
  "insideTopLeft",
  "insideBottomLeft",
  "insideTopRight",
  "insideBottomRight"
], Ej = Ee(function(o, e) {
  return Ot(o, e, function(t) {
    return wj.includes(t);
  });
}, "expecting an optional crossLine label position keyword such as 'topLeft', 'topRight' or 'inside'"), Rj = Ee(function(o, e) {
  return Ot(o, e, function(t) {
    return t === "range" || t === "line";
  });
}, "expecting a crossLine type keyword such as 'range' or 'line'"), Tj = (
  /** @class */
  function() {
    function o() {
      this.enabled = void 0, this.text = void 0, this.fontStyle = void 0, this.fontWeight = void 0, this.fontSize = 14, this.fontFamily = "Verdana, sans-serif", this.padding = 5, this.color = "rgba(87, 87, 87, 1)", this.position = void 0, this.rotation = void 0, this.parallel = void 0;
    }
    return jt([
      A(_o)
    ], o.prototype, "enabled", void 0), jt([
      A(De)
    ], o.prototype, "text", void 0), jt([
      A(fc)
    ], o.prototype, "fontStyle", void 0), jt([
      A(gc)
    ], o.prototype, "fontWeight", void 0), jt([
      A(le(0))
    ], o.prototype, "fontSize", void 0), jt([
      A(Ri)
    ], o.prototype, "fontFamily", void 0), jt([
      A(le(0))
    ], o.prototype, "padding", void 0), jt([
      A(St)
    ], o.prototype, "color", void 0), jt([
      A(Ej)
    ], o.prototype, "position", void 0), jt([
      A(lt(-360, 360))
    ], o.prototype, "rotation", void 0), jt([
      A(_o)
    ], o.prototype, "parallel", void 0), o;
  }()
), xj = (
  /** @class */
  function() {
    function o() {
      this.id = Vs(this), this.enabled = void 0, this.type = void 0, this.range = void 0, this.value = void 0, this.fill = void 0, this.fillOpacity = void 0, this.stroke = void 0, this.strokeWidth = void 0, this.strokeOpacity = void 0, this.lineDash = void 0, this.label = new Tj(), this.scale = void 0, this.clippedRange = [-1 / 0, 1 / 0], this.gridLength = 0, this.sideFlag = -1, this.parallelFlipRotation = 0, this.regularFlipRotation = 0, this.direction = de.X, this.group = new we({ name: "" + this.id, layer: !0, zIndex: o.LINE_LAYER_ZINDEX }), this.crossLineRange = new bj(), this.crossLineLabel = new ut(), this.labelPoint = void 0, this.data = [], this.startLine = !1, this.endLine = !1, this.isRange = !1;
      var e = this, t = e.group, i = e.crossLineRange, r = e.crossLineLabel;
      t.append([i, r]), i.pointerEvents = ki.None;
    }
    return o.prototype.update = function(e) {
      if (this.enabled && (this.group.visible = e, !!e)) {
        var t = this.createNodeData();
        if (!t) {
          this.group.visible = !1;
          return;
        }
        this.updateNodes(), this.group.zIndex = this.getZIndex(this.isRange);
      }
    }, o.prototype.updateNodes = function() {
      this.updateRangeNode(), this.label.enabled && (this.updateLabel(), this.positionLabel());
    }, o.prototype.createNodeData = function() {
      var e, t, i, r, n, s = this, a = s.scale, l = s.gridLength, c = s.sideFlag, d = s.direction, u = s.label.position, h = u === void 0 ? "top" : u, p = s.clippedRange, f = s.strokeWidth, g = f === void 0 ? 0 : f;
      if (!a)
        return !1;
      var v = (r = a.bandwidth) !== null && r !== void 0 ? r : 0, y = function(j) {
        return Math.max(Math.min.apply(Math, dE([], os(p))), Math.min(Math.max.apply(Math, dE([], os(p))), j));
      }, m = os([0, c * l], 2), C = m[0], R = m[1], E = os(this.getRange(), 2), b = E[0], T = E[1], D = os([
        Number(a.convert(b, { strict: !1 })),
        a.convert(T, { strict: !1 }) + v
      ], 2), P = D[0], O = D[1];
      P = y(P), O = y(O), e = os([Number(a.convert(b)), a.convert(T) + v], 2), b = e[0], T = e[1];
      var M = !isNaN(P) && !isNaN(O) && (b === P || T === O || P !== O) && Math.abs(O - P) > 0;
      if (M) {
        var _ = P !== Math.min(P, O);
        _ && (t = os([
          Math.min(P, O),
          Math.max(P, O)
        ], 2), P = t[0], O = t[1], i = os([T, b], 2), b = i[0], T = i[1]);
      }
      if (this.isRange = M, this.startLine = !isNaN(b) && g > 0 && b === P, this.endLine = !isNaN(T) && g > 0 && T === O, !M && !this.startLine && !this.endLine)
        return !1;
      if (this.data = [P, O], this.label.enabled) {
        var F = d === de.Y, I = ((n = Cj[h]) !== null && n !== void 0 ? n : {}).c, G = I === void 0 ? YC : I, k = G({ yDirection: F, xStart: C, xEnd: R, yStart: P, yEnd: O }), N = k.x, W = k.y;
        this.labelPoint = {
          x: N,
          y: W
        };
      }
      return !0;
    }, o.prototype.updateRangeNode = function() {
      var e, t = this, i = t.crossLineRange, r = t.sideFlag, n = t.gridLength, s = t.data, a = t.startLine, l = t.endLine, c = t.isRange, d = t.fill, u = t.fillOpacity, h = t.stroke, p = t.strokeWidth, f = t.lineDash;
      i.x1 = 0, i.x2 = r * n, i.y1 = s[0], i.y2 = s[1], i.startLine = a, i.endLine = l, i.isRange = c, i.fill = d, i.fillOpacity = u != null ? u : 1, i.stroke = h, i.strokeWidth = p != null ? p : 1, i.strokeOpacity = (e = this.strokeOpacity) !== null && e !== void 0 ? e : 1, i.lineDash = f;
    }, o.prototype.updateLabel = function() {
      var e = this, t = e.crossLineLabel, i = e.label;
      i.text && (t.fontStyle = i.fontStyle, t.fontWeight = i.fontWeight, t.fontSize = i.fontSize, t.fontFamily = i.fontFamily, t.fill = i.color, t.text = i.text);
    }, o.prototype.positionLabel = function() {
      var e = this, t = e.crossLineLabel, i = e.labelPoint, r = i === void 0 ? {} : i, n = r.x, s = n === void 0 ? void 0 : n, a = r.y, l = a === void 0 ? void 0 : a, c = e.label, d = c.parallel, u = c.rotation, h = c.position, p = h === void 0 ? "top" : h, f = c.padding, g = f === void 0 ? 0 : f, v = e.direction, y = e.parallelFlipRotation, m = e.regularFlipRotation;
      if (!(s === void 0 || l === void 0)) {
        var C = ow({
          rotation: u,
          parallel: d,
          regularFlipRotation: m,
          parallelFlipRotation: y
        }), R = C.defaultRotation, E = C.configuredRotation;
        t.rotation = R + E, t.textBaseline = "middle", t.textAlign = "center";
        var b = this.computeLabelBBox();
        if (b) {
          var T = v === de.Y, D = vj({ yDirection: T, padding: g, position: p, bbox: b }), P = D.xTranslation, O = D.yTranslation;
          t.translationX = s + P, t.translationY = l + O;
        }
      }
    }, o.prototype.getZIndex = function(e) {
      return e === void 0 && (e = !1), e ? o.RANGE_LAYER_ZINDEX : o.LINE_LAYER_ZINDEX;
    }, o.prototype.getRange = function() {
      var e = this, t = e.value, i = e.range, r = e.scale, n = r instanceof ct, s = os(i != null ? i : [t, void 0], 2), a = s[0], l = s[1];
      return !n && l === void 0 && (l = a), a = up(a, n) != null ? a : void 0, l = up(l, n) != null ? l : void 0, n && a === l && (l = void 0), a === void 0 && l !== void 0 && (a = l, l = void 0), [a, l];
    }, o.prototype.computeLabelBBox = function() {
      return this.crossLineLabel.computeTransformedBBox();
    }, o.prototype.calculatePadding = function(e) {
      var t, i, r, n, s, a, l, c, d = this, u = d.isRange, h = d.startLine, p = d.endLine, f = d.direction, g = d.label, v = g.padding, y = v === void 0 ? 0 : v, m = g.position, C = m === void 0 ? "top" : m;
      if (!(!u && !h && !p)) {
        var R = this.computeLabelBBox(), E = R == null ? void 0 : R.x, b = R == null ? void 0 : R.y;
        if (!(!R || E == null || b == null)) {
          var T = mj({
            yDirection: f === de.Y,
            padding: y,
            position: C,
            bbox: R
          });
          e.left = Math.max((t = e.left) !== null && t !== void 0 ? t : 0, (i = T.left) !== null && i !== void 0 ? i : 0), e.right = Math.max((r = e.right) !== null && r !== void 0 ? r : 0, (n = T.right) !== null && n !== void 0 ? n : 0), e.top = Math.max((s = e.top) !== null && s !== void 0 ? s : 0, (a = T.top) !== null && a !== void 0 ? a : 0), e.bottom = Math.max((l = e.bottom) !== null && l !== void 0 ? l : 0, (c = T.bottom) !== null && c !== void 0 ? c : 0);
        }
      }
    }, o.LINE_LAYER_ZINDEX = kt.SERIES_CROSSLINE_LINE_ZINDEX, o.RANGE_LAYER_ZINDEX = kt.SERIES_CROSSLINE_RANGE_ZINDEX, o.className = "CrossLine", jt([
      A(_o)
    ], o.prototype, "enabled", void 0), jt([
      A(Rj)
    ], o.prototype, "type", void 0), jt([
      A(Yb(2))
    ], o.prototype, "range", void 0), jt([
      A(St)
    ], o.prototype, "fill", void 0), jt([
      A(lt(0, 1))
    ], o.prototype, "fillOpacity", void 0), jt([
      A(St)
    ], o.prototype, "stroke", void 0), jt([
      A(lt())
    ], o.prototype, "strokeWidth", void 0), jt([
      A(lt(0, 1))
    ], o.prototype, "strokeOpacity", void 0), jt([
      A(Au)
    ], o.prototype, "lineDash", void 0), o;
  }()
), Dj = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), dv = function() {
  return dv = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, dv.apply(this, arguments);
}, uE = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, Um = (
  /** @class */
  function(o) {
    Dj(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.thickness = 0, t.position = "left", t;
    }
    return Object.defineProperty(e.prototype, "direction", {
      get: function() {
        return ["top", "bottom"].includes(this.position) ? de.X : de.Y;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.updateDirection = function() {
      switch (this.position) {
        case "top":
          this.rotation = -90, this.label.mirrored = !0, this.label.parallel = !0;
          break;
        case "right":
          this.rotation = 0, this.label.mirrored = !0, this.label.parallel = !1;
          break;
        case "bottom":
          this.rotation = -90, this.label.mirrored = !1, this.label.parallel = !0;
          break;
        case "left":
          this.rotation = 0, this.label.mirrored = !1, this.label.parallel = !1;
          break;
      }
      this.axisContext && (this.axisContext.position = this.position, this.axisContext.direction = this.direction);
    }, e.prototype.update = function(t) {
      return this.updateDirection(), o.prototype.update.call(this, t);
    }, e.prototype.createAxisContext = function() {
      return dv(dv({}, o.prototype.createAxisContext.call(this)), { position: this.position });
    }, e.prototype.assignCrossLineArrayConstructor = function(t) {
      pj(t, xj);
    }, uE([
      A(le(0))
    ], e.prototype, "thickness", void 0), uE([
      A(CD)
    ], e.prototype, "position", void 0), e;
  }(XD)
), Oj = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Pj = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, Aj = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, hE = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, pE = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, Qd = (
  /** @class */
  function(o) {
    Oj(e, o);
    function e(t) {
      var i = o.call(this, t, new $n()) || this;
      return i._paddingOverrideEnabled = !1, i.groupPaddingInner = 0.1, i.includeInvisibleDomains = !0, i;
    }
    return Object.defineProperty(e.prototype, "paddingInner", {
      get: function() {
        return this._paddingOverrideEnabled = !0, this.scale.paddingInner;
      },
      set: function(t) {
        this._paddingOverrideEnabled = !0, this.scale.paddingInner = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "paddingOuter", {
      get: function() {
        return this.scale.paddingOuter;
      },
      set: function(t) {
        this.scale.paddingOuter = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.normaliseDataDomain = function(t) {
      var i, r, n, s, a = {};
      try {
        for (var l = Aj(t), c = l.next(); !c.done; c = l.next()) {
          var d = c.value;
          (n = a[s = String(d)]) !== null && n !== void 0 || (a[s] = d);
        }
      } catch (u) {
        i = { error: u };
      } finally {
        try {
          c && !c.done && (r = l.return) && r.call(l);
        } finally {
          if (i)
            throw i.error;
        }
      }
      return Object.values(a);
    }, e.prototype.calculateDomain = function() {
      if (!this._paddingOverrideEnabled) {
        var t = this.boundSeries, i = t.map(function(r) {
          var n;
          return (n = r.getBandScalePadding) === null || n === void 0 ? void 0 : n.call(r);
        }).filter(function(r) {
          return r != null;
        });
        i.length > 0 && (this.scale.paddingInner = Math.min.apply(Math, pE([], hE(i.map(function(r) {
          return r.inner;
        })))), this.scale.paddingOuter = Math.max.apply(Math, pE([], hE(i.map(function(r) {
          return r.outer;
        })))));
      }
      return o.prototype.calculateDomain.call(this);
    }, e.className = "CategoryAxis", e.type = "category", Pj([
      A(le(0, 1))
    ], e.prototype, "groupPaddingInner", void 0), e;
  }(Um)
), iO = (
  /** @class */
  function() {
    function o(e, t, i) {
      e === void 0 && (e = ""), i === void 0 && (i = 0), this.x = 0, this.y = 0, this.subtreeLeft = NaN, this.subtreeRight = NaN, this.screenX = 0, this.screenY = 0, this.children = [], this.leafCount = 0, this.prelim = 0, this.mod = 0, this.ancestor = this, this.change = 0, this.shift = 0, this.label = e, this.parent = t, this.depth = t ? t.depth + 1 : 0, this.number = i;
    }
    return o.prototype.getLeftSibling = function() {
      return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : void 0;
    }, o.prototype.getLeftmostSibling = function() {
      return this.number > 0 && this.parent ? this.parent.children[0] : void 0;
    }, o.prototype.nextLeft = function() {
      return this.children ? this.children[0] : this.thread;
    }, o.prototype.nextRight = function() {
      return this.children ? this.children[this.children.length - 1] : this.thread;
    }, o.prototype.getSiblings = function() {
      var e = this;
      return this.parent ? this.parent.children.filter(function(t, i) {
        return i !== e.number;
      }) : [];
    }, o;
  }()
);
function Mj(o, e) {
  e === void 0 && (e = !0);
  var t = new iO(), i = 0;
  return e && o.forEach(function(r) {
    return i = Math.max(i, r.labels.length);
  }), o.forEach(function(r) {
    if (e)
      for (; r.labels.length < i; )
        r.labels.unshift("");
    _j(t, r);
  }), t;
}
function _j(o, e) {
  var t = e.labels.slice().reverse(), i = t.length - 1;
  t.forEach(function(r, n) {
    var s = o.children, a = s.find(function(d) {
      return d.label === r;
    }), l = n !== i;
    if (a && l)
      o = a;
    else {
      var c = new iO(r, o);
      c.number = s.length, s.push(c), l && (o = c);
    }
  });
}
function Ij(o, e, t) {
  var i = e.number - o.number, r = t / i;
  e.change -= r, e.shift += t, o.change += r, e.prelim += t, e.mod += t;
}
function Fj(o, e, t) {
  return e.getSiblings().indexOf(o.ancestor) >= 0 ? o.ancestor : t;
}
function Lj(o) {
  var e = o.children;
  if (e)
    for (var t = 0, i = 0, r = e.length - 1; r >= 0; r--) {
      var n = e[r];
      n.prelim += t, n.mod += t, i += n.change, t += n.shift + i;
    }
}
function Nj(o, e, t) {
  var i = o.getLeftSibling();
  if (i) {
    for (var r = o, n = o, s = i, a = n.getLeftmostSibling(), l = n.mod, c = r.mod, d = s.mod, u = a.mod; s.nextRight() && n.nextLeft(); ) {
      s = s.nextRight(), n = n.nextLeft(), a = a.nextLeft(), r = r.nextRight(), r.ancestor = o;
      var h = s.prelim + d - (n.prelim + l) + t;
      h > 0 && (Ij(Fj(s, o, e), o, h), l += h, c += h), d += s.mod, l += n.mod, u += a.mod, c += r.mod;
    }
    s.nextRight() && !r.nextRight() ? (r.thread = s.nextRight(), r.mod += d - c) : (n.nextLeft() && !a.nextLeft() && (a.thread = n.nextLeft(), a.mod += l - u), e = o);
  }
  return e;
}
function rO(o, e) {
  var t = o.children;
  if (t.length) {
    var i = t[0];
    t.forEach(function(s) {
      rO(s, e), i = Nj(s, i, e);
    }), Lj(o);
    var r = (t[0].prelim + t[t.length - 1].prelim) / 2, n = o.getLeftSibling();
    n ? (o.prelim = n.prelim + e, o.mod = o.prelim - r) : o.prelim = r;
  } else {
    var n = o.getLeftSibling();
    o.prelim = n ? n.prelim + e : 0;
  }
}
var fE = (
  /** @class */
  function() {
    function o() {
      this.top = 1 / 0, this.right = -1 / 0, this.bottom = -1 / 0, this.left = 1 / 0;
    }
    return o.prototype.update = function(e, t) {
      var i = t(e), r = i.x, n = i.y;
      r > this.right && (this.right = r), r < this.left && (this.left = r), n > this.bottom && (this.bottom = n), n < this.top && (this.top = n);
    }, o;
  }()
);
function nO(o, e, t) {
  o.x = o.prelim + e, o.y = o.depth, t.update(o), o.children.forEach(function(i) {
    return nO(i, e + o.mod, t);
  });
}
function oO(o) {
  var e = o.children, t = 0;
  e.forEach(function(i) {
    oO(i), i.children.length ? t += i.leafCount : t++;
  }), o.leafCount = t, e.length ? (o.subtreeLeft = e[0].subtreeLeft, o.subtreeRight = e[o.children.length - 1].subtreeRight, o.x = (o.subtreeLeft + o.subtreeRight) / 2) : (o.subtreeLeft = o.x, o.subtreeRight = o.x);
}
function Gj(o) {
  var e = new kj();
  return rO(o, 1), nO(o, -o.prelim, e), oO(o), e;
}
var kj = (
  /** @class */
  function() {
    function o() {
      this.dimensions = new fE(), this.leafCount = 0, this.nodes = [], this.leafNodes = [], this.nonLeafNodes = [], this.depth = 0;
    }
    return o.prototype.update = function(e) {
      this.dimensions.update(e, function(t) {
        return { x: t.x, y: t.y };
      }), e.children.length ? this.nonLeafNodes.push(e) : (this.leafCount++, this.leafNodes.push(e)), e.depth > this.depth && (this.depth = e.depth), this.nodes.push(e);
    }, o.prototype.resize = function(e, t, i, r, n) {
      i === void 0 && (i = 0), r === void 0 && (r = 0), n === void 0 && (n = !1);
      var s = this.leafCount - 1, a = this.depth, l = this.dimensions, c = 1, d = 1;
      if (e > 0 && s) {
        var u = (l.right - l.left) / s, h = e / s;
        c = h / u, n && (c = -c);
      }
      if (t > 0 && a) {
        var p = (l.bottom - l.top) / a, f = t / a;
        d = f / p;
      }
      var g = new fE();
      this.nodes.forEach(function(m) {
        m.screenX = m.x * c, m.screenY = m.y * d, g.update(m, function(C) {
          return { x: C.screenX, y: C.screenY };
        });
      });
      var v = -g.left, y = -g.top;
      this.nodes.forEach(function(m) {
        m.screenX += v + i, m.screenY += y + r;
      });
    }, o;
  }()
), sO = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), aO = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, Vj = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, Bj = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, Hj = (
  /** @class */
  function(o) {
    sO(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.grid = !1, t;
    }
    return aO([
      A(ht)
    ], e.prototype, "grid", void 0), e;
  }(KD)
), uv = (
  /** @class */
  function(o) {
    sO(e, o);
    function e(t) {
      var i = o.call(this, t, new $n()) || this;
      i.tickScale = new $n(), i.translation = {
        x: 0,
        y: 0
      }, i.line = new YD(), i.label = new Hj(), i.labelColor = "rgba(87, 87, 87, 1)", i.includeInvisibleDomains = !0;
      var r = i, n = r.tickLineGroup, s = r.tickLabelGroup, a = r.gridLineGroup, l = r.tickScale, c = r.scale;
      return c.paddingOuter = 0.1, c.paddingInner = c.paddingOuter * 2, i.range = c.range.slice(), i.refreshScale(), l.paddingInner = 1, l.paddingOuter = 0, i.gridLineSelection = Et.select(a, Qt), i.axisLineSelection = Et.select(n, Qt), i.separatorSelection = Et.select(n, Qt), i.labelSelection = Et.select(s, ut), i;
    }
    return e.prototype.updateRange = function() {
      var t = this, i = t.range, r = t.visibleRange, n = t.scale, s = (i[1] - i[0]) / (r[1] - r[0]), a = s * r[0], l = i[0] - a;
      this.tickScale.range = n.range = [l, l + s], this.resizeTickTree();
    }, e.prototype.resizeTickTree = function() {
      var t, i = this.scale, r = i.domain.length ? [i.convert(i.domain[0]), i.convert(i.domain[i.domain.length - 1])] : i.range, n = this.tickTreeLayout, s = this.lineHeight;
      n && n.resize(Math.abs(r[1] - r[0]), n.depth * s, (Math.min(r[0], r[1]) || 0) + ((t = i.bandwidth) !== null && t !== void 0 ? t : 0) / 2, -n.depth * s, r[1] - r[0] < 0);
    }, Object.defineProperty(e.prototype, "lineHeight", {
      get: function() {
        return this.label.fontSize * 1.5;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "gridLength", {
      get: function() {
        return this._gridLength;
      },
      /**
       * The length of the grid. The grid is only visible in case of a non-zero value.
       */
      set: function(t) {
        (this._gridLength && !t || !this._gridLength && t) && (this.gridLineSelection.clear(), this.labelSelection.clear()), this._gridLength = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.calculateDomain = function() {
      var t, i, r = this, n = r.direction, s = r.boundSeries, a = [], l = void 0;
      s.filter(function(u) {
        return u.visible;
      }).forEach(function(u) {
        if (n === de.X)
          if (l === void 0) {
            var h = u.getDomain(n);
            a.push(h), l = typeof h[0] == "number";
          } else
            l && a.push(u.getDomain(n));
        else
          a.push(u.getDomain(n));
      });
      var c = (t = new Array()).concat.apply(t, Bj([], Vj(a))), d = (i = Uo(c)) !== null && i !== void 0 ? i : c;
      this.dataDomain = this.normaliseDataDomain(d), this.scale.domain = this.dataDomain;
    }, e.prototype.normaliseDataDomain = function(t) {
      var i = t.filter(function(s, a, l) {
        return l.indexOf(s) === a;
      }), r = Mj(i);
      this.tickTreeLayout = Gj(r);
      var n = i.slice();
      return n.push(""), this.tickScale.domain = n, this.resizeTickTree(), i;
    }, e.prototype.update = function(t) {
      var i = this;
      this.updateDirection(), this.calculateDomain(), this.updateRange();
      var r = this, n = r.scale, s = r.label, a = r.label.parallel, l = r.moduleCtx.callbackCache, c = r.tickScale, d = r.range, u = r.title, h = r.title, p = h === void 0 ? {} : h, f = p.formatter, g = f === void 0 ? function(J) {
        return J.defaultValue;
      } : f, v = r._titleCaption, y = n.range[0], m = n.range[1], C = Math.abs(m - y), R = C / n.domain.length || 0, E = xr(this.rotation), b = Math.abs(Math.cos(E)) < 1e-8, T = s.getSideFlag();
      this.updatePosition({ rotation: E, sideFlag: T }), v.node.visible = !1;
      var D = this.lineHeight, P = this.tickTreeLayout, O = n.ticks(), M = P ? P.nodes : [], _ = P ? P.depth > 1 : !1, F = c.ticks(), I = ow({
        rotation: s.rotation,
        parallel: a,
        regularFlipRotation: Vi(E - Math.PI / 2),
        parallelFlipRotation: Vi(E)
      }), G = I.defaultRotation, k = I.configuredRotation, N = I.parallelFlipFlag, W = this.gridLineSelection.update(this.gridLength ? F : []), j = this.labelSelection.update(M), K = s.formatter, $ = /* @__PURE__ */ new Map(), ae = 0;
      j.each(function(J, ge, Me) {
        var $e;
        J.fontStyle = s.fontStyle, J.fontWeight = s.fontWeight, J.fontSize = s.fontSize, J.fontFamily = s.fontFamily, J.fill = s.color, J.textBaseline = N === -1 ? "bottom" : "hanging", J.textAlign = "center", J.translationX = ge.screenY - s.fontSize * 0.25, J.translationY = ge.screenX, Me === 0 ? u != null && u.enabled && O.length > 0 ? (J.visible = !0, J.text = l.call(g, i.getTitleFormatterParams()), J.fontSize = u.fontSize, J.fontStyle = u.fontStyle, J.fontWeight = u.fontWeight, J.fontFamily = u.fontFamily, J.textBaseline = "hanging") : J.visible = !1 : K ? (J.text = ($e = l.call(K, {
          value: String(ge.label),
          index: Me
        })) !== null && $e !== void 0 ? $e : String(ge.label), J.visible = ge.screenX >= d[0] && ge.screenX <= d[1]) : (J.text = String(ge.label), J.visible = ge.screenX >= d[0] && ge.screenX <= d[1]);
        var At = J.computeBBox();
        $.set(J.id, At), At.width > ae && (ae = At.width);
      });
      var ee = T * s.padding, ne = this.label.grid, Y = [];
      j.each(function(J, ge, Me) {
        if (J.x = ee, J.rotationCenterX = ee, ge.children.length) {
          J.translationX -= ae - D + i.label.padding;
          var At = ge.leafCount * R, $e = $.get(J.id);
          $e && $e.width > At ? J.visible = !1 : b ? J.rotation = G : J.rotation = -Math.PI / 2;
        } else {
          J.rotation = k, J.textAlign = "end", J.textBaseline = "middle";
          var $e = $.get(J.id);
          $e && $e.height > R && (J.visible = !1);
        }
        if (ge.parent && _) {
          var di = ge.children.length ? ge.screenX - ge.leafCount * R / 2 : ge.screenX - R / 2;
          if (!ge.children.length)
            (ge.number !== ge.children.length - 1 || ne) && Y.push({
              y: di,
              x1: 0,
              x2: -ae - i.label.padding * 2,
              toString: function() {
                return String(Me);
              }
            });
          else {
            var Rn = -ae - i.label.padding * 2 + ge.screenY;
            Y.push({
              y: di,
              x1: Rn + D,
              x2: Rn,
              toString: function() {
                return String(Me);
              }
            });
          }
        }
      });
      var te = 0;
      Y.forEach(function(J) {
        return te = Math.min(te, J.x2);
      }), Y.push({
        y: Math.max(y, m),
        x1: 0,
        x2: te,
        toString: function() {
          return String(Y.length);
        }
      });
      var se = this.separatorSelection.update(Y), he = 1e-7;
      se.each(function(J, ge) {
        J.x1 = ge.x1, J.x2 = ge.x2, J.y1 = ge.y, J.y2 = ge.y, J.visible = ge.y >= d[0] - he && ge.y <= d[1] + he, J.stroke = i.tick.color, J.fill = void 0, J.strokeWidth = 1;
      }), this.gridLineSelection = W, this.labelSelection = j;
      for (var be = P ? P.depth + 1 : 1, ye = [], Xe = 0; Xe < be; Xe++)
        ye.push(Xe);
      var Je = this.axisLineSelection.update(ye);
      if (Je.each(function(J, ge, Me) {
        var $e = Me > 0 ? -ae - i.label.padding * 2 - (Me - 1) * D : 0;
        J.x1 = $e, J.x2 = $e, J.y1 = d[0], J.y2 = d[1], J.strokeWidth = i.line.width, J.stroke = i.line.color, J.visible = O.length > 0 && (Me === 0 || ne && _);
      }), this.gridLength) {
        var We = this.gridStyle, Ue = We.length;
        W.each(function(J, ge, Me) {
          var $e = Math.round(c.convert(ge));
          J.x1 = 0, J.x2 = -T * i.gridLength, J.y1 = $e, J.y2 = $e, J.visible = $e >= d[0] && $e <= d[1];
          var At = We[Me % Ue];
          J.stroke = At.stroke, J.strokeWidth = i.tick.width, J.lineDash = At.lineDash, J.fill = void 0;
        });
      }
      return t;
    }, e.className = "GroupedCategoryAxis", e.type = "groupedCategory", aO([
      A(St)
    ], e.prototype, "labelColor", void 0), e;
  }(Um)
), Wj = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Mh = function() {
  return Mh = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, Mh.apply(this, arguments);
}, jj = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, Uj = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, gE = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, eC = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, $j = ["top", "right", "bottom", "left"], lO = (
  /** @class */
  function(o) {
    Wj(e, o);
    function e(t, i, r) {
      t === void 0 && (t = window.document);
      var n = o.call(this, t, i, r) || this;
      return n.paired = !0, n._lastAxisWidths = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      }, n._lastVisibility = {
        crossLines: !0,
        series: !0
      }, n;
    }
    return e.prototype.performLayout = function() {
      return jj(this, void 0, void 0, function() {
        var t, i, r, n, s, a, l, c, d, u, h;
        return Uj(this, function(p) {
          switch (p.label) {
            case 0:
              return [4, o.prototype.performLayout.call(this)];
            case 1:
              return t = p.sent(), i = this.updateAxes(t), r = i.seriesRect, n = i.visibility, s = i.clipSeries, this.seriesRoot.visible = n.series, this.seriesRect = r, this.seriesRoot.translationX = Math.floor(r.x), this.seriesRoot.translationY = Math.floor(r.y), a = this, l = a.seriesRoot, c = a.seriesAreaPadding, d = r.clone().grow({
                top: c.top,
                right: c.right,
                bottom: c.bottom,
                left: c.left
              }), u = 20, h = d.clone().grow(u), this.hoverRect = h, this.layoutService.dispatchLayoutComplete({
                type: "layout-complete",
                chart: { width: this.scene.width, height: this.scene.height },
                series: { rect: r, paddedRect: d, hoverRect: h, visible: n.series },
                axes: this.axes.map(function(f) {
                  return Mh({ id: f.id }, f.getLayoutState());
                })
              }), s ? l.setClipRectInGroupCoordinateSpace(r) : l.setClipRectInGroupCoordinateSpace(), [2, t];
          }
        });
      });
    }, e.prototype.updateAxes = function(t) {
      var i, r, n, s = Mh({}, this._lastAxisWidths), a = Mh({}, this._lastVisibility), l = new Set(this._axes.map(function(E) {
        return E.position;
      }));
      try {
        for (var c = gE(Object.keys(s)), d = c.next(); !d.done; d = c.next()) {
          var u = d.value;
          l.has(u) || delete s[u];
        }
      } catch (E) {
        i = { error: E };
      } finally {
        try {
          d && !d.done && (r = c.return) && r.call(c);
        } finally {
          if (i)
            throw i.error;
        }
      }
      var h = function(E, b) {
        return Object.keys(E).some(function(T) {
          return s[T] == null;
        }) ? !1 : a.crossLines === b.crossLines && a.series === b.series && // Check for existing axis positions and equality.
        Object.entries(s).every(function(T) {
          var D = eC(T, 2), P = D[0], O = D[1], M = E[P];
          return O != null || M != null ? O === M : !0;
        });
      }, p = function(E) {
        return Object.entries(E).reduce(function(b, T) {
          var D = eC(T, 2), P = D[0], O = D[1];
          return O && Math.abs(O) === 1 / 0 && (O = 0), b[P] = O != null ? Math.ceil(O) : O, b;
        }, {});
      }, f = {}, g = {}, v = !1, y = (n = this.seriesRect) === null || n === void 0 ? void 0 : n.clone(), m = 0;
      do {
        Object.assign(s, f), Object.assign(a, g);
        var C = this.updateAxesPass(s, t.clone(), y);
        if (f = p(C.axisWidths), g = C.visibility, v = C.clipSeries, y = C.seriesRect, m++ > 10) {
          pe.warn("unable to find stable axis layout.");
          break;
        }
      } while (!h(f, g));
      var R = 5;
      return this.axes.forEach(function(E) {
        if (E.setCrossLinesVisible(a.crossLines), !!y)
          switch (E.clipGrid(y.x, y.y, y.width + R, y.height + R), E.position) {
            case "left":
            case "right":
              E.clipTickLines(t.x, y.y, t.width + R, y.height + R);
              break;
            case "top":
            case "bottom":
              E.clipTickLines(y.x, t.y, y.width + R, t.height + R);
              break;
          }
      }), this._lastAxisWidths = s, this._lastVisibility = a, { seriesRect: y, visibility: a, clipSeries: v };
    }, e.prototype.updateAxesPass = function(t, i, r) {
      var n = this, s = this.axes, a = {}, l = {}, c = {
        series: !0,
        crossLines: !0
      }, d = !1, u = {}, h = this.applySeriesPadding(i), p = r ? this.buildCrossLinePadding(t) : {}, f = this.buildAxisBound(h, t, p, c), g = this.buildSeriesRect(f, t);
      return s.forEach(function(v) {
        var y, m, C = v.position, R = C === void 0 ? "left" : C, E = n.calculateAxisDimensions({
          axis: v,
          seriesRect: g,
          paddedBounds: h,
          axisWidths: t,
          newAxisWidths: l,
          primaryTickCounts: u,
          clipSeries: d,
          addInterAxisPadding: ((y = a[R]) !== null && y !== void 0 ? y : 0) > 0
        }), b = E.clipSeries, T = E.axisThickness, D = E.axisOffset;
        a[R] = ((m = a[R]) !== null && m !== void 0 ? m : 0) + 1, d = d || b, n.positionAxis({
          axis: v,
          axisBound: f,
          axisOffset: D,
          axisThickness: T,
          axisWidths: t,
          primaryTickCounts: u,
          seriesRect: g
        });
      }), { clipSeries: d, seriesRect: g, axisWidths: l, visibility: c };
    }, e.prototype.buildCrossLinePadding = function(t) {
      var i, r, n, s = {};
      this.axes.forEach(function(p) {
        p.crossLines && p.crossLines.forEach(function(f) {
          f.calculatePadding(s);
        });
      });
      try {
        for (var a = gE(Object.entries(s)), l = a.next(); !l.done; l = a.next()) {
          var c = eC(l.value, 2), d = c[0], u = c[1], h = u === void 0 ? 0 : u;
          s[d] = Math.max(h - ((n = t[d]) !== null && n !== void 0 ? n : 0), 0);
        }
      } catch (p) {
        i = { error: p };
      } finally {
        try {
          l && !l.done && (r = a.return) && r.call(a);
        } finally {
          if (i)
            throw i.error;
        }
      }
      return s;
    }, e.prototype.applySeriesPadding = function(t) {
      var i = this, r = t.clone(), n = this.axes.slice().reverse();
      return $j.forEach(function(s) {
        var a = i.seriesAreaPadding[s], l = n.find(function(c) {
          return c.position === s;
        });
        l ? l.seriesAreaPadding = a : r.shrink(a, s);
      }), r;
    }, e.prototype.buildAxisBound = function(t, i, r, n) {
      var s, a, l, c, d = t.clone(), u = r.top, h = u === void 0 ? 0 : u, p = r.right, f = p === void 0 ? 0 : p, g = r.bottom, v = g === void 0 ? 0 : g, y = r.left, m = y === void 0 ? 0 : y, C = m + f, R = h + v, E = ((s = i.left) !== null && s !== void 0 ? s : 0) + ((a = i.right) !== null && a !== void 0 ? a : 0) + C, b = ((l = i.top) !== null && l !== void 0 ? l : 0) + ((c = i.bottom) !== null && c !== void 0 ? c : 0) + R;
      return d.width <= E || d.height <= b ? (n.crossLines = !1, n.series = !1, d) : (d.x += m, d.y += h, d.width -= C, d.height -= R, d);
    }, e.prototype.buildSeriesRect = function(t, i) {
      var r = t.clone(), n = i.top, s = i.bottom, a = i.left, l = i.right;
      return r.x += a != null ? a : 0, r.y += n != null ? n : 0, r.width -= (a != null ? a : 0) + (l != null ? l : 0), r.height -= (n != null ? n : 0) + (s != null ? s : 0), r.width = Math.max(0, r.width), r.height = Math.max(0, r.height), r;
    }, e.prototype.clampToOutsideSeriesRect = function(t, i, r, n) {
      var s = t.x, a = t.y, l = t.width, c = t.height, d = [s, a, s + l, a + c], u = n === 1 ? Math.min : Math.max, h = d[(r === "x" ? 0 : 1) + (n === 1 ? 0 : 2)];
      return u(i, h);
    }, e.prototype.calculateAxisDimensions = function(t) {
      var i, r, n, s, a, l = t.axis, c = t.seriesRect, d = t.paddedBounds, u = t.axisWidths, h = t.newAxisWidths, p = t.primaryTickCounts, f = t.addInterAxisPadding, g = t.clipSeries, v = l.position, y = v === void 0 ? "left" : v, m = l.direction, C = function(k) {
        return k instanceof Qd || k instanceof uv ? [0, c.height] : [c.height, 0];
      }, R = (i = h[y]) !== null && i !== void 0 ? i : 0;
      switch (y) {
        case "top":
        case "bottom":
          l.range = [0, c.width], l.gridLength = c.height;
          break;
        case "right":
        case "left":
          l.range = C(l), l.gridLength = c.width;
          break;
      }
      var E = this.zoomManager.getAxisZoom(l.id), b = E != null ? E : {}, T = b.min, D = T === void 0 ? 0 : T, P = b.max, O = P === void 0 ? 1 : P;
      l.visibleRange = [D, O], !g && (l.visibleRange[0] > 0 || l.visibleRange[1] < 1) && (g = !0);
      var M = l.nice ? p[m] : void 0, _ = 0.3;
      l.thickness != null && l.thickness > 0 ? l.maxThickness = l.thickness : m === de.Y ? l.maxThickness = d.width * _ : l.maxThickness = d.height * _, M = l.update(M), p[m] = (r = p[m]) !== null && r !== void 0 ? r : M;
      var F = 0;
      if (l.thickness != null && l.thickness > 0)
        F = l.thickness;
      else {
        var I = l.computeBBox();
        F = m === de.X ? I.height : I.width;
      }
      var G = 15;
      return f && (F += G), F = Math.ceil(F), h[y] = ((n = h[y]) !== null && n !== void 0 ? n : 0) + F, l.gridPadding = ((s = u[y]) !== null && s !== void 0 ? s : 0) - ((a = h[y]) !== null && a !== void 0 ? a : 0), { clipSeries: g, axisThickness: F, axisOffset: R };
    }, e.prototype.positionAxis = function(t) {
      var i, r, n, s, a = t.axis, l = t.axisBound, c = t.axisWidths, d = t.seriesRect, u = t.axisOffset, h = t.axisThickness, p = a.position;
      switch (p) {
        case "top":
          a.translation.x = l.x + ((i = c.left) !== null && i !== void 0 ? i : 0), a.translation.y = this.clampToOutsideSeriesRect(d, l.y + 1 + u + h, "y", 1);
          break;
        case "bottom":
          a.translation.x = l.x + ((r = c.left) !== null && r !== void 0 ? r : 0), a.translation.y = this.clampToOutsideSeriesRect(d, l.y + l.height + 1 - h - u, "y", -1);
          break;
        case "left":
          a.translation.y = l.y + ((n = c.top) !== null && n !== void 0 ? n : 0), a.translation.x = this.clampToOutsideSeriesRect(d, l.x + u + h, "x", 1);
          break;
        case "right":
          a.translation.y = l.y + ((s = c.top) !== null && s !== void 0 ? s : 0), a.translation.x = this.clampToOutsideSeriesRect(d, l.x + l.width - h - u, "x", -1);
          break;
      }
      a.updatePosition({ rotation: xr(a.rotation), sideFlag: a.label.getSideFlag() });
    }, e.className = "CartesianChart", e.type = "cartesian", e;
  }(tw)
), zj = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), vE = (
  /** @class */
  function(o) {
    zj(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.shape = "polygon", t;
    }
    return e.prototype.computeLabelsBBox = function(t, i) {
      return null;
    }, e;
  }(XD)
), Kj = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Yj = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, Xj = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, mE = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, yE = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, qj = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, cO = (
  /** @class */
  function(o) {
    Kj(e, o);
    function e(t, i, r) {
      t === void 0 && (t = window.document);
      var n = o.call(this, t, i, r) || this;
      return n.padding = new tv(40), n;
    }
    return e.prototype.performLayout = function() {
      return Yj(this, void 0, void 0, function() {
        var t, i, r, n;
        return Xj(this, function(s) {
          switch (s.label) {
            case 0:
              return [4, o.prototype.performLayout.call(this)];
            case 1:
              return t = s.sent(), i = t.clone(), this.computeSeriesRect(t), this.computeCircle(t), this.axes.forEach(function(a) {
                return a.update();
              }), r = 20, n = t.clone().grow(r), this.hoverRect = n, this.layoutService.dispatchLayoutComplete({
                type: "layout-complete",
                chart: { width: this.scene.width, height: this.scene.height },
                series: { rect: i, paddedRect: t, hoverRect: n, visible: !0 },
                axes: []
              }), [2, t];
          }
        });
      });
    }, e.prototype.updateAxes = function(t, i, r) {
      var n;
      this.axes.forEach(function(c) {
        var d;
        if (c.direction === de.X) {
          var u = xr((d = c.rotation) !== null && d !== void 0 ? d : 0);
          c.range = [-Math.PI / 2 + u, 3 * Math.PI / 2 + u], c.gridLength = r, c.translation.x = t, c.translation.y = i;
        } else
          c.direction === de.Y && (c.range = [r, 0], c.translation.x = t, c.translation.y = i - r);
        c.updateScale();
      });
      var s = this.axes.find(function(c) {
        return c.direction === de.X;
      }), a = s == null ? void 0 : s.scale, l = (n = a == null ? void 0 : a.ticks) === null || n === void 0 ? void 0 : n.call(a).map(function(c) {
        return a.convert(c);
      });
      this.axes.filter(function(c) {
        return c instanceof vE;
      }).forEach(function(c) {
        return c.gridAngles = l;
      });
    }, e.prototype.computeSeriesRect = function(t) {
      var i = this.seriesAreaPadding;
      t.shrink(i.left, "left"), t.shrink(i.top, "top"), t.shrink(i.right, "right"), t.shrink(i.bottom, "bottom"), this.seriesRect = t;
    }, e.prototype.computeCircle = function(t) {
      var i = this, r = this.series.filter(function(h) {
        return h instanceof QD;
      }), n = this.axes.filter(function(h) {
        return h instanceof vE;
      }), s = function(h, p, f) {
        i.updateAxes(h, p, f), r.forEach(function(m) {
          m.centerX = h, m.centerY = p, m.radius = f;
        });
        var g = r.filter(function(m) {
          return m instanceof eO;
        });
        if (g.length > 1) {
          var v = g.map(function(m) {
            var C = m.getInnerRadius();
            return { series: m, innerRadius: C };
          }).sort(function(m, C) {
            return m.innerRadius - C.innerRadius;
          });
          v[v.length - 1].series.surroundingRadius = void 0;
          for (var y = 0; y < v.length - 1; y++)
            v[y].series.surroundingRadius = v[y + 1].innerRadius;
        }
      }, a = t.x + t.width / 2, l = t.y + t.height / 2, c = Math.max(0, Math.min(t.width, t.height) / 2), d = c;
      s(a, l, d);
      var u = function(h) {
        var p, f, g = h === void 0 ? {} : h, v = g.hideWhenNecessary, y = v === void 0 ? !1 : v, m = [];
        try {
          for (var C = qj(yE(yE([], mE(n)), mE(r))), R = C.next(); !R.done; R = C.next()) {
            var E = R.value, b = E.computeLabelsBBox({ hideWhenNecessary: y }, t);
            b && m.push(b);
          }
        } catch (P) {
          p = { error: P };
        } finally {
          try {
            R && !R.done && (f = C.return) && f.call(C);
          } finally {
            if (p)
              throw p.error;
          }
        }
        if (m.length === 0) {
          s(a, l, c);
          return;
        }
        var T = nt.merge(m), D = i.refineCircle(T, d, t);
        s(D.centerX, D.centerY, D.radius), D.radius !== d && (d = D.radius);
      };
      return u(), u(), u(), u({ hideWhenNecessary: !0 }), u({ hideWhenNecessary: !0 }), { radius: d, centerX: a, centerY: l };
    }, e.prototype.refineCircle = function(t, i, r) {
      var n = 0.5, s = -i, a = -i, l = i, c = i, d = Math.max(0, s - t.x), u = Math.max(0, a - t.y), h = Math.max(0, t.x + t.width - l), p = Math.max(0, t.y + t.height - c), f = r.width - d - h, g = r.height - u - p, v = Math.min(f, g) / 2, y = n * r.width / 2, m = n * r.height / 2, C = Math.min(y, m);
      if (v < C) {
        v = C;
        var R = d + h, E = u + p;
        if (2 * v + E > r.height) {
          var b = r.height - 2 * v;
          Math.min(u, p) * 2 > b ? (u = b / 2, p = b / 2) : u > p ? u = b - p : p = b - u;
        }
        if (2 * v + R > r.width) {
          var T = r.width - 2 * v;
          Math.min(d, h) * 2 > T ? (d = T / 2, h = T / 2) : d > h ? d = T - h : h = T - d;
        }
      }
      var D = d + 2 * v + h, P = u + 2 * v + p;
      return {
        centerX: r.x + (r.width - D) / 2 + d + v,
        centerY: r.y + (r.height - P) / 2 + u + v,
        radius: v
      };
    }, e.className = "PolarChart", e.type = "polar", e;
  }(tw)
), Zj = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), CE = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, SE = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, dO = (
  /** @class */
  function(o) {
    Zj(e, o);
    function e(t, i, r) {
      t === void 0 && (t = window.document);
      var n = o.call(this, t, i, r) || this;
      return n._data = {}, n;
    }
    return e.prototype.performLayout = function() {
      return CE(this, void 0, void 0, function() {
        var t, i, r, n, s, a, l = this;
        return SE(this, function(c) {
          switch (c.label) {
            case 0:
              return [4, o.prototype.performLayout.call(this)];
            case 1:
              return t = c.sent(), i = this.seriesAreaPadding, r = t.clone(), t.shrink(i.left, "left"), t.shrink(i.top, "top"), t.shrink(i.right, "right"), t.shrink(i.bottom, "bottom"), this.seriesRect = t, n = 20, s = t.clone().grow(n), this.hoverRect = s, this.seriesRoot.translationX = Math.floor(t.x), this.seriesRoot.translationY = Math.floor(t.y), [4, Promise.all(this.series.map(function(d) {
                return CE(l, void 0, void 0, function() {
                  return SE(this, function(u) {
                    switch (u.label) {
                      case 0:
                        return [4, d.update({ seriesRect: t })];
                      case 1:
                        return u.sent(), [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              }))];
            case 2:
              return c.sent(), a = this.seriesRoot, a.setClipRectInGroupCoordinateSpace(new nt(t.x, t.y, t.width, t.height)), this.layoutService.dispatchLayoutComplete({
                type: "layout-complete",
                chart: { width: this.scene.width, height: this.scene.height },
                series: { rect: r, paddedRect: t, hoverRect: s, visible: !0 },
                axes: []
              }), [2, t];
          }
        });
      });
    }, e.className = "HierarchyChart", e.type = "hierarchy", e;
  }(tw)
);
function Qj(o, e) {
  var t = Math.floor(o[0]), i = o[1];
  t = Jj(t, i, e);
  var r = t3(t, i, e), n = e - 1;
  i = t + n * r;
  var s = [t, i], a = e3(t, r, e);
  return [s, a];
}
function Jj(o, e, t) {
  var i = Math.abs(e - o) / (t - 1), r = Math.floor(Math.log10(i)), n = Math.pow(10, r);
  return Math.floor(o / n) * n;
}
function e3(o, e, t) {
  for (var i = Math.floor(Math.log10(e)), r = e > 0 && e < 1 ? Math.abs(i) : 0, n = Math.pow(10, r), s = new iw(r), a = 0; a < t; a++) {
    var l = o + e * a;
    s[a] = Math.round(l * n) / n;
  }
  return s;
}
function t3(o, e, t) {
  var i = t - 1, r = (e - o) / i;
  return i3(r);
}
function i3(o) {
  var e = Math.floor(Math.log10(o)), t = Math.pow(10, e), i = o / t * 10;
  return i > 0 && i <= 1 ? t / 10 : i > 1 && i <= 2 ? 2 * t / 10 : i > 1 && i <= 5 ? 5 * t / 10 : i > 5 && i <= 10 ? 10 * t / 10 : i > 10 && i <= 20 ? 20 * t / 10 : i > 20 && i <= 40 ? 40 * t / 10 : i > 40 && i <= 50 ? 50 * t / 10 : i > 50 && i <= 100 ? 100 * t / 10 : i;
}
var uO = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), XC = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, r3 = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, n3 = (
  /** @class */
  function(o) {
    uO(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.maxSpacing = NaN, t;
    }
    return XC([
      A(Os(Ca(1), ff("minSpacing"))),
      ba(NaN)
    ], e.prototype, "maxSpacing", void 0), e;
  }(sw)
), hv = (
  /** @class */
  function(o) {
    uO(e, o);
    function e(t, i) {
      i === void 0 && (i = new ri());
      var r = o.call(this, t, i) || this;
      return r.min = NaN, r.max = NaN, i.strictClampByDefault = !0, r;
    }
    return e.prototype.normaliseDataDomain = function(t) {
      var i = this, r = i.min, n = i.max;
      return zD(t, r, n);
    }, e.prototype.formatDatum = function(t) {
      return typeof t == "number" ? t.toFixed(2) : (pe.warnOnce("data contains Date objects which are being plotted against a number axis, please only use a number axis for numbers."), String(t));
    }, e.prototype.createTick = function() {
      return new n3();
    }, e.prototype.updateSecondaryAxisTicks = function(t) {
      if (this.dataDomain == null)
        throw new Error("AG Charts - dataDomain not calculated, cannot perform tick calculation.");
      var i = r3(Qj(this.dataDomain, t != null ? t : 0), 2), r = i[0], n = i[1];
      return this.scale.nice = !1, this.scale.domain = r, this.scale.update(), n;
    }, e.className = "NumberAxis", e.type = "number", XC([
      A(Os(Ca(), Vm("max"))),
      ba(NaN)
    ], e.prototype, "min", void 0), XC([
      A(Os(Ca(), ff("min"))),
      ba(NaN)
    ], e.prototype, "max", void 0), e;
  }(Um)
), o3 = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), bE = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
function wE() {
  var o = "expecting a non-zero Number";
  return Ee(function(e) {
    return typeof e == "number" && e !== 0;
  }, o);
}
var pv = (
  /** @class */
  function(o) {
    o3(e, o);
    function e(t) {
      var i = o.call(this, t, new $D()) || this;
      return i.min = NaN, i.max = NaN, i.scale.strictClampByDefault = !0, i;
    }
    return e.prototype.normaliseDataDomain = function(t) {
      var i, r = this, n = r.min, s = r.max;
      t.length > 2 && (t = (i = Uo(t)) !== null && i !== void 0 ? i : [NaN, NaN]), isNaN(n) || (t = [n, t[1]]), isNaN(s) || (t = [t[0], s]);
      var a = t[0] > t[1], l = t[0] < 0 && t[1] > 0, c = t[0] === 0 && t[1] === 0, d = a || l || c;
      return d && (t = [], l ? pe.warn("the data domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.") : c && pe.warn("the data domain has 0 extent, no data is rendered.")), t[0] === 0 && (t[0] = 1), t[1] === 0 && (t[1] = -1), t;
    }, Object.defineProperty(e.prototype, "base", {
      get: function() {
        return this.scale.base;
      },
      set: function(t) {
        this.scale.base = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.className = "LogAxis", e.type = "log", bE([
      A(Os(Ca(), Vm("max"), wE())),
      ba(NaN)
    ], e.prototype, "min", void 0), bE([
      A(Os(Ca(), ff("min"), wE())),
      ba(NaN)
    ], e.prototype, "max", void 0), e;
  }(hv)
), hO = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), qC = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, s3 = (
  /** @class */
  function(o) {
    hO(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.maxSpacing = NaN, t;
    }
    return qC([
      A(Os(Ca(1), ff("minSpacing"))),
      ba(NaN)
    ], e.prototype, "maxSpacing", void 0), e;
  }(sw)
), ZC = (
  /** @class */
  function(o) {
    hO(e, o);
    function e(t) {
      var i = o.call(this, t, new nw()) || this;
      i.datumFormat = "%m/%d/%y, %H:%M:%S", i.min = void 0, i.max = void 0;
      var r = i.scale;
      return r.strictClampByDefault = !0, i.refreshScale(), i.datumFormatter = r.tickFormat({
        specifier: i.datumFormat
      }), i;
    }
    return e.prototype.normaliseDataDomain = function(t) {
      var i, r = this, n = r.min, s = r.max;
      return typeof n == "number" && (n = new Date(n)), typeof s == "number" && (s = new Date(s)), t.length > 2 && (t = ((i = Uo(t)) !== null && i !== void 0 ? i : [0, 1e3]).map(function(a) {
        return new Date(a);
      })), n instanceof Date && (t = [n, t[1]]), s instanceof Date && (t = [t[0], s]), t[0] > t[1] && (t = []), t;
    }, e.prototype.createTick = function() {
      return new s3();
    }, e.prototype.onLabelFormatChange = function(t, i) {
      i ? o.prototype.onLabelFormatChange.call(this, t, i) : this.labelFormatter = this.scale.tickFormat({ ticks: t });
    }, e.prototype.formatDatum = function(t) {
      var i;
      return (i = this.moduleCtx.callbackCache.call(this.datumFormatter, t)) !== null && i !== void 0 ? i : String(t);
    }, e.prototype.calculatePadding = function(t, i) {
      return [0, 1];
    }, e.className = "TimeAxis", e.type = "time", qC([
      A(Os(b0, Vm("max")))
    ], e.prototype, "min", void 0), qC([
      A(Os(b0, ff("min")))
    ], e.prototype, "max", void 0), e;
  }(Um)
), gl, fv = (gl = {}, gl[hv.type] = hv, gl[Qd.type] = Qd, gl[ZC.type] = ZC, gl[uv.type] = uv, gl[pv.type] = pv, gl);
function a3(o, e) {
  fv[o] = e;
}
function l3(o, e) {
  var t = fv[o];
  if (t)
    return new t(e);
  throw new Error("AG Charts - unknown axis type: " + o);
}
var cw = {
  has: function(o) {
    return Object.prototype.hasOwnProperty.call(fv, o);
  },
  get axesTypes() {
    return Object.keys(fv);
  }
}, pO = {};
function EE(o, e) {
  pO[o] = e;
}
function c3(o) {
  var e;
  return (e = pO[o]) !== null && e !== void 0 ? e : {};
}
var d3 = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), so = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, u3 = ["circle", "cross", "diamond", "heart", "plus", "square", "triangle"], h3 = Ee(function(o) {
  return u3.includes(o) || Object.getPrototypeOf(o) === el;
}, "expecting a marker shape keyword such as 'circle', 'diamond' or 'square' or an object extending the Marker class"), p3 = (
  /** @class */
  function(o) {
    d3(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.enabled = !0, t.shape = pp, t.size = 6, t.maxSize = 30, t.domain = void 0, t.fill = void 0, t.stroke = void 0, t.strokeWidth = 1, t.fillOpacity = void 0, t.strokeOpacity = void 0, t;
    }
    return so([
      A(ht),
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "enabled", void 0), so([
      A(h3),
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "shape", void 0), so([
      A(le(0)),
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "size", void 0), so([
      A(le(0)),
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "maxSize", void 0), so([
      A(vD),
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "domain", void 0), so([
      A(St),
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "fill", void 0), so([
      A(St),
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "stroke", void 0), so([
      A(lt(0)),
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "strokeWidth", void 0), so([
      A(lt(0, 1)),
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "fillOpacity", void 0), so([
      A(lt(0, 1)),
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "strokeOpacity", void 0), e;
  }($b)
), _u = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), gv = function() {
  return gv = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, gv.apply(this, arguments);
}, fO = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, pr = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, fr = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, Xs = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, f3 = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, sg, ag, g3 = (sg = {}, sg[de.X] = ["xKey"], sg[de.Y] = ["yKey"], sg), v3 = (ag = {}, ag[de.X] = ["xName"], ag[de.Y] = ["yName"], ag), dw = (
  /** @class */
  function(o) {
    _u(e, o);
    function e(t, i, r, n, s) {
      var a = o.call(this, r, n, s) || this;
      return a.xKey = t, a.yKey = i, a;
    }
    return e;
  }(gf)
), $m = (
  /** @class */
  function(o) {
    _u(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.type = "nodeClick", t;
    }
    return e;
  }(dw)
), zm = (
  /** @class */
  function(o) {
    _u(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.type = "nodeDoubleClick", t;
    }
    return e;
  }(dw)
), m3 = (
  /** @class */
  function(o) {
    _u(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e;
  }(aw)
), mf = (
  /** @class */
  function(o) {
    _u(e, o);
    function e(t) {
      var i = o.call(this, gv(gv({}, t), { useSeriesGroupLayer: !0, directionKeys: g3, directionNames: v3 })) || this;
      i.legendItemName = void 0, i._contextNodeData = [], i.nodeDataDependencies = {}, i.highlightSelection = Et.select(i.highlightNode, function() {
        return i.opts.hasMarkers ? i.markerFactory() : i.nodeFactory();
      }), i.highlightLabelSelection = Et.select(i.highlightLabel, ut), i.subGroups = [], i.subGroupId = 0, i.datumSelectionGarbageCollection = !0;
      var r = t.pathsPerSeries, n = r === void 0 ? 1 : r, s = t.hasMarkers, a = s === void 0 ? !1 : s, l = t.hasHighlightedLabels, c = l === void 0 ? !1 : l, d = t.pathsZIndexSubOrderOffset, u = d === void 0 ? [] : d;
      return i.opts = { pathsPerSeries: n, hasMarkers: a, hasHighlightedLabels: c, pathsZIndexSubOrderOffset: u }, i.animationState = new m3("empty", {
        empty: {
          on: {
            update: {
              target: "ready",
              action: function(h) {
                return i.animateEmptyUpdateReady(h);
              }
            }
          }
        },
        ready: {
          on: {
            updateData: {
              target: "waiting",
              action: function() {
              }
            },
            update: {
              target: "ready",
              action: function(h) {
                return i.animateReadyUpdate(h);
              }
            },
            highlight: {
              target: "ready",
              action: function(h) {
                return i.animateReadyHighlight(h);
              }
            },
            highlightMarkers: {
              target: "ready",
              action: function(h) {
                return i.animateReadyHighlightMarkers(h);
              }
            },
            resize: {
              target: "ready",
              action: function(h) {
                return i.animateReadyResize(h);
              }
            }
          }
        },
        waiting: {
          on: {
            update: {
              target: "ready",
              action: function(h) {
                return i.animateWaitingUpdateReady(h);
              }
            }
          }
        }
      }), i;
    }
    return Object.defineProperty(e.prototype, "contextNodeData", {
      get: function() {
        var t;
        return (t = this._contextNodeData) === null || t === void 0 ? void 0 : t.slice();
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.addChartEventListeners = function() {
      var t = this, i, r;
      (i = this.ctx.chartEventManager) === null || i === void 0 || i.addListener("legend-item-click", function(n) {
        return t.onLegendItemClick(n);
      }), (r = this.ctx.chartEventManager) === null || r === void 0 || r.addListener("legend-item-double-click", function(n) {
        return t.onLegendItemDoubleClick(n);
      });
    }, e.prototype.destroy = function() {
      o.prototype.destroy.call(this), this._contextNodeData.splice(0, this._contextNodeData.length), this.subGroups.splice(0, this.subGroups.length);
    }, e.prototype.checkDomainXY = function(t, i, r, n) {
      var s = (r && dp(t) || !r && Zg(t)) && (n && dp(i) || !n && Zg(i));
      return s ? [t, i] : void 0;
    }, e.prototype.checkRangeXY = function(t, i, r, n) {
      return !isNaN(t) && !isNaN(i) && r.inRange(t) && n.inRange(i);
    }, e.prototype.update = function(t) {
      var i, r, n = t.seriesRect;
      return pr(this, void 0, void 0, function() {
        var s, a, l, c, d;
        return fr(this, function(u) {
          switch (u.label) {
            case 0:
              return s = this.visible, a = ((r = (i = this.ctx.highlightManager) === null || i === void 0 ? void 0 : i.getActiveHighlight()) !== null && r !== void 0 ? r : {}).series, l = a ? a === this : void 0, c = {
                seriesRectWidth: n == null ? void 0 : n.width,
                seriesRectHeight: n == null ? void 0 : n.height
              }, d = Sa(this.nodeDataDependencies, c) != null, d && (this.nodeDataDependencies = c, this.markNodeDataDirty()), [4, this.updateSelections(l, s)];
            case 1:
              return u.sent(), [4, this.updateNodes(l, s)];
            case 2:
              return u.sent(), d && this.animationState.transition("resize", {
                datumSelections: this.subGroups.map(function(h) {
                  var p = h.datumSelection;
                  return p;
                }),
                markerSelections: this.subGroups.map(function(h) {
                  var p = h.markerSelection;
                  return p;
                }),
                contextData: this._contextNodeData,
                paths: this.subGroups.map(function(h) {
                  var p = h.paths;
                  return p;
                })
              }), this.animationState.transition("update", {
                datumSelections: this.subGroups.map(function(h) {
                  var p = h.datumSelection;
                  return p;
                }),
                markerSelections: this.subGroups.map(function(h) {
                  var p = h.markerSelection;
                  return p;
                }),
                labelSelections: this.subGroups.map(function(h) {
                  var p = h.labelSelection;
                  return p;
                }),
                contextData: this._contextNodeData,
                paths: this.subGroups.map(function(h) {
                  var p = h.paths;
                  return p;
                }),
                seriesRect: n
              }), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.updateSelections = function(t, i) {
      var r;
      return pr(this, void 0, void 0, function() {
        var n, s = this;
        return fr(this, function(a) {
          switch (a.label) {
            case 0:
              return [4, this.updateHighlightSelection(t)];
            case 1:
              return a.sent(), i ? !this.nodeDataRefresh && !this.isPathOrSelectionDirty() ? [
                2
                /*return*/
              ] : this.nodeDataRefresh ? (this.nodeDataRefresh = !1, !((r = this.chart) === null || r === void 0) && r.debug && pe.debug("CartesianSeries.updateSelections() - calling createNodeData() for", this.id), n = this, [4, this.createNodeData()]) : [3, 4] : [
                2
                /*return*/
              ];
            case 2:
              return n._contextNodeData = a.sent(), [4, this.updateSeriesGroups()];
            case 3:
              a.sent(), a.label = 4;
            case 4:
              return [4, Promise.all(this.subGroups.map(function(l, c) {
                return s.updateSeriesGroupSelections(l, c);
              }))];
            case 5:
              return a.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.updateSeriesGroupSelections = function(t, i) {
      return pr(this, void 0, void 0, function() {
        var r, n, s, a, l, c, d, u, h;
        return fr(this, function(p) {
          switch (p.label) {
            case 0:
              return r = t.datumSelection, n = t.labelSelection, s = t.markerSelection, a = this._contextNodeData[i], l = a.nodeData, c = a.labelData, d = t, [4, this.updateDatumSelection({ nodeData: l, datumSelection: r, seriesIdx: i })];
            case 1:
              return d.datumSelection = p.sent(), u = t, [4, this.updateLabelSelection({ labelData: c, labelSelection: n, seriesIdx: i })];
            case 2:
              return u.labelSelection = p.sent(), s ? (h = t, [4, this.updateMarkerSelection({
                nodeData: l,
                markerSelection: s,
                seriesIdx: i
              })]) : [3, 4];
            case 3:
              h.markerSelection = p.sent(), p.label = 4;
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.nodeFactory = function() {
      return new we();
    }, e.prototype.markerFactory = function() {
      var t = Mu();
      return new t();
    }, e.prototype.updateSeriesGroups = function() {
      return pr(this, void 0, void 0, function() {
        var t, i, r, n, s, a, l, c, d, u, h, p, f, g, v, y = this;
        return fr(this, function(m) {
          if (t = this, i = t._contextNodeData, r = t.contentGroup, n = t.subGroups, s = t.opts, a = s.pathsPerSeries, l = s.hasMarkers, i.length === n.length)
            return [
              2
              /*return*/
            ];
          for (i.length < n.length && n.splice(i.length).forEach(function(C) {
            var R, E, b = C.dataNodeGroup, T = C.markerGroup, D = C.labelGroup, P = C.paths;
            r.removeChild(b), T && r.removeChild(T), D && r.removeChild(D);
            try {
              for (var O = Xs(P), M = O.next(); !M.done; M = O.next()) {
                var _ = M.value;
                r.removeChild(_);
              }
            } catch (F) {
              R = { error: F };
            } finally {
              try {
                M && !M.done && (E = O.return) && E.call(O);
              } finally {
                if (R)
                  throw R.error;
              }
            }
          }), c = i.length; c > n.length; ) {
            for (d = !1, u = this.subGroupId++, h = new we({
              name: this.id + "-series-sub" + u + "-dataNodes",
              layer: d,
              zIndex: kt.SERIES_LAYER_ZINDEX,
              zIndexSubOrder: this.getGroupZIndexSubOrder("data", u)
            }), p = l ? new we({
              name: this.id + "-series-sub" + this.subGroupId++ + "-markers",
              layer: d,
              zIndex: kt.SERIES_LAYER_ZINDEX,
              zIndexSubOrder: this.getGroupZIndexSubOrder("marker", u)
            }) : void 0, f = new we({
              name: this.id + "-series-sub" + this.subGroupId++ + "-labels",
              layer: d,
              zIndex: kt.SERIES_LABEL_ZINDEX,
              zIndexSubOrder: this.getGroupZIndexSubOrder("labels", u)
            }), r.appendChild(h), r.appendChild(f), p && r.appendChild(p), g = [], v = 0; v < a; v++)
              g[v] = new Zi(), g[v].zIndex = kt.SERIES_LAYER_ZINDEX, g[v].zIndexSubOrder = this.getGroupZIndexSubOrder("paths", v), r.appendChild(g[v]);
            n.push({
              paths: g,
              dataNodeGroup: h,
              markerGroup: p,
              labelGroup: f,
              labelSelection: Et.select(f, ut),
              datumSelection: Et.select(h, function() {
                return y.nodeFactory();
              }, this.datumSelectionGarbageCollection),
              markerSelection: p ? Et.select(p, function() {
                return y.markerFactory();
              }) : void 0
            });
          }
          return [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.getGroupZIndexSubOrder = function(t, i) {
      var r;
      i === void 0 && (i = 0);
      var n = o.prototype.getGroupZIndexSubOrder.call(this, t, i);
      if (t === "paths") {
        var s = (r = this.opts.pathsZIndexSubOrderOffset[i]) !== null && r !== void 0 ? r : 0, a = n[0];
        typeof a == "function" ? n[0] = function() {
          return +a() + s;
        } : n[0] = +a + s;
      }
      return n;
    }, e.prototype.updateNodes = function(t, i) {
      var r;
      return pr(this, void 0, void 0, function() {
        var n, s, a, l, c, d, u, h, p, f = this;
        return fr(this, function(g) {
          switch (g.label) {
            case 0:
              return n = this, s = n.highlightSelection, a = n.highlightLabelSelection, l = n._contextNodeData, c = n.opts, d = c.hasMarkers, u = c.hasHighlightedLabels, h = this.visible && ((r = this._contextNodeData) === null || r === void 0 ? void 0 : r.length) > 0 && i, this.rootGroup.visible = h, this.contentGroup.visible = h, this.highlightGroup.visible = h && !!t, p = this.subGroups.map(function(v, y) {
                var m = l[y].itemId;
                return f.getOpacity({ itemId: m });
              }), d ? [4, this.updateMarkerNodes({
                markerSelection: s,
                isHighlight: !0,
                seriesIdx: -1
              })] : [3, 2];
            case 1:
              return g.sent(), this.animationState.transition("highlightMarkers", s), [3, 4];
            case 2:
              return [4, this.updateDatumNodes({ datumSelection: s, isHighlight: !0, seriesIdx: -1 })];
            case 3:
              g.sent(), this.animationState.transition("highlight", s), g.label = 4;
            case 4:
              return u ? [4, this.updateLabelNodes({ labelSelection: a, seriesIdx: -1 })] : [3, 6];
            case 5:
              g.sent(), g.label = 6;
            case 6:
              return [4, Promise.all(this.subGroups.map(function(v, y) {
                return pr(f, void 0, void 0, function() {
                  var m, C, R, E, b, T, D, P, O, M, _, F, I, G;
                  return fr(this, function(k) {
                    switch (k.label) {
                      case 0:
                        m = v.dataNodeGroup, C = v.markerGroup, R = v.datumSelection, E = v.labelSelection, b = v.markerSelection, T = v.paths, D = v.labelGroup, P = h, O = p[y], m.opacity = O, m.visible = P, D.visible = P, C && (C.opacity = O, C.zIndex = m.zIndex >= kt.SERIES_LAYER_ZINDEX ? m.zIndex : m.zIndex + 1, C.visible = P), D && (D.opacity = O);
                        try {
                          for (M = Xs(T), _ = M.next(); !_.done; _ = M.next())
                            F = _.value, F.opacity = O, F.visible = P;
                        } catch (N) {
                          I = { error: N };
                        } finally {
                          try {
                            _ && !_.done && (G = M.return) && G.call(M);
                          } finally {
                            if (I)
                              throw I.error;
                          }
                        }
                        return m.visible ? [4, this.updateDatumNodes({ datumSelection: R, isHighlight: !1, seriesIdx: y })] : [
                          2
                          /*return*/
                        ];
                      case 1:
                        return k.sent(), [4, this.updateLabelNodes({ labelSelection: E, seriesIdx: y })];
                      case 2:
                        return k.sent(), d && b ? [4, this.updateMarkerNodes({ markerSelection: b, isHighlight: !1, seriesIdx: y })] : [3, 4];
                      case 3:
                        k.sent(), k.label = 4;
                      case 4:
                        return [
                          2
                          /*return*/
                        ];
                    }
                  });
                });
              }))];
            case 7:
              return g.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.updateHighlightSelection = function(t) {
      var i;
      return pr(this, void 0, void 0, function() {
        var r, n, s, a, l, c, d, u, h, p, f, g, v, y, m, C;
        return fr(this, function(R) {
          switch (R.label) {
            case 0:
              return r = this, n = r.highlightSelection, s = r.highlightLabelSelection, a = r._contextNodeData, l = (i = this.ctx.highlightManager) === null || i === void 0 ? void 0 : i.getActiveHighlight(), c = t && (l != null && l.datum) ? l : void 0, d = this, [4, this.updateHighlightSelectionItem({ item: c, highlightSelection: n })];
            case 1:
              if (d.highlightSelection = R.sent(), this.isLabelEnabled() && c != null) {
                h = c.itemId, p = h === void 0 ? void 0 : h;
                try {
                  for (f = Xs(a), g = f.next(); !g.done && (v = g.value.labelData, u = v.find(function(E) {
                    return E.datum === c.datum && E.itemId === p;
                  }), u == null); g = f.next())
                    ;
                } catch (E) {
                  m = { error: E };
                } finally {
                  try {
                    g && !g.done && (C = f.return) && C.call(f);
                  } finally {
                    if (m)
                      throw m.error;
                  }
                }
              }
              return y = this, [4, this.updateHighlightSelectionLabel({
                item: u,
                highlightLabelSelection: s
              })];
            case 2:
              return y.highlightLabelSelection = R.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.pickNodeExactShape = function(t) {
      var i, r, n = o.prototype.pickNodeExactShape.call(this, t);
      if (n)
        return n;
      var s = t.x, a = t.y, l = this.opts.hasMarkers;
      try {
        for (var c = Xs(this.subGroups), d = c.next(); !d.done; d = c.next()) {
          var u = d.value, h = u.dataNodeGroup, p = u.markerGroup, f = h.pickNode(s, a);
          if (!f && l && (f = p == null ? void 0 : p.pickNode(s, a)), f)
            return { datum: f.datum, distance: 0 };
        }
      } catch (g) {
        i = { error: g };
      } finally {
        try {
          d && !d.done && (r = c.return) && r.call(c);
        } finally {
          if (i)
            throw i.error;
        }
      }
    }, e.prototype.pickNodeClosestDatum = function(t) {
      var i, r, n, s, a, l, c = t.x, d = t.y, u = this, h = u.axes, p = u.rootGroup, f = u._contextNodeData, g = h[de.X], v = h[de.Y], y = p.transformPoint(c, d), m = 1 / 0, C;
      try {
        for (var R = Xs(f), E = R.next(); !E.done; E = R.next()) {
          var b = E.value;
          try {
            for (var T = (n = void 0, Xs(b.nodeData)), D = T.next(); !D.done; D = T.next()) {
              var P = D.value, O = P.point, M = O === void 0 ? {} : O, _ = M.x, F = _ === void 0 ? NaN : _, I = M.y, G = I === void 0 ? NaN : I;
              if (!(isNaN(F) || isNaN(G))) {
                var k = (g == null ? void 0 : g.inRange(F)) && (v == null ? void 0 : v.inRange(G));
                if (k) {
                  var N = Math.max(Math.pow(y.x - F, 2) + Math.pow(y.y - G, 2), 0);
                  N < m && (m = N, C = P);
                }
              }
            }
          } catch (W) {
            n = { error: W };
          } finally {
            try {
              D && !D.done && (s = T.return) && s.call(T);
            } finally {
              if (n)
                throw n.error;
            }
          }
        }
      } catch (W) {
        i = { error: W };
      } finally {
        try {
          E && !E.done && (r = R.return) && r.call(R);
        } finally {
          if (i)
            throw i.error;
        }
      }
      if (C) {
        var N = Math.max(Math.sqrt(m) - ((l = (a = C.point) === null || a === void 0 ? void 0 : a.size) !== null && l !== void 0 ? l : 0), 0);
        return { datum: C, distance: N };
      }
    }, e.prototype.pickNodeMainAxisFirst = function(t, i) {
      var r, n, s, a, l, c, d = t.x, u = t.y, h = this, p = h.axes, f = h.rootGroup, g = h._contextNodeData, v = p[de.X], y = p[de.Y], m = [v, y].filter(function(he) {
        return he instanceof Qd;
      }).map(function(he) {
        return he.direction;
      });
      if (!(i && m.length === 0)) {
        var C = f3(m, 1), R = C[0], E = R === void 0 ? de.X : R, b = f.transformPoint(d, u), T = E === de.X ? [b.x, b.y] : [b.y, b.x], D = [1 / 0, 1 / 0], P = void 0;
        try {
          for (var O = Xs(g), M = O.next(); !M.done; M = O.next()) {
            var _ = M.value;
            try {
              for (var F = (s = void 0, Xs(_.nodeData)), I = F.next(); !I.done; I = F.next()) {
                var G = I.value, k = G.point, N = k === void 0 ? {} : k, W = N.x, j = W === void 0 ? NaN : W, K = N.y, $ = K === void 0 ? NaN : K;
                if (!(isNaN(j) || isNaN($))) {
                  var ae = (v == null ? void 0 : v.inRange(j)) && (y == null ? void 0 : y.inRange($));
                  if (ae) {
                    for (var ee = E === de.X ? [j, $] : [$, j], ne = !0, Y = 0; Y < ee.length; Y++) {
                      var te = Math.abs(ee[Y] - T[Y]);
                      if (te > D[Y]) {
                        ne = !1;
                        break;
                      }
                      te < D[Y] && (D[Y] = te, D.fill(1 / 0, Y + 1, D.length));
                    }
                    ne && (P = G);
                  }
                }
              }
            } catch (he) {
              s = { error: he };
            } finally {
              try {
                I && !I.done && (a = F.return) && a.call(F);
              } finally {
                if (s)
                  throw s.error;
              }
            }
          }
        } catch (he) {
          r = { error: he };
        } finally {
          try {
            M && !M.done && (n = O.return) && n.call(O);
          } finally {
            if (r)
              throw r.error;
          }
        }
        if (P) {
          var se = Math.max(Math.sqrt(Math.pow(D[0], 2) + Math.pow(D[1], 2)) - ((c = (l = P.point) === null || l === void 0 ? void 0 : l.size) !== null && c !== void 0 ? c : 0), 0);
          return { datum: P, distance: se };
        }
      }
    }, e.prototype.onLegendItemClick = function(t) {
      var i = t.enabled, r = t.itemId, n = t.series, s = t.legendItemName, a = this.legendItemName != null && this.legendItemName === s;
      n.id === this.id ? this.toggleSeriesItem(r, i) : a && this.toggleSeriesItem(r, i);
    }, e.prototype.onLegendItemDoubleClick = function(t) {
      var i = t.enabled, r = t.itemId, n = t.series, s = t.numVisibleItems, a = t.legendItemName, l = Object.values(s).reduce(function(d, u) {
        return d + u;
      }, 0), c = this.legendItemName != null && this.legendItemName === a;
      n.id === this.id || c ? this.toggleSeriesItem(r, !0) : i && l === 1 ? this.toggleSeriesItem(r, !0) : this.toggleSeriesItem(r, !1);
    }, e.prototype.isPathOrSelectionDirty = function() {
      return !1;
    }, e.prototype.getLabelData = function() {
      return [];
    }, e.prototype.updateHighlightSelectionItem = function(t) {
      return pr(this, void 0, void 0, function() {
        var i, r, n, s, a;
        return fr(this, function(l) {
          return i = this.opts.hasMarkers, r = t.item, n = t.highlightSelection, s = r ? [r] : [], i ? (a = n, [2, this.updateMarkerSelection({ nodeData: s, markerSelection: a, seriesIdx: -1 })]) : [2, this.updateDatumSelection({ nodeData: s, datumSelection: n, seriesIdx: -1 })];
        });
      });
    }, e.prototype.updateHighlightSelectionLabel = function(t) {
      return pr(this, void 0, void 0, function() {
        var i, r, n;
        return fr(this, function(s) {
          return i = t.item, r = t.highlightLabelSelection, n = i ? [i] : [], [2, this.updateLabelSelection({ labelData: n, labelSelection: r, seriesIdx: -1 })];
        });
      });
    }, e.prototype.updateDatumSelection = function(t) {
      return pr(this, void 0, void 0, function() {
        return fr(this, function(i) {
          return [2, t.datumSelection];
        });
      });
    }, e.prototype.updateDatumNodes = function(t) {
      return pr(this, void 0, void 0, function() {
        return fr(this, function(i) {
          return [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.updateMarkerSelection = function(t) {
      return pr(this, void 0, void 0, function() {
        return fr(this, function(i) {
          return [2, t.markerSelection];
        });
      });
    }, e.prototype.updateMarkerNodes = function(t) {
      return pr(this, void 0, void 0, function() {
        return fr(this, function(i) {
          return [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.animateEmptyUpdateReady = function(t) {
    }, e.prototype.animateReadyUpdate = function(t) {
    }, e.prototype.animateWaitingUpdateReady = function(t) {
    }, e.prototype.animateReadyHighlight = function(t) {
    }, e.prototype.animateReadyHighlightMarkers = function(t) {
    }, e.prototype.animateReadyResize = function(t) {
    }, fO([
      A(De)
    ], e.prototype, "legendItemName", void 0), e;
  }(Hm)
), uw = (
  /** @class */
  function(o) {
    _u(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.formatter = void 0, t;
    }
    return fO([
      A(Pt),
      ve({ redraw: oe.MAJOR })
    ], e.prototype, "formatter", void 0), e;
  }(p3)
), y3 = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, C3 = /(#\{(.*?)\})/g;
function hw(o, e, t) {
  return o.replace(C3, function() {
    for (var i = [], r = 0; r < arguments.length; r++)
      i[r] = arguments[r];
    var n = i[2], s = y3(n.split(":"), 2), a = s[0], l = s[1], c = e[a];
    if (typeof c == "number") {
      var d = l && t && t[l];
      if (d) {
        var u = d, h = u.locales, p = u.options;
        return c.toLocaleString(h, p);
      }
      return String(c);
    }
    if (c instanceof Date) {
      var d = l && t && t[l];
      if (typeof d == "string") {
        var f = av(d);
        return f(c);
      }
      return c.toDateString();
    }
    return typeof c == "string" || c != null && c.toString ? String(c) : "";
  });
}
var zc = null;
function ai(o) {
  return zc = zc != null ? zc : document.createElement("div"), o ? (zc.textContent = o, zc.innerHTML) : "";
}
var pw = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), ea = function() {
  return ea = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, ea.apply(this, arguments);
}, $i = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, Kc = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, Yc = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, ss = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, Xc = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, S3 = (
  /** @class */
  function(o) {
    pw(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.formatter = void 0, t;
    }
    return $i([
      A(Pt)
    ], e.prototype, "formatter", void 0), e;
  }(qn)
), b3 = (
  /** @class */
  function(o) {
    pw(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.renderer = void 0, t.format = void 0, t;
    }
    return $i([
      A(Pt)
    ], e.prototype, "renderer", void 0), $i([
      A(De)
    ], e.prototype, "format", void 0), e;
  }(vc)
), vd;
(function(o) {
  o[o.Fill = 0] = "Fill", o[o.Stroke = 1] = "Stroke", o[o.Marker = 2] = "Marker", o[o.Label = 3] = "Label";
})(vd || (vd = {}));
var w3 = (
  /** @class */
  function(o) {
    pw(e, o);
    function e(t) {
      var i = o.call(this, {
        moduleCtx: t,
        pathsPerSeries: 2,
        pathsZIndexSubOrderOffset: [0, 1e3],
        hasMarkers: !0
      }) || this;
      i.tooltip = new b3(), i.marker = new uw(), i.label = new S3(), i.fill = "#c16068", i.stroke = "#874349", i.fillOpacity = 1, i.strokeOpacity = 1, i.lineDash = [0], i.lineDashOffset = 0, i.xKey = void 0, i.xName = void 0, i.strokeWidth = 2, i.shadow = void 0;
      var r = i, n = r.marker, s = r.label;
      return n.enabled = !1, s.enabled = !1, i;
    }
    return e.prototype.processData = function(t) {
      return Kc(this, void 0, void 0, function() {
        var i, r, n, s, a, l, c, d, u, h, p, f, g, v, y, m, C, R, E, b, T;
        return Yc(this, function(D) {
          switch (D.label) {
            case 0:
              return i = this, r = i.xKey, n = i.yKey, s = i.axes, a = i.normalizedTo, l = i.data, c = i.visible, d = i.seriesGrouping, u = d === void 0 ? {} : d, h = u.groupIndex, p = h === void 0 ? this.id : h, !r || !n || !l ? [
                2
                /*return*/
              ] : (f = s[de.X], g = s[de.Y], v = (f == null ? void 0 : f.scale) instanceof ct, y = (g == null ? void 0 : g.scale) instanceof ct, m = [
                "area-stack-" + p + "-yValues",
                "area-stack-" + p + "-yValues-trailing",
                "area-stack-" + p + "-yValues-prev",
                "area-stack-" + p + "-yValues-trailing-prev",
                "area-stack-" + p + "-yValues-marker"
              ], C = [], R = a && isFinite(a) ? a : void 0, R && (C.push(UC(this, [m[0], m[1], m[4]], R, "range")), C.push(UC(this, [m[2], m[3]], R, "range"))), [4, t.request(this.id, l, {
                props: Xc(Xc(Xc(Xc(Xc(Xc([
                  Jb(this, r, v, { id: "xValue" }),
                  wi(this, n, y, { id: "yValue-raw", invalidValue: null })
                ], ss(bl(this, n, y, "window", "current", {
                  id: "yValue-end",
                  invalidValue: null,
                  groupId: m[0]
                }))), ss(bl(this, n, y, "window-trailing", "current", {
                  id: "yValue-start",
                  invalidValue: null,
                  groupId: m[1]
                }))), ss(bl(this, n, y, "window", "last", {
                  id: "yValue-previous-end",
                  invalidValue: null,
                  groupId: m[2]
                }))), ss(bl(this, n, y, "window-trailing", "last", {
                  id: "yValue-previous-start",
                  invalidValue: null,
                  groupId: m[3]
                }))), ss(bl(this, n, y, "normal", "current", {
                  id: "yValue-cumulative",
                  invalidValue: null,
                  groupId: m[4]
                }))), ss(C)),
                groupByKeys: !0,
                dataVisible: c
              })]);
            case 1:
              return E = D.sent(), b = E.dataModel, T = E.processedData, this.dataModel = b, this.processedData = T, [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.getDomain = function(t) {
      var i = this, r = i.processedData, n = i.dataModel, s = i.axes;
      if (!r || !n)
        return [];
      var a = s[de.X], l = s[de.Y], c = n.resolveProcessedDataDefById(this, "xValue"), d = n.getDomain(this, "xValue", "key", r), u = n.getDomain(this, /yValue-(previous-)?end/, "value", r);
      if (t === de.X)
        return (c == null ? void 0 : c.def.type) === "key" && c.def.valueType === "category" ? d : this.fixNumericExtent(Uo(d), a);
      if (l instanceof pv || l instanceof ZC)
        return this.fixNumericExtent(u, l);
      var h = [u[0] > 0 ? 0 : u[0], u[1] < 0 ? 0 : u[1]];
      return this.fixNumericExtent(h, l);
    }, e.prototype.createNodeData = function() {
      var t;
      return Kc(this, void 0, void 0, function() {
        var i, r, n, s, a, l, c, d, u, h, p, f, g, v, y, m, C, R, E, b, T, D, P, O, M, _, F, I, G, k, N, W, j, K, $, ae, ee, ne, Y, te, se, he, be, ye, Xe = this;
        return Yc(this, function(Je) {
          if (i = this, r = i.axes, n = i.data, s = i.processedData, a = s === void 0 ? {} : s, l = a.data, c = i.dataModel, d = i.ctx.callbackCache, u = r[de.X], h = r[de.Y], !u || !h || !n || !c)
            return [2, []];
          for (p = this, f = p.yKey, g = f === void 0 ? "" : f, v = p.xKey, y = v === void 0 ? "" : v, m = p.marker, C = p.label, R = p.fill, E = p.stroke, b = p.id, T = u.scale, D = h.scale, P = D instanceof ct, O = ((t = T.bandwidth) !== null && t !== void 0 ? t : 0) / 2, M = c.resolveProcessedDataIndexById(this, "yValue-start").index, _ = c.resolveProcessedDataIndexById(this, "yValue-end").index, F = c.resolveProcessedDataIndexById(this, "yValue-raw").index, I = c.resolveProcessedDataIndexById(this, "yValue-previous-start").index, G = c.resolveProcessedDataIndexById(this, "yValue-previous-end").index, k = c.resolveProcessedDataIndexById(this, "yValue-cumulative").index, N = function(We, Ue, J) {
            var ge = T.convert(We) + O, Me = D.convert(Ue, { strict: !1 }), $e = D.convert(J, { strict: !1 });
            return [
              { x: ge, y: $e, size: m.size },
              { x: ge, y: Me, size: m.size }
            ];
          }, W = function(We, Ue, J) {
            var ge, Me = Xe.normalizedTo && isFinite(Xe.normalizedTo), $e = Me && P && dp(J), At = !Me && !isNaN(J) || $e;
            At && (ge = Ue);
            var di = T.convert(We) + O, Rn = D.convert(ge, { strict: !1 });
            return { x: di, y: Rn, size: m.size };
          }, j = [], K = [], $ = { itemId: g, points: [], yValues: [] }, ae = { itemId: g, points: [] }, ee = {
            itemId: g,
            fillSelectionData: ae,
            labelData: j,
            nodeData: K,
            strokeSelectionData: $
          }, ne = ae.points, Y = [], te = $.points, se = $.yValues, he = -1, l == null || l.forEach(function(We) {
            var Ue = ss(We.keys, 1), J = Ue[0], ge = We.datum, Me = We.values;
            Me.forEach(function($e, At) {
              var di;
              he++;
              var Rn = ge[At], Tn = $e[F], cy = $e[M], _c = $e[_], dy = $e[I], es = $e[G], kf = $e[k], Vf = Tn != null, Ic = W(J, +kf, Tn);
              if (Vf && m && K.push({
                index: he,
                series: Xe,
                itemId: g,
                datum: Rn,
                nodeMidPoint: { x: Ic.x, y: Ic.y },
                cumulativeValue: _c,
                yValue: Tn,
                xValue: J,
                yKey: g,
                xKey: y,
                point: Ic,
                fill: R,
                stroke: E
              }), Vf && C) {
                var Fc = void 0;
                C.formatter ? Fc = (di = d.call(C.formatter, { value: Tn, seriesId: b })) !== null && di !== void 0 ? di : "" : Fc = Dr(Tn) ? Number(Tn).toFixed(2) : String(Tn), j.push({
                  index: he,
                  itemId: g,
                  point: Ic,
                  label: Fc ? {
                    text: Fc,
                    fontStyle: C.fontStyle,
                    fontWeight: C.fontWeight,
                    fontSize: C.fontSize,
                    fontFamily: C.fontFamily,
                    textAlign: "center",
                    textBaseline: "bottom",
                    fill: C.color
                  } : void 0
                });
              }
              var uy = [be, J], $s = [dy, cy], Zu = [es, _c];
              if (uy.some(function(Qu) {
                return Qu == null;
              })) {
                be = J;
                return;
              }
              $s.some(function(Qu) {
                return Qu == null;
              }) && ($s[0] = 0, $s[1] = 0), Zu.some(function(Qu) {
                return Qu == null;
              }) && (Zu[0] = 0, Zu[1] = 0);
              var hy = N(be, +$s[0], +Zu[0]);
              ne.push(hy[0]), Y.push(hy[1]);
              var py = N(J, +$s[1], +Zu[1]);
              ne.push(py[0]), Y.push(py[1]), te.push({ x: NaN, y: NaN }), se.push(void 0), es != null && (te.push(hy[0]), se.push(es)), _c != null && (te.push(py[0]), se.push(_c)), be = J;
            });
          }), ye = Y.length - 1; ye >= 0; ye--)
            ne.push(Y[ye]);
          return [2, [ee]];
        });
      });
    }, e.prototype.isPathOrSelectionDirty = function() {
      return this.marker.isDirty();
    }, e.prototype.markerFactory = function() {
      var t = this.marker.shape, i = Mu(t);
      return new i();
    }, e.prototype.updateMarkerSelection = function(t) {
      return Kc(this, void 0, void 0, function() {
        var i, r, n, s;
        return Yc(this, function(a) {
          return i = t.nodeData, r = t.markerSelection, n = this.marker.enabled, s = n && i ? i : [], this.marker.isDirty() && r.clear(), [2, r.update(s, function(l) {
            l.tag = vd.Marker;
          })];
        });
      });
    }, e.prototype.updateMarkerNodes = function(t) {
      var i;
      return Kc(this, void 0, void 0, function() {
        var r, n, s, a, l, c, d, u, h, p, f, g, v, y, m, C, R, E, b, T, D, P, O, M, _;
        return Yc(this, function(F) {
          return r = t.markerSelection, n = t.isHighlight, s = this, a = s.id, l = s.xKey, c = l === void 0 ? "" : l, d = s.marker, u = s.fill, h = s.stroke, p = s.fillOpacity, f = s.marker.fillOpacity, g = f === void 0 ? p : f, v = s.strokeOpacity, y = s.highlightStyle.item, m = y.fill, C = y.fillOpacity, R = C === void 0 ? g : C, E = y.stroke, b = y.strokeWidth, T = s.visible, D = s.ctx.callbackCache, P = d.size, O = d.formatter, M = (i = d.strokeWidth) !== null && i !== void 0 ? i : this.strokeWidth, _ = typeof d.shape == "function", r.each(function(I, G) {
            var k, N, W, j, K, $, ae, ee, ne = n && m !== void 0 ? m : (k = d.fill) !== null && k !== void 0 ? k : u, Y = n ? R : g, te = n && E !== void 0 ? E : (N = d.stroke) !== null && N !== void 0 ? N : h, se = n && b !== void 0 ? b : M, he = void 0;
            O && (he = D.call(O, {
              datum: G.datum,
              xKey: c,
              yKey: G.yKey,
              fill: ne,
              stroke: te,
              strokeWidth: se,
              size: P,
              highlighted: n,
              seriesId: a
            })), I.fill = (W = he == null ? void 0 : he.fill) !== null && W !== void 0 ? W : ne, I.stroke = (j = he == null ? void 0 : he.stroke) !== null && j !== void 0 ? j : te, I.strokeWidth = (K = he == null ? void 0 : he.strokeWidth) !== null && K !== void 0 ? K : se, I.fillOpacity = Y != null ? Y : 1, I.strokeOpacity = (ae = ($ = d.strokeOpacity) !== null && $ !== void 0 ? $ : v) !== null && ae !== void 0 ? ae : 1, I.size = (ee = he == null ? void 0 : he.size) !== null && ee !== void 0 ? ee : P, I.translationX = G.point.x, I.translationY = G.point.y, I.visible = I.size > 0 && T && !isNaN(G.point.x) && !isNaN(G.point.y), !(!_ || I.dirtyPath) && (I.path.clear({ trackChanges: !0 }), I.updatePath(), I.checkPathDirty());
          }), n || this.marker.markClean(), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.updateLabelSelection = function(t) {
      return Kc(this, void 0, void 0, function() {
        var i, r;
        return Yc(this, function(n) {
          return i = t.labelData, r = t.labelSelection, [2, r.update(i, function(s) {
            s.tag = vd.Label;
          })];
        });
      });
    }, e.prototype.updateLabelNodes = function(t) {
      return Kc(this, void 0, void 0, function() {
        var i, r, n, s, a, l, c, d;
        return Yc(this, function(u) {
          return i = t.labelSelection, r = this.label, n = r.enabled, s = r.fontStyle, a = r.fontWeight, l = r.fontSize, c = r.fontFamily, d = r.color, i.each(function(h, p) {
            var f = p.point, g = p.label;
            g && n ? (h.fontStyle = s, h.fontWeight = a, h.fontSize = l, h.fontFamily = c, h.textAlign = g.textAlign, h.textBaseline = g.textBaseline, h.text = g.text, h.x = f.x, h.y = f.y - 10, h.fill = d, h.visible = !0) : h.visible = !1;
          }), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.getNodeClickEvent = function(t, i) {
      var r;
      return new $m((r = this.xKey) !== null && r !== void 0 ? r : "", i.yKey, t, i, this);
    }, e.prototype.getNodeDoubleClickEvent = function(t, i) {
      var r;
      return new zm((r = this.xKey) !== null && r !== void 0 ? r : "", i.yKey, t, i, this);
    }, e.prototype.getTooltipHtml = function(t) {
      var i, r, n, s = this, a = s.xKey, l = s.id, c = s.axes, d = s.xName, u = s.yName, h = s.fill, p = s.stroke, f = s.tooltip, g = s.marker, v = s.dataModel, y = t.yKey, m = t.xValue, C = t.yValue, R = t.datum, E = c[de.X], b = c[de.Y];
      if (!(a && y) || !(E && b && Dr(C)) || !v)
        return "";
      var T = v.resolveProcessedDataIndexById(this, "yValue-raw").index, D = g.size, P = g.formatter, O = g.strokeWidth, M = g.fill, _ = g.stroke, F = E.formatDatum(m), I = b.formatDatum(C), G = (r = (i = this.processedData) === null || i === void 0 ? void 0 : i.data[t.index]) === null || r === void 0 ? void 0 : r.values[0][T], k = ai(u), N = ai(F + ": " + I), W = O != null ? O : this.strokeWidth, j = M != null ? M : h, K = _ != null ? _ : p, $ = void 0;
      P && ($ = P({
        datum: R,
        xKey: a,
        yKey: y,
        fill: j,
        stroke: K,
        strokeWidth: W,
        size: D,
        highlighted: !1,
        seriesId: l
      }));
      var ae = (n = $ == null ? void 0 : $.fill) !== null && n !== void 0 ? n : j, ee = {
        title: k,
        backgroundColor: ae,
        content: N
      }, ne = f.renderer, Y = f.format;
      if (Y || ne) {
        var te = {
          datum: R,
          xKey: a,
          xName: d,
          xValue: m,
          yKey: y,
          yValue: C,
          processedYValue: G,
          yName: u,
          color: ae,
          title: k,
          seriesId: l
        };
        if (Y)
          return Ti({
            content: hw(Y, te)
          }, ee);
        if (ne)
          return Ti(ne(te), ee);
      }
      return Ti(ee);
    }, e.prototype.getLegendData = function() {
      var t, i, r, n, s = this, a = s.data, l = s.id, c = s.xKey, d = s.yKey, u = s.yName, h = s.marker, p = s.fill, f = s.stroke, g = s.fillOpacity, v = s.strokeOpacity, y = s.visible;
      return !(a != null && a.length) || !c || !d ? [] : [
        {
          legendType: "category",
          id: l,
          itemId: d,
          seriesId: l,
          enabled: y,
          label: {
            text: u != null ? u : d
          },
          marker: {
            shape: h.shape,
            fill: (t = h.fill) !== null && t !== void 0 ? t : p,
            stroke: (i = h.stroke) !== null && i !== void 0 ? i : f,
            fillOpacity: (r = h.fillOpacity) !== null && r !== void 0 ? r : g,
            strokeOpacity: (n = h.strokeOpacity) !== null && n !== void 0 ? n : v
          }
        }
      ];
    }, e.prototype.animateEmptyUpdateReady = function(t) {
      var i = this, r = t.markerSelections, n = t.labelSelections, s = t.contextData, a = t.paths, l = t.seriesRect, c = this, d = c.stroke, u = c.fill, h = c.fillOpacity, p = c.lineDash, f = c.lineDashOffset, g = c.strokeOpacity, v = c.strokeWidth, y = c.shadow;
      s.forEach(function(m, C) {
        var R, E, b, T, D, P = m.fillSelectionData, O = m.strokeSelectionData, M = m.itemId, _ = ss(a[C], 2), F = _[0], I = _[1], G = (E = (R = i.ctx.animationManager) === null || R === void 0 ? void 0 : R.defaultOptions.duration) !== null && E !== void 0 ? E : 1e3, k = 200, N = {
          from: 0,
          to: (b = l == null ? void 0 : l.width) !== null && b !== void 0 ? b : 0,
          duration: G
        };
        {
          var W = O.points, j = O.yValues;
          I.tag = vd.Stroke, I.fill = void 0, I.lineJoin = I.lineCap = "round", I.pointerEvents = ki.None, I.stroke = d, I.strokeWidth = i.getStrokeWidth(i.strokeWidth, { itemId: M }), I.strokeOpacity = g, I.lineDash = p, I.lineDashOffset = f, (T = i.ctx.animationManager) === null || T === void 0 || T.animate(i.id + "_empty-update-ready_stroke_" + C, ea(ea({}, N), { onUpdate: function(ee) {
            I.path.clear({ trackChanges: !0 });
            var ne = !0;
            W.forEach(function(Y, te) {
              if (j[te] === void 0 || isNaN(Y.x) || isNaN(Y.y))
                ne = !0;
              else if (Y.x <= ee)
                ne ? (I.path.moveTo(Y.x, Y.y), ne = !1) : I.path.lineTo(Y.x, Y.y);
              else if (te > 0 && j[te] !== void 0 && j[te - 1] !== void 0 && W[te - 1].x <= ee) {
                var se = W[te - 1], he = Y, be = ee, ye = se.y + (be - se.x) * (he.y - se.y) / (he.x - se.x);
                I.path.lineTo(be, ye);
              }
            }), I.checkPathDirty();
          } }));
        }
        {
          var K = P.points, $ = K.slice(0, K.length / 2), ae = K.slice(K.length / 2);
          F.tag = vd.Fill, F.stroke = void 0, F.lineJoin = "round", F.pointerEvents = ki.None, F.fill = u, F.fillOpacity = h, F.strokeOpacity = g, F.strokeWidth = v, F.lineDash = p, F.lineDashOffset = f, F.fillShadow = y, (D = i.ctx.animationManager) === null || D === void 0 || D.animate(i.id + "_empty-update-ready_fill_" + C, ea(ea({}, N), { onUpdate: function(ee) {
            F.path.clear({ trackChanges: !0 });
            var ne = 0, Y = 0;
            $.forEach(function(te, se) {
              if (te.x <= ee)
                ne = te.x, Y = te.y, F.path.lineTo(te.x, te.y);
              else if (se > 0 && $[se - 1].x < ee) {
                var he = $[se - 1], be = te;
                ne = ee, Y = he.y + (ne - he.x) * (be.y - he.y) / (be.x - he.x), F.path.lineTo(ne, Y);
              }
            }), ae.forEach(function(te, se) {
              var he = ae.length - se - 1;
              if (te.x <= ee)
                F.path.lineTo(te.x, te.y);
              else if (he > 0 && $[he - 1].x < ee) {
                var be = te, ye = ae[se + 1], Xe = be.y + (ne - be.x) * (ye.y - be.y) / (ye.x - be.x);
                F.path.lineTo(ne, Xe);
              }
            }), ae.length > 0 && F.path.lineTo(ae[ae.length - 1].x, ae[ae.length - 1].y), F.path.closePath(), F.checkPathDirty();
          } }));
        }
        r[C].each(function(ee, ne) {
          var Y, te, se, he, be = l != null && l.width ? ne.point.x / l.width * G : 0, ye = i.animateFormatter(ne), Xe = (te = (Y = ne.point) === null || Y === void 0 ? void 0 : Y.size) !== null && te !== void 0 ? te : 0;
          (se = i.ctx.animationManager) === null || se === void 0 || se.animate(i.id + "_empty-update-ready_" + ee.id, ea(ea({}, N), { to: (he = ye == null ? void 0 : ye.size) !== null && he !== void 0 ? he : Xe, delay: be, duration: k, onUpdate: function(Je) {
            ee.size = Je;
          } }));
        }), n[C].each(function(ee, ne) {
          var Y, te = l != null && l.width ? ne.point.x / l.width * G : 0;
          (Y = i.ctx.animationManager) === null || Y === void 0 || Y.animate(i.id + "_empty-update-ready_" + ee.id, {
            from: 0,
            to: 1,
            delay: te,
            duration: k,
            onUpdate: function(se) {
              ee.opacity = se;
            }
          });
        });
      });
    }, e.prototype.animateReadyUpdate = function(t) {
      var i = this, r = t.contextData, n = t.paths, s = this, a = s.stroke, l = s.fill, c = s.fillOpacity, d = s.lineDash, u = s.lineDashOffset, h = s.strokeOpacity, p = s.strokeWidth, f = s.shadow;
      r.forEach(function(g, v) {
        var y = g.strokeSelectionData, m = g.fillSelectionData, C = g.itemId, R = ss(n[v], 2), E = R[0], b = R[1];
        b.stroke = a, b.strokeWidth = i.getStrokeWidth(i.strokeWidth, { itemId: C }), b.strokeOpacity = h, b.lineDash = d, b.lineDashOffset = u, b.path.clear({ trackChanges: !0 });
        var T = !0;
        y.points.forEach(function(D, P) {
          y.yValues[P] === void 0 || isNaN(D.x) || isNaN(D.y) ? T = !0 : T ? (b.path.moveTo(D.x, D.y), T = !1) : b.path.lineTo(D.x, D.y);
        }), b.checkPathDirty(), E.fill = l, E.fillOpacity = c, E.strokeOpacity = h, E.strokeWidth = p, E.lineDash = d, E.lineDashOffset = u, E.fillShadow = f, E.path.clear({ trackChanges: !0 }), m.points.forEach(function(D) {
          E.path.lineTo(D.x, D.y);
        }), E.path.closePath(), E.checkPathDirty();
      });
    }, e.prototype.animateFormatter = function(t) {
      var i, r, n, s = this, a = s.marker, l = s.fill, c = s.stroke, d = s.xKey, u = d === void 0 ? "" : d, h = s.id, p = s.ctx.callbackCache, f = a.size, g = a.formatter, v = (i = a.fill) !== null && i !== void 0 ? i : l, y = (r = a.stroke) !== null && r !== void 0 ? r : c, m = (n = a.strokeWidth) !== null && n !== void 0 ? n : this.strokeWidth, C = void 0;
      return g && (C = p.call(g, {
        datum: t.datum,
        xKey: u,
        yKey: t.yKey,
        fill: v,
        stroke: y,
        strokeWidth: m,
        size: f,
        highlighted: !1,
        seriesId: h
      })), C;
    }, e.prototype.isLabelEnabled = function() {
      return this.label.enabled;
    }, e.className = "AreaSeries", e.type = "area", $i([
      A(Lr)
    ], e.prototype, "fill", void 0), $i([
      A(Lr)
    ], e.prototype, "stroke", void 0), $i([
      A(le(0, 1))
    ], e.prototype, "fillOpacity", void 0), $i([
      A(le(0, 1))
    ], e.prototype, "strokeOpacity", void 0), $i([
      A(Au)
    ], e.prototype, "lineDash", void 0), $i([
      A(le(0))
    ], e.prototype, "lineDashOffset", void 0), $i([
      A(De)
    ], e.prototype, "xKey", void 0), $i([
      A(De)
    ], e.prototype, "xName", void 0), $i([
      A(De)
    ], e.prototype, "yKey", void 0), $i([
      A(De)
    ], e.prototype, "yName", void 0), $i([
      A(lt(0))
    ], e.prototype, "normalizedTo", void 0), $i([
      A(le(0))
    ], e.prototype, "strokeWidth", void 0), e;
  }(mf)
), E3 = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), qc = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, kn = (
  /** @class */
  function(o) {
    E3(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.borderPath = new zC(), t.x = 0, t.y = 0, t.width = 10, t.height = 10, t.radius = 0, t.crisp = !1, t.lastUpdatePathStrokeWidth = Mo.defaultStyles.strokeWidth, t.effectiveStrokeWidth = Mo.defaultStyles.strokeWidth, t.microPixelEffectOpacity = 1, t;
    }
    return e.prototype.isDirtyPath = function() {
      var t;
      return !!(this.lastUpdatePathStrokeWidth !== this.strokeWidth || this.path.isDirty() || this.borderPath.isDirty() || !((t = this.clipPath) === null || t === void 0) && t.isDirty());
    }, e.prototype.updatePath = function() {
      var t, i, r, n = this, s = n.path, a = n.borderPath, l = n.crisp, c = this, d = c.x, u = c.y, h = c.width, p = c.height, f = c.strokeWidth, g = (i = (t = this.layerManager) === null || t === void 0 ? void 0 : t.canvas.pixelRatio) !== null && i !== void 0 ? i : 1, v = 1 / g, y = 1;
      if (s.clear({ trackChanges: !0 }), a.clear({ trackChanges: !0 }), l && (h <= v && (y *= h / v), p <= v && (y *= p / v), h = this.align(d, h), p = this.align(u, p), d = this.align(d), u = this.align(u)), f)
        if (h < v) {
          var m = d + v / 2;
          a.moveTo(m, u), a.lineTo(m, u + p), f = v, this.borderClipPath = void 0;
        } else if (p < v) {
          var C = u + v / 2;
          a.moveTo(d, C), a.lineTo(d + h, C), f = v, this.borderClipPath = void 0;
        } else if (f < h && f < p) {
          var R = f / 2;
          d += R, u += R, h -= f, p -= f, this.borderClipPath = void 0, s.rect(d, u, h, p), a.rect(d, u, h, p);
        } else
          this.borderClipPath = (r = this.borderClipPath) !== null && r !== void 0 ? r : new zC(), this.borderClipPath.clear({ trackChanges: !0 }), this.borderClipPath.rect(d, u, h, p), a.rect(d, u, h, p);
      else
        this.borderClipPath = void 0, s.rect(d, u, h, p);
      this.effectiveStrokeWidth = f, this.lastUpdatePathStrokeWidth = f, this.microPixelEffectOpacity = y;
    }, e.prototype.computeBBox = function() {
      var t = this, i = t.x, r = t.y, n = t.width, s = t.height;
      return new nt(i, r, n, s);
    }, e.prototype.isPointInPath = function(t, i) {
      var r = this.transformPoint(t, i), n = this.computeBBox();
      return n.containsPoint(r.x, r.y);
    }, e.prototype.applyFillAlpha = function(t) {
      var i = this, r = i.fillOpacity, n = i.microPixelEffectOpacity, s = i.opacity, a = t.globalAlpha;
      t.globalAlpha = a * s * r * n;
    }, e.prototype.renderStroke = function(t) {
      var i = this, r = i.stroke, n = i.effectiveStrokeWidth, s = i.borderPath, a = i.borderClipPath, l = i.opacity, c = i.microPixelEffectOpacity, d = !!r && !!n;
      if (d) {
        var u = this, h = u.strokeOpacity, p = u.lineDash, f = u.lineDashOffset, g = u.lineCap, v = u.lineJoin;
        a && (a.draw(t), t.clip()), s.draw(t);
        var y = t.globalAlpha;
        t.strokeStyle = r, t.globalAlpha = y * l * h * c, t.lineWidth = n, p && t.setLineDash(p), f && (t.lineDashOffset = f), g && (t.lineCap = g), v && (t.lineJoin = v), t.stroke(), t.globalAlpha = y;
      }
    }, e.className = "Rect", qc([
      yt()
    ], e.prototype, "x", void 0), qc([
      yt()
    ], e.prototype, "y", void 0), qc([
      yt()
    ], e.prototype, "width", void 0), qc([
      yt()
    ], e.prototype, "height", void 0), qc([
      yt()
    ], e.prototype, "radius", void 0), qc([
      yt()
    ], e.prototype, "crisp", void 0), e;
  }(Zi)
), QC = function() {
  return QC = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, QC.apply(this, arguments);
}, R3 = function(o, e) {
  var t = {};
  for (var i in o)
    Object.prototype.hasOwnProperty.call(o, i) && e.indexOf(i) < 0 && (t[i] = o[i]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(o); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(o, i[r]) && (t[i[r]] = o[i[r]]);
  return t;
}, T3 = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
};
function x3(o) {
  var e = o.value, t = o.rect, i = o.placement, r = o.seriesId, n = o.padding, s = n === void 0 ? 0 : n, a = o.formatter, l = o.barAlongX, c = o.ctx.callbackCache, d;
  a && (d = c.call(a, {
    value: Dr(e) ? e : void 0,
    seriesId: r
  })), d === void 0 && (d = Dr(e) ? e.toFixed(2) : "");
  var u = t.x + t.width / 2, h = t.y + t.height / 2, p = "center", f = "middle", g = e >= 0;
  switch (i) {
    case "start": {
      l ? (u = g ? t.x - s : t.x + t.width + s, p = g ? "start" : "end") : (h = g ? t.y + t.height + s : t.y - s, f = g ? "top" : "bottom");
      break;
    }
    case "outside":
    case "end": {
      l ? (u = g ? t.x + t.width + s : t.x - s, p = g ? "start" : "end") : (h = g ? t.y - s : t.y + t.height + s, f = g ? "bottom" : "top");
      break;
    }
    case "inside":
    default: {
      f = "middle";
      break;
    }
  }
  return {
    text: d,
    textAlign: p,
    textBaseline: f,
    x: u,
    y: h
  };
}
function D3(o) {
  var e = o.rect, t = o.config, i = t.crisp, r = i === void 0 ? !0 : i, n = t.fill, s = t.stroke, a = t.strokeWidth, l = t.fillOpacity, c = t.strokeOpacity, d = t.lineDash, u = t.lineDashOffset, h = t.fillShadow, p = t.visible, f = p === void 0 ? !0 : p;
  e.crisp = r, e.fill = n, e.stroke = s, e.strokeWidth = a, e.fillOpacity = l, e.strokeOpacity = c, e.lineDash = d, e.lineDashOffset = u, e.fillShadow = h, e.visible = f;
}
function O3(o) {
  var e, t, i, r, n, s, a, l = o.datum, c = o.isHighlighted, d = o.style, u = o.highlightStyle, h = o.formatter, p = o.seriesId, f = o.stackGroup, g = o.ctx.callbackCache, v = R3(o, ["datum", "isHighlighted", "style", "highlightStyle", "formatter", "seriesId", "stackGroup", "ctx"]), y = c && (e = u.fill) !== null && e !== void 0 ? e : d.fill, m = c && (t = u.stroke) !== null && t !== void 0 ? t : d.stroke, C = c && (i = u.strokeWidth) !== null && i !== void 0 ? i : d.strokeWidth, R = c && (r = u.fillOpacity) !== null && r !== void 0 ? r : d.fillOpacity, E = d.strokeOpacity, b = d.fillShadow, T = d.lineDash, D = d.lineDashOffset, P = void 0;
  return h && (P = g.call(h, QC({ datum: l.datum, xKey: l.xKey, yKey: l.yKey, fill: y, stroke: m, strokeWidth: C, highlighted: c, seriesId: p, stackGroup: f }, v))), {
    fill: (n = P == null ? void 0 : P.fill) !== null && n !== void 0 ? n : y,
    stroke: (s = P == null ? void 0 : P.stroke) !== null && s !== void 0 ? s : m,
    strokeWidth: (a = P == null ? void 0 : P.strokeWidth) !== null && a !== void 0 ? a : C,
    fillOpacity: R,
    strokeOpacity: E,
    lineDash: T,
    lineDashOffset: D,
    fillShadow: b
  };
}
function P3(o) {
  o === void 0 && (o = []);
  var e = T3(o, 2), t = e[0], i = e[1], r = t !== 0 || i !== 1, n = !r;
  return n;
}
function A3(o) {
  var e = o.labelNode, t = o.labelDatum, i = o.config, r = o.visible;
  if (t && i && i.enabled) {
    var n = t.x, s = t.y, a = t.text, l = t.textAlign, c = t.textBaseline, d = i.fontStyle, u = i.fontWeight, h = i.fontSize, p = i.fontFamily, f = i.color;
    e.fontStyle = d, e.fontWeight = u, e.fontSize = h, e.fontFamily = p, e.textAlign = l, e.textBaseline = c, e.text = a, e.x = n, e.y = s, e.fill = f, e.visible = r;
  } else
    e.visible = !1;
}
var Km = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), gi = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, Zc = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, Qc = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, Jc = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, lg = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, M3 = ["inside", "outside"], _3 = function(o, e) {
  return Ot(o, e, function(t) {
    return M3.includes(t);
  });
}, vv;
(function(o) {
  o[o.Bar = 0] = "Bar", o[o.Label = 1] = "Label";
})(vv || (vv = {}));
var I3 = (
  /** @class */
  function(o) {
    Km(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.formatter = void 0, t.placement = "inside", t;
    }
    return gi([
      A(Pt)
    ], e.prototype, "formatter", void 0), gi([
      A(_3)
    ], e.prototype, "placement", void 0), e;
  }(qn)
), F3 = (
  /** @class */
  function(o) {
    Km(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.renderer = void 0, t;
    }
    return gi([
      A(Pt)
    ], e.prototype, "renderer", void 0), e;
  }(vc)
), gO = (
  /** @class */
  function(o) {
    Km(e, o);
    function e(t) {
      var i = o.call(this, {
        moduleCtx: t,
        pickModes: [Zt.EXACT_SHAPE_MATCH],
        pathsPerSeries: 0,
        hasHighlightedLabels: !0
      }) || this;
      return i.label = new I3(), i.tooltip = new F3(), i.fill = "#c16068", i.stroke = "#874349", i.fillOpacity = 1, i.strokeOpacity = 1, i.lineDash = [0], i.lineDashOffset = 0, i.formatter = void 0, i.xKey = void 0, i.xName = void 0, i.yKey = void 0, i.yName = void 0, i.groupScale = new $n(), i.stackGroup = void 0, i.strokeWidth = 1, i.shadow = void 0, i.smallestDataInterval = void 0, i.datumSelectionGarbageCollection = !1, i.label.enabled = !1, i;
    }
    return e.prototype.resolveKeyDirection = function(t) {
      return this.getBarDirection() === de.X ? t === de.X ? de.Y : de.X : t;
    }, e.prototype.processData = function(t) {
      var i, r, n, s, a;
      return Zc(this, void 0, void 0, function() {
        var l, c, d, u, h, p, f, g, v, y, m, C, R, E, b, T, D, P, O, M;
        return Qc(this, function(_) {
          switch (_.label) {
            case 0:
              return l = this, c = l.xKey, d = l.yKey, u = l.normalizedTo, h = l.seriesGrouping, p = h === void 0 ? {} : h, f = p.groupIndex, g = f === void 0 ? this.id : f, v = l.data, y = v === void 0 ? [] : v, m = Math.abs(u != null ? u : NaN), C = ((i = this.getCategoryAxis()) === null || i === void 0 ? void 0 : i.scale) instanceof ct, R = ((r = this.getValueAxis()) === null || r === void 0 ? void 0 : r.scale) instanceof ct, E = "bar-stack-" + g + "-yValues", b = E + "-trailing", T = m && isFinite(m) ? m : void 0, D = [], T && D.push(UC(this, [E, b], T, "range")), !(!((n = this.ctx.animationManager) === null || n === void 0) && n.skipAnimations) && this.processedData && D.push(TD(this.processedData)), [4, t.request(this.id, y, {
                props: lg(lg(lg(lg([
                  Jb(this, c, C, { id: "xValue" }),
                  wi(this, d, R, { id: "yValue-raw", invalidValue: null })
                ], Jc(bl(this, d, R, "normal", "current", {
                  id: "yValue-end",
                  invalidValue: null,
                  groupId: E
                }))), Jc(bl(this, d, R, "trailing", "current", {
                  id: "yValue-start",
                  invalidValue: null,
                  groupId: b
                }))), Jc(C ? [jy] : [])), Jc(D)),
                groupByKeys: !0,
                dataVisible: this.visible
              })];
            case 1:
              return P = _.sent(), O = P.dataModel, M = P.processedData, this.dataModel = O, this.processedData = M, this.smallestDataInterval = {
                x: (a = (s = M.reduced) === null || s === void 0 ? void 0 : s[jy.property]) !== null && a !== void 0 ? a : 1 / 0,
                y: 1 / 0
              }, this.animationState.transition("updateData"), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.getDomain = function(t) {
      var i, r = this, n = r.processedData, s = r.dataModel;
      if (!n || !s)
        return [];
      var a = n, l = a.reduced, c = l === void 0 ? {} : l, d = jy.property, u = c[d], h = this.getCategoryAxis(), p = this.getValueAxis(), f = s.resolveProcessedDataDefById(this, "xValue"), g = s.getDomain(this, "xValue", "key", n), v = s.getDomain(this, "yValue-end", "value", n);
      if (t === this.getCategoryDirection()) {
        if ((f == null ? void 0 : f.def.type) === "key" && (f == null ? void 0 : f.def.valueType) === "category")
          return g;
        var y = isFinite(u) ? u : 0, m = (i = Uo(g)) !== null && i !== void 0 ? i : [NaN, NaN];
        return t === de.Y ? this.fixNumericExtent([m[0] + -y, m[1]], h) : this.fixNumericExtent([m[0], m[1] + y], h);
      } else {
        if (this.getValueAxis() instanceof pv)
          return this.fixNumericExtent(v, p);
        var C = [v[0] > 0 ? 0 : v[0], v[1] < 0 ? 0 : v[1]];
        return this.fixNumericExtent(C, p);
      }
    }, e.prototype.getNodeClickEvent = function(t, i) {
      var r;
      return new $m((r = this.xKey) !== null && r !== void 0 ? r : "", i.yKey, t, i, this);
    }, e.prototype.getNodeDoubleClickEvent = function(t, i) {
      var r;
      return new zm((r = this.xKey) !== null && r !== void 0 ? r : "", i.yKey, t, i, this);
    }, e.prototype.getCategoryAxis = function() {
      var t = this.getCategoryDirection();
      return this.axes[t];
    }, e.prototype.getValueAxis = function() {
      var t = this.getBarDirection();
      return this.axes[t];
    }, e.prototype.calculateStep = function(t) {
      var i, r = this.smallestDataInterval, n = this.getCategoryAxis();
      if (n) {
        var s = n.dataDomain[1] - n.dataDomain[0], a = s / ((i = r == null ? void 0 : r.x) !== null && i !== void 0 ? i : 1) + 1, l = Math.floor(t), c = Math.min(a, l), d = t / Math.max(1, c);
        return d;
      }
    }, e.prototype.createNodeData = function() {
      return Zc(this, void 0, void 0, function() {
        var t, i, r, n, s, a, l, c, d, u, h, p, f, g, v, y, m, C, R, E, b, T, D, P, O, M, _, F, I, G, k, N, W, j, K, $ = this;
        return Qc(this, function(ae) {
          if (t = this, i = t.visible, r = t.dataModel, n = this.getCategoryAxis(), s = this.getValueAxis(), !(r && i && n && s))
            return [2, []];
          for (a = n.scale, l = s.scale, c = this, d = c.groupScale, u = c.yKey, h = u === void 0 ? "" : u, p = c.xKey, f = p === void 0 ? "" : p, g = c.fill, v = c.stroke, y = c.strokeWidth, m = c.label, C = c.id, R = c.processedData, E = c.ctx, b = c.ctx.seriesStateManager, T = a.bandwidth, a instanceof ct && (D = Math.max(n.range[0], n.range[1]), P = this.calculateStep(D), T = P), O = [], M = b.getVisiblePeerGroupIndex(this), _ = M.index, F = M.visibleGroupCount, I = 0; I < F; I++)
            O.push(String(I));
          return d.domain = O, d.range = [0, T != null ? T : 0], n instanceof Qd ? d.padding = n.groupPaddingInner : n instanceof uv ? d.padding = 0.1 : d.padding = 0, d.padding === 0 ? d.round = !1 : d.round = !0, G = d.bandwidth >= 1 ? (
            // Pixel-rounded value for low-volume bar charts.
            d.bandwidth
          ) : (
            // Handle high-volume bar charts gracefully.
            d.rawBandwidth
          ), k = r.resolveProcessedDataIndexById(this, "xValue", "key").index, N = r.resolveProcessedDataIndexById(this, "yValue-raw").index, W = r.resolveProcessedDataIndexById(this, "yValue-start").index, j = r.resolveProcessedDataIndexById(this, "yValue-end").index, K = {
            itemId: h,
            nodeData: [],
            labelData: []
          }, R == null || R.data.forEach(function(ee, ne) {
            var Y = ee.keys, te = ee.datum, se = ee.values, he = Y[k], be = a.convert(he), ye = +se[0][j], Xe = +se[0][W], Je = se[0][N], We = be + d.convert(String(_));
            if (n.inRange(We, G) && !isNaN(ye)) {
              var Ue = l.convert(ye, { strict: !1 }), J = l.convert(Xe, { strict: !1 }), ge = $.getBarDirection() === de.X, Me = {
                x: ge ? Math.min(Ue, J) : We,
                y: ge ? We : Math.min(Ue, J),
                width: ge ? Math.abs(J - Ue) : G,
                height: ge ? G : Math.abs(J - Ue)
              }, $e = {
                x: Me.x + Me.width / 2,
                y: Me.y + Me.height / 2
              }, At = m.fontStyle, di = m.fontWeight, Rn = m.fontSize, Tn = m.fontFamily, cy = m.color, _c = m.formatter, dy = m.placement, es = x3({ value: Je, rect: Me, formatter: _c, placement: dy, seriesId: C, barAlongX: ge, ctx: E }), kf = es.text, Vf = es.textAlign, Ic = es.textBaseline, Fc = es.x, uy = es.y, $s = {
                index: ne,
                series: $,
                itemId: h,
                datum: te[0],
                cumulativeValue: Xe + ye,
                xValue: he,
                yValue: Je,
                yKey: h,
                xKey: f,
                x: Me.x,
                y: Me.y,
                width: Me.width,
                height: Me.height,
                nodeMidPoint: $e,
                fill: g,
                stroke: v,
                strokeWidth: y,
                label: kf ? {
                  text: kf,
                  fontStyle: At,
                  fontWeight: di,
                  fontSize: Rn,
                  fontFamily: Tn,
                  textAlign: Vf,
                  textBaseline: Ic,
                  fill: cy,
                  x: Fc,
                  y: uy
                } : void 0
              };
              K.nodeData.push($s), K.labelData.push($s);
            }
          }), [2, [K]];
        });
      });
    }, e.prototype.nodeFactory = function() {
      return new kn();
    }, e.prototype.updateDatumSelection = function(t) {
      return Zc(this, void 0, void 0, function() {
        var i, r, n;
        return Qc(this, function(s) {
          return i = t.nodeData, r = t.datumSelection, n = function(a) {
            return a.xValue;
          }, [2, r.update(i, function(a) {
            return a.tag = vv.Bar;
          }, n)];
        });
      });
    }, e.prototype.updateDatumNodes = function(t) {
      return Zc(this, void 0, void 0, function() {
        var i, r, n, s, a, l, c, d, u, h, p, f, g, v, y, m, C, R, E = this;
        return Qc(this, function(b) {
          return i = t.datumSelection, r = t.isHighlight, n = this, s = n.fill, a = n.stroke, l = n.fillOpacity, c = n.strokeOpacity, d = n.lineDash, u = n.lineDashOffset, h = n.shadow, p = n.formatter, f = n.id, g = n.highlightStyle.item, v = n.ctx, y = n.stackGroup, m = this.axes[de.X], C = P3(m == null ? void 0 : m.visibleRange), R = this.getCategoryDirection() === de.X, i.each(function(T, D) {
            var P = {
              fill: s,
              stroke: a,
              fillOpacity: l,
              strokeOpacity: c,
              lineDash: d,
              lineDashOffset: u,
              fillShadow: h,
              strokeWidth: E.getStrokeWidth(E.strokeWidth, D)
            }, O = R ? D.width > 0 : D.height > 0, M = O3({
              datum: D,
              isHighlighted: r,
              style: P,
              highlightStyle: g,
              formatter: p,
              seriesId: f,
              stackGroup: y,
              ctx: v
            });
            M.crisp = C, M.visible = O, D3({ rect: T, config: M });
          }), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.updateLabelSelection = function(t) {
      return Zc(this, void 0, void 0, function() {
        var i, r, n, s;
        return Qc(this, function(a) {
          return i = t.labelData, r = t.labelSelection, n = this.label.enabled, s = n ? i : [], [2, r.update(s, function(l) {
            l.tag = vv.Label, l.pointerEvents = ki.None;
          })];
        });
      });
    }, e.prototype.updateLabelNodes = function(t) {
      return Zc(this, void 0, void 0, function() {
        var i, r = this;
        return Qc(this, function(n) {
          return i = t.labelSelection, i.each(function(s, a) {
            var l = a.label;
            A3({ labelNode: s, labelDatum: l, config: r.label, visible: !0 });
          }), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.getTooltipHtml = function(t) {
      var i, r = this, n = r.xKey, s = r.yKey, a = r.processedData, l = r.ctx.callbackCache, c = this.getCategoryAxis(), d = this.getValueAxis(), u = t.xValue, h = t.yValue, p = t.datum;
      if (!a || !n || !s || !c || !d)
        return "";
      var f = this, g = f.xName, v = f.yName, y = f.fill, m = f.stroke, C = f.tooltip, R = f.formatter, E = f.id, b = f.stackGroup, T = C.renderer, D = this.getStrokeWidth(this.strokeWidth), P = ai(c.formatDatum(u)), O = ai(d.formatDatum(h)), M = ai(v), _ = P + ": " + O, F = void 0;
      R && (F = l.call(R, {
        datum: p,
        fill: y,
        stroke: m,
        strokeWidth: D,
        highlighted: !1,
        xKey: n,
        yKey: s,
        seriesId: E,
        stackGroup: b
      }));
      var I = (i = F == null ? void 0 : F.fill) !== null && i !== void 0 ? i : y, G = {
        title: M,
        backgroundColor: I,
        content: _
      };
      return T ? Ti(T({
        datum: p,
        xKey: n,
        xValue: u,
        xName: g,
        yKey: s,
        yValue: h,
        yName: v,
        color: I,
        title: M,
        seriesId: E,
        stackGroup: b
      }), G) : Ti(G);
    }, e.prototype.getLegendData = function() {
      var t, i = this, r = i.id, n = i.data, s = i.xKey, a = i.yKey, l = i.yName, c = i.legendItemName, d = i.fill, u = i.stroke, h = i.fillOpacity, p = i.strokeOpacity, f = i.visible, g = i.showInLegend;
      if (!g || !(n != null && n.length) || !s || !a)
        return [];
      var v = [];
      return v.push({
        legendType: "category",
        id: r,
        itemId: a,
        seriesId: r,
        enabled: f,
        label: {
          text: (t = c != null ? c : l) !== null && t !== void 0 ? t : a
        },
        legendItemName: c,
        marker: {
          fill: d,
          stroke: u,
          fillOpacity: h,
          strokeOpacity: p
        }
      }), v;
    }, e.prototype.animateEmptyUpdateReady = function(t) {
      var i = this, r, n, s = t.datumSelections, a = t.labelSelections, l = (n = (r = this.ctx.animationManager) === null || r === void 0 ? void 0 : r.defaultOptions.duration) !== null && n !== void 0 ? n : 1e3, c = 200, d = this.getDirectionStartingValues(s), u = d.startingX, h = d.startingY;
      s.forEach(function(p) {
        p.each(function(f, g) {
          var v, y = u, m = 0, C = g.y, R = g.height;
          i.getBarDirection() === de.Y && (y = g.x, m = g.width, C = h, R = 0);
          var E = [
            { from: y, to: g.x },
            { from: m, to: g.width },
            { from: C, to: g.y },
            { from: R, to: g.height }
          ];
          (v = i.ctx.animationManager) === null || v === void 0 || v.animateMany(i.id + "_empty-update-ready_" + f.id, E, {
            duration: l,
            ease: qd,
            onUpdate: function(b) {
              var T = Jc(b, 4), D = T[0], P = T[1], O = T[2], M = T[3];
              f.x = D, f.width = P, f.y = O, f.height = M;
            }
          });
        });
      }), a.forEach(function(p) {
        p.each(function(f) {
          var g;
          (g = i.ctx.animationManager) === null || g === void 0 || g.animate(i.id + "_empty-update-ready_" + f.id, {
            from: 0,
            to: 1,
            delay: l,
            duration: c,
            onUpdate: function(v) {
              f.opacity = v;
            }
          });
        });
      });
    }, e.prototype.animateReadyHighlight = function(t) {
      this.resetSelectionRects(t);
    }, e.prototype.animateReadyResize = function(t) {
      var i = this, r, n = t.datumSelections;
      (r = this.ctx.animationManager) === null || r === void 0 || r.reset(), n.forEach(function(s) {
        i.resetSelectionRects(s);
      });
    }, e.prototype.animateWaitingUpdateReady = function(t) {
      var i = this, r, n, s, a, l, c = t.datumSelections, d = t.labelSelections, u = this.processedData, h = (r = u == null ? void 0 : u.reduced) === null || r === void 0 ? void 0 : r.diff;
      if (!(h != null && h.changed)) {
        c.forEach(function(D) {
          i.resetSelectionRects(D);
        });
        return;
      }
      var p = (s = (n = this.ctx.animationManager) === null || n === void 0 ? void 0 : n.defaultOptions.duration) !== null && s !== void 0 ? s : 1e3, f = 200, g = p;
      (h.added.length > 0 || h.removed.length > 0) && (g = Math.floor(p / 2));
      var v = this.getDirectionStartingValues(c), y = v.startingX, m = v.startingY, C = (l = (a = this.processedData) === null || a === void 0 ? void 0 : a.defs.keys) === null || l === void 0 ? void 0 : l[0], R = {};
      h.added.forEach(function(D) {
        R[D[0]] = !0;
      });
      var E = {};
      h.removed.forEach(function(D) {
        E[D[0]] = !0;
      });
      var b = this.id + "_" + Math.random(), T = this.id + "_" + Math.random();
      c.forEach(function(D) {
        D.each(function(P, O) {
          var M, _ = [
            { from: P.x, to: O.x },
            { from: P.width, to: O.width },
            { from: P.y, to: O.y },
            { from: P.height, to: O.height }
          ], F = h.removed.length > 0 ? g : 0, I = g, G = !1, k = C ? O.xValue : "", N = y, W = 0, j = O.y, K = O.height;
          i.getBarDirection() === de.Y && (N = O.x, W = O.width, j = m, K = 0);
          var $ = k !== void 0 && R[k] !== void 0, ae = k !== void 0 && E[k] !== void 0;
          $ ? (_ = [
            { from: N, to: O.x },
            { from: W, to: O.width },
            { from: j, to: O.y },
            { from: K, to: O.height }
          ], I = g) : ae && (_ = [
            { from: O.x, to: N },
            { from: O.width, to: W },
            { from: O.y, to: j },
            { from: O.height, to: K }
          ], F = 0, I = g, G = !0), (M = i.ctx.animationManager) === null || M === void 0 || M.animateManyWithThrottle(i.id + "_waiting-update-ready_" + P.id, _, {
            delay: F,
            duration: I,
            ease: qd,
            throttleId: i.id + "_rects",
            throttleGroup: b,
            onUpdate: function(ee) {
              var ne = Jc(ee, 4), Y = ne[0], te = ne[1], se = ne[2], he = ne[3];
              P.x = Y, P.width = te, P.y = se, P.height = he;
            },
            onComplete: function() {
              G && D.cleanup();
            }
          });
        });
      }), d.forEach(function(D) {
        D.each(function(P) {
          var O;
          P.opacity = 0, (O = i.ctx.animationManager) === null || O === void 0 || O.animateWithThrottle(i.id + "_waiting-update-ready_" + P.id, {
            from: 0,
            to: 1,
            delay: p,
            duration: f,
            throttleId: i.id + "_labels",
            throttleGroup: T,
            onUpdate: function(M) {
              P.opacity = M;
            }
          });
        });
      });
    }, e.prototype.resetSelectionRects = function(t) {
      t.each(function(i, r) {
        i.x = r.x, i.y = r.y, i.width = r.width, i.height = r.height;
      }), t.cleanup();
    }, e.prototype.getDirectionStartingValues = function(t) {
      var i = this.getBarDirection() === de.Y, r = this.axes[de.X], n = this.axes[de.Y], s = (r == null ? void 0 : r.scale) instanceof ct, a = (n == null ? void 0 : n.scale) instanceof ct, l = 1 / 0, c = 0;
      return n && i && (a ? c = n.scale.convert(0) : t.forEach(function(d) {
        return d.each(function(u, h) {
          h.yValue >= 0 && (c = Math.max(c, h.height + h.y));
        });
      })), r && !i && (s ? l = r.scale.convert(0) : t.forEach(function(d) {
        return d.each(function(u, h) {
          h.yValue >= 0 && (l = Math.min(l, h.x));
        });
      })), { startingX: l, startingY: c };
    }, e.prototype.isLabelEnabled = function() {
      return this.label.enabled;
    }, e.prototype.getBandScalePadding = function() {
      return { inner: 0.2, outer: 0.3 };
    }, e.prototype.getBarDirection = function() {
      return de.X;
    }, e.prototype.getCategoryDirection = function() {
      return de.Y;
    }, e.className = "BarSeries", e.type = "bar", gi([
      A(St)
    ], e.prototype, "fill", void 0), gi([
      A(St)
    ], e.prototype, "stroke", void 0), gi([
      A(le(0, 1))
    ], e.prototype, "fillOpacity", void 0), gi([
      A(le(0, 1))
    ], e.prototype, "strokeOpacity", void 0), gi([
      A(Au)
    ], e.prototype, "lineDash", void 0), gi([
      A(le(0))
    ], e.prototype, "lineDashOffset", void 0), gi([
      A(Pt)
    ], e.prototype, "formatter", void 0), gi([
      A(De)
    ], e.prototype, "xKey", void 0), gi([
      A(De)
    ], e.prototype, "xName", void 0), gi([
      A(De)
    ], e.prototype, "yKey", void 0), gi([
      A(De)
    ], e.prototype, "yName", void 0), gi([
      A(De)
    ], e.prototype, "stackGroup", void 0), gi([
      A(lt())
    ], e.prototype, "normalizedTo", void 0), gi([
      A(le(0))
    ], e.prototype, "strokeWidth", void 0), e;
  }(mf)
), L3 = (
  /** @class */
  function(o) {
    Km(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.getBarDirection = function() {
      return de.Y;
    }, e.prototype.getCategoryDirection = function() {
      return de.X;
    }, e.type = "column", e.className = "ColumnSeries", e;
  }(gO)
), fw = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), fi = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, ed = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, td = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, qs = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, RE = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, N3 = ["count", "sum", "mean"], G3 = Ee(function(o) {
  return N3.includes(o);
}, "expecting a histogram aggregation keyword such as 'count', 'sum' or 'mean"), mv;
(function(o) {
  o[o.Bin = 0] = "Bin", o[o.Label = 1] = "Label";
})(mv || (mv = {}));
var k3 = (
  /** @class */
  function(o) {
    fw(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.formatter = void 0, t;
    }
    return fi([
      A(Pt)
    ], e.prototype, "formatter", void 0), e;
  }(qn)
), TE = 10, V3 = (
  /** @class */
  function(o) {
    fw(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.renderer = void 0, t;
    }
    return fi([
      A(Pt)
    ], e.prototype, "renderer", void 0), e;
  }(vc)
), B3 = (
  /** @class */
  function(o) {
    fw(e, o);
    function e(t) {
      var i = o.call(this, { moduleCtx: t, pickModes: [Zt.EXACT_SHAPE_MATCH] }) || this;
      return i.label = new k3(), i.tooltip = new V3(), i.fill = void 0, i.stroke = void 0, i.fillOpacity = 1, i.strokeOpacity = 1, i.lineDash = [0], i.lineDashOffset = 0, i.xKey = void 0, i.areaPlot = !1, i.bins = void 0, i.aggregation = "count", i.binCount = void 0, i.xName = void 0, i.yKey = void 0, i.yName = void 0, i.strokeWidth = 1, i.shadow = void 0, i.calculatedBins = [], i.datumSelectionGarbageCollection = !1, i.label.enabled = !1, i;
    }
    return e.prototype.deriveBins = function(t) {
      if (this.binCount === void 0) {
        var i = Wm(t[0], t[1], TE), r = fp(t[0], t[1], TE), n = i[0], s = function(a) {
          return [a, a + r];
        };
        return RE([[n - r, n]], qs(i.map(s)));
      } else
        return this.calculateNiceBins(t, this.binCount);
    }, e.prototype.calculateNiceBins = function(t, i) {
      var r = Math.floor(t[0]), n = t[1], s = i || 1, a = this.calculateNiceStart(r, n, s), l = a.start, c = a.binSize;
      return this.getBins(l, n, c, s);
    }, e.prototype.getBins = function(t, i, r, n) {
      for (var s = [], a = 0; a < n; a++) {
        var l = Math.round((t + a * r) * 10) / 10, c = Math.round((t + (a + 1) * r) * 10) / 10;
        a === n - 1 && (c = Math.max(c, i)), s[a] = [l, c];
      }
      return s;
    }, e.prototype.calculateNiceStart = function(t, i, r) {
      var n = Math.abs(i - t) / r, s = Math.floor(Math.log10(n)), a = Math.pow(10, s), l = Math.floor(t / a) * a;
      return {
        start: l,
        binSize: n
      };
    }, e.prototype.processData = function(t) {
      var i;
      return ed(this, void 0, void 0, function() {
        var r, n, s, a, l, c, d, u, u, h, p, f, g, v = this;
        return td(this, function(y) {
          switch (y.label) {
            case 0:
              return r = this, n = r.xKey, s = r.yKey, a = r.data, l = r.areaPlot, c = r.aggregation, d = [Jb(this, n, !0), yB], s ? (u = w0(this, "groupCount"), c === "count" || (c === "sum" ? u = fB(this, "groupAgg") : c === "mean" && (u = gB(this, "groupAgg"))), l && (u = E0(this, "groupAgg", u)), d.push(wi(this, s, !0, { invalidValue: void 0 }), u)) : (u = w0(this, "groupAgg"), l && (u = E0(this, "groupAgg", u)), d.push(u)), h = function(m) {
                var C, R = mg(m.domain.keys[0]);
                if (R.length === 0)
                  return m.domain.groups = [], function() {
                    return [];
                  };
                var E = (C = v.bins) !== null && C !== void 0 ? C : v.deriveBins(R), b = E.length;
                return v.calculatedBins = RE([], qs(E)), function(T) {
                  for (var D = T.keys[0], P = 0; P < b; P++) {
                    var O = E[P];
                    if (D >= O[0] && D < O[1] || P === b - 1 && D <= O[1])
                      return O;
                  }
                  return [];
                };
              }, !(!((i = this.ctx.animationManager) === null || i === void 0) && i.skipAnimations) && this.processedData && d.push(TD(this.processedData, !1)), [4, t.request(this.id, a != null ? a : [], {
                props: d,
                dataVisible: this.visible,
                groupByFn: h
              })];
            case 1:
              return p = y.sent(), f = p.dataModel, g = p.processedData, this.dataModel = f, this.processedData = g, this.animationState.transition("updateData"), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.getDomain = function(t) {
      var i, r, n, s, a = this, l = a.processedData, c = a.dataModel;
      if (!l || !c)
        return [];
      var d = c.getDomain(this, "groupAgg", "aggregate", l), u = (i = this.calculatedBins) === null || i === void 0 ? void 0 : i[0][0], h = (r = this.calculatedBins) === null || r === void 0 ? void 0 : r[((s = (n = this.calculatedBins) === null || n === void 0 ? void 0 : n.length) !== null && s !== void 0 ? s : 0) - 1][1];
      return t === de.X ? mg([u, h]) : mg(d);
    }, e.prototype.getNodeClickEvent = function(t, i) {
      var r, n;
      return new $m((r = this.xKey) !== null && r !== void 0 ? r : "", (n = this.yKey) !== null && n !== void 0 ? n : "", t, i, this);
    }, e.prototype.getNodeDoubleClickEvent = function(t, i) {
      var r, n;
      return new zm((r = this.xKey) !== null && r !== void 0 ? r : "", (n = this.yKey) !== null && n !== void 0 ? n : "", t, i, this);
    }, e.prototype.createNodeData = function() {
      var t;
      return ed(this, void 0, void 0, function() {
        var i, r, n, s, a, l, c, d, u, h, p, f, g, v, y, m, C, R, E, b, T, D, P, O, M, _, F, I = this;
        return td(this, function(G) {
          return i = this, r = i.axes, n = i.processedData, s = i.ctx.callbackCache, a = r[de.X], l = r[de.Y], !this.visible || !a || !l || !n || n.type !== "grouped" ? [2, []] : (c = a.scale, d = l.scale, u = this, h = u.fill, p = u.stroke, f = u.strokeWidth, g = u.id, v = u.yKey, y = v === void 0 ? "" : v, m = u.xKey, C = m === void 0 ? "" : m, R = [], E = function(k) {
            return String(k.value);
          }, b = this.label, T = b.formatter, D = T === void 0 ? E : T, P = b.fontStyle, O = b.fontWeight, M = b.fontSize, _ = b.fontFamily, F = b.color, n.data.forEach(function(k) {
            var N, W = k.aggValues, j = W === void 0 ? [[0, 0]] : W, K = qs(j, 1), $ = qs(K[0], 2), ae = $[0], ee = $[1], ne = k.datum, Y = k.datum.length, te = k.keys, se = qs(k.keys, 2), he = se[0], be = se[1], ye = c.convert(he), Xe = c.convert(be), Je = ae + ee, We = d.convert(0), Ue = d.convert(Je), J = Xe - ye, ge = Math.abs(Ue - We), Me = Je !== 0 ? {
              text: (N = s.call(D, { value: Je, seriesId: g })) !== null && N !== void 0 ? N : String(Je),
              fontStyle: P,
              fontWeight: O,
              fontSize: M,
              fontFamily: _,
              fill: F,
              x: ye + J / 2,
              y: Ue + ge / 2
            } : void 0, $e = {
              x: ye + J / 2,
              y: Ue + ge / 2
            };
            R.push({
              series: I,
              datum: ne,
              // since each selection is an aggregation of multiple data.
              aggregatedValue: Je,
              frequency: Y,
              domain: te,
              yKey: y,
              xKey: C,
              x: ye,
              y: Ue,
              xValue: ye,
              yValue: Ue,
              width: J,
              height: ge,
              nodeMidPoint: $e,
              fill: h,
              stroke: p,
              strokeWidth: f,
              label: Me
            });
          }), [2, [{ itemId: (t = this.yKey) !== null && t !== void 0 ? t : this.id, nodeData: R, labelData: R }]]);
        });
      });
    }, e.prototype.nodeFactory = function() {
      return new kn();
    }, e.prototype.updateDatumSelection = function(t) {
      return ed(this, void 0, void 0, function() {
        var i, r;
        return td(this, function(n) {
          return i = t.nodeData, r = t.datumSelection, [2, r.update(i, function(s) {
            s.tag = mv.Bin, s.crisp = !0;
          }, function(s) {
            return s.domain.join("_");
          })];
        });
      });
    }, e.prototype.updateDatumNodes = function(t) {
      return ed(this, void 0, void 0, function() {
        var i, r, n, s, a, l, c, d, u, h, p, f, g = this;
        return td(this, function(v) {
          return i = t.datumSelection, r = t.isHighlight, n = this, s = n.fillOpacity, a = n.strokeOpacity, l = n.shadow, c = n.highlightStyle.item, d = c.fill, u = c.fillOpacity, h = u === void 0 ? s : u, p = c.stroke, f = c.strokeWidth, i.each(function(y, m, C) {
            var R, E, b = r && f !== void 0 ? f : m.strokeWidth, T = r ? h : s;
            y.fill = (R = r ? d : void 0) !== null && R !== void 0 ? R : m.fill, y.stroke = (E = r ? p : void 0) !== null && E !== void 0 ? E : m.stroke, y.fillOpacity = T, y.strokeOpacity = a, y.strokeWidth = b, y.lineDash = g.lineDash, y.lineDashOffset = g.lineDashOffset, y.fillShadow = l, y.zIndex = r ? Hm.highlightedZIndex : C, y.visible = m.height > 0;
          }), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.updateLabelSelection = function(t) {
      return ed(this, void 0, void 0, function() {
        var i, r;
        return td(this, function(n) {
          return i = t.labelData, r = t.labelSelection, [2, r.update(i, function(s) {
            s.tag = mv.Label, s.pointerEvents = ki.None, s.textAlign = "center", s.textBaseline = "middle";
          })];
        });
      });
    }, e.prototype.updateLabelNodes = function(t) {
      return ed(this, void 0, void 0, function() {
        var i, r;
        return td(this, function(n) {
          return i = t.labelSelection, r = this.label.enabled, i.each(function(s, a) {
            var l = a.label;
            l && r ? (s.text = l.text, s.x = l.x, s.y = l.y, s.fontStyle = l.fontStyle, s.fontWeight = l.fontWeight, s.fontSize = l.fontSize, s.fontFamily = l.fontFamily, s.fill = l.fill, s.visible = !0) : s.visible = !1;
          }), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.getTooltipHtml = function(t) {
      var i = this, r = i.xKey, n = i.yKey, s = n === void 0 ? "" : n, a = i.axes, l = a[de.X], c = a[de.Y];
      if (!r || !l || !c)
        return "";
      var d = this, u = d.xName, h = d.yName, p = d.fill, f = d.tooltip, g = d.aggregation, v = d.id, y = f.renderer, m = t.aggregatedValue, C = t.frequency, R = t.domain, E = qs(t.domain, 2), b = E[0], T = E[1], D = ai(u != null ? u : r) + ": " + l.formatDatum(b) + " - " + l.formatDatum(T), P = s ? "<b>" + ai(h != null ? h : s) + " (" + g + ")</b>: " + c.formatDatum(m) + "<br>" : "";
      P += "<b>Frequency</b>: " + C;
      var O = {
        title: D,
        backgroundColor: p,
        content: P
      };
      return y ? Ti(y({
        datum: {
          data: t.datum,
          aggregatedValue: t.aggregatedValue,
          domain: t.domain,
          frequency: t.frequency
        },
        xKey: r,
        xValue: R,
        xName: u,
        yKey: s,
        yValue: m,
        yName: h,
        color: p,
        title: D,
        seriesId: v
      }), O) : Ti(O);
    }, e.prototype.getLegendData = function() {
      var t, i = this, r = i.id, n = i.data, s = i.xKey, a = i.yName, l = i.visible, c = i.fill, d = i.stroke, u = i.fillOpacity, h = i.strokeOpacity;
      if (!n || n.length === 0)
        return [];
      var p = [
        {
          legendType: "category",
          id: r,
          itemId: s,
          seriesId: r,
          enabled: l,
          label: {
            text: (t = a != null ? a : s) !== null && t !== void 0 ? t : "Frequency"
          },
          marker: {
            fill: c != null ? c : "rgba(0, 0, 0, 0)",
            stroke: d != null ? d : "rgba(0, 0, 0, 0)",
            fillOpacity: u,
            strokeOpacity: h
          }
        }
      ];
      return p;
    }, e.prototype.animateEmptyUpdateReady = function(t) {
      var i = this, r, n, s = t.datumSelections, a = t.labelSelections, l = (n = (r = this.ctx.animationManager) === null || r === void 0 ? void 0 : r.defaultOptions.duration) !== null && n !== void 0 ? n : 1e3, c = 200, d = 0;
      s.forEach(function(u) {
        return u.each(function(h, p) {
          d = Math.max(d, p.height + p.y);
        });
      }), s.forEach(function(u) {
        u.each(function(h, p) {
          var f;
          (f = i.ctx.animationManager) === null || f === void 0 || f.animateMany(i.id + "_empty-update-ready_" + h.id, [
            { from: d, to: p.y },
            { from: 0, to: p.height }
          ], {
            duration: l,
            ease: qd,
            onUpdate: function(g) {
              var v = qs(g, 2), y = v[0], m = v[1];
              h.y = y, h.height = m, h.x = p.x, h.width = p.width;
            }
          });
        });
      }), a.forEach(function(u) {
        u.each(function(h) {
          var p;
          (p = i.ctx.animationManager) === null || p === void 0 || p.animate(i.id + "_empty-update-ready_" + h.id, {
            from: 0,
            to: 1,
            delay: l,
            duration: c,
            onUpdate: function(f) {
              h.opacity = f;
            }
          });
        });
      });
    }, e.prototype.animateReadyUpdate = function(t) {
      var i = this, r = t.datumSelections;
      r.forEach(function(n) {
        i.resetSelectionRects(n);
      });
    }, e.prototype.animateReadyHighlight = function(t) {
      this.resetSelectionRects(t);
    }, e.prototype.animateReadyResize = function(t) {
      var i = this, r, n = t.datumSelections;
      (r = this.ctx.animationManager) === null || r === void 0 || r.reset(), n.forEach(function(s) {
        i.resetSelectionRects(s);
      });
    }, e.prototype.animateWaitingUpdateReady = function(t) {
      var i = this, r, n, s, a = t.datumSelections, l = t.labelSelections, c = this.processedData, d = (r = c == null ? void 0 : c.reduced) === null || r === void 0 ? void 0 : r.diff;
      if (!(d != null && d.changed)) {
        a.forEach(function(y) {
          i.resetSelectionRects(y);
        });
        return;
      }
      var u = (s = (n = this.ctx.animationManager) === null || n === void 0 ? void 0 : n.defaultOptions.duration) !== null && s !== void 0 ? s : 1e3, h = 200, p = u;
      d.added.length > 0 && d.removed.length > 0 ? p = Math.floor(u / 3) : (d.added.length > 0 || d.removed.length > 0) && (p = Math.floor(u / 2));
      var f = 0;
      a.forEach(function(y) {
        return y.each(function(m, C) {
          f = Math.max(f, C.height + C.y);
        });
      });
      var g = {};
      d.added.forEach(function(y) {
        g[y.join("_")] = !0;
      });
      var v = {};
      d.removed.forEach(function(y) {
        v[y.join("_")] = !0;
      }), a.forEach(function(y) {
        y.each(function(m, C) {
          var R, E = [
            { from: m.x, to: C.x },
            { from: m.width, to: C.width },
            { from: m.y, to: C.y },
            { from: m.height, to: C.height }
          ], b = d.removed.length > 0 ? p : 0, T = !1, D = C.domain.join("_"), P = f, O = 0;
          D !== void 0 && g[D] !== void 0 ? (E = [
            { from: C.x, to: C.x },
            { from: C.width, to: C.width },
            { from: P, to: C.y },
            { from: O, to: C.height }
          ], b += p) : D !== void 0 && v[D] !== void 0 && (E = [
            { from: m.x, to: C.x },
            { from: m.width, to: C.width },
            { from: C.y, to: P },
            { from: C.height, to: O }
          ], b = 0, T = !0), (R = i.ctx.animationManager) === null || R === void 0 || R.animateMany(i.id + "_waiting-update-ready_" + m.id, E, {
            disableInteractions: !0,
            delay: b,
            duration: p,
            ease: qd,
            repeat: 0,
            onUpdate: function(M) {
              var _ = qs(M, 4), F = _[0], I = _[1], G = _[2], k = _[3];
              m.x = F, m.width = I, m.y = G, m.height = k;
            },
            onComplete: function() {
              T && y.cleanup();
            }
          });
        });
      }), l.forEach(function(y) {
        y.each(function(m) {
          var C;
          m.opacity = 0, (C = i.ctx.animationManager) === null || C === void 0 || C.animate(i.id + "_waiting-update-ready_" + m.id, {
            from: 0,
            to: 1,
            delay: u,
            duration: h,
            ease: _D,
            repeat: 0,
            onUpdate: function(R) {
              m.opacity = R;
            }
          });
        });
      });
    }, e.prototype.resetSelectionRects = function(t) {
      t.each(function(i, r) {
        i.x = r.x, i.y = r.y, i.width = r.width, i.height = r.height;
      });
    }, e.prototype.isLabelEnabled = function() {
      return this.label.enabled;
    }, e.className = "HistogramSeries", e.type = "histogram", fi([
      A(St)
    ], e.prototype, "fill", void 0), fi([
      A(St)
    ], e.prototype, "stroke", void 0), fi([
      A(le(0, 1))
    ], e.prototype, "fillOpacity", void 0), fi([
      A(le(0, 1))
    ], e.prototype, "strokeOpacity", void 0), fi([
      A(Au)
    ], e.prototype, "lineDash", void 0), fi([
      A(le(0))
    ], e.prototype, "lineDashOffset", void 0), fi([
      A(De)
    ], e.prototype, "xKey", void 0), fi([
      A(ht)
    ], e.prototype, "areaPlot", void 0), fi([
      A(Yb())
    ], e.prototype, "bins", void 0), fi([
      A(G3)
    ], e.prototype, "aggregation", void 0), fi([
      A(lt(0))
    ], e.prototype, "binCount", void 0), fi([
      A(De)
    ], e.prototype, "xName", void 0), fi([
      A(De)
    ], e.prototype, "yKey", void 0), fi([
      A(De)
    ], e.prototype, "yName", void 0), fi([
      A(le(0))
    ], e.prototype, "strokeWidth", void 0), e;
  }(mf)
), gw = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), md = function() {
  return md = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, md.apply(this, arguments);
}, mr = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, id = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, rd = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, xE = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, H3 = (
  /** @class */
  function(o) {
    gw(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.formatter = void 0, t;
    }
    return mr([
      A(Pt)
    ], e.prototype, "formatter", void 0), e;
  }(qn)
), W3 = (
  /** @class */
  function(o) {
    gw(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.renderer = void 0, t.format = void 0, t;
    }
    return mr([
      A(Pt)
    ], e.prototype, "renderer", void 0), mr([
      A(De)
    ], e.prototype, "format", void 0), e;
  }(vc)
), j3 = (
  /** @class */
  function(o) {
    gw(e, o);
    function e(t) {
      var i = o.call(this, {
        moduleCtx: t,
        hasMarkers: !0,
        pickModes: [
          Zt.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST,
          Zt.NEAREST_NODE,
          Zt.EXACT_SHAPE_MATCH
        ]
      }) || this;
      i.marker = new uw(), i.label = new H3(), i.title = void 0, i.stroke = "#874349", i.lineDash = [0], i.lineDashOffset = 0, i.strokeWidth = 2, i.strokeOpacity = 1, i.tooltip = new W3(), i.xKey = void 0, i.xName = void 0, i.yKey = void 0, i.yName = void 0;
      var r = i, n = r.marker, s = r.label;
      return n.fill = "#c16068", n.stroke = "#874349", s.enabled = !1, i;
    }
    return e.prototype.processData = function(t) {
      return id(this, void 0, void 0, function() {
        var i, r, n, s, a, l, c, d, u, h, p, f, g, v;
        return rd(this, function(y) {
          switch (y.label) {
            case 0:
              return i = this, r = i.axes, n = i.xKey, s = n === void 0 ? "" : n, a = i.yKey, l = a === void 0 ? "" : a, c = s && l && this.data ? this.data : [], d = r[de.X], u = r[de.Y], h = (d == null ? void 0 : d.scale) instanceof ct, p = (u == null ? void 0 : u.scale) instanceof ct, [4, t.request(this.id, c != null ? c : [], {
                props: [
                  wi(this, s, h, { id: "xValue" }),
                  wi(this, l, p, { id: "yValue", invalidValue: void 0 })
                ],
                dataVisible: this.visible
              })];
            case 1:
              return f = y.sent(), g = f.dataModel, v = f.processedData, this.dataModel = g, this.processedData = v, [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.getDomain = function(t) {
      var i = this, r = i.axes, n = i.dataModel, s = i.processedData;
      if (!s || !n)
        return [];
      var a = r[de.X], l = r[de.Y], c = n.resolveProcessedDataDefById(this, "xValue");
      if (t === de.X) {
        var d = n.getDomain(this, "xValue", "value", s);
        return (c == null ? void 0 : c.def.type) === "value" && c.def.valueType === "category" ? d : this.fixNumericExtent(Uo(d), a);
      } else {
        var d = n.getDomain(this, "yValue", "value", s);
        return this.fixNumericExtent(d, l);
      }
    }, e.prototype.createNodeData = function() {
      var t, i, r, n, s;
      return id(this, void 0, void 0, function() {
        var a, l, c, d, u, h, p, f, g, v, y, m, C, R, E, b, T, D, P, O, M, _, F, I, G, k, N, W, j, K, $, ae, ee, ne, Y, te, se, he, be, ye, Xe, Je, We;
        return rd(this, function(Ue) {
          if (a = this, l = a.processedData, c = a.dataModel, d = a.axes, u = a.marker, h = u.enabled, p = u.size, f = u.strokeWidth, g = a.ctx.callbackCache, v = d[de.X], y = d[de.Y], !l || !c || !v || !y)
            return [2, []];
          for (m = this, C = m.label, R = m.yKey, E = R === void 0 ? "" : R, b = m.xKey, T = b === void 0 ? "" : b, D = m.id, P = v.scale, O = y.scale, M = ((t = P.bandwidth) !== null && t !== void 0 ? t : 0) / 2, _ = ((i = O.bandwidth) !== null && i !== void 0 ? i : 0) / 2, F = new Array(l.data.length), I = h ? p : 0, G = c.resolveProcessedDataIndexById(this, "xValue").index, k = c.resolveProcessedDataIndexById(this, "yValue").index, N = !0, W = void 0, j = void 0, K = 0, $ = 0; $ < l.data.length; $++)
            if (ae = j != null ? j : l.data[$], ee = ae.datum, ne = ae.values, Y = ne[G], te = ne[k], te === void 0)
              W = void 0, N = !0;
            else {
              if (se = P.convert(Y) + M, isNaN(se)) {
                W = void 0, N = !0, j = void 0;
                continue;
              }
              if (he = ((r = P.bandwidth) !== null && r !== void 0 ? r : p * 0.5 + (f != null ? f : 0)) + 1, j = ((n = l.data[$ + 1]) === null || n === void 0 ? void 0 : n.values[k]) === void 0 ? void 0 : l.data[$ + 1], be = (s = l.data[$ + 1]) === null || s === void 0 ? void 0 : s.values[G], ye = v.inRangeEx(se, 0, he), Xe = j && v.inRangeEx(P.convert(be) + M, 0, he), ye === -1 && Xe === -1) {
                N = !0;
                continue;
              }
              if (ye === 1 && W === 1) {
                N = !0;
                continue;
              }
              W = ye, Je = O.convert(te) + _, We = void 0, C.formatter && (We = g.call(C.formatter, { value: te, seriesId: D })), We !== void 0 || (typeof te == "number" && isFinite(te) ? We = te.toFixed(2) : te && (We = String(te))), F[K++] = {
                series: this,
                datum: ee,
                yKey: E,
                xKey: T,
                point: { x: se, y: Je, moveTo: N, size: I },
                nodeMidPoint: { x: se, y: Je },
                yValue: te,
                xValue: Y,
                label: We ? {
                  text: We,
                  fontStyle: C.fontStyle,
                  fontWeight: C.fontWeight,
                  fontSize: C.fontSize,
                  fontFamily: C.fontFamily,
                  textAlign: "center",
                  textBaseline: "bottom",
                  fill: C.color
                } : void 0
              }, N = !1;
            }
          return F.length = K, [2, [{ itemId: E, nodeData: F, labelData: F }]];
        });
      });
    }, e.prototype.isPathOrSelectionDirty = function() {
      return this.marker.isDirty();
    }, e.prototype.markerFactory = function() {
      var t = this.marker.shape, i = Mu(t);
      return new i();
    }, e.prototype.updateMarkerSelection = function(t) {
      return id(this, void 0, void 0, function() {
        var i, r, n, s, a;
        return rd(this, function(l) {
          return i = t.nodeData, r = t.markerSelection, n = this.marker, s = n.shape, a = n.enabled, i = s && a ? i : [], this.marker.isDirty() && r.clear(), [2, r.update(i)];
        });
      });
    }, e.prototype.updateMarkerNodes = function(t) {
      var i;
      return id(this, void 0, void 0, function() {
        var r, n, s, a, l, c, d, u, h, p, f, g, v, y, m, C, R, E, b, T, D, P, O;
        return rd(this, function(M) {
          return r = t.markerSelection, n = t.isHighlight, s = this, a = s.marker, l = s.marker.fillOpacity, c = s.xKey, d = c === void 0 ? "" : c, u = s.yKey, h = u === void 0 ? "" : u, p = s.stroke, f = s.strokeOpacity, g = s.highlightStyle.item, v = g.fill, y = g.fillOpacity, m = y === void 0 ? l : y, C = g.stroke, R = g.strokeWidth, E = s.id, b = s.ctx.callbackCache, T = a.size, D = a.formatter, P = (i = a.strokeWidth) !== null && i !== void 0 ? i : this.strokeWidth, O = typeof a.shape == "function", r.each(function(_, F) {
            var I, G, k, N, W, j, K, $ = n && v !== void 0 ? v : a.fill, ae = n ? m : l, ee = n && C !== void 0 ? C : (I = a.stroke) !== null && I !== void 0 ? I : p, ne = n && R !== void 0 ? R : P, Y = void 0;
            D && (Y = b.call(D, {
              datum: F.datum,
              xKey: d,
              yKey: h,
              fill: $,
              stroke: ee,
              strokeWidth: ne,
              size: T,
              highlighted: n,
              seriesId: E
            })), _.fill = (G = Y == null ? void 0 : Y.fill) !== null && G !== void 0 ? G : $, _.stroke = (k = Y == null ? void 0 : Y.stroke) !== null && k !== void 0 ? k : ee, _.strokeWidth = (N = Y == null ? void 0 : Y.strokeWidth) !== null && N !== void 0 ? N : ne, _.fillOpacity = ae != null ? ae : 1, _.strokeOpacity = (j = (W = a.strokeOpacity) !== null && W !== void 0 ? W : f) !== null && j !== void 0 ? j : 1, _.size = (K = Y == null ? void 0 : Y.size) !== null && K !== void 0 ? K : T, _.translationX = F.point.x, _.translationY = F.point.y, _.visible = _.size > 0 && !isNaN(F.point.x) && !isNaN(F.point.y), !(!O || _.dirtyPath) && (_.path.clear({ trackChanges: !0 }), _.updatePath(), _.checkPathDirty());
          }), n || this.marker.markClean(), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.updateLabelSelection = function(t) {
      return id(this, void 0, void 0, function() {
        var i, r, n, s, a;
        return rd(this, function(l) {
          return i = t.labelData, r = t.labelSelection, n = this.marker, s = n.shape, a = n.enabled, i = s && a ? i : [], [2, r.update(i)];
        });
      });
    }, e.prototype.updateLabelNodes = function(t) {
      return id(this, void 0, void 0, function() {
        var i, r, n, s, a, l, c, d;
        return rd(this, function(u) {
          return i = t.labelSelection, r = this.label, n = r.enabled, s = r.fontStyle, a = r.fontWeight, l = r.fontSize, c = r.fontFamily, d = r.color, i.each(function(h, p) {
            var f = p.point, g = p.label;
            p && g && n ? (h.fontStyle = s, h.fontWeight = a, h.fontSize = l, h.fontFamily = c, h.textAlign = g.textAlign, h.textBaseline = g.textBaseline, h.text = g.text, h.x = f.x, h.y = f.y - 10, h.fill = d, h.visible = !0) : h.visible = !1;
          }), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.getNodeClickEvent = function(t, i) {
      var r, n;
      return new $m((r = this.xKey) !== null && r !== void 0 ? r : "", (n = this.yKey) !== null && n !== void 0 ? n : "", t, i, this);
    }, e.prototype.getNodeDoubleClickEvent = function(t, i) {
      var r, n;
      return new zm((r = this.xKey) !== null && r !== void 0 ? r : "", (n = this.yKey) !== null && n !== void 0 ? n : "", t, i, this);
    }, e.prototype.getTooltipHtml = function(t) {
      var i, r, n = this, s = n.xKey, a = n.yKey, l = n.axes, c = l[de.X], d = l[de.Y];
      if (!s || !a || !c || !d)
        return "";
      var u = this, h = u.xName, p = u.yName, f = u.tooltip, g = u.marker, v = u.id, y = f.renderer, m = f.format, C = t.datum, R = t.xValue, E = t.yValue, b = c.formatDatum(R), T = d.formatDatum(E), D = ai((i = this.title) !== null && i !== void 0 ? i : p), P = ai(b + ": " + T), O = g.formatter, M = g.fill, _ = g.stroke, F = g.strokeWidth, I = g.size, G = F != null ? F : this.strokeWidth, k = void 0;
      O && (k = O({
        datum: C,
        xKey: s,
        yKey: a,
        fill: M,
        stroke: _,
        strokeWidth: G,
        size: I,
        highlighted: !1,
        seriesId: v
      }));
      var N = (r = k == null ? void 0 : k.fill) !== null && r !== void 0 ? r : M, W = {
        title: D,
        backgroundColor: N,
        content: P
      };
      if (m || y) {
        var j = {
          datum: C,
          xKey: s,
          xValue: R,
          xName: h,
          yKey: a,
          yValue: E,
          yName: p,
          title: D,
          color: N,
          seriesId: v
        };
        if (m)
          return Ti({
            content: hw(m, j)
          }, W);
        if (y)
          return Ti(y(j), W);
      }
      return Ti(W);
    }, e.prototype.getLegendData = function() {
      var t, i, r, n, s, a, l, c = this, d = c.id, u = c.data, h = c.xKey, p = c.yKey, f = c.yName, g = c.visible, v = c.title, y = c.marker, m = c.stroke, C = c.strokeOpacity;
      if (!(u != null && u.length && h && p))
        return [];
      var R = [
        {
          legendType: "category",
          id: d,
          itemId: p,
          seriesId: d,
          enabled: g,
          label: {
            text: (t = v != null ? v : f) !== null && t !== void 0 ? t : p
          },
          marker: {
            shape: y.shape,
            fill: (i = y.fill) !== null && i !== void 0 ? i : "rgba(0, 0, 0, 0)",
            stroke: (n = (r = y.stroke) !== null && r !== void 0 ? r : m) !== null && n !== void 0 ? n : "rgba(0, 0, 0, 0)",
            fillOpacity: (s = y.fillOpacity) !== null && s !== void 0 ? s : 1,
            strokeOpacity: (l = (a = y.strokeOpacity) !== null && a !== void 0 ? a : C) !== null && l !== void 0 ? l : 1
          }
        }
      ];
      return R;
    }, e.prototype.animateEmptyUpdateReady = function(t) {
      var i = this, r = t.markerSelections, n = t.labelSelections, s = t.contextData, a = t.paths;
      s.forEach(function(l, c) {
        var d, u, h, p = l.nodeData, f = xE(a[c], 1), g = f[0], v = g.path, y = [0], m = p.reduce(function(b, T, D) {
          if (D === 0)
            return b;
          var P = p[D - 1];
          if (isNaN(T.point.x) || isNaN(T.point.y) || isNaN(P.point.x) || isNaN(P.point.y))
            return y.push(b), b;
          var O = Math.sqrt(Math.pow(T.point.x - P.point.x, 2) + Math.pow(T.point.y - P.point.y, 2));
          return y.push(b + O), b + O;
        }, 0);
        g.fill = void 0, g.lineJoin = "round", g.pointerEvents = ki.None, g.stroke = i.stroke, g.strokeWidth = i.getStrokeWidth(i.strokeWidth), g.strokeOpacity = i.strokeOpacity, g.lineDash = i.lineDash, g.lineDashOffset = i.lineDashOffset;
        var C = (u = (d = i.ctx.animationManager) === null || d === void 0 ? void 0 : d.defaultOptions.duration) !== null && u !== void 0 ? u : 1e3, R = 200, E = {
          from: 0,
          to: m
        };
        (h = i.ctx.animationManager) === null || h === void 0 || h.animate(i.id + "_empty-update-ready", md(md({}, E), { duration: C, onUpdate: function(b) {
          v.clear({ trackChanges: !0 }), p.forEach(function(T, D) {
            if (y[D] <= b)
              T.point.moveTo ? v.moveTo(T.point.x, T.point.y) : v.lineTo(T.point.x, T.point.y);
            else if (D > 0 && y[D - 1] < b) {
              var P = p[D - 1].point, O = T.point, M = y[D] - y[D - 1], _ = y[D] - b, F = (M - _) / M, I = (1 - F) * P.x + F * O.x, G = (1 - F) * P.y + F * O.y;
              T.point.moveTo ? v.moveTo(I, G) : v.lineTo(I, G);
            }
          }), g.checkPathDirty();
        } })), r[c].each(function(b, T, D) {
          var P, O, M, _, F = m > 0 ? y[D] / m * C : 0, I = i.animateFormatter(T), G = (O = (P = T.point) === null || P === void 0 ? void 0 : P.size) !== null && O !== void 0 ? O : 0;
          (M = i.ctx.animationManager) === null || M === void 0 || M.animate(i.id + "_empty-update-ready_" + b.id, md(md({}, E), { to: (_ = I == null ? void 0 : I.size) !== null && _ !== void 0 ? _ : G, delay: F, duration: R, onUpdate: function(k) {
            b.size = k;
          } }));
        }), n[c].each(function(b, T, D) {
          var P, O = y[D] / m * C;
          (P = i.ctx.animationManager) === null || P === void 0 || P.animate(i.id + "_empty-update-ready_" + b.id, {
            from: 0,
            to: 1,
            delay: O,
            duration: R,
            onUpdate: function(M) {
              b.opacity = M;
            }
          });
        });
      });
    }, e.prototype.animateReadyUpdate = function(t) {
      this.resetMarkersAndPaths(t);
    }, e.prototype.animateReadyResize = function(t) {
      var i;
      (i = this.ctx.animationManager) === null || i === void 0 || i.reset(), this.resetMarkersAndPaths(t);
    }, e.prototype.resetMarkersAndPaths = function(t) {
      var i = this, r = t.markerSelections, n = t.contextData, s = t.paths;
      n.forEach(function(a, l) {
        var c = a.nodeData, d = xE(s[l], 1), u = d[0], h = u.path;
        u.stroke = i.stroke, u.strokeWidth = i.getStrokeWidth(i.strokeWidth), u.strokeOpacity = i.strokeOpacity, u.lineDash = i.lineDash, u.lineDashOffset = i.lineDashOffset, h.clear({ trackChanges: !0 }), c.forEach(function(p) {
          p.point.moveTo ? h.moveTo(p.point.x, p.point.y) : h.lineTo(p.point.x, p.point.y);
        }), u.checkPathDirty(), r[l].each(function(p, f) {
          var g, v, y, m = i.animateFormatter(f), C = (v = (g = f.point) === null || g === void 0 ? void 0 : g.size) !== null && v !== void 0 ? v : 0;
          p.size = (y = m == null ? void 0 : m.size) !== null && y !== void 0 ? y : C;
        });
      });
    }, e.prototype.animateFormatter = function(t) {
      var i, r, n = this, s = n.marker, a = n.xKey, l = a === void 0 ? "" : a, c = n.yKey, d = c === void 0 ? "" : c, u = n.stroke, h = n.id, p = n.ctx.callbackCache, f = s.size, g = s.formatter, v = s.fill, y = (i = s.stroke) !== null && i !== void 0 ? i : u, m = (r = s.strokeWidth) !== null && r !== void 0 ? r : this.strokeWidth, C = void 0;
      return g && (C = p.call(g, {
        datum: t.datum,
        xKey: l,
        yKey: d,
        fill: v,
        stroke: y,
        strokeWidth: m,
        size: f,
        highlighted: !1,
        seriesId: h
      })), C;
    }, e.prototype.isLabelEnabled = function() {
      return this.label.enabled;
    }, e.className = "LineSeries", e.type = "line", mr([
      A(De)
    ], e.prototype, "title", void 0), mr([
      A(St)
    ], e.prototype, "stroke", void 0), mr([
      A(Au)
    ], e.prototype, "lineDash", void 0), mr([
      A(le(0))
    ], e.prototype, "lineDashOffset", void 0), mr([
      A(le(0))
    ], e.prototype, "strokeWidth", void 0), mr([
      A(le(0, 1))
    ], e.prototype, "strokeOpacity", void 0), mr([
      A(De)
    ], e.prototype, "xKey", void 0), mr([
      A(De)
    ], e.prototype, "xName", void 0), mr([
      A(De)
    ], e.prototype, "yKey", void 0), mr([
      A(De)
    ], e.prototype, "yName", void 0), e;
  }(mf)
), vw = (
  /** @class */
  function() {
    function o() {
      this.domain = [0, 1], this.range = ["red", "blue"], this.parsedRange = this.range.map(function(e) {
        return Kt.fromString(e);
      });
    }
    return o.prototype.update = function() {
      var e = this, t = e.domain, i = e.range;
      t.length < 2 && (pe.warnOnce("`colorDomain` should have at least 2 values."), t.length === 0 ? t.push(0, 1) : t.length === 1 && t.push(t[0] + 1));
      for (var r = 1; r < t.length; r++) {
        var n = t[r - 1], s = t[r];
        if (n >= s) {
          pe.warnOnce("`colorDomain` values should be supplied in ascending order."), t.sort(function(l, c) {
            return l - c;
          });
          break;
        }
      }
      var a = i.length < t.length;
      if (a || t.length > 2 && i.length > t.length)
        if (pe.warnOnce("Number of elements in `colorRange` needs to match the number of elements in `colorDomain`."), a)
          for (var r = i.length; r < t.length; r++)
            i.push("black");
        else
          i.splice(t.length);
      this.parsedRange = this.range.map(function(l) {
        return Kt.fromString(l);
      });
    }, o.prototype.convert = function(e) {
      var t = this, i = t.domain, r = t.range, n = t.parsedRange, s = i[0], a = i[i.length - 1], l = r[0], c = r[r.length - 1];
      if (e <= s)
        return l;
      if (e >= a)
        return c;
      var d, u;
      if (i.length === 2) {
        var h = (e - s) / (a - s), p = 1 / (r.length - 1);
        d = r.length <= 2 ? 0 : Math.min(Math.floor(h * (r.length - 1)), r.length - 2), u = (h - d * p) / p;
      } else {
        for (d = 0; d < i.length - 2 && !(e < i[d + 1]); d++)
          ;
        var f = i[d], g = i[d + 1];
        u = (e - f) / (g - f);
      }
      var v = n[d], y = n[d + 1];
      return AD(v, y)(u);
    }, o;
  }()
), Iu = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), _h = function() {
  return _h = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, _h.apply(this, arguments);
}, Ui = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, nd = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, od = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, tC = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, iC = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, U3 = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, $3 = (
  /** @class */
  function(o) {
    Iu(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.formatter = void 0, t;
    }
    return Ui([
      A(Pt)
    ], e.prototype, "formatter", void 0), e;
  }(qn)
), vO = (
  /** @class */
  function(o) {
    Iu(e, o);
    function e(t, i, r, n, s, a) {
      var l = o.call(this, i, r, n, s, a) || this;
      return l.sizeKey = t, l;
    }
    return e;
  }(dw)
), z3 = (
  /** @class */
  function(o) {
    Iu(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.type = "nodeClick", t;
    }
    return e;
  }(vO)
), K3 = (
  /** @class */
  function(o) {
    Iu(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.type = "nodeDoubleClick", t;
    }
    return e;
  }(vO)
), Y3 = (
  /** @class */
  function(o) {
    Iu(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.renderer = void 0, t;
    }
    return Ui([
      A(Pt)
    ], e.prototype, "renderer", void 0), e;
  }(vc)
), X3 = (
  /** @class */
  function(o) {
    Iu(e, o);
    function e(t) {
      var i = o.call(this, {
        moduleCtx: t,
        pickModes: [
          Zt.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST,
          Zt.NEAREST_NODE,
          Zt.EXACT_SHAPE_MATCH
        ],
        pathsPerSeries: 0,
        hasMarkers: !0
      }) || this;
      i.sizeScale = new ri(), i.marker = new uw(), i.label = new $3(), i.title = void 0, i.labelKey = void 0, i.xName = void 0, i.yName = void 0, i.sizeName = "Size", i.labelName = "Label", i.xKey = void 0, i.yKey = void 0, i.sizeKey = void 0, i.colorKey = void 0, i.colorName = "Color", i.colorDomain = void 0, i.colorRange = ["#ffff00", "#00ff00", "#0000ff"], i.colorScale = new vw(), i.tooltip = new Y3();
      var r = i.label;
      return r.enabled = !1, i;
    }
    return e.prototype.processData = function(t) {
      var i, r;
      return nd(this, void 0, void 0, function() {
        var n, s, a, l, c, d, u, h, p, f, g, v, y, m, C, R, E, b, T, D, P, O, M, _, F;
        return od(this, function(I) {
          switch (I.label) {
            case 0:
              return n = this, s = n.xKey, a = s === void 0 ? "" : s, l = n.yKey, c = l === void 0 ? "" : l, d = n.sizeKey, u = n.labelKey, h = n.axes, p = n.marker, f = n.data, g = h[de.X], v = h[de.Y], y = (g == null ? void 0 : g.scale) instanceof ct, m = (v == null ? void 0 : v.scale) instanceof ct, C = this, R = C.colorScale, E = C.colorDomain, b = C.colorRange, T = C.colorKey, [4, t.request(this.id, f != null ? f : [], {
                props: iC(iC(iC([
                  wi(this, a, y, { id: "xValue" }),
                  wi(this, c, m, { id: "yValue" })
                ], tC(d ? [wi(this, d, !0, { id: "sizeValue" })] : [])), tC(T ? [wi(this, T, !0, { id: "colorValue" })] : [])), tC(u ? [wi(this, u, !1, { id: "labelValue" })] : [])),
                dataVisible: this.visible
              })];
            case 1:
              return D = I.sent(), P = D.dataModel, O = D.processedData, this.dataModel = P, this.processedData = O, d && (M = P.resolveProcessedDataIndexById(this, "sizeValue").index, _ = (i = O.domain.values[M]) !== null && i !== void 0 ? i : [], this.sizeScale.domain = p.domain ? p.domain : _), T && (F = P.resolveProcessedDataIndexById(this, "colorValue").index, R.domain = (r = E != null ? E : O.domain.values[F]) !== null && r !== void 0 ? r : [], R.range = b, R.update()), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.getDomain = function(t) {
      var i = this, r = i.dataModel, n = i.processedData;
      if (!n || !r)
        return [];
      var s = t === de.X ? "xValue" : "yValue", a = r.resolveProcessedDataDefById(this, s, "value"), l = r.getDomain(this, s, "value", n);
      if ((a == null ? void 0 : a.def.type) === "value" && (a == null ? void 0 : a.def.valueType) === "category")
        return l;
      var c = this.axes[t];
      return this.fixNumericExtent(Uo(l), c);
    }, e.prototype.getNodeClickEvent = function(t, i) {
      var r, n;
      return new z3(this.sizeKey, (r = this.xKey) !== null && r !== void 0 ? r : "", (n = this.yKey) !== null && n !== void 0 ? n : "", t, i, this);
    }, e.prototype.getNodeDoubleClickEvent = function(t, i) {
      var r, n;
      return new K3(this.sizeKey, (r = this.xKey) !== null && r !== void 0 ? r : "", (n = this.yKey) !== null && n !== void 0 ? n : "", t, i, this);
    }, e.prototype.createNodeData = function() {
      var t, i, r, n, s, a;
      return nd(this, void 0, void 0, function() {
        var l, c, d, u, h, p, f, g, v, y, m, C, R, E, b, T, D, P, O, M, _, F, I, G, k, N, W, j, K, $, ae, ee, ne, Y, te, se, he, be, ye, Xe, Je, We, Ue, J, ge, Me, $e, At, di;
        return od(this, function(Rn) {
          if (l = this, c = l.visible, d = l.axes, u = l.yKey, h = u === void 0 ? "" : u, p = l.xKey, f = p === void 0 ? "" : p, g = l.label, v = l.labelKey, y = l.ctx.callbackCache, m = l.dataModel, C = l.processedData, R = d[de.X], E = d[de.Y], !(m && C && c && R && E))
            return [2, []];
          b = m.resolveProcessedDataIndexById(this, "xValue").index, T = m.resolveProcessedDataIndexById(this, "yValue").index, D = this.sizeKey ? m.resolveProcessedDataIndexById(this, "sizeValue").index : -1, P = this.colorKey ? m.resolveProcessedDataIndexById(this, "colorValue").index : -1, O = this.labelKey ? m.resolveProcessedDataIndexById(this, "labelValue").index : -1, M = this, _ = M.colorScale, F = M.sizeKey, I = M.colorKey, G = M.id, k = R.scale, N = E.scale, W = ((t = k.bandwidth) !== null && t !== void 0 ? t : 0) / 2, j = ((i = N.bandwidth) !== null && i !== void 0 ? i : 0) / 2, K = this, $ = K.sizeScale, ae = K.marker, ee = new Array((n = (r = this.processedData) === null || r === void 0 ? void 0 : r.data.length) !== null && n !== void 0 ? n : 0), $.range = [ae.size, ae.maxSize], ne = g.getFont(), Y = 0;
          try {
            for (te = U3((s = C.data) !== null && s !== void 0 ? s : []), se = te.next(); !se.done; se = te.next())
              he = se.value, be = he.values, ye = he.datum, Xe = be[b], Je = be[T], We = k.convert(Xe) + W, Ue = N.convert(Je) + j, this.checkRangeXY(We, Ue, R, E) && (J = void 0, g.formatter && (J = y.call(g.formatter, { value: Je, seriesId: G, datum: ye })), J === void 0 && (J = v ? String(be[O]) : ""), ge = It.getTextSize(J, ne), Me = F ? $.convert(be[D]) : ae.size, $e = I ? _.convert(be[P]) : void 0, ee[Y++] = {
                series: this,
                itemId: h,
                yKey: h,
                xKey: f,
                datum: ye,
                xValue: Xe,
                yValue: Je,
                sizeValue: be[D],
                point: { x: We, y: Ue, size: Me },
                nodeMidPoint: { x: We, y: Ue },
                fill: $e,
                label: _h({ text: J }, ge)
              });
          } catch (Tn) {
            At = { error: Tn };
          } finally {
            try {
              se && !se.done && (di = te.return) && di.call(te);
            } finally {
              if (At)
                throw At.error;
            }
          }
          return ee.length = Y, [2, [{ itemId: (a = this.yKey) !== null && a !== void 0 ? a : this.id, nodeData: ee, labelData: ee }]];
        });
      });
    }, e.prototype.isPathOrSelectionDirty = function() {
      return this.marker.isDirty();
    }, e.prototype.getLabelData = function() {
      var t;
      return (t = this.contextNodeData) === null || t === void 0 ? void 0 : t.reduce(function(i, r) {
        return i.concat(r.labelData);
      }, []);
    }, e.prototype.markerFactory = function() {
      var t = this.marker.shape, i = Mu(t);
      return new i();
    }, e.prototype.updateMarkerSelection = function(t) {
      return nd(this, void 0, void 0, function() {
        var i, r, n, s;
        return od(this, function(a) {
          return i = t.nodeData, r = t.markerSelection, n = this.marker.enabled, this.marker.isDirty() && r.clear(), s = n ? i : [], [2, r.update(s)];
        });
      });
    }, e.prototype.updateMarkerNodes = function(t) {
      return nd(this, void 0, void 0, function() {
        var i, r, n, s, a, l, c, d, u, h, p, f, g, v, y, m, C, R, E, b, T, D, P;
        return od(this, function(O) {
          return i = t.markerSelection, r = t.isHighlight, n = this, s = n.marker, a = n.xKey, l = a === void 0 ? "" : a, c = n.yKey, d = c === void 0 ? "" : c, u = n.sizeScale, h = n.marker, p = h.fillOpacity, f = h.strokeOpacity, g = h.strokeWidth, v = n.highlightStyle.item, y = v.fill, m = v.fillOpacity, C = m === void 0 ? p : m, R = v.stroke, E = v.strokeWidth, b = n.id, T = n.ctx.callbackCache, D = s.formatter, u.range = [s.size, s.maxSize], P = typeof s.shape == "function", i.each(function(M, _) {
            var F, I, G, k, N, W, j, K, $, ae, ee = r && y !== void 0 ? y : (F = _.fill) !== null && F !== void 0 ? F : s.fill, ne = r ? C : p, Y = r && R !== void 0 ? R : s.stroke, te = f, se = r && E !== void 0 ? E : g != null ? g : 1, he = (G = (I = _.point) === null || I === void 0 ? void 0 : I.size) !== null && G !== void 0 ? G : 0, be = void 0;
            D && (be = T.call(D, {
              datum: _.datum,
              xKey: l,
              yKey: d,
              fill: ee,
              stroke: Y,
              strokeWidth: se,
              size: he,
              highlighted: r,
              seriesId: b
            })), M.fill = (k = be == null ? void 0 : be.fill) !== null && k !== void 0 ? k : ee, M.stroke = (N = be == null ? void 0 : be.stroke) !== null && N !== void 0 ? N : Y, M.strokeWidth = (W = be == null ? void 0 : be.strokeWidth) !== null && W !== void 0 ? W : se, M.fillOpacity = ne != null ? ne : 1, M.strokeOpacity = te != null ? te : 1, M.translationX = (K = (j = _.point) === null || j === void 0 ? void 0 : j.x) !== null && K !== void 0 ? K : 0, M.translationY = (ae = ($ = _.point) === null || $ === void 0 ? void 0 : $.y) !== null && ae !== void 0 ? ae : 0, M.visible = M.size > 0, !(!P || M.dirtyPath) && (M.path.clear({ trackChanges: !0 }), M.updatePath(), M.checkPathDirty());
          }), r || this.marker.markClean(), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.updateLabelSelection = function(t) {
      var i, r;
      return nd(this, void 0, void 0, function() {
        var n, s, a, l;
        return od(this, function(c) {
          return n = t.labelSelection, s = this.label.enabled, a = s ? (r = (i = this.chart) === null || i === void 0 ? void 0 : i.placeLabels().get(this)) !== null && r !== void 0 ? r : [] : [], l = a.map(function(d) {
            return _h(_h({}, d.datum), { point: {
              x: d.x,
              y: d.y,
              size: d.datum.point.size
            } });
          }), [2, n.update(l)];
        });
      });
    }, e.prototype.updateLabelNodes = function(t) {
      return nd(this, void 0, void 0, function() {
        var i, r;
        return od(this, function(n) {
          return i = t.labelSelection, r = this.label, i.each(function(s, a) {
            var l, c, d, u;
            s.text = a.label.text, s.fill = r.color, s.x = (c = (l = a.point) === null || l === void 0 ? void 0 : l.x) !== null && c !== void 0 ? c : 0, s.y = (u = (d = a.point) === null || d === void 0 ? void 0 : d.y) !== null && u !== void 0 ? u : 0, s.fontStyle = r.fontStyle, s.fontWeight = r.fontWeight, s.fontSize = r.fontSize, s.fontFamily = r.fontFamily, s.textAlign = "left", s.textBaseline = "top";
          }), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.getTooltipHtml = function(t) {
      var i, r, n, s, a, l, c, d = this, u = d.xKey, h = d.yKey, p = d.axes, f = p[de.X], g = p[de.Y];
      if (!u || !h || !f || !g)
        return "";
      var v = this, y = v.marker, m = v.tooltip, C = v.xName, R = v.yName, E = v.sizeKey, b = v.sizeName, T = v.labelKey, D = v.labelName, P = v.id, O = v.ctx.callbackCache, M = y.stroke, _ = (i = t.fill) !== null && i !== void 0 ? i : y.fill, F = this.getStrokeWidth((r = y.strokeWidth) !== null && r !== void 0 ? r : 1), I = this.marker.formatter, G = void 0;
      I && (G = O.call(I, {
        datum: t,
        xKey: u,
        yKey: h,
        fill: _,
        stroke: M,
        strokeWidth: F,
        size: (s = (n = t.point) === null || n === void 0 ? void 0 : n.size) !== null && s !== void 0 ? s : 0,
        highlighted: !1,
        seriesId: P
      }));
      var k = (l = (a = G == null ? void 0 : G.fill) !== null && a !== void 0 ? a : _) !== null && l !== void 0 ? l : "gray", N = (c = this.title) !== null && c !== void 0 ? c : R, W = t.datum, j = t.xValue, K = t.yValue, $ = t.sizeValue, ae = t.label.text, ee = ai(f.formatDatum(j)), ne = ai(g.formatDatum(K)), Y = "<b>" + ai(C != null ? C : u) + "</b>: " + ee + "<br>" + ("<b>" + ai(R != null ? R : h) + "</b>: " + ne);
      E && (Y += "<br><b>" + ai(b != null ? b : E) + "</b>: " + ai($)), T && (Y = "<b>" + ai(D != null ? D : T) + "</b>: " + ai(ae) + "<br>" + Y);
      var te = {
        title: N,
        backgroundColor: k,
        content: Y
      }, se = m.renderer;
      return se ? Ti(se({
        datum: W,
        xKey: u,
        xValue: j,
        xName: C,
        yKey: h,
        yValue: K,
        yName: R,
        sizeKey: E,
        sizeName: b,
        labelKey: T,
        labelName: D,
        title: N,
        color: k,
        seriesId: P
      }), te) : Ti(te);
    }, e.prototype.getLegendData = function() {
      var t, i, r, n, s, a = this, l = a.id, c = a.data, d = a.xKey, u = a.yKey, h = a.yName, p = a.title, f = a.visible, g = a.marker, v = g.fill, y = g.stroke, m = g.fillOpacity, C = g.strokeOpacity;
      if (!(c != null && c.length && d && u))
        return [];
      var R = [
        {
          legendType: "category",
          id: l,
          itemId: u,
          seriesId: l,
          enabled: f,
          label: {
            text: (t = p != null ? p : h) !== null && t !== void 0 ? t : u
          },
          marker: {
            shape: g.shape,
            fill: (r = (i = g.fill) !== null && i !== void 0 ? i : v) !== null && r !== void 0 ? r : "rgba(0, 0, 0, 0)",
            stroke: (s = (n = g.stroke) !== null && n !== void 0 ? n : y) !== null && s !== void 0 ? s : "rgba(0, 0, 0, 0)",
            fillOpacity: m != null ? m : 1,
            strokeOpacity: C != null ? C : 1
          }
        }
      ];
      return R;
    }, e.prototype.animateEmptyUpdateReady = function(t) {
      var i = this, r, n, s = t.markerSelections, a = t.labelSelections, l = (n = (r = this.ctx.animationManager) === null || r === void 0 ? void 0 : r.defaultOptions.duration) !== null && n !== void 0 ? n : 1e3, c = 200;
      s.forEach(function(d) {
        d.each(function(u, h) {
          var p, f, g, v, y = i.animateFormatter(u, h), m = (f = (p = h.point) === null || p === void 0 ? void 0 : p.size) !== null && f !== void 0 ? f : 0, C = (g = y == null ? void 0 : y.size) !== null && g !== void 0 ? g : m;
          (v = i.ctx.animationManager) === null || v === void 0 || v.animate(i.id + "_empty-update-ready_" + u.id, {
            from: 0,
            to: C,
            duration: l,
            onUpdate: function(R) {
              u.size = R;
            }
          });
        });
      }), a.forEach(function(d) {
        d.each(function(u) {
          var h;
          (h = i.ctx.animationManager) === null || h === void 0 || h.animate(i.id + "_empty-update-ready_" + u.id, {
            from: 0,
            to: 1,
            delay: l,
            duration: c,
            onUpdate: function(p) {
              u.opacity = p;
            }
          });
        });
      });
    }, e.prototype.animateReadyUpdate = function(t) {
      var i = this, r = t.markerSelections;
      r.forEach(function(n) {
        i.resetMarkers(n);
      });
    }, e.prototype.animateReadyHighlightMarkers = function(t) {
      this.resetMarkers(t);
    }, e.prototype.resetMarkers = function(t) {
      var i = this;
      t.each(function(r, n) {
        var s, a, l, c = i.animateFormatter(r, n), d = (a = (s = n.point) === null || s === void 0 ? void 0 : s.size) !== null && a !== void 0 ? a : 0;
        r.size = (l = c == null ? void 0 : c.size) !== null && l !== void 0 ? l : d;
      });
    }, e.prototype.animateFormatter = function(t, i) {
      var r, n, s, a = this, l = a.xKey, c = l === void 0 ? "" : l, d = a.yKey, u = d === void 0 ? "" : d, h = a.marker.strokeWidth, p = a.id, f = a.ctx.callbackCache, g = this.marker.formatter, v = (r = i.fill) !== null && r !== void 0 ? r : t.fill, y = t.stroke, m = h != null ? h : 1, C = (s = (n = i.point) === null || n === void 0 ? void 0 : n.size) !== null && s !== void 0 ? s : 0, R = void 0;
      return g && (R = f.call(g, {
        datum: i.datum,
        xKey: c,
        yKey: u,
        fill: v,
        stroke: y,
        strokeWidth: m,
        size: C,
        highlighted: !1,
        seriesId: p
      })), R;
    }, e.prototype.isLabelEnabled = function() {
      return this.label.enabled;
    }, e.className = "ScatterSeries", e.type = "scatter", Ui([
      A(De)
    ], e.prototype, "title", void 0), Ui([
      A(De)
    ], e.prototype, "labelKey", void 0), Ui([
      A(De)
    ], e.prototype, "xName", void 0), Ui([
      A(De)
    ], e.prototype, "yName", void 0), Ui([
      A(De)
    ], e.prototype, "sizeName", void 0), Ui([
      A(De)
    ], e.prototype, "labelName", void 0), Ui([
      A(De)
    ], e.prototype, "xKey", void 0), Ui([
      A(De)
    ], e.prototype, "yKey", void 0), Ui([
      A(De)
    ], e.prototype, "sizeKey", void 0), Ui([
      A(De)
    ], e.prototype, "colorKey", void 0), Ui([
      A(De)
    ], e.prototype, "colorName", void 0), Ui([
      A(vD)
    ], e.prototype, "colorDomain", void 0), Ui([
      A(hp)
    ], e.prototype, "colorRange", void 0), e;
  }(mf)
), q3 = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Z3 = (
  /** @class */
  function(o) {
    q3(e, o);
    function e(t) {
      return o.call(this, { moduleCtx: t, pickModes: [Zt.EXACT_SHAPE_MATCH] }) || this;
    }
    return e.prototype.getLabelData = function() {
      return [];
    }, e;
  }(Hm)
), tl = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), JC = function() {
  return JC = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, JC.apply(this, arguments);
}, wt = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, ah = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, lh = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, Q3 = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, J3 = (
  /** @class */
  function(o) {
    tl(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.renderer = void 0, t;
    }
    return wt([
      A(Pt)
    ], e.prototype, "renderer", void 0), e;
  }(vc)
), mO = (
  /** @class */
  function(o) {
    tl(e, o);
    function e(t, i, r, n, s, a) {
      var l = o.call(this, n, s, a) || this;
      return l.labelKey = t, l.sizeKey = i, l.colorKey = r, l;
    }
    return e;
  }(gf)
), eU = (
  /** @class */
  function(o) {
    tl(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.type = "nodeClick", t;
    }
    return e;
  }(mO)
), tU = (
  /** @class */
  function(o) {
    tl(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.type = "nodeDoubleClick", t;
    }
    return e;
  }(mO)
), DE = (
  /** @class */
  function(o) {
    tl(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.padding = 10, t;
    }
    return wt([
      A(le(0))
    ], e.prototype, "padding", void 0), e;
  }(qn)
), rC = (
  /** @class */
  function(o) {
    tl(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.wrapping = "on-space", t;
    }
    return wt([
      A(qb)
    ], e.prototype, "wrapping", void 0), e;
  }(qn)
), iU = (
  /** @class */
  function() {
    function o() {
      this.style = function() {
        var e = new qn();
        return e.color = "white", e;
      }();
    }
    return wt([
      A(De)
    ], o.prototype, "key", void 0), wt([
      A(De)
    ], o.prototype, "name", void 0), wt([
      A(Pt)
    ], o.prototype, "formatter", void 0), o;
  }()
), ta;
(function(o) {
  o[o.Name = 0] = "Name", o[o.Value = 1] = "Value";
})(ta || (ta = {}));
var ao = new ut();
function sd(o, e) {
  var t = e.fontStyle, i = e.fontWeight, r = e.fontSize, n = e.fontFamily;
  ao.fontStyle = t, ao.fontWeight = i, ao.fontSize = r, ao.fontFamily = n, ao.text = o, ao.x = 0, ao.y = 0, ao.textAlign = "left", ao.textBaseline = "top";
  var s = ao.computeBBox(), a = s.width, l = s.height;
  return { width: a, height: l };
}
function nC(o) {
  if (typeof o == "string" && !Kt.validColorString(o)) {
    var e = "black";
    return pe.warnOnce('invalid Treemap tile colour string "' + o + '". Affected treemap tiles will be coloured ' + e + "."), "black";
  }
  return o;
}
var rU = (
  /** @class */
  function() {
    function o() {
      this.color = "black";
    }
    return wt([
      A(St)
    ], o.prototype, "color", void 0), o;
  }()
), nU = (
  /** @class */
  function(o) {
    tl(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.text = new rU(), t;
    }
    return e;
  }(ew)
), oU = (
  /** @class */
  function(o) {
    tl(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t.groupSelection = Et.select(t.contentGroup, we), t.highlightSelection = Et.select(t.highlightGroup, we), t.title = function() {
        var i = new DE();
        return i.color = "white", i.fontWeight = "bold", i.fontSize = 12, i.fontFamily = "Verdana, sans-serif", i.padding = 15, i;
      }(), t.subtitle = function() {
        var i = new DE();
        return i.color = "white", i.fontSize = 9, i.fontFamily = "Verdana, sans-serif", i.padding = 13, i;
      }(), t.labels = {
        large: function() {
          var i = new rC();
          return i.color = "white", i.fontWeight = "bold", i.fontSize = 18, i;
        }(),
        medium: function() {
          var i = new rC();
          return i.color = "white", i.fontWeight = "bold", i.fontSize = 14, i;
        }(),
        small: function() {
          var i = new rC();
          return i.color = "white", i.fontWeight = "bold", i.fontSize = 10, i;
        }(),
        formatter: void 0,
        value: new iU()
      }, t.nodePadding = 2, t.nodeGap = 0, t.labelKey = "label", t.sizeKey = "size", t.colorKey = "color", t.colorDomain = [-5, 5], t.colorRange = ["#cb4b3f", "#6acb64"], t.groupFill = "#272931", t.groupStroke = "black", t.groupStrokeWidth = 1, t.tileStroke = "black", t.tileStrokeWidth = 1, t.gradient = !0, t.formatter = void 0, t.colorName = "Change", t.rootName = "Root", t.highlightGroups = !0, t.tileShadow = new KC(), t.labelShadow = new KC(), t.tooltip = new J3(), t.highlightStyle = new nU(), t;
    }
    return e.prototype.getNodePaddingTop = function(t, i) {
      var r, n = this, s = n.title, a = n.subtitle, l = n.nodePadding, c = t.label;
      if (t.isLeaf || !c || t.depth === 0)
        return l;
      var d = t.depth > 1 ? a : s, u = sd(c, d), h = 3;
      return d.fontSize > i.width / h || d.fontSize > i.height / h || u.height >= i.height ? l : u.height + l + ((r = d.padding) !== null && r !== void 0 ? r : 0);
    }, e.prototype.getNodePadding = function(t, i) {
      var r = this.nodePadding, n = this.getNodePaddingTop(t, i);
      return {
        top: n,
        right: r,
        bottom: r,
        left: r
      };
    }, e.prototype.squarify = function(t, i, r) {
      if (r === void 0 && (r = /* @__PURE__ */ new Map()), i.width <= 0 || i.height <= 0)
        return r;
      r.set(t, i);
      var n = 1, s = this.getNodePadding(t, i), a = i.width - s.left - s.right, l = i.height - s.top - s.bottom;
      if (a <= 0 || l <= 0 || t.value <= 0)
        return r;
      for (var c = 0, d = 0, u = 1 / 0, h = t.value, p = t.children, f = new nt(i.x + s.left, i.y + s.top, a, l), g = f.clone(), v = 0; v < p.length; v++) {
        var y = p[v].value, m = p[d].value, C = g.width < g.height;
        c += y;
        var R = C ? g.height : g.width, E = C ? g.width : g.height, b = E * m / c, T = R * c / h, D = Math.max(b, T) / Math.min(b, T), P = Math.abs(n - D);
        if (P < u) {
          u = P;
          continue;
        }
        c -= y, T = R * c / h;
        for (var O = C ? g.x : g.y, M = d; M < v; M++) {
          var _ = p[M], F = C ? O : g.x, I = C ? g.y : O, G = E * _.value / c, k = C ? G : T, N = C ? T : G, W = new nt(F, I, k, N);
          this.applyGap(f, W), this.squarify(_, W, r), h -= _.value, O += G;
        }
        C ? (g.y += T, g.height -= T) : (g.x += T, g.width -= T), d = v, c = 0, u = 1 / 0, v--;
      }
      for (var j = g.width < g.height, K = j ? g.x : g.y, v = d; v < p.length; v++) {
        var F = j ? K : g.x, I = j ? g.y : K, $ = p[v].value / h, ae = g.width * (j ? $ : 1), ee = g.height * (j ? 1 : $), W = new nt(F, I, ae, ee);
        this.applyGap(f, W), this.squarify(p[v], W, r), K += j ? ae : ee;
      }
      return r;
    }, e.prototype.applyGap = function(t, i) {
      var r = this.nodeGap / 2, n = function(c) {
        return {
          left: c.x,
          top: c.y,
          right: c.x + c.width,
          bottom: c.y + c.height
        };
      }, s = n(t), a = n(i), l = Object.keys(s);
      l.forEach(function(c) {
        jm(s[c], a[c]) || i.shrink(r, c);
      });
    }, e.prototype.processData = function() {
      return ah(this, void 0, void 0, function() {
        var t, i, r, n, s, a, l, c, d, u, h, p = this;
        return lh(this, function(f) {
          return this.data ? (t = this, i = t.data, r = t.sizeKey, n = t.labelKey, s = t.colorKey, a = t.colorDomain, l = t.colorRange, c = t.groupFill, d = this.labels.formatter, u = new vw(), u.domain = a, u.range = l, u.update(), h = function(g, v, y) {
            var m, C, R, E;
            v === void 0 && (v = 0);
            var b;
            d && (b = p.ctx.callbackCache.call(d, { datum: g })), b !== void 0 || (n ? b = (m = g[n]) !== null && m !== void 0 ? m : "" : b = "");
            var T = s && (C = g[s]) !== null && C !== void 0 ? C : v;
            T = nC(T);
            var D = !g.children, P = c;
            typeof T == "string" ? P = T : (D || !c) && (P = u.convert(T));
            var O = {
              datum: g,
              depth: v,
              parent: y,
              value: 0,
              label: b,
              fill: P,
              series: p,
              isLeaf: D,
              children: []
            };
            return D ? O.value = r && (R = g[r]) !== null && R !== void 0 ? R : 1 : ((E = g.children) === null || E === void 0 || E.forEach(function(M) {
              var _ = h(M, v + 1, O), F = _.value;
              isNaN(F) || !isFinite(F) || F === 0 || (O.value += F, O.children.push(_));
            }), O.children.sort(function(M, _) {
              return _.value - M.value;
            })), O;
          }, this.dataRoot = h(i), [
            2
            /*return*/
          ]) : [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.createNodeData = function() {
      return ah(this, void 0, void 0, function() {
        return lh(this, function(t) {
          return [2, []];
        });
      });
    }, e.prototype.update = function() {
      return ah(this, void 0, void 0, function() {
        return lh(this, function(t) {
          switch (t.label) {
            case 0:
              return [4, this.updateSelections()];
            case 1:
              return t.sent(), [4, this.updateNodes()];
            case 2:
              return t.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.updateSelections = function() {
      return ah(this, void 0, void 0, function() {
        var t, i, r, n, s, a, l, c, d, u;
        return lh(this, function(h) {
          return this.nodeDataRefresh ? (this.nodeDataRefresh = !1, t = this, i = t.chart, r = t.dataRoot, !i || !r ? [
            2
            /*return*/
          ] : (n = i.getSeriesRect(), n ? (s = [], a = function(p) {
            var f;
            s.push(p), (f = p.children) === null || f === void 0 || f.forEach(a);
          }, a(r), l = this, c = l.groupSelection, d = l.highlightSelection, u = function(p) {
            return p.update(s, function(f) {
              var g = new kn(), v = new ut();
              v.tag = ta.Name;
              var y = new ut();
              y.tag = ta.Value, f.append([g, v, y]);
            });
          }, this.groupSelection = u(c), this.highlightSelection = u(d), [
            2
            /*return*/
          ]) : [
            2
            /*return*/
          ])) : [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.isDatumHighlighted = function(t) {
      var i, r = (i = this.ctx.highlightManager) === null || i === void 0 ? void 0 : i.getActiveHighlight();
      return t === r && (t.isLeaf || this.highlightGroups);
    }, e.prototype.getTileFormat = function(t, i) {
      var r, n = this, s = n.formatter, a = n.ctx.callbackCache;
      if (!s)
        return {};
      var l = this, c = l.gradient, d = l.colorKey, u = l.labelKey, h = l.sizeKey, p = l.tileStroke, f = l.tileStrokeWidth, g = l.groupStroke, v = l.groupStrokeWidth, y = t.isLeaf ? p : g, m = t.isLeaf ? f : v, C = a.call(s, {
        seriesId: this.id,
        datum: t.datum,
        depth: t.depth,
        parent: (r = t.parent) === null || r === void 0 ? void 0 : r.datum,
        colorKey: d,
        sizeKey: h,
        labelKey: u,
        fill: t.fill,
        stroke: y,
        strokeWidth: m,
        gradient: c,
        highlighted: i
      });
      return C != null ? C : {};
    }, e.prototype.updateNodes = function() {
      return ah(this, void 0, void 0, function() {
        var t, i, r, n, s, a, l, c, d, u, h, p, f, g, v, y, m, C, R, E, b, T, D = this;
        return lh(this, function(P) {
          return this.chart ? (t = this, i = t.gradient, r = t.highlightStyle, n = r.item, s = n.fill, a = n.fillOpacity, l = n.stroke, c = n.strokeWidth, d = r.text.color, u = t.tileStroke, h = t.tileStrokeWidth, p = t.groupStroke, f = t.groupStrokeWidth, g = t.tileShadow, v = t.labelShadow, y = t.dataRoot, y ? (m = this.chart.getSeriesRect(), C = this.squarify(y, new nt(0, 0, m.width, m.height)), R = this.buildLabelMeta(C), E = this.getHighlightedSubtree(y), this.updateNodeMidPoint(C), b = function(O, M, _) {
            var F, I, G, k, N, W, j = C.get(M);
            if (!j) {
              O.visible = !1;
              return;
            }
            var K = _ && s !== void 0 ? s : M.fill, $ = (F = _ ? a : 1) !== null && F !== void 0 ? F : 1, ae = p;
            _ && l !== void 0 ? ae = l : M.isLeaf && (ae = u);
            var ee = f;
            _ && c !== void 0 ? ee = c : M.isLeaf && (ee = h);
            var ne = D.getTileFormat(M, _), Y = nC((I = ne == null ? void 0 : ne.fill) !== null && I !== void 0 ? I : K);
            if ((G = ne == null ? void 0 : ne.gradient) !== null && G !== void 0 ? G : i) {
              var te = Kt.tryParseFromString(K).brighter().toString(), se = Kt.tryParseFromString(K).darker().toString();
              O.fill = "linear-gradient(180deg, " + te + ", " + se + ")";
            } else
              O.fill = Y;
            O.fillOpacity = (k = ne == null ? void 0 : ne.fillOpacity) !== null && k !== void 0 ? k : $, O.stroke = nC((N = ne == null ? void 0 : ne.stroke) !== null && N !== void 0 ? N : ae), O.strokeWidth = (W = ne == null ? void 0 : ne.strokeWidth) !== null && W !== void 0 ? W : ee, O.fillShadow = g, O.crisp = !0, O.x = j.x, O.y = j.y, O.width = j.width, O.height = j.height, O.visible = !0;
          }, this.groupSelection.selectByClass(kn).forEach(function(O) {
            return b(O, O.datum, !1);
          }), this.highlightSelection.selectByClass(kn).forEach(function(O) {
            var M = D.isDatumHighlighted(O.datum);
            O.visible = M || E.has(O.datum), O.visible && b(O, O.datum, M);
          }), T = function(O, M, _, F) {
            var I = R.get(M), G = I == null ? void 0 : I[F];
            if (!G) {
              O.visible = !1;
              return;
            }
            O.text = G.text, O.fontFamily = G.style.fontFamily, O.fontSize = G.style.fontSize, O.fontWeight = G.style.fontWeight, O.fill = _ && d != null ? d : G.style.color, O.fillShadow = _ ? void 0 : v, O.textAlign = G.hAlign, O.textBaseline = G.vAlign, O.x = G.x, O.y = G.y, O.visible = !0;
          }, this.groupSelection.selectByTag(ta.Name).forEach(function(O) {
            return T(O, O.datum, !1, "label");
          }), this.highlightSelection.selectByTag(ta.Name).forEach(function(O) {
            var M = D.isDatumHighlighted(O.datum);
            O.visible = M || E.has(O.datum), O.visible && T(O, O.datum, M, "label");
          }), this.groupSelection.selectByTag(ta.Value).forEach(function(O) {
            return T(O, O.datum, !1, "value");
          }), this.highlightSelection.selectByTag(ta.Value).forEach(function(O) {
            var M = D.isDatumHighlighted(O.datum);
            O.visible = M || E.has(O.datum), O.visible && T(O, O.datum, M, "value");
          }), [
            2
            /*return*/
          ]) : [
            2
            /*return*/
          ]) : [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.updateNodeMidPoint = function(t) {
      t.forEach(function(i, r) {
        r.nodeMidPoint = {
          x: i.x + i.width / 2,
          y: i.y
        };
      });
    }, e.prototype.getHighlightedSubtree = function(t) {
      var i = this, r = /* @__PURE__ */ new Set(), n = function(s) {
        var a;
        (i.isDatumHighlighted(s) || s.parent && r.has(s.parent)) && r.add(s), (a = s.children) === null || a === void 0 || a.forEach(n);
      };
      return n(t), r;
    }, e.prototype.buildLabelMeta = function(t) {
      var i = this, r = i.labels, n = i.title, s = i.subtitle, a = i.nodePadding, l = i.labelKey, c = i.ctx.callbackCache, d = /-$/m, u = /* @__PURE__ */ new Map();
      return t.forEach(function(h, p) {
        var f, g, v;
        if (!(!l || p.depth === 0)) {
          var y = h.width - 2 * a, m = h.height - 2 * a, C = function(N) {
            var W = 3;
            return N.fontSize > h.width / W || N.fontSize > h.height / W;
          }, R = p.isLeaf ? p.label : p.label.toUpperCase(), E = "", b = r.value, T = b.style, D = Math.ceil(T.fontSize * 2 * (ut.defaultLineHeightRatio - 1));
          p.isLeaf && (b.formatter ? E = (f = c.call(b.formatter, { datum: p.datum })) !== null && f !== void 0 ? f : "" : b.key && (E = p.datum[b.key]));
          var P = sd(E, T);
          E && P.width > y && (E = "");
          var O, M = "";
          if (p.isLeaf) {
            var _ = function() {
              var N, W, j = m - (E ? T.fontSize + D : 0), K = [r.large, r.medium, r.small];
              try {
                for (var $ = Q3(K), ae = $.next(); !ae.done; ae = $.next()) {
                  var ee = ae.value, ne = sd(R, ee), Y = ne.width, te = ne.height;
                  if (!(te > j || C(ee))) {
                    if (Y <= y)
                      return { style: ee, wrappedText: void 0 };
                    var se = ut.wrap(R, y, j, ee, ee.wrapping);
                    if (se && se !== "…" && (ee === r.small || !(d.exec(se) || se.endsWith("…"))))
                      return { style: ee, wrappedText: se };
                  }
                }
              } catch (be) {
                N = { error: be };
              } finally {
                try {
                  ae && !ae.done && (W = $.return) && W.call($);
                } finally {
                  if (N)
                    throw N.error;
                }
              }
              var he = sd(R, r.small);
              return he.height <= j && !C(r.small) ? { style: r.small, wrappedText: void 0 } : { style: void 0, wrappedText: void 0 };
            }, F = _();
            !F.style && E && (E = "", F = _()), O = (g = F.style) !== null && g !== void 0 ? g : r.small, M = (v = F.wrappedText) !== null && v !== void 0 ? v : "";
          } else
            p.depth === 1 ? O = n : O = s;
          var I = sd(M || R, O);
          if (!C(O)) {
            if (I.width > y) {
              var G = Math.floor(R.length * y / I.width) - 1;
              R = R.substring(0, G).trim() + "…";
            }
            P = sd(E, T);
            var k = E && P.width < y && P.height + I.height + D < m;
            u.set(p, {
              label: JC({ text: M || R, style: O }, p.isLeaf ? {
                hAlign: "center",
                vAlign: "middle",
                x: h.x + h.width / 2,
                y: h.y + h.height / 2 - (k ? P.height / 2 + D / 2 : 0)
              } : {
                hAlign: "left",
                vAlign: "top",
                x: h.x + a,
                y: h.y + a
              }),
              value: k ? {
                text: E,
                style: T,
                hAlign: "center",
                vAlign: "middle",
                x: h.x + h.width / 2,
                y: h.y + h.height / 2 + I.height / 2 + D / 2
              } : void 0
            });
          }
        }
      }), u;
    }, e.prototype.getDomain = function(t) {
      return [0, 1];
    }, e.prototype.getNodeClickEvent = function(t, i) {
      return new eU(this.labelKey, this.sizeKey, this.colorKey, t, i, this);
    }, e.prototype.getNodeDoubleClickEvent = function(t, i) {
      return new tU(this.labelKey, this.sizeKey, this.colorKey, t, i, this);
    }, e.prototype.getTooltipHtml = function(t) {
      var i, r, n, s;
      if (!this.highlightGroups && !t.isLeaf)
        return "";
      var a = this, l = a.tooltip, c = a.sizeKey, d = a.labelKey, u = a.colorKey, h = a.rootName, p = a.id, f = a.labels, g = a.ctx.callbackCache, v = t.datum, y = l.renderer, m = t.depth ? v[d] : (i = v[d]) !== null && i !== void 0 ? i : h, C = "", R = this.getTileFormat(t, !1), E = (n = (r = R == null ? void 0 : R.fill) !== null && r !== void 0 ? r : t.fill) !== null && n !== void 0 ? n : "gray", b = f.value.key, T = f.value.formatter;
      if (b || T) {
        var D = "";
        if (T)
          D = g.call(T, { datum: v });
        else if (b != null) {
          var P = v[b];
          typeof P == "number" && isFinite(P) && (D = lw(P));
        }
        D && (f.value.name && (C += "<b>" + f.value.name + ":</b> "), C += D);
      }
      var O = {
        title: m,
        backgroundColor: E,
        content: C
      };
      return y ? Ti(y({
        datum: t.datum,
        parent: (s = t.parent) === null || s === void 0 ? void 0 : s.datum,
        depth: t.depth,
        sizeKey: c,
        labelKey: d,
        colorKey: u,
        title: m,
        color: E,
        seriesId: p
      }), O) : !m && !C ? "" : Ti(O);
    }, e.prototype.getLegendData = function() {
      return [];
    }, e.className = "TreemapSeries", e.type = "treemap", wt([
      A(le(0))
    ], e.prototype, "nodePadding", void 0), wt([
      A(le(0))
    ], e.prototype, "nodeGap", void 0), wt([
      A(Ri)
    ], e.prototype, "labelKey", void 0), wt([
      A(De)
    ], e.prototype, "sizeKey", void 0), wt([
      A(De)
    ], e.prototype, "colorKey", void 0), wt([
      A(gD)
    ], e.prototype, "colorDomain", void 0), wt([
      A(hp)
    ], e.prototype, "colorRange", void 0), wt([
      A(De)
    ], e.prototype, "groupFill", void 0), wt([
      A(St)
    ], e.prototype, "groupStroke", void 0), wt([
      A(lt(0))
    ], e.prototype, "groupStrokeWidth", void 0), wt([
      A(St)
    ], e.prototype, "tileStroke", void 0), wt([
      A(lt(0))
    ], e.prototype, "tileStrokeWidth", void 0), wt([
      A(ht)
    ], e.prototype, "gradient", void 0), wt([
      A(Pt)
    ], e.prototype, "formatter", void 0), wt([
      A(Ri)
    ], e.prototype, "colorName", void 0), wt([
      A(Ri)
    ], e.prototype, "rootName", void 0), wt([
      A(_o)
    ], e.prototype, "highlightGroups", void 0), e;
  }(Z3)
), ad = {
  area: "cartesian",
  bar: "cartesian",
  column: "cartesian",
  histogram: "cartesian",
  line: "cartesian",
  scatter: "cartesian",
  treemap: "hierarchy",
  pie: "polar"
}, eS = {}, Ut = {
  has: function(o) {
    return Object.prototype.hasOwnProperty.call(ad, o);
  },
  isCartesian: function(o) {
    return ad[o] === "cartesian";
  },
  isPolar: function(o) {
    return ad[o] === "polar";
  },
  isHierarchy: function(o) {
    return ad[o] === "hierarchy";
  },
  get seriesTypes() {
    return Object.keys(ad);
  },
  get cartesianTypes() {
    var o = this;
    return this.seriesTypes.filter(function(e) {
      return o.isCartesian(e);
    });
  },
  get polarTypes() {
    var o = this;
    return this.seriesTypes.filter(function(e) {
      return o.isPolar(e);
    });
  },
  get hierarchyTypes() {
    var o = this;
    return this.seriesTypes.filter(function(e) {
      return o.isHierarchy(e);
    });
  }
};
function sU(o, e) {
  ad[o] = e;
}
function aU(o, e) {
  var t;
  eS[o] = Ft([(t = eS[o]) !== null && t !== void 0 ? t : {}, e]);
}
function OE(o) {
  var e;
  return (e = eS[o]) !== null && e !== void 0 ? e : {};
}
var lU = {
  area: w3,
  bar: gO,
  column: L3,
  histogram: B3,
  line: j3,
  pie: eO,
  scatter: X3,
  treemap: oU
}, yO = {}, CO = {}, SO = {}, bO = {};
function cU(o, e, t, i, r, n) {
  yO[o] = t, CO[o] = i, SO[o] = r, n && il(o, n), sU(o, e);
}
function dU(o, e) {
  var t, i = (t = yO[o]) !== null && t !== void 0 ? t : lU[o];
  if (i)
    return new i(e);
  throw new Error("AG Charts - unknown series type: " + o);
}
function PE(o) {
  return CO[o];
}
function wO(o) {
  return SO[o];
}
function il(o, e) {
  bO[o] = e;
}
function uU(o) {
  return bO[o];
}
var hU = {
  axes: [
    {
      type: hv.type,
      position: "left"
    },
    {
      type: Qd.type,
      position: "bottom"
    }
  ]
}, pU = {
  axes: [
    {
      type: "number",
      position: "bottom"
    },
    {
      type: "category",
      position: "left"
    }
  ]
}, fU = {
  axes: [
    {
      type: "number",
      position: "bottom"
    },
    {
      type: "number",
      position: "left"
    }
  ]
};
function co(o, e) {
  if (AE(o) && AE(e)) {
    var t = {};
    return Object.keys(o).forEach(function(i) {
      i in e ? t[i] = co(o[i], e[i]) : t[i] = o[i];
    }), Object.keys(e).forEach(function(i) {
      i in o || (t[i] = e[i]);
    }), t;
  }
  return Array.isArray(o) && !Array.isArray(e) || tS(o) && !tS(e) ? o : e;
}
function tS(o) {
  return o && typeof o == "object";
}
function AE(o) {
  return tS(o) && o.constructor === Object;
}
var xe = function() {
  return xe = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, xe.apply(this, arguments);
}, ME = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, gU = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, vU = {
  fills: ["#f3622d", "#fba71b", "#57b757", "#41a9c9", "#4258c9", "#9a42c8", "#c84164", "#888888"],
  strokes: ["#aa4520", "#b07513", "#3d803d", "#2d768d", "#2e3e8d", "#6c2e8c", "#8c2d46", "#5f5f5f"]
}, mU = Symbol("extends-axes-defaults"), yU = Symbol("extends-axes-label-defaults"), CU = Symbol("extends-axes-line-defaults"), SU = Symbol("extends-series-defaults"), EO = Symbol("override-series-label-defaults"), bU = Symbol("default-font"), _E = "bold", wU = "inside", EU = "bottom", mc = (
  /** @class */
  function() {
    function o(e) {
      e = co({}, e != null ? e : {});
      var t = e.overrides, i = t === void 0 ? null : t, r = e.palette, n = r === void 0 ? null : r, s = this.createChartConfigPerChartType(this.getDefaults());
      if (i) {
        var a = i.common, l = i.cartesian, c = i.polar, d = i.hierarchy, u = function(h, p, f) {
          f && (s[h] = co(s[h], f), p.forEach(function(g) {
            var v = g;
            s[v] = co(s[v], f);
          }));
        };
        u("common", Object.keys(s), a), u("cartesian", Ut.cartesianTypes, l), u("polar", Ut.polarTypes, c), u("hierarchy", Ut.hierarchyTypes, d), Ut.seriesTypes.forEach(function(h) {
          var p, f = h, g = i[f];
          g && (g.series && (g.series = (p = {}, p[f] = g.series, p)), s[f] = co(s[f], g));
        });
      }
      this.palette = n != null ? n : this.getPalette(), this.config = Object.freeze(s);
    }
    return o.prototype.getPalette = function() {
      return vU;
    }, o.getAxisDefaults = function() {
      return {
        top: {},
        right: {},
        bottom: {},
        left: {},
        title: {
          enabled: !1,
          text: "Axis Title",
          fontStyle: void 0,
          fontWeight: _E,
          fontSize: 12,
          fontFamily: this.fontFamily,
          color: "rgb(70, 70, 70)"
        },
        label: {
          fontStyle: void 0,
          fontWeight: void 0,
          fontSize: 12,
          fontFamily: this.fontFamily,
          padding: 5,
          rotation: void 0,
          color: "rgb(87, 87, 87)",
          formatter: void 0,
          autoRotate: !1,
          avoidCollisions: !0
        },
        line: {
          width: 1,
          color: "rgb(195, 195, 195)"
        },
        tick: {
          width: 1,
          size: 6,
          color: "rgb(195, 195, 195)"
        },
        gridStyle: [
          {
            stroke: "rgb(219, 219, 219)",
            lineDash: [4, 2]
          }
        ],
        crossLines: {
          enabled: !1,
          fill: "rgb(187,221,232)",
          stroke: "rgb(70,162,192)",
          strokeWidth: 1,
          label: {
            enabled: !1,
            fontStyle: void 0,
            fontWeight: void 0,
            fontSize: 12,
            fontFamily: this.fontFamily,
            padding: 5,
            color: "rgb(87, 87, 87)",
            rotation: void 0
          }
        }
      };
    }, o.getSeriesDefaults = function() {
      return {
        tooltip: {
          enabled: !0,
          renderer: void 0
        },
        visible: !0,
        showInLegend: !0,
        highlightStyle: {
          item: {
            fill: "yellow",
            fillOpacity: 1
          },
          series: {
            dimOpacity: 1
          },
          text: {
            color: "black"
          }
        },
        nodeClickRange: "exact"
      };
    }, o.getBarSeriesDefaults = function() {
      return xe(xe({}, this.getSeriesDefaults()), { fillOpacity: 1, strokeOpacity: 1, normalizedTo: void 0, strokeWidth: 1, lineDash: [0], lineDashOffset: 0, label: {
        enabled: !1,
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 12,
        fontFamily: this.fontFamily,
        color: "rgb(70, 70, 70)",
        formatter: void 0,
        placement: wU
      }, shadow: {
        enabled: !1,
        color: "rgba(0, 0, 0, 0.5)",
        xOffset: 3,
        yOffset: 3,
        blur: 5
      } });
    }, o.getLineSeriesDefaults = function() {
      var e = this.getSeriesDefaults();
      return xe(xe({}, e), { tooltip: xe(xe({}, e.tooltip), { format: void 0, position: {
        type: "node"
      } }) });
    }, o.getAreaSeriesDefaults = function() {
      var e = this.getSeriesDefaults();
      return xe(xe({}, e), { nodeClickRange: "nearest", tooltip: xe(xe({}, e.tooltip), { position: {
        type: "node"
      } }) });
    }, o.getScatterSeriesDefaults = function() {
      var e = this.getSeriesDefaults();
      return xe(xe({}, e), { tooltip: xe(xe({}, e.tooltip), { position: {
        type: "node"
      } }) });
    }, o.getCartesianSeriesMarkerDefaults = function() {
      return {
        enabled: !0,
        shape: "circle",
        size: 6,
        maxSize: 30,
        strokeWidth: 1,
        formatter: void 0
      };
    }, o.getCaptionWrappingDefaults = function() {
      return "hyphenate";
    }, o.getChartDefaults = function() {
      return {
        background: {
          visible: !0,
          fill: "white"
        },
        padding: {
          top: 20,
          right: 20,
          bottom: 20,
          left: 20
        },
        title: {
          enabled: !1,
          text: "Title",
          fontStyle: void 0,
          fontWeight: _E,
          fontSize: 16,
          fontFamily: this.fontFamily,
          color: "rgb(70, 70, 70)",
          wrapping: o.getCaptionWrappingDefaults()
        },
        subtitle: {
          enabled: !1,
          text: "Subtitle",
          fontStyle: void 0,
          fontWeight: void 0,
          fontSize: 12,
          fontFamily: this.fontFamily,
          color: "rgb(140, 140, 140)",
          wrapping: o.getCaptionWrappingDefaults()
        },
        footnote: {
          enabled: !1,
          text: "Footnote",
          fontStyle: void 0,
          fontWeight: void 0,
          fontSize: 12,
          fontFamily: this.fontFamily,
          color: "rgb(140, 140, 140)",
          spacing: 30,
          wrapping: o.getCaptionWrappingDefaults()
        },
        legend: {
          position: EU,
          spacing: 20,
          listeners: {},
          item: {
            paddingX: 16,
            paddingY: 8,
            marker: {
              shape: void 0,
              size: 15,
              strokeWidth: 1,
              padding: 8
            },
            label: {
              color: "black",
              fontStyle: void 0,
              fontWeight: void 0,
              fontSize: 12,
              fontFamily: this.fontFamily,
              formatter: void 0
            }
          },
          reverseOrder: !1,
          pagination: {
            marker: {
              size: 12
            },
            activeStyle: {
              fill: "rgb(70, 70, 70)"
            },
            inactiveStyle: {
              fill: "rgb(219, 219, 219)"
            },
            highlightStyle: {
              fill: "rgb(70, 70, 70)"
            },
            label: {
              color: "rgb(70, 70, 70)"
            }
          }
        },
        tooltip: {
          enabled: !0,
          range: "nearest",
          delay: 0
        },
        listeners: {}
      };
    }, o.prototype.createChartConfigPerChartType = function(e) {
      var t = this, i = {
        cartesian: Ut.cartesianTypes,
        polar: Ut.polarTypes,
        hierarchy: Ut.hierarchyTypes,
        groupedCategory: []
      };
      return Object.entries(i).forEach(function(r) {
        var n = ME(r, 2), s = n[0], a = n[1], l = s, c = t.templateTheme(OE(l));
        a.forEach(function(d) {
          var u = d;
          e[u] || (e[u] = co({}, e[l]), co(e[u], c));
        });
      }), e;
    }, o.prototype.getDefaults = function() {
      var e = this, t = co({}, o.defaults), i = function(n, s) {
        var a = e.templateTheme(OE(n));
        return a.series = s.reduce(function(l, c) {
          var d = wO(c);
          return d && (l[c] = e.templateTheme(d)), l;
        }, {}), (n === "cartesian" || n === "polar") && (a.axes = cw.axesTypes.reduce(function(l, c) {
          var d = c3(c);
          return d && (l[c] = e.templateTheme(d)), l;
        }, {})), a;
      }, r = {
        cartesian: i("cartesian", Ut.cartesianTypes),
        groupedCategory: i("cartesian", Ut.cartesianTypes),
        polar: i("polar", Ut.polarTypes),
        hierarchy: i("hierarchy", Ut.hierarchyTypes)
      };
      return co(t, r);
    }, o.prototype.templateTheme = function(e) {
      var t = Ft([e]), i = this.getTemplateParameters(), r = i.extensions, n = i.properties;
      return $l(t, function(s, a) {
        var l, c;
        if (a.__extends__) {
          var d = a.__extends__, u = r.get(d);
          if (u == null)
            throw new Error("AG Charts - no template variable provided for: " + d);
          Object.keys(u).forEach(function(m) {
            m in a || (a[m] = u[m]);
          }), delete a.__extends__;
        }
        if (a.__overrides__) {
          var d = a.__overrides__, h = r.get(d);
          if (h == null)
            throw new Error("AG Charts - no template variable provided for: " + d);
          Object.assign(a, h), delete a.__overrides__;
        }
        try {
          for (var p = gU(Object.entries(a)), f = p.next(); !f.done; f = p.next()) {
            var g = ME(f.value, 2), v = g[0], y = g[1];
            n.has(y) && (a[v] = n.get(y));
          }
        } catch (m) {
          l = { error: m };
        } finally {
          try {
            f && !f.done && (c = p.return) && c.call(p);
          } finally {
            if (l)
              throw l.error;
          }
        }
      }, {}), t;
    }, o.prototype.getTemplateParameters = function() {
      var e = /* @__PURE__ */ new Map();
      e.set(mU, o.getAxisDefaults()), e.set(yU, o.getAxisDefaults().label), e.set(CU, o.getAxisDefaults().line), e.set(SU, o.getSeriesDefaults()), e.set(EO, {});
      var t = /* @__PURE__ */ new Map();
      return t.set(bU, o.fontFamily), {
        extensions: e,
        properties: t
      };
    }, o.prototype.mergeWithParentDefaults = function(e, t) {
      return co(e, t);
    }, o.fontFamily = "Verdana, sans-serif", o.cartesianDefaults = xe(xe({}, o.getChartDefaults()), { axes: {
      number: xe({}, o.getAxisDefaults()),
      log: xe(xe({}, o.getAxisDefaults()), { base: 10 }),
      category: xe(xe({}, o.getAxisDefaults()), { groupPaddingInner: 0.1, label: xe(xe({}, o.getAxisDefaults().label), { autoRotate: !0 }) }),
      groupedCategory: xe({}, o.getAxisDefaults()),
      time: xe({}, o.getAxisDefaults())
    }, series: {
      column: xe({}, o.getBarSeriesDefaults()),
      bar: xe({}, o.getBarSeriesDefaults()),
      line: xe(xe({}, o.getLineSeriesDefaults()), { title: void 0, strokeWidth: 2, strokeOpacity: 1, lineDash: [0], lineDashOffset: 0, marker: xe(xe({}, o.getCartesianSeriesMarkerDefaults()), { fillOpacity: 1, strokeOpacity: 1 }), label: {
        enabled: !1,
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 12,
        fontFamily: o.fontFamily,
        color: "rgb(70, 70, 70)",
        formatter: void 0
      } }),
      scatter: xe(xe({}, o.getScatterSeriesDefaults()), { sizeName: "Size", labelName: "Label", marker: xe({}, o.getCartesianSeriesMarkerDefaults()), label: {
        enabled: !1,
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 12,
        fontFamily: o.fontFamily,
        color: "rgb(70, 70, 70)"
      } }),
      area: xe(xe({}, o.getAreaSeriesDefaults()), { normalizedTo: void 0, fillOpacity: 0.8, strokeOpacity: 1, strokeWidth: 2, lineDash: [0], lineDashOffset: 0, shadow: {
        enabled: !1,
        color: "rgba(0, 0, 0, 0.5)",
        xOffset: 3,
        yOffset: 3,
        blur: 5
      }, marker: xe(xe({}, o.getCartesianSeriesMarkerDefaults()), { fillOpacity: 1, strokeOpacity: 1, enabled: !1 }), label: {
        enabled: !1,
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 12,
        fontFamily: o.fontFamily,
        color: "rgb(70, 70, 70)",
        formatter: void 0
      } }),
      histogram: xe(xe({}, o.getSeriesDefaults()), { strokeWidth: 1, fillOpacity: 1, strokeOpacity: 1, lineDash: [0], lineDashOffset: 0, areaPlot: !1, bins: void 0, aggregation: "sum", label: {
        enabled: !1,
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 12,
        fontFamily: o.fontFamily,
        color: "rgb(70, 70, 70)",
        formatter: void 0
      }, shadow: {
        enabled: !0,
        color: "rgba(0, 0, 0, 0.5)",
        xOffset: 0,
        yOffset: 0,
        blur: 5
      } })
    } }), o.polarDefaults = xe(xe({}, o.getChartDefaults()), { series: {
      pie: xe(xe({}, o.getSeriesDefaults()), { title: {
        enabled: !0,
        fontStyle: void 0,
        fontWeight: "bold",
        fontSize: 14,
        fontFamily: o.fontFamily,
        color: "rgb(70, 70, 70)",
        spacing: 0
      }, radiusKey: void 0, radiusName: void 0, calloutLabelKey: void 0, calloutLabelName: void 0, sectorLabelKey: void 0, sectorLabelName: void 0, calloutLabel: {
        enabled: !0,
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 12,
        fontFamily: o.fontFamily,
        color: "rgb(70, 70, 70)",
        offset: 3,
        minAngle: 0
      }, sectorLabel: {
        enabled: !0,
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 12,
        fontFamily: o.fontFamily,
        color: "rgb(70, 70, 70)",
        positionOffset: 0,
        positionRatio: 0.5
      }, calloutLine: {
        length: 10,
        strokeWidth: 2
      }, fillOpacity: 1, strokeOpacity: 1, strokeWidth: 1, lineDash: [0], lineDashOffset: 0, rotation: 0, outerRadiusOffset: 0, innerRadiusOffset: 0, shadow: {
        enabled: !1,
        color: "rgba(0, 0, 0, 0.5)",
        xOffset: 3,
        yOffset: 3,
        blur: 5
      }, innerLabels: {
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 12,
        fontFamily: o.fontFamily,
        color: "rgb(70, 70, 70)",
        margin: 2
      } })
    } }), o.hierarchyDefaults = xe(xe({}, o.getChartDefaults()), { series: {
      treemap: xe(xe({}, o.getSeriesDefaults()), { showInLegend: !1, labelKey: "label", sizeKey: "size", colorKey: "color", colorDomain: [-5, 5], colorRange: ["#cb4b3f", "#6acb64"], groupFill: "#272931", groupStroke: "black", groupStrokeWidth: 1, tileStroke: "black", tileStrokeWidth: 1, gradient: !0, tileShadow: {
        enabled: !1,
        color: "rgba(0, 0, 0, 0.5)",
        xOffset: 3,
        yOffset: 3,
        blur: 5
      }, labelShadow: {
        enabled: !0,
        color: "rgba(0, 0, 0, 0.4)",
        xOffset: 1.5,
        yOffset: 1.5,
        blur: 5
      }, highlightGroups: !0, nodePadding: 2, nodeGap: 0, title: {
        enabled: !0,
        color: "white",
        fontStyle: void 0,
        fontWeight: "bold",
        fontSize: 12,
        fontFamily: "Verdana, sans-serif",
        padding: 2
      }, subtitle: {
        enabled: !0,
        color: "white",
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 9,
        fontFamily: "Verdana, sans-serif",
        padding: 2
      }, labels: {
        large: {
          enabled: !0,
          fontStyle: void 0,
          fontWeight: "bold",
          fontSize: 18,
          fontFamily: "Verdana, sans-serif",
          color: "white",
          wrapping: "on-space"
        },
        medium: {
          enabled: !0,
          fontStyle: void 0,
          fontWeight: "bold",
          fontSize: 14,
          fontFamily: "Verdana, sans-serif",
          color: "white",
          wrapping: "on-space"
        },
        small: {
          enabled: !0,
          fontStyle: void 0,
          fontWeight: "bold",
          fontSize: 10,
          fontFamily: "Verdana, sans-serif",
          color: "white",
          wrapping: "on-space"
        },
        value: {
          style: {
            enabled: !0,
            fontStyle: void 0,
            fontWeight: void 0,
            fontSize: 12,
            fontFamily: "Verdana, sans-serif",
            color: "white"
          }
        }
      } })
    } }), o.defaults = {
      cartesian: o.cartesianDefaults,
      groupedCategory: o.cartesianDefaults,
      polar: o.polarDefaults,
      hierarchy: o.hierarchyDefaults
    }, o;
  }()
), RU = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), ft = function() {
  return ft = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, ft.apply(this, arguments);
}, yf = (
  /** @class */
  function(o) {
    RU(e, o);
    function e(t) {
      return o.call(this, t) || this;
    }
    return e.prototype.getDefaults = function() {
      var t = this, i = e.fontColor, r = e.mutedFontColor, n = {
        title: {
          color: i
        },
        label: {
          color: i
        },
        gridStyle: [
          {
            stroke: "rgb(88, 88, 88)",
            lineDash: [4, 2]
          }
        ]
      }, s = {
        label: {
          color: i
        }
      }, a = {
        axes: {
          number: ft({}, n),
          category: ft({}, n),
          time: ft({}, n)
        }
      }, l = {
        background: {
          fill: "rgb(34, 38, 41)"
        },
        title: {
          color: i
        },
        subtitle: {
          color: r
        },
        legend: {
          item: {
            label: {
              color: i
            }
          },
          pagination: {
            activeStyle: {
              fill: i
            },
            inactiveStyle: {
              fill: r
            },
            highlightStyle: {
              fill: i
            },
            label: {
              color: i
            }
          }
        }
      }, c = function(d) {
        return d.reduce(function(u, h) {
          var p = wO(h);
          return p && (u[h] = t.templateTheme(p)), u;
        }, {});
      };
      return this.mergeWithParentDefaults(o.prototype.getDefaults.call(this), {
        cartesian: ft(ft(ft({}, l), a), { series: ft({ line: ft({}, s), bar: ft({}, s), column: ft({}, s), histogram: ft({}, s) }, c(Ut.cartesianTypes)) }),
        groupedCategory: ft(ft(ft({}, l), a), { series: ft({ bar: ft({}, s), column: ft({}, s), histogram: ft({}, s) }, c(Ut.cartesianTypes)) }),
        polar: ft(ft({}, l), { series: ft({ pie: {
          calloutLabel: {
            color: i
          },
          sectorLabel: {
            color: i
          },
          title: {
            color: i
          },
          innerLabels: {
            color: i
          }
        } }, c(Ut.polarTypes)) }),
        hierarchy: ft(ft({}, l), { series: ft({ treemap: {
          tileStroke: "white",
          groupStroke: "white",
          title: {
            color: i
          },
          subtitle: {
            color: r
          },
          labels: {
            large: {
              color: i
            },
            medium: {
              color: i
            },
            small: {
              color: i
            },
            value: {
              style: {
                color: i
              }
            }
          }
        } }, c(Ut.hierarchyTypes)) })
      });
    }, e.prototype.getTemplateParameters = function() {
      var t = o.prototype.getTemplateParameters.call(this);
      return t.extensions.set(EO, e.seriesLabelDefaults.label), t;
    }, e.fontColor = "rgb(200, 200, 200)", e.mutedFontColor = "rgb(150, 150, 150)", e.seriesLabelDefaults = {
      label: {
        color: e.fontColor
      }
    }, e;
  }(mc)
), TU = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), xU = {
  fills: [
    "#f44336",
    "#e91e63",
    "#9c27b0",
    "#673ab7",
    "#3f51b5",
    "#2196f3",
    "#03a9f4",
    "#00bcd4",
    "#009688",
    "#4caf50",
    "#8bc34a",
    "#cddc39",
    "#ffeb3b",
    "#ffc107",
    "#ff9800",
    "#ff5722"
  ],
  strokes: [
    "#ab2f26",
    "#a31545",
    "#6d1b7b",
    "#482980",
    "#2c397f",
    "#1769aa",
    "#0276ab",
    "#008494",
    "#00695f",
    "#357a38",
    "#618834",
    "#909a28",
    "#b3a429",
    "#b38705",
    "#b36a00",
    "#b33d18"
  ]
}, DU = (
  /** @class */
  function(o) {
    TU(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.getPalette = function() {
      return xU;
    }, e;
  }(mc)
), OU = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), PU = {
  fills: [
    "#f44336",
    "#e91e63",
    "#9c27b0",
    "#673ab7",
    "#3f51b5",
    "#2196f3",
    "#03a9f4",
    "#00bcd4",
    "#009688",
    "#4caf50",
    "#8bc34a",
    "#cddc39",
    "#ffeb3b",
    "#ffc107",
    "#ff9800",
    "#ff5722"
  ],
  strokes: [
    "#ab2f26",
    "#a31545",
    "#6d1b7b",
    "#482980",
    "#2c397f",
    "#1769aa",
    "#0276ab",
    "#008494",
    "#00695f",
    "#357a38",
    "#618834",
    "#909a28",
    "#b3a429",
    "#b38705",
    "#b36a00",
    "#b33d18"
  ]
}, AU = (
  /** @class */
  function(o) {
    OU(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.getPalette = function() {
      return PU;
    }, e;
  }(yf)
), MU = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), _U = {
  fills: ["#c16068", "#a2bf8a", "#ebcc87", "#80a0c3", "#b58dae", "#85c0d1"],
  strokes: ["#874349", "#718661", "#a48f5f", "#5a7088", "#7f637a", "#5d8692"]
}, IU = (
  /** @class */
  function(o) {
    MU(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.getPalette = function() {
      return _U;
    }, e;
  }(mc)
), FU = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), LU = {
  fills: ["#c16068", "#a2bf8a", "#ebcc87", "#80a0c3", "#b58dae", "#85c0d1"],
  strokes: ["#874349", "#718661", "#a48f5f", "#5a7088", "#7f637a", "#5d8692"]
}, NU = (
  /** @class */
  function(o) {
    FU(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.getPalette = function() {
      return LU;
    }, e;
  }(yf)
), GU = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), kU = {
  fills: [
    "#febe76",
    "#ff7979",
    "#badc58",
    "#f9ca23",
    "#f0932b",
    "#eb4c4b",
    "#6ab04c",
    "#7ed6df",
    "#e056fd",
    "#686de0"
  ],
  strokes: [
    "#b28553",
    "#b35555",
    "#829a3e",
    "#ae8d19",
    "#a8671e",
    "#a43535",
    "#4a7b35",
    "#58969c",
    "#9d3cb1",
    "#494c9d"
  ]
}, VU = (
  /** @class */
  function(o) {
    GU(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.getPalette = function() {
      return kU;
    }, e;
  }(mc)
), BU = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), HU = {
  fills: [
    "#febe76",
    "#ff7979",
    "#badc58",
    "#f9ca23",
    "#f0932b",
    "#eb4c4b",
    "#6ab04c",
    "#7ed6df",
    "#e056fd",
    "#686de0"
  ],
  strokes: [
    "#b28553",
    "#b35555",
    "#829a3e",
    "#ae8d19",
    "#a8671e",
    "#a43535",
    "#4a7b35",
    "#58969c",
    "#9d3cb1",
    "#494c9d"
  ]
}, WU = (
  /** @class */
  function(o) {
    BU(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.getPalette = function() {
      return HU;
    }, e;
  }(yf)
), jU = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), UU = {
  fills: ["#5BC0EB", "#FDE74C", "#9BC53D", "#E55934", "#FA7921", "#fa3081"],
  strokes: ["#4086a4", "#b1a235", "#6c8a2b", "#a03e24", "#af5517", "#af225a"]
}, $U = (
  /** @class */
  function(o) {
    jU(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.getPalette = function() {
      return UU;
    }, e;
  }(mc)
), zU = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), KU = {
  fills: ["#5BC0EB", "#FDE74C", "#9BC53D", "#E55934", "#FA7921", "#fa3081"],
  strokes: ["#4086a4", "#b1a235", "#6c8a2b", "#a03e24", "#af5517", "#af225a"]
}, YU = (
  /** @class */
  function(o) {
    zU(e, o);
    function e() {
      return o !== null && o.apply(this, arguments) || this;
    }
    return e.prototype.getPalette = function() {
      return KU;
    }, e;
  }(yf)
), vp = function() {
  return vp = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, vp.apply(this, arguments);
}, Cg = function() {
  return new mc();
}, oC = function() {
  return new yf();
}, XU = {
  undefined: Cg,
  null: Cg,
  "ag-default": Cg,
  "ag-material": function() {
    return new DU();
  },
  "ag-pastel": function() {
    return new IU();
  },
  "ag-solar": function() {
    return new VU();
  },
  "ag-vivid": function() {
    return new $U();
  }
}, qU = {
  undefined: oC,
  null: oC,
  "ag-default-dark": oC,
  "ag-material-dark": function() {
    return new AU();
  },
  "ag-pastel-dark": function() {
    return new NU();
  },
  "ag-solar-dark": function() {
    return new WU();
  },
  "ag-vivid-dark": function() {
    return new YU();
  }
}, RO = vp(vp({}, qU), XU);
function Cf(o) {
  var e;
  if (o instanceof mc)
    return o;
  var t = RO[o];
  if (t)
    return t();
  o = o;
  for (var i = [], r; typeof o == "object"; )
    i.push((e = o.overrides) !== null && e !== void 0 ? e : {}), o.palette && r == null && (r = o.palette), o = o.baseTheme;
  i.reverse();
  var n = vp({ baseTheme: o, overrides: Ft(i) }, r ? { palette: r } : {});
  if (n.baseTheme || n.overrides) {
    var s = Cf(n.baseTheme);
    return new s.constructor(n);
  }
  return Cg();
}
var yv = function() {
  return yv = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, yv.apply(this, arguments);
}, yd = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, iS = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, IE = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, ZU = ["bar", "column", "area"], QU = ["bar", "column"];
function JU(o) {
  var e, t, i, r, n, s, a, l, c, d, u = {}, h = {}, p = {}, f = "default-ag-charts-group", g = [];
  try {
    for (var v = yd(o), y = v.next(); !y.done; y = v.next()) {
      var m = y.value, C = (n = m.type) !== null && n !== void 0 ? n : "line", R = ZU.includes(C), E = QU.includes(C);
      if (!R && !E) {
        g.push({ type: "ungrouped", opts: [m] });
        continue;
      }
      var b = m, T = b.stacked, D = b.stackGroup, P = b.grouped, O = P === void 0 ? void 0 : P, M = b.xKey, _ = D != null || T === !0;
      (s = p[C]) !== null && s !== void 0 || (p[C] = !1), p[C] || (p[C] = _);
      var F = O === !0, I = [D != null ? D : T === !0 ? "stacked" : void 0, F ? "grouped" : void 0].filter(function($) {
        return $ != null;
      }).join("-");
      I || (I = f);
      var G = C + "-" + M + "-" + I;
      if (_ && R) {
        var k = (a = h[G]) !== null && a !== void 0 ? a : h[G] = { type: "stack", opts: [] };
        k.opts.length === 0 && g.push(k), k.opts.push(m);
      } else if (F && E) {
        var k = (l = u[G]) !== null && l !== void 0 ? l : u[G] = { type: "group", opts: [] };
        k.opts.length === 0 && g.push(k), k.opts.push(m);
      } else
        g.push({ type: "ungrouped", opts: [m] });
    }
  } catch ($) {
    e = { error: $ };
  } finally {
    try {
      y && !y.done && (t = v.return) && t.call(v);
    } finally {
      if (e)
        throw e.error;
    }
  }
  if (!Object.values(p).some(function($) {
    return $;
  }))
    return g;
  try {
    for (var N = yd(Object.entries(u)), W = N.next(); !W.done; W = N.next()) {
      var j = iS(W.value, 2), K = j[1], C = (d = (c = K.opts[0]) === null || c === void 0 ? void 0 : c.type) !== null && d !== void 0 ? d : "line";
      p[C] === !0 && (K.type = "stack");
    }
  } catch ($) {
    i = { error: $ };
  } finally {
    try {
      W && !W.done && (r = N.return) && r.call(N);
    } finally {
      if (i)
        throw i.error;
    }
  }
  return g;
}
var e$ = function() {
  return [!0, "opts"].includes(Fn("agChartsDebug"));
};
function t$(o, e) {
  var t, i, r = [], n = e.map(function(p) {
    var f;
    return (p.type === "bar" || p.type === "column") && p.yKey != null && !p.stacked ? yv(yv({}, p), { grouped: (f = p.grouped) !== null && f !== void 0 ? f : !0 }) : p;
  }), s = JU(n), a = s.reduce(function(p, f) {
    var g, v;
    if (f.type === "ungrouped")
      return p;
    var y = (g = f.opts[0].type) !== null && g !== void 0 ? g : "line";
    return (v = p[y]) !== null && v !== void 0 || (p[y] = 0), p[y] += f.type === "stack" ? 1 : f.opts.length, p;
  }, {}), l = {}, c = function(p) {
    var f, g, v, y, m, C, R, E, b = 0, T = (R = p.opts[0].type) !== null && R !== void 0 ? R : "line";
    if ((E = l[T]) !== null && E !== void 0 || (l[T] = 0), p.type === "stack") {
      try {
        for (var D = yd(p.opts), P = D.next(); !P.done; P = D.next()) {
          var O = P.value;
          O.seriesGrouping = {
            groupIndex: l[T],
            groupCount: a[T],
            stackIndex: b++,
            stackCount: p.opts.length
          };
        }
      } catch (G) {
        f = { error: G };
      } finally {
        try {
          P && !P.done && (g = D.return) && g.call(D);
        } finally {
          if (f)
            throw f.error;
        }
      }
      l[T]++;
    } else if (p.type === "group")
      try {
        for (var M = yd(p.opts), _ = M.next(); !_.done; _ = M.next()) {
          var O = _.value;
          O.seriesGrouping = {
            groupIndex: l[T],
            groupCount: a[T],
            stackIndex: 0,
            stackCount: 0
          }, l[T]++;
        }
      } catch (G) {
        v = { error: G };
      } finally {
        try {
          _ && !_.done && (y = M.return) && y.call(M);
        } finally {
          if (v)
            throw v.error;
        }
      }
    else
      try {
        for (var F = yd(p.opts), I = F.next(); !I.done; I = F.next()) {
          var O = I.value;
          O.seriesGrouping = void 0;
        }
      } catch (G) {
        m = { error: G };
      } finally {
        try {
          I && !I.done && (C = F.return) && C.call(F);
        } finally {
          if (m)
            throw m.error;
        }
      }
    return p.opts;
  };
  e$() && pe.debug("processSeriesOptions() - series grouping: ", s);
  try {
    for (var d = yd(s), u = d.next(); !u.done; u = d.next()) {
      var h = u.value;
      switch (h.opts[0].type) {
        case "column":
        case "bar":
        case "area":
          r.push.apply(r, IE([], iS(c(h))));
          break;
        case "line":
        default:
          h.opts.length > 1 && pe.warn("unexpected grouping of series type: " + h.opts[0].type), r.push.apply(r, IE([], iS(h.opts)));
          break;
      }
    }
  } catch (p) {
    t = { error: p };
  } finally {
    try {
      u && !u.done && (i = d.return) && i.call(d);
    } finally {
      if (t)
        throw t.error;
    }
  }
  return r;
}
var hs = function() {
  return hs = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, hs.apply(this, arguments);
}, rS = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Jd = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, FE = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
};
function Fu(o) {
  var e, t, i, r;
  return (r = (e = o.type) !== null && e !== void 0 ? e : (i = (t = o.series) === null || t === void 0 ? void 0 : t[0]) === null || i === void 0 ? void 0 : i.type) !== null && r !== void 0 ? r : "line";
}
function eu(o) {
  var e = Fu(o);
  return e == null ? !0 : e === "cartesian" ? (pe.warnOnce("type '" + e + "' is deprecated, use a series type instead"), !0) : Ut.isCartesian(e);
}
function Ym(o) {
  var e = Fu(o);
  return e == null ? !1 : e === "hierarchy" ? (pe.warnOnce("type '" + e + "' is deprecated, use a series type instead"), !0) : Ut.isHierarchy(e);
}
function Xm(o) {
  var e = Fu(o);
  return e == null ? !1 : e === "polar" ? (pe.warnOnce("type '" + e + "' is deprecated, use a series type instead"), !0) : Ut.isPolar(e);
}
function LE(o) {
  return o == null ? !1 : Ut.has(o);
}
function i$(o) {
  return o == null ? !1 : cw.has(o);
}
function TO(o) {
  var e, t, i = 0;
  try {
    for (var r = rS(o), n = r.next(); !n.done; n = r.next()) {
      var s = n.value;
      s instanceof Array && (i += TO(s)), s != null && i++;
    }
  } catch (a) {
    e = { error: a };
  } finally {
    try {
      n && !n.done && (t = r.return) && t.call(r);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return i;
}
function NE(o, e, t) {
  for (var i = [], r = 0; r < t; r++)
    i.push(e[(r + o.colourIndex) % e.length]);
  return i;
}
var wa = {
  avoidDeepClone: ["data"]
};
function r$(o, e) {
  var t, i, r, n, s, a, l, c, d, u, h = Ft([e, o], wa);
  n$(h);
  var p = h.type, f = Fu(h), g = (a = (s = h.tooltip) === null || s === void 0 ? void 0 : s.position) !== null && a !== void 0 ? a : {}, v = function(N) {
    if (N != null && !(LE(N) || PE(N)))
      throw new Error("AG Charts - unknown series type: " + N + "; expected one of: " + Ut.seriesTypes);
  };
  v(f);
  try {
    for (var y = rS((l = h.series) !== null && l !== void 0 ? l : []), m = y.next(); !m.done; m = y.next()) {
      var C = m.value.type;
      C != null && v(C);
    }
  } catch (N) {
    t = { error: N };
  } finally {
    try {
      m && !m.done && (i = y.return) && i.call(y);
    } finally {
      if (t)
        throw t.error;
    }
  }
  h = hs(hs({}, h), { type: f });
  var R = "line";
  eu(h) ? R = "line" : Ym(h) ? R = "treemap" : Xm(h) && (R = "pie");
  var E = {}, b = PE(f);
  b ? E = b : f === "bar" ? E = pU : f === "scatter" || f === "histogram" ? E = fU : eu(h) && (E = hU), u$(h);
  var T = s$(E, h), D = T.context, P = T.mergedOptions, O = T.axesThemes, M = T.seriesThemes;
  P.series = t$(P, ((c = P.series) !== null && c !== void 0 ? c : []).map(function(N) {
    var W = R;
    N.type ? W = N.type : LE(p) && (W = p);
    var j = o$(N, W, M, g);
    return W === "pie" && f$(M.pie, N, j), j;
  })).map(function(N) {
    return l$(D, N);
  });
  var _ = function(N) {
    var W = i$(N);
    return W || pe.warnOnce("AG Charts - unknown axis type: " + N + "; expected one of: " + cw.axesTypes + ", ignoring."), W;
  };
  if ("axes" in P) {
    var F = !0;
    try {
      for (var I = rS((d = P.axes) !== null && d !== void 0 ? d : []), G = I.next(); !G.done; G = I.next()) {
        var k = G.value.type;
        _(k) || (F = !1);
      }
    } catch (N) {
      r = { error: N };
    } finally {
      try {
        G && !G.done && (n = I.return) && n.call(I);
      } finally {
        if (r)
          throw r.error;
      }
    }
    F ? P.axes = (u = P.axes) === null || u === void 0 ? void 0 : u.map(function(N) {
      var W, j, K = N.type, $ = Ft([
        O[K],
        (j = O[K][(W = N.position) !== null && W !== void 0 ? W : "unknown"]) !== null && j !== void 0 ? j : {}
      ]);
      return d$(N, $);
    }) : P.axes = E.axes, h$(h, P);
  }
  return p$(h, P), P;
}
function n$(o) {
  var e = {
    yKeys: "yKey",
    yNames: "yName"
  };
  Object.entries(e).forEach(function(t) {
    var i, r = Jd(t, 2), n = r[0], s = r[1];
    !((i = o.series) === null || i === void 0) && i.some(function(a) {
      return a[n] != null;
    }) && pe.warnOnce("property [series." + n + "] is deprecated, please use [series." + s + "] and multiple series instead.");
  });
}
function o$(o, e, t, i) {
  var r, n, s = Ft([hs({}, i), (r = o.tooltip) === null || r === void 0 ? void 0 : r.position], wa), a = Ft([
    (n = t[e]) !== null && n !== void 0 ? n : {},
    hs(hs({}, o), { type: e, tooltip: hs(hs({}, o.tooltip), { position: s }) })
  ], wa);
  return a;
}
function s$(o, e) {
  var t = a$(e), i = t.theme, r = t.cleanedTheme, n = t.axesThemes, s = t.seriesThemes, a = { colourIndex: 0, palette: i.palette }, l = Ft([o, r, e], wa);
  return { context: a, mergedOptions: l, axesThemes: n, seriesThemes: s };
}
function a$(o) {
  var e, t, i = Cf(o.theme), r = i.config[(e = Fu(o)) !== null && e !== void 0 ? e : "cartesian"], n = Object.entries(i.config).reduce(function(s, a) {
    var l = Jd(a, 2), c = l[0], d = l[1].series;
    return s[c] = d == null ? void 0 : d[c], s;
  }, {});
  return {
    theme: i,
    axesThemes: (t = r.axes) !== null && t !== void 0 ? t : {},
    seriesThemes: n,
    cleanedTheme: Ft([r, { axes: nn, series: nn }])
  };
}
function l$(o, e) {
  for (var t = [], i = 2; i < arguments.length; i++)
    t[i - 2] = arguments[i];
  var r = c$(o, e), n = { stacked: nn, grouped: nn };
  return Ft(FE(FE([], Jd(t)), [r, e, n]), wa);
}
il("pie", function(o) {
  var e = o.takeColors, t = o.colorsCount;
  return e(t);
});
var Lu = function(o) {
  var e = o.takeColors, t = e(1), i = Jd(t.fills, 1), r = i[0], n = Jd(t.strokes, 1), s = n[0];
  return { fill: r, stroke: s };
};
il("area", Lu);
il("bar", Lu);
il("column", Lu);
il("histogram", Lu);
il("scatter", function(o) {
  var e = Lu(o), t = e.fill, i = e.stroke;
  return { marker: { fill: t, stroke: i } };
});
il("line", function(o) {
  var e = Lu(o), t = e.fill, i = e.stroke;
  return {
    stroke: t,
    marker: { fill: t, stroke: i }
  };
});
function c$(o, e) {
  var t, i = uU(e.type);
  if (!i)
    return {};
  var r = o.palette, n = r.fills, s = r.strokes, a = e, l = TO((t = a.yKeys) !== null && t !== void 0 ? t : []) || 1, c = Math.max(n.length, s.length);
  return i({
    seriesCount: l,
    colorsCount: c,
    takeColors: function(d) {
      var u = {
        fills: NE(o, n, d),
        strokes: NE(o, s, d)
      };
      return o.colourIndex += d, u;
    }
  });
}
function d$(o, e) {
  var t = { top: nn, bottom: nn, left: nn, right: nn };
  if (o.crossLines) {
    Array.isArray(o.crossLines) || (pe.warn("axis[].crossLines should be an array."), o.crossLines = []);
    var i = e.crossLines;
    o.crossLines = o.crossLines.map(function(n) {
      return Ft([i, n]);
    });
  }
  var r = { crossLines: nn };
  return Ft([e, r, o, t], wa);
}
function u$(o) {
  $l(o, function(e, t) {
    "enabled" in t && t.enabled === !1 && Object.entries(t).forEach(function(i) {
      var r = Jd(i, 1), n = r[0];
      n !== "enabled" && delete t[n];
    });
  }, { skip: ["data", "theme"] });
}
function h$(o, e) {
  var t, i, r, n;
  if (!(((t = o.legend) === null || t === void 0 ? void 0 : t.enabled) !== void 0 || ((i = e.legend) === null || i === void 0 ? void 0 : i.enabled) !== void 0)) {
    if ((r = e.legend) !== null && r !== void 0 || (e.legend = {}), ((n = o.series) !== null && n !== void 0 ? n : []).length > 1) {
      e.legend.enabled = !0;
      return;
    }
    e.legend.enabled = !1;
  }
}
function p$(o, e) {
  $l(o, function(t, i, r) {
    if (r) {
      var n = r._enabledFromTheme;
      n != null && delete r._enabledFromTheme, "enabled" in r && (n || i.enabled == null && (r.enabled = !0));
    }
  }, { skip: ["data", "theme"] }, e), $l(e, function(t, i) {
    i._enabledFromTheme != null && delete i._enabledFromTheme;
  }, { skip: ["data", "theme"] });
}
function f$(o, e, t) {
  Array.isArray(e.innerLabels) ? t.innerLabels = e.innerLabels.map(function(i) {
    return Ft([o.innerLabels, i]);
  }) : t.innerLabels = nn;
}
var g$ = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, xO = (
  /** @class */
  function() {
    function o() {
      this.destroyFns = [];
    }
    return o.prototype.destroy = function() {
      var e, t;
      try {
        for (var i = g$(this.destroyFns), r = i.next(); !r.done; r = i.next()) {
          var n = r.value;
          n();
        }
      } catch (s) {
        e = { error: s };
      } finally {
        try {
          r && !r.done && (t = i.return) && t.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
    }, o;
  }()
), Rl = [];
function DO(o) {
  var e = Rl.find(function(i) {
    return o.type === i.type && o.optionsKey === i.optionsKey && o.identifier === i.identifier;
  });
  if (e) {
    if (o.packageType === "enterprise" && e.packageType === "community") {
      var t = Rl.indexOf(e);
      Rl.splice(t, 1, o);
    }
  } else
    Rl.push(o);
}
var v$ = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Zs = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, GE = (
  /** @class */
  function(o) {
    v$(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t._fill = "#f2f2f2", t._stroke = "#999999", t._strokeWidth = 1, t._lineCap = "square", t._centerX = 0, t._centerY = 0, t._width = 8, t._gripLineGap = 2, t._gripLineLength = 8, t._height = 16, t;
    }
    return Object.defineProperty(e.prototype, "centerX", {
      get: function() {
        return this._centerX;
      },
      set: function(t) {
        this._centerX !== t && (this._centerX = t, this.dirtyPath = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "centerY", {
      get: function() {
        return this._centerY;
      },
      set: function(t) {
        this._centerY !== t && (this._centerY = t, this.dirtyPath = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "width", {
      get: function() {
        return this._width;
      },
      set: function(t) {
        this._width !== t && (this._width = t, this.dirtyPath = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "gripLineGap", {
      get: function() {
        return this._gripLineGap;
      },
      set: function(t) {
        this._gripLineGap !== t && (this._gripLineGap = t, this.dirtyPath = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "gripLineLength", {
      get: function() {
        return this._gripLineLength;
      },
      set: function(t) {
        this._gripLineLength !== t && (this._gripLineLength = t, this.dirtyPath = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "height", {
      get: function() {
        return this._height;
      },
      set: function(t) {
        this._height !== t && (this._height = t, this.dirtyPath = !0);
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.computeBBox = function() {
      var t = this, i = t.centerX, r = t.centerY, n = t.width, s = t.height, a = i - n / 2, l = r - s / 2;
      return new nt(a, l, n, s);
    }, e.prototype.isPointInPath = function(t, i) {
      var r = this.transformPoint(t, i), n = this.computeBBox();
      return n.containsPoint(r.x, r.y);
    }, e.prototype.updatePath = function() {
      var t = this, i = t.path, r = t.centerX, n = t.centerY, s = t.width, a = t.height;
      i.clear();
      var l = r - s / 2, c = n - a / 2, d = this.align(l), u = this.align(c), h = d + this.align(l, s), p = u + this.align(c, a);
      i.moveTo(d, u), i.lineTo(h, u), i.lineTo(h, p), i.lineTo(d, p), i.lineTo(d, u);
      var f = this.gripLineGap / 2, g = this.gripLineLength / 2;
      i.moveTo(this.align(r - f), this.align(n - g)), i.lineTo(this.align(r - f), this.align(n + g)), i.moveTo(this.align(r + f), this.align(n - g)), i.lineTo(this.align(r + f), this.align(n + g));
    }, e.className = "RangeHandle", Zs([
      A(Lr)
    ], e.prototype, "_fill", void 0), Zs([
      A(Lr)
    ], e.prototype, "_stroke", void 0), Zs([
      A(le(0))
    ], e.prototype, "_strokeWidth", void 0), Zs([
      A(Xb)
    ], e.prototype, "_lineCap", void 0), Zs([
      A(le(0))
    ], e.prototype, "_width", void 0), Zs([
      A(le(0))
    ], e.prototype, "_gripLineGap", void 0), Zs([
      A(le(0))
    ], e.prototype, "_gripLineLength", void 0), Zs([
      A(le(0))
    ], e.prototype, "_height", void 0), e;
  }(Zi)
), m$ = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), as = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, y$ = (
  /** @class */
  function(o) {
    m$(e, o);
    function e() {
      var t = o !== null && o.apply(this, arguments) || this;
      return t._stroke = "#999999", t._strokeWidth = 1, t._fill = "#999999", t._fillOpacity = 0.2, t._lineCap = "square", t._x = 0, t._y = 0, t._width = 200, t._height = 30, t.minRange = 0.05, t._min = 0, t._max = 1, t;
    }
    return Object.defineProperty(e.prototype, "x", {
      get: function() {
        return this._x;
      },
      set: function(t) {
        this._x !== t && (this._x = t, this.dirtyPath = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "y", {
      get: function() {
        return this._y;
      },
      set: function(t) {
        this._y !== t && (this._y = t, this.dirtyPath = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "width", {
      get: function() {
        return this._width;
      },
      set: function(t) {
        this._width !== t && (this._width = t, this.dirtyPath = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "height", {
      get: function() {
        return this._height;
      },
      set: function(t) {
        this._height !== t && (this._height = t, this.dirtyPath = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "min", {
      get: function() {
        return this._min;
      },
      set: function(t) {
        var i;
        t = Math.min(Math.max(t, 0), this.max - this.minRange), !isNaN(t) && this._min !== t && (this._min = t, this.dirtyPath = !0, (i = this.onRangeChange) === null || i === void 0 || i.call(this));
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "max", {
      get: function() {
        return this._max;
      },
      set: function(t) {
        var i;
        t = Math.max(Math.min(t, 1), this.min + this.minRange), !isNaN(t) && this._max !== t && (this._max = t, this.dirtyPath = !0, (i = this.onRangeChange) === null || i === void 0 || i.call(this));
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.computeBBox = function() {
      var t = this, i = t.x, r = t.y, n = t.width, s = t.height;
      return new nt(i, r, n, s);
    }, e.prototype.computeVisibleRangeBBox = function() {
      var t = this, i = t.x, r = t.y, n = t.width, s = t.height, a = t.min, l = t.max, c = i + n * a, d = i + n * l;
      return new nt(c, r, d - c, s);
    }, e.prototype.updatePath = function() {
      var t = this, i = t.path, r = t.x, n = t.y, s = t.width, a = t.height, l = t.min, c = t.max;
      i.clear();
      var d = this.align(r), u = this.align(n), h = d + this.align(r, s), p = u + this.align(n, a);
      i.moveTo(d, u), i.lineTo(h, u), i.lineTo(h, p), i.lineTo(d, p), i.lineTo(d, u);
      var f = this.align(r + s * l), g = this.align(r + s * c);
      i.moveTo(f, u), i.lineTo(f, p), i.lineTo(g, p), i.lineTo(g, u), i.lineTo(f, u);
    }, e.className = "RangeMask", as([
      A(Lr)
    ], e.prototype, "_stroke", void 0), as([
      A(le(0))
    ], e.prototype, "_strokeWidth", void 0), as([
      A(Lr)
    ], e.prototype, "_fill", void 0), as([
      A(le(0, 1))
    ], e.prototype, "_fillOpacity", void 0), as([
      A(Xb)
    ], e.prototype, "_lineCap", void 0), as([
      A(le(0))
    ], e.prototype, "_width", void 0), as([
      A(le(0))
    ], e.prototype, "_height", void 0), as([
      A(le())
    ], e.prototype, "_min", void 0), as([
      A(le())
    ], e.prototype, "_max", void 0), e;
  }(Zi)
), C$ = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), Cv = function() {
  return Cv = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, Cv.apply(this, arguments);
}, S$ = (
  /** @class */
  function(o) {
    C$(e, o);
    function e() {
      var t = o.call(this, { name: "rangeSelectorGroup" }) || this;
      return t.minHandle = new GE(), t.maxHandle = new GE(), t.mask = function() {
        var i = e.defaults, r = i.x, n = i.y, s = i.width, a = i.height, l = i.min, c = i.max, d = new y$();
        d.x = r, d.y = n, d.width = s, d.height = a, d.min = l, d.max = c;
        var u = t, h = u.minHandle, p = u.maxHandle;
        return h.centerX = r, p.centerX = r + s, h.centerY = p.centerY = n + a / 2, t.append([d, h, p]), d.onRangeChange = function() {
          var f;
          t.updateHandles(), (f = t.onRangeChange) === null || f === void 0 || f.call(t);
        }, d;
      }(), t._x = e.defaults.x, t._y = e.defaults.y, t._width = e.defaults.width, t._height = e.defaults.height, t._min = e.defaults.min, t._max = e.defaults.max, t.isContainerNode = !0, t;
    }
    return Object.defineProperty(e.prototype, "x", {
      get: function() {
        return this.mask.x;
      },
      set: function(t) {
        this.mask.x = t, this.updateHandles();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "y", {
      get: function() {
        return this.mask.y;
      },
      set: function(t) {
        this.mask.y = t, this.updateHandles();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "width", {
      get: function() {
        return this.mask.width;
      },
      set: function(t) {
        this.mask.width = t, this.updateHandles();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "height", {
      get: function() {
        return this.mask.height;
      },
      set: function(t) {
        this.mask.height = t, this.updateHandles();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "min", {
      get: function() {
        return this.mask.min;
      },
      set: function(t) {
        this.mask.min = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "max", {
      get: function() {
        return this.mask.max;
      },
      set: function(t) {
        this.mask.max = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.updateHandles = function() {
      var t = this, i = t.minHandle, r = t.maxHandle, n = t.x, s = t.y, a = t.width, l = t.height, c = t.mask;
      i.centerX = n + a * c.min, r.centerX = n + a * c.max, i.centerY = r.centerY = s + l / 2;
    }, e.prototype.computeBBox = function() {
      return this.mask.computeBBox();
    }, e.prototype.computeVisibleRangeBBox = function() {
      return this.mask.computeVisibleRangeBBox();
    }, e.prototype.render = function(t) {
      var i = t.ctx, r = t.forceRender, n = t.stats;
      if (this.dirty === oe.NONE && !r) {
        n && n.nodesSkipped++;
        return;
      }
      this.computeTransformMatrix(), this.matrix.toContext(i);
      var s = this, a = s.mask, l = s.minHandle, c = s.maxHandle;
      [a, l, c].forEach(function(d) {
        d.visible && (r || d.dirty > oe.NONE) && (i.save(), d.render(Cv(Cv({}, t), { ctx: i, forceRender: r })), i.restore());
      }), this.markClean({ force: !0 }), n && n.nodesRendered++;
    }, e.className = "Range", e.defaults = {
      x: 0,
      y: 0,
      width: 200,
      height: 30,
      min: 0,
      max: 1
    }, e;
  }(we)
), b$ = (
  /** @class */
  function() {
    function o(e) {
      this.rm = e;
    }
    return Object.defineProperty(o.prototype, "fill", {
      get: function() {
        return this.rm.fill;
      },
      set: function(e) {
        this.rm.fill = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "stroke", {
      get: function() {
        return this.rm.stroke;
      },
      set: function(e) {
        this.rm.stroke = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "strokeWidth", {
      get: function() {
        return this.rm.strokeWidth;
      },
      set: function(e) {
        this.rm.strokeWidth = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "fillOpacity", {
      get: function() {
        return this.rm.fillOpacity;
      },
      set: function(e) {
        this.rm.fillOpacity = e;
      },
      enumerable: !1,
      configurable: !0
    }), o;
  }()
), kE = (
  /** @class */
  function() {
    function o(e) {
      this.rh = e;
    }
    return Object.defineProperty(o.prototype, "fill", {
      get: function() {
        return this.rh.fill;
      },
      set: function(e) {
        this.rh.fill = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "stroke", {
      get: function() {
        return this.rh.stroke;
      },
      set: function(e) {
        this.rh.stroke = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "strokeWidth", {
      get: function() {
        return this.rh.strokeWidth;
      },
      set: function(e) {
        this.rh.strokeWidth = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "width", {
      get: function() {
        return this.rh.width;
      },
      set: function(e) {
        this.rh.width = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "height", {
      get: function() {
        return this.rh.height;
      },
      set: function(e) {
        this.rh.height = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "gripLineGap", {
      get: function() {
        return this.rh.gripLineGap;
      },
      set: function(e) {
        this.rh.gripLineGap = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(o.prototype, "gripLineLength", {
      get: function() {
        return this.rh.gripLineLength;
      },
      set: function(e) {
        this.rh.gripLineLength = e;
      },
      enumerable: !1,
      configurable: !0
    }), o;
  }()
), w$ = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), VE = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, E$ = (
  /** @class */
  function(o) {
    w$(e, o);
    function e(t) {
      var i, r = o.call(this) || this;
      return r.ctx = t, r.rs = new S$(), r.mask = new b$(r.rs.mask), r.minHandle = new kE(r.rs.minHandle), r.maxHandle = new kE(r.rs.maxHandle), r.minHandleDragging = !1, r.maxHandleDragging = !1, r.panHandleOffset = NaN, r._enabled = !1, r.margin = 10, r._visible = !0, r.rs.onRangeChange = function() {
        return r.ctx.zoomManager.updateZoom("navigator", { x: { min: r.rs.min, max: r.rs.max } });
      }, [
        t.interactionManager.addListener("drag-start", function(n) {
          return r.onDragStart(n);
        }),
        t.interactionManager.addListener("drag", function(n) {
          return r.onDrag(n);
        }),
        t.interactionManager.addListener("hover", function(n) {
          return r.onDrag(n);
        }),
        t.interactionManager.addListener("drag-end", function() {
          return r.onDragStop();
        })
      ].forEach(function(n) {
        return r.destroyFns.push(function() {
          return t.interactionManager.removeListener(n);
        });
      }), [
        t.layoutService.addListener("before-series", function(n) {
          return r.layout(n);
        }),
        t.layoutService.addListener("layout-complete", function(n) {
          return r.layoutComplete(n);
        })
      ].forEach(function(n) {
        return r.destroyFns.push(function() {
          return t.layoutService.removeListener(n);
        });
      }), (i = t.scene.root) === null || i === void 0 || i.appendChild(r.rs), r.destroyFns.push(function() {
        var n;
        return (n = t.scene.root) === null || n === void 0 ? void 0 : n.removeChild(r.rs);
      }), r.destroyFns.push(function() {
        return r.ctx.zoomManager.updateZoom("navigator");
      }), r.updateGroupVisibility(), r;
    }
    return Object.defineProperty(e.prototype, "enabled", {
      get: function() {
        return this._enabled;
      },
      set: function(t) {
        this._enabled = t, this.updateGroupVisibility();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "width", {
      get: function() {
        return this.rs.width;
      },
      set: function(t) {
        this.rs.width = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "height", {
      get: function() {
        return this.rs.height;
      },
      set: function(t) {
        this.rs.height = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "min", {
      get: function() {
        return this.rs.min;
      },
      set: function(t) {
        this.rs.min = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "max", {
      get: function() {
        return this.rs.max;
      },
      set: function(t) {
        this.rs.max = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "visible", {
      get: function() {
        return this._visible;
      },
      set: function(t) {
        this._visible = t, this.updateGroupVisibility();
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.updateGroupVisibility = function() {
      var t = this.enabled && this.visible;
      this.rs.visible = t, t ? this.ctx.zoomManager.updateZoom("navigator", { x: { min: this.rs.min, max: this.rs.max } }) : this.ctx.zoomManager.updateZoom("navigator");
    }, e.prototype.layout = function(t) {
      var i = t.shrinkRect;
      if (this.enabled) {
        var r = this.rs.height + this.margin;
        i.shrink(r, "bottom"), this.rs.y = i.y + i.height + this.margin;
      }
      return { shrinkRect: i };
    }, e.prototype.layoutComplete = function(t) {
      var i = t.series, r = i.rect, n = i.visible;
      this.enabled && n && (this.rs.x = r.x, this.rs.width = r.width), this.visible = n;
    }, e.prototype.onDragStart = function(t) {
      if (this.enabled) {
        var i = t.offsetX, r = t.offsetY, n = this.rs, s = n.minHandle, a = n.maxHandle, l = n.x, c = n.width, d = n.min, u = n.computeVisibleRangeBBox();
        this.minHandleDragging || this.maxHandleDragging || (s.containsPoint(i, r) ? this.minHandleDragging = !0 : a.containsPoint(i, r) ? this.maxHandleDragging = !0 : u.containsPoint(i, r) && (this.panHandleOffset = (i - l) / c - d));
      }
    }, e.prototype.onDrag = function(t) {
      if (this.enabled) {
        var i = this, r = i.rs, n = i.panHandleOffset, s = r.x, a = r.y, l = r.width, c = r.height, d = r.minHandle, u = r.maxHandle, h = t.offsetX, p = t.offsetY, f = s + l * r.min, g = s + l * r.max, v = new nt(f, a, g - f, c), y = function() {
          return Math.min(Math.max((h - s) / l, 0), 1);
        };
        if (d.containsPoint(h, p) || u.containsPoint(h, p) ? this.ctx.cursorManager.updateCursor("navigator", "ew-resize") : v.containsPoint(h, p) ? this.ctx.cursorManager.updateCursor("navigator", "grab") : this.ctx.cursorManager.updateCursor("navigator"), this.minHandleDragging)
          r.min = y();
        else if (this.maxHandleDragging)
          r.max = y();
        else if (!isNaN(n)) {
          var m = r.max - r.min, C = Math.min(y() - n, 1 - m);
          C <= r.min ? (r.min = C, r.max = r.min + m) : (r.max = C + m, r.min = r.max - m);
        }
      }
    }, e.prototype.onDragStop = function() {
      this.stopHandleDragging();
    }, e.prototype.stopHandleDragging = function() {
      this.minHandleDragging = this.maxHandleDragging = !1, this.panHandleOffset = NaN;
    }, VE([
      A(ht)
    ], e.prototype, "_enabled", void 0), VE([
      A(le(0))
    ], e.prototype, "margin", void 0), e;
  }(xO)
), R$ = {
  type: "root",
  optionsKey: "navigator",
  packageType: "community",
  chartTypes: ["cartesian"],
  instanceConstructor: E$,
  themeTemplate: {
    navigator: {
      enabled: !1,
      height: 30,
      mask: {
        fill: "#999999",
        stroke: "#999999",
        strokeWidth: 1,
        fillOpacity: 0.2
      },
      minHandle: {
        fill: "#f2f2f2",
        stroke: "#999999",
        strokeWidth: 1,
        width: 8,
        height: 16,
        gripLineGap: 2,
        gripLineLength: 8
      },
      maxHandle: {
        fill: "#f2f2f2",
        stroke: "#999999",
        strokeWidth: 1,
        width: 8,
        height: 16,
        gripLineGap: 2,
        gripLineLength: 8
      }
    }
  }
};
DO(R$);
var T$ = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), BE = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, x$ = (
  /** @class */
  function(o) {
    T$(e, o);
    function e(t) {
      var i, r = o.call(this) || this;
      r.onLayoutComplete = function(s) {
        var a = s.chart, l = a.width, c = a.height;
        r.rectNode.width = l, r.rectNode.height = c;
      }, r.node = new we({ name: "background" }), r.node.zIndex = kt.SERIES_BACKGROUND_ZINDEX, r.rectNode = new kn(), r.node.appendChild(r.rectNode), r.fill = "white", r.visible = !0, (i = t.scene.root) === null || i === void 0 || i.appendChild(r.node), r.destroyFns.push(function() {
        var s;
        return (s = t.scene.root) === null || s === void 0 ? void 0 : s.removeChild(r.node);
      });
      var n = t.layoutService.addListener("layout-complete", r.onLayoutComplete);
      return r.destroyFns.push(function() {
        return t.layoutService.removeListener(n);
      }), r;
    }
    return BE([
      A(ht),
      qt("node", "visible")
    ], e.prototype, "visible", void 0), BE([
      A(St),
      qt("rectNode", "fill")
    ], e.prototype, "fill", void 0), e;
  }(xO)
), D$ = {
  type: "root",
  optionsKey: "background",
  packageType: "community",
  chartTypes: ["cartesian", "polar", "hierarchy"],
  instanceConstructor: x$
};
DO(D$);
var sC = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function O$() {
  var o, e, t, i, r, n;
  try {
    for (var s = sC(Rl), a = s.next(); !a.done; a = s.next()) {
      var l = a.value;
      if (gp.constructors != null && l.optionConstructors != null && Object.assign(gp.constructors, l.optionConstructors), l.type === "root" && l.themeTemplate)
        try {
          for (var c = (t = void 0, sC(l.chartTypes)), d = c.next(); !d.done; d = c.next()) {
            var u = d.value;
            aU(u, l.themeTemplate);
          }
        } catch (g) {
          t = { error: g };
        } finally {
          try {
            d && !d.done && (i = c.return) && i.call(c);
          } finally {
            if (t)
              throw t.error;
          }
        }
      if (l.type === "series") {
        if (l.chartTypes.length > 1)
          throw new Error("AG Charts - Module definition error: " + l.identifier);
        cU(l.identifier, l.chartTypes[0], l.instanceConstructor, l.seriesDefaults, l.themeTemplate, l.paletteFactory);
      }
      if (l.type === "axis-option" && l.themeTemplate)
        try {
          for (var h = (r = void 0, sC(l.axisTypes)), p = h.next(); !p.done; p = h.next()) {
            var f = p.value;
            EE(f, l.themeTemplate);
          }
        } catch (g) {
          r = { error: g };
        } finally {
          try {
            p && !p.done && (n = h.return) && n.call(h);
          } finally {
            if (r)
              throw r.error;
          }
        }
      l.type === "axis" && (a3(l.identifier, l.instanceConstructor), l.themeTemplate && EE(l.identifier, l.themeTemplate)), l.type === "legend" && aW(l.identifier, l.instanceConstructor);
    }
  } catch (g) {
    o = { error: g };
  } finally {
    try {
      a && !a.done && (e = s.return) && e.call(s);
    } finally {
      if (o)
        throw o.error;
    }
  }
}
var si = function() {
  return si = Object.assign || function(o) {
    for (var e, t = 1, i = arguments.length; t < i; t++) {
      e = arguments[t];
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && (o[r] = e[r]);
    }
    return o;
  }, si.apply(this, arguments);
}, ch = function(o, e, t, i) {
  function r(n) {
    return n instanceof t ? n : new t(function(s) {
      s(n);
    });
  }
  return new (t || (t = Promise))(function(n, s) {
    function a(d) {
      try {
        c(i.next(d));
      } catch (u) {
        s(u);
      }
    }
    function l(d) {
      try {
        c(i.throw(d));
      } catch (u) {
        s(u);
      }
    }
    function c(d) {
      d.done ? n(d.value) : r(d.value).then(a, l);
    }
    c((i = i.apply(o, e || [])).next());
  });
}, dh = function(o, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, r, n, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(c) {
    return function(d) {
      return l([c, d]);
    };
  }
  function l(c) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, r && (n = c[0] & 2 ? r.return : c[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, c[1])).done)
          return n;
        switch (r = 0, n && (c = [c[0] & 2, n.value]), c[0]) {
          case 0:
          case 1:
            n = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, r = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!n || c[1] > n[0] && c[1] < n[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = c;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(c);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(o, t);
      } catch (d) {
        c = [6, d], r = 0;
      } finally {
        i = n = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}, OO = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, PO = function(o, e) {
  for (var t = 0, i = e.length, r = o.length; t < i; t++, r++)
    o[r] = e[t];
  return o;
}, qm = function(o) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && o[e], i = 0;
  if (t)
    return t.call(o);
  if (o && typeof o.length == "number")
    return {
      next: function() {
        return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function HE(o) {
  if (eu(o))
    return "cartesian";
  if (Xm(o))
    return "polar";
  if (Ym(o))
    return "hierarchy";
  throw new Error("AG Chart - unknown type of chart for options with type: " + o.type);
}
var Od = (
  /** @class */
  function() {
    function o() {
    }
    return o.create = function(e) {
      return ld.createOrUpdate(e);
    }, o.update = function(e, t) {
      if (!yh.isInstance(e))
        throw new Error("AG Charts - invalid chart reference passed");
      ld.createOrUpdate(t, e);
    }, o.updateDelta = function(e, t) {
      if (!yh.isInstance(e))
        throw new Error("AG Charts - invalid chart reference passed");
      return ld.updateUserDelta(e, t);
    }, o.download = function(e, t) {
      if (!(e instanceof yh))
        throw new Error("AG Charts - invalid chart reference passed");
      return ld.download(e, t);
    }, o.getImageDataURL = function(e, t) {
      if (!(e instanceof yh))
        throw new Error("AG Charts - invalid chart reference passed");
      return ld.getImageDataURL(e, t);
    }, o;
  }()
), yh = (
  /** @class */
  function() {
    function o(e) {
      this.chart = e;
    }
    return o.isInstance = function(e) {
      var t, i;
      if (e instanceof o || ((t = e.constructor) === null || t === void 0 ? void 0 : t.name) === "AgChartInstanceProxy" && e.chart != null)
        return !0;
      var r = Object.keys((i = e.constructor) === null || i === void 0 ? void 0 : i.prototype), n = Object.keys(o.prototype).every(function(s) {
        return r.includes(s);
      });
      return !!(n && e.chart != null);
    }, o.prototype.getOptions = function() {
      return this.chart.getOptions();
    }, o.prototype.destroy = function() {
      this.chart.destroy();
    }, o;
  }()
), ld = (
  /** @class */
  function() {
    function o() {
    }
    return o.initialiseModules = function() {
      o.initialised || (O$(), o.initialised = !0);
    }, o.createOrUpdate = function(e, t) {
      var i = this;
      o.initialiseModules(), Tl(">>> AgChartV2.createOrUpdate() user options", e);
      var r = {};
      o.DEBUG() === !0 && (r.debug = !0);
      var n = e.overrideDevicePixelRatio;
      delete e.overrideDevicePixelRatio;
      var s = r$(e, r), a = t == null ? void 0 : t.chart;
      (a == null || HE(e) !== HE(a.processedOptions)) && (a = o.createChartInstance(s, n, a)), t == null ? t = new yh(a) : t.chart = a;
      var l = a;
      l.queuedUserOptions.push(e);
      var c = function() {
        var d = l.queuedUserOptions.indexOf(e);
        l.queuedUserOptions.splice(0, d);
      };
      return l.requestFactoryUpdate(function() {
        return ch(i, void 0, void 0, function() {
          var d;
          return dh(this, function(u) {
            switch (u.label) {
              case 0:
                return l.destroyed ? [
                  2
                  /*return*/
                ] : (d = Sa(l.processedOptions, s), d == null ? (c(), [
                  2
                  /*return*/
                ]) : [4, o.updateDelta(l, d, e)]);
              case 1:
                return u.sent(), c(), [
                  2
                  /*return*/
                ];
            }
          });
        });
      }), t;
    }, o.updateUserDelta = function(e, t) {
      var i, r = e.chart, n = e.chart.queuedUserOptions, s = (i = n[n.length - 1]) !== null && i !== void 0 ? i : r.userOptions, a = Ft([s, t]);
      Tl(">>> AgChartV2.updateUserDelta() user delta", t), Tl("AgChartV2.updateUserDelta() - base options", s), o.createOrUpdate(a, e);
    }, o.download = function(e, t) {
      var i = this, r = function() {
        return ch(i, void 0, void 0, function() {
          var n, s;
          return dh(this, function(a) {
            switch (a.label) {
              case 0:
                return [4, o.prepareResizedChart(e, t)];
              case 1:
                return n = a.sent(), s = n.chart, s.scene.download(t == null ? void 0 : t.fileName, t == null ? void 0 : t.fileFormat), n !== e && n.destroy(), [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      r().catch(function(n) {
        return pe.errorOnce(n);
      });
    }, o.getImageDataURL = function(e, t) {
      return ch(this, void 0, void 0, function() {
        var i, r, n;
        return dh(this, function(s) {
          switch (s.label) {
            case 0:
              return [4, o.prepareResizedChart(e, t)];
            case 1:
              return i = s.sent(), r = i.chart, n = r.scene.canvas.getDataURL(t == null ? void 0 : t.fileFormat), i !== e && i.destroy(), [2, n];
          }
        });
      });
    }, o.prepareResizedChart = function(e, t) {
      return ch(this, void 0, void 0, function() {
        var i, r, n, s, a, l, c, d, u;
        return dh(this, function(h) {
          switch (h.label) {
            case 0:
              return i = e.chart, r = t != null ? t : {}, n = r.width, s = r.height, a = i.width, l = i.height, c = n === void 0 && s === void 0 || i.scene.canvas.pixelRatio === 1 && a === n && l === s, c ? [2, e] : (n = n != null ? n : a, s = s != null ? s : l, d = si(si({}, i.userOptions), { container: document.createElement("div"), width: n, height: s, autoSize: !1, overrideDevicePixelRatio: 1 }), u = o.createOrUpdate(d), [4, u.chart.waitForUpdate()]);
            case 1:
              return h.sent(), [2, u];
          }
        });
      });
    }, o.createChartInstance = function(e, t, i) {
      var r = i == null ? void 0 : i.destroy({ keepTransferableResources: !0 });
      if (eu(e))
        return new lO(document, t, r);
      if (Ym(e))
        return new dO(document, t, r);
      if (Xm(e))
        return new cO(document, t, r);
      throw new Error("AG Charts - couldn't apply configuration, check type of options: " + e.type);
    }, o.updateDelta = function(e, t, i) {
      var r;
      return ch(this, void 0, void 0, function() {
        return dh(this, function(n) {
          switch (n.label) {
            case 0:
              return t.type == null && (t = si(si({}, t), { type: (r = e.processedOptions.type) !== null && r !== void 0 ? r : Fu(t) })), [4, e.awaitUpdateCompletion()];
            case 1:
              return n.sent(), e.destroyed ? [
                2
                /*return*/
              ] : (Tl("AgChartV2.updateDelta() - applying delta", t), P$(e, t, i), [
                2
                /*return*/
              ]);
          }
        });
      });
    }, o.DEBUG = function() {
      var e;
      return (e = Fn("agChartsDebug")) !== null && e !== void 0 ? e : !1;
    }, o.initialised = !1, o;
  }()
);
function Tl(o) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  [!0, "opts"].includes(ld.DEBUG()) && pe.debug.apply(pe, PO([o], OO(e)));
}
function P$(o, e, t) {
  var i, r, n, s, a = Ft([(i = o.processedOptions) !== null && i !== void 0 ? i : {}, e], wa), l = A$(o, a), c = ["type", "data", "series", "listeners", "theme", "legend"];
  if (eu(e) || Xm(e))
    c.push("axes");
  else if (!Ym(e))
    throw new Error("AG Charts - couldn't apply configuration, check type of options and chart: " + e.type);
  e.listeners && AO(o, e.listeners), Zm(o, e, { skip: c });
  var d = !1;
  if (e.series && e.series.length > 0 && (M$(o, e), d = !0), "axes" in e && Array.isArray(e.axes)) {
    var u = _$(o, e);
    u && (d = !0);
  }
  I$(o, e);
  var h = e.series, p = !!e.data || (h == null ? void 0 : h.some(function(y) {
    return y.data != null;
  })), f = (n = (r = e.legend) !== null && r !== void 0 ? r : e.title) !== null && n !== void 0 ? n : e.subtitle;
  d = d || p || !!f, e.data && (o.data = e.data), e.listeners && o.updateAllSeriesListeners(), o.processedOptions = a, o.userOptions = Ft([(s = o.userOptions) !== null && s !== void 0 ? s : {}, t], wa);
  var g = d || l, v = g ? qe.PROCESS_DATA : qe.PERFORM_LAYOUT;
  Tl("AgChartV2.applyChartOptions() - update type", qe[v]), o.update(v, { forceNodeDataRefresh: d });
}
function A$(o, e) {
  var t, i, r = function(h) {
    return o instanceof lO && h.chartTypes.includes("cartesian") || o instanceof cO && h.chartTypes.includes("polar") || o instanceof dO && h.chartTypes.includes("hierarchy");
  }, n = !1, s = Rl.filter(function(h) {
    return h.type === "root";
  });
  try {
    for (var a = qm(s), l = a.next(); !l.done; l = a.next()) {
      var c = l.value, d = r(c) && e[c.optionsKey] != null, u = o.isModuleEnabled(c);
      d !== u && (n = !0, d ? o.addModule(c) : o.removeModule(c));
    }
  } catch (h) {
    t = { error: h };
  } finally {
    try {
      l && !l.done && (i = a.return) && i.call(a);
    } finally {
      if (t)
        throw t.error;
    }
  }
  return n;
}
function M$(o, e) {
  var t = e.series;
  if (t) {
    var i = o.series.length === t.length && o.series.every(function(r, n) {
      var s;
      return r.type === ((s = t[n]) === null || s === void 0 ? void 0 : s.type);
    });
    if (i) {
      o.series.forEach(function(r, n) {
        var s, a, l, c, d = (l = (a = (s = o.processedOptions) === null || s === void 0 ? void 0 : s.series) === null || a === void 0 ? void 0 : a[n]) !== null && l !== void 0 ? l : {}, u = Sa(d, (c = t[n]) !== null && c !== void 0 ? c : {});
        u && (Tl("AgChartV2.applySeries() - applying series diff idx " + n, u), MO(r, u, { path: "series[" + n + "]", index: n }), r.markNodeDataDirty());
      });
      return;
    }
    o.series = F$(o, t);
  }
}
function _$(o, e) {
  var t = e.axes;
  if (!t)
    return !1;
  var i = o.axes.length === t.length && o.axes.every(function(n, s) {
    return n.type === t[s].type;
  });
  if (i) {
    var r = o.processedOptions;
    if (eu(r))
      return o.axes.forEach(function(n, s) {
        var a, l, c = (l = (a = r.axes) === null || a === void 0 ? void 0 : a[s]) !== null && l !== void 0 ? l : {}, d = Sa(c, t[s]);
        Tl("AgChartV2.applyAxes() - applying axis diff idx " + s, d);
        var u = "axes[" + s + "]", h = ["axes[].type"];
        Zm(n, d, { path: u, skip: h });
      }), !0;
  }
  return o.axes = L$(o, t), !0;
}
function I$(o, e) {
  var t = ["listeners"];
  o.setLegendInit(function(i) {
    var r, n, s, a;
    Zm(i, (r = e.legend) !== null && r !== void 0 ? r : {}, { skip: t }), !((n = e.legend) === null || n === void 0) && n.listeners && Object.assign((s = o.legend) === null || s === void 0 ? void 0 : s.listeners, (a = e.legend.listeners) !== null && a !== void 0 ? a : {});
  });
}
function F$(o, e) {
  var t, i, r, n = [], s = o.getModuleContext(), a = 0;
  try {
    for (var l = qm(e != null ? e : []), c = l.next(); !c.done; c = l.next()) {
      var d = c.value, u = "series[" + a++ + "]", h = dU((r = d.type) !== null && r !== void 0 ? r : "unknown", s);
      MO(h, d, { path: u, index: a }), n.push(h);
    }
  } catch (p) {
    t = { error: p };
  } finally {
    try {
      c && !c.done && (i = l.return) && i.call(l);
    } finally {
      if (t)
        throw t.error;
    }
  }
  return n;
}
function L$(o, e) {
  var t, i, r = [], n = ["axes[].type"], s = o.getModuleContext(), a = 0;
  try {
    for (var l = qm(e != null ? e : []), c = l.next(); !c.done; c = l.next()) {
      var d = c.value, u = l3(d.type, s), h = "axes[" + a++ + "]";
      N$(u, d), Zm(u, d, { path: h, skip: n }), r.push(u);
    }
  } catch (p) {
    t = { error: p };
  } finally {
    try {
      c && !c.done && (i = l.return) && i.call(l);
    } finally {
      if (t)
        throw t.error;
    }
  }
  return r;
}
function N$(o, e) {
  var t, i, r = !1, n = Rl.filter(function(u) {
    return u.type === "axis-option";
  });
  try {
    for (var s = qm(n), a = s.next(); !a.done; a = s.next()) {
      var l = a.value, c = e[l.optionsKey] != null, d = o.isModuleEnabled(l);
      c !== d && (r = !0, c ? o.addModule(l) : o.removeModule(l));
    }
  } catch (u) {
    t = { error: u };
  } finally {
    try {
      a && !a.done && (i = s.return) && i.call(s);
    } finally {
      if (t)
        throw t.error;
    }
  }
  return r;
}
function AO(o, e) {
  o.clearEventListeners();
  for (var t in e) {
    var i = e[t];
    typeof i == "function" && o.addEventListener(t, i);
  }
}
function Zm(o, e, t) {
  var i = t === void 0 ? {} : t, r = i.skip, n = i.path, s = si(si(si({}, tO()), { skip: r }), n ? { path: n } : {});
  return Td(o, e, s);
}
function MO(o, e, t) {
  var i, r, n = t === void 0 ? {} : t, s = n.path, a = n.index, l = ["series[].listeners", "series[].seriesGrouping"], c = tO(), d = (i = c.constructors) !== null && i !== void 0 ? i : {}, u = {
    constructors: si(si({}, d), { title: o.type === "pie" ? cj : d.title })
  }, h = si(si(si(si(si({}, c), u), { skip: PO(["series[].type"], OO(l != null ? l : [])) }), s ? { path: s } : {}), { idx: a != null ? a : -1 }), p = Td(o, e, h), f = e == null ? void 0 : e.listeners;
  f != null && AO(o, f);
  var g = e.seriesGrouping;
  if ("seriesGrouping" in (e != null ? e : {}))
    if (g) {
      var v = Object.freeze(si(si({}, (r = o.seriesGrouping) !== null && r !== void 0 ? r : {}), g));
      o.seriesGrouping = v;
    } else
      o.seriesGrouping = g;
  return p;
}
var G$ = "8.0.5", k$ = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), vl = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, Cd;
(function(o) {
  o[o.Open = 0] = "Open", o[o.Chord = 1] = "Chord", o[o.Round = 2] = "Round";
})(Cd || (Cd = {}));
var _O = (
  /** @class */
  function(o) {
    k$(e, o);
    function e() {
      var t = o.call(this) || this;
      return t.centerX = 0, t.centerY = 0, t.radius = 10, t.startAngle = 0, t.endAngle = Math.PI * 2, t.counterClockwise = !1, t.type = Cd.Open, t.restoreOwnStyles(), t;
    }
    return Object.defineProperty(e.prototype, "fullPie", {
      get: function() {
        return jm(Vi(this.startAngle), Vi(this.endAngle));
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.updatePath = function() {
      var t = this.path;
      t.clear(), t.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, this.counterClockwise), this.type === Cd.Chord ? t.closePath() : this.type === Cd.Round && !this.fullPie && (t.lineTo(this.centerX, this.centerY), t.closePath());
    }, e.prototype.computeBBox = function() {
      return new nt(this.centerX - this.radius, this.centerY - this.radius, this.radius * 2, this.radius * 2);
    }, e.prototype.isPointInPath = function(t, i) {
      var r = this.transformPoint(t, i), n = this.computeBBox();
      return this.type !== Cd.Open && n.containsPoint(r.x, r.y) && this.path.isPointInPath(r.x, r.y);
    }, e.className = "Arc", e.defaultStyles = Object.assign({}, Mo.defaultStyles, {
      lineWidth: 1,
      fillStyle: null
    }), vl([
      yt()
    ], e.prototype, "centerX", void 0), vl([
      yt()
    ], e.prototype, "centerY", void 0), vl([
      yt()
    ], e.prototype, "radius", void 0), vl([
      yt()
    ], e.prototype, "startAngle", void 0), vl([
      yt()
    ], e.prototype, "endAngle", void 0), vl([
      yt()
    ], e.prototype, "counterClockwise", void 0), vl([
      yt()
    ], e.prototype, "type", void 0), e;
  }(Zi)
), V$ = function() {
  var o = function(e, t) {
    return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
    }, o(e, t);
  };
  return function(e, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    o(e, t);
    function i() {
      this.constructor = e;
    }
    e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
  };
}(), uh = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
(function(o) {
  V$(e, o);
  function e(t) {
    var i = o.call(this) || this;
    return i.x = 0, i.y = 0, i.width = 0, i.height = 0, i.opacity = 1, i.sourceImage = t, i;
  }
  return e.prototype.render = function(t) {
    var i = t.ctx, r = t.forceRender, n = t.stats;
    if (this.dirty === oe.NONE && !r) {
      n && n.nodesSkipped++;
      return;
    }
    this.computeTransformMatrix(), this.matrix.toContext(i);
    var s = this.sourceImage;
    i.globalAlpha = this.opacity, i.drawImage(s, 0, 0, s.width, s.height, this.x, this.y, this.width, this.height), o.prototype.render.call(this, t);
  }, uh([
    ve({ redraw: oe.MAJOR })
  ], e.prototype, "x", void 0), uh([
    ve({ redraw: oe.MAJOR })
  ], e.prototype, "y", void 0), uh([
    ve({ redraw: oe.MAJOR })
  ], e.prototype, "width", void 0), uh([
    ve({ redraw: oe.MAJOR })
  ], e.prototype, "height", void 0), uh([
    ve({ redraw: oe.MAJOR })
  ], e.prototype, "opacity", void 0), e;
})(km);
var B$ = function(o, e) {
  var t = typeof Symbol == "function" && o[Symbol.iterator];
  if (!t)
    return o;
  var i = t.call(o), r, n = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; )
      n.push(r.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return n;
}, H$ = Object.entries(RO).reduce(function(o, e) {
  var t = B$(e, 2), i = t[0], r = t[1];
  return o[i] = r(), o;
}, {}), Sf = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  TimeScale: nw,
  BandScale: $n,
  ContinuousScale: ct,
  ColorScale: vw,
  LinearScale: ri
}), yc = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ticks: Wm,
  extent: Uo,
  normalisedExtent: zD,
  toFixed: lw,
  isNumberEqual: jm,
  tickFormat: UD,
  interpolateString: hw,
  Color: Kt,
  isString: Kb,
  isStringObject: pD,
  isDate: N1,
  isDiscrete: Zg,
  isContinuous: dp,
  checkDatum: up,
  isNumber: Dr,
  resetIds: g1,
  createId: Vs,
  Padding: tv,
  jsonDiff: Sa,
  DELETE: nn,
  jsonMerge: Ft,
  jsonApply: Td,
  jsonWalk: $l,
  normalizeAngle360: Vi,
  normalizeAngle360Inclusive: D1,
  normalizeAngle180: aD,
  toRadians: xr,
  toDegrees: O1,
  sanitizeHtml: ai,
  Logger: pe
});
const W$ = [
  "area",
  "bar",
  "column",
  "histogram",
  "line",
  "pie",
  "scatter"
];
function pn(o) {
  switch (o) {
    case "bar":
    case "groupedBar":
    case "stackedBar":
    case "normalizedBar":
      return "bar";
    case "column":
    case "groupedColumn":
    case "stackedColumn":
    case "normalizedColumn":
      return "column";
    case "line":
      return "line";
    case "area":
    case "stackedArea":
    case "normalizedArea":
      return "area";
    case "scatter":
    case "bubble":
      return "scatter";
    case "histogram":
      return "histogram";
    case "pie":
    case "doughnut":
      return "pie";
    default:
      return "cartesian";
  }
}
const IO = ["number", "category", "groupedCategory", "log", "time"];
function j$(o) {
  switch (o) {
    case "bar":
    case "stackedBar":
    case "normalizedBar":
      return ["number", "category"];
    case "groupedBar":
      return ["number", "groupedCategory"];
    case "column":
    case "stackedColumn":
    case "normalizedColumn":
    case "line":
    case "area":
    case "stackedArea":
    case "normalizedArea":
    case "histogram":
      return ["category", "number"];
    case "groupedColumn":
      return ["groupedCategory", "number"];
    case "scatter":
    case "bubble":
      return ["number", "number"];
    default:
      return;
  }
}
function U$(o, e) {
  var t;
  const { chartOptionsToRestore: i, chartPaletteToRestore: r, chartThemeToRestore: n } = o, s = X$(o), a = FO(s), l = a ? { baseTheme: s } : (t = LO(o, s)) !== null && t !== void 0 ? t : {}, c = o.getGridOptionsChartThemeOverrides(), d = o.apiChartThemeOverrides, h = pn(o.chartType) === "pie" ? "polar" : "cartesian", p = o.crossFiltering ? z$(e, o, h) : void 0, f = Object.assign({}, i != null ? i : {}), y = [
    a ? Y$(o, (() => {
      const m = (C) => C ? Object.keys(C).some((R) => x.get(C[R], "title.enabled", !1)) : !1;
      return m(c) || m(d);
    })()) : void 0,
    p,
    c,
    d,
    f
  ].filter((m) => !!m).reduce((m, C) => ({
    baseTheme: m,
    overrides: C
  }), l);
  if (r && s === n) {
    const m = Cf(l).palette;
    $$(r, m) || (y.palette = r);
  }
  return y;
}
function $$(o, e) {
  const t = (i, r) => i.length !== r.length ? !1 : i.every((n, s) => n === r[s]);
  return t(o.fills, e.fills) && t(o.strokes, e.strokes);
}
function FO(o) {
  return x.includes(Object.keys(H$), o);
}
function z$(o, e, t) {
  const i = {
    listeners: {
      legendItemClick: (n) => {
        o.getChart().series.forEach((a) => {
          a.toggleSeriesItem(n.itemId, n.enabled), a.toggleSeriesItem(`${n.itemId}-filtered-out`, n.enabled);
        });
      }
    }
  }, r = {};
  return t === "polar" && (r.pie = {
    tooltip: {
      renderer: ({ angleName: n, datum: s, calloutLabelKey: a, radiusKey: l, angleValue: c }) => {
        const d = n, u = s[a], h = s[l];
        return { title: d, content: `${u}: ${c * h}` };
      }
    }
  }), {
    [t]: {
      tooltip: {
        delay: 500
      },
      legend: i,
      listeners: {
        click: (n) => e.crossFilterCallback(n, !0)
      },
      series: r
    }
  };
}
const K$ = IO.reduce((o, e) => Object.assign(Object.assign({}, o), { [e]: { title: { _enabledFromTheme: !0 } } }), {});
function Y$(o, e) {
  const t = o.getExtraPaddingDirections();
  return {
    common: {
      axes: K$,
      padding: {
        // don't add extra padding when a title is present!
        top: !e && t.includes("top") ? 40 : 20,
        right: t.includes("right") ? 30 : 20,
        bottom: t.includes("bottom") ? 40 : 20,
        left: t.includes("left") ? 30 : 20
      }
    },
    pie: {
      series: {
        title: { _enabledFromTheme: !0 },
        calloutLabel: { _enabledFromTheme: !0 },
        sectorLabel: {
          enabled: !1,
          _enabledFromTheme: !0
        }
      }
    }
  };
}
function X$(o) {
  let e = o.getChartThemeName();
  const t = o.getChartThemes();
  return x.includes(t, e) || (e = t[0]), e;
}
function LO(o, e) {
  const { customChartThemes: t } = o, i = t && t[e];
  return i || console.warn(`AG Grid: no stock theme exists with the name '${e}' and no custom chart theme with that name was supplied to 'customChartThemes'`), i;
}
const Qm = (o) => (e) => e === void 0 ? !0 : o(e), WE = (o) => typeof o == "string", NO = (o) => typeof o == "boolean", q$ = (o) => typeof o == "object", ps = (o, e) => (t) => `AG Grid - unable to update chart as invalid params supplied:  \`${o}: ${t}\`, expected ${e}.`;
class gt {
  static validateChartParams(e) {
    switch (e.type) {
      case "rangeChartUpdate":
        return gt.validateUpdateRangeChartParams(e);
      case "pivotChartUpdate":
        return gt.validateUpdatePivotChartParams(e);
      case "crossFilterChartUpdate":
        return gt.validateUpdateCrossFilterChartParams(e);
      default:
        return console.warn(`AG Grid - Invalid value supplied for 'type': ${e.type}. It must be either 'rangeChartUpdate', 'pivotChartUpdate', or 'crossFilterChartUpdate'.`), !1;
    }
  }
  static validateUpdateRangeChartParams(e) {
    const t = [
      ...gt.commonValidations,
      ...gt.cellRangeValidations,
      {
        property: "seriesChartTypes",
        validationFn: (i) => i === void 0 || Array.isArray(i) && i.every(q$),
        warnMessage: ps("seriesChartTypes", "Array of SeriesChartType")
      }
    ];
    return gt.validateProperties(e, t, ["type", "chartId", "chartType", "chartThemeName", "chartThemeOverrides", "unlinkChart", "cellRange", "suppressChartRanges", "aggFunc", "seriesChartTypes"], "UpdateRangeChartParams");
  }
  static validateUpdatePivotChartParams(e) {
    const t = [
      ...gt.commonValidations
    ];
    return gt.validateProperties(e, t, ["type", "chartId", "chartType", "chartThemeName", "chartThemeOverrides", "unlinkChart"], "UpdatePivotChartParams");
  }
  static validateUpdateCrossFilterChartParams(e) {
    const t = [
      ...gt.commonValidations,
      ...gt.cellRangeValidations
    ];
    return gt.validateProperties(e, t, ["type", "chartId", "chartType", "chartThemeName", "chartThemeOverrides", "unlinkChart", "cellRange", "suppressChartRanges", "aggFunc"], "UpdateCrossFilterChartParams");
  }
  static validateProperties(e, t, i, r) {
    for (const n of t) {
      const { property: s, validationFn: a, warnMessage: l } = n;
      if (s in e) {
        const c = e[s];
        if (!a(c))
          return console.warn(l(c)), !1;
      }
    }
    for (const n in e)
      if (!i.includes(n))
        return console.warn(`AG Grid - Unexpected property supplied. ${r} does not contain: \`${n}\`.`), !1;
    return !0;
  }
}
gt.validChartTypes = [
  "column",
  "groupedColumn",
  "stackedColumn",
  "normalizedColumn",
  "bar",
  "groupedBar",
  "stackedBar",
  "normalizedBar",
  "line",
  "scatter",
  "bubble",
  "pie",
  "doughnut",
  "area",
  "stackedArea",
  "normalizedArea",
  "histogram",
  "columnLineCombo",
  "areaColumnCombo",
  "customCombo"
];
gt.validateChartType = Qm((o) => gt.validChartTypes.includes(o));
gt.validateAgChartThemeOverrides = Qm((o) => typeof o == "object");
gt.validateChartParamsCellRange = Qm((o) => typeof o == "object");
gt.validateAggFunc = Qm((o) => typeof o == "string" || typeof o == "function");
gt.commonValidations = [
  { property: "chartId", validationFn: WE, warnMessage: ps("chartId", "string") },
  {
    property: "chartType",
    validationFn: gt.validateChartType,
    warnMessage: ps("chartType", gt.validChartTypes.join(", "))
  },
  {
    property: "chartThemeName",
    validationFn: WE,
    warnMessage: ps("chartThemeName", "string")
  },
  {
    property: "chartThemeOverrides",
    validationFn: gt.validateAgChartThemeOverrides,
    warnMessage: ps("chartThemeOverrides", "AgChartThemeOverrides")
  },
  { property: "unlinkChart", validationFn: NO, warnMessage: ps("unlinkChart", "boolean") }
];
gt.cellRangeValidations = [
  {
    property: "cellRange",
    validationFn: gt.validateChartParamsCellRange,
    warnMessage: ps("cellRange", "ChartParamsCellRange")
  },
  {
    property: "suppressChartRanges",
    validationFn: NO,
    warnMessage: ps("suppressChartRanges", "boolean")
  },
  {
    property: "aggFunc",
    validationFn: gt.validateAggFunc,
    warnMessage: ps("aggFunc", "string or IAggFunc")
  }
];
var GO = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const kO = ["ag-default", "ag-material", "ag-pastel", "ag-vivid", "ag-solar"];
class Rt extends H {
  constructor(e) {
    super(), this.model = e;
  }
  init() {
    this.setChartRange(), this.addManagedListener(this.eventService, w.EVENT_RANGE_SELECTION_CHANGED, (e) => {
      e.id && e.id === this.model.chartId && this.updateForRangeChange();
    }), this.model.unlinked && this.rangeService && this.rangeService.setCellRanges([]), this.addManagedListener(this.eventService, w.EVENT_COLUMN_MOVED, this.updateForGridChange.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PINNED, this.updateForGridChange.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_VISIBLE, this.updateForGridChange.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, this.updateForGridChange.bind(this)), this.addManagedListener(this.eventService, w.EVENT_MODEL_UPDATED, this.updateForGridChange.bind(this)), this.addManagedListener(this.eventService, w.EVENT_CELL_VALUE_CHANGED, this.updateForDataChange.bind(this));
  }
  update(e) {
    var t, i, r, n, s, a, l;
    if (!this.validUpdateType(e) || !gt.validateChartParams(e))
      return !1;
    const { chartId: c, chartType: d, chartThemeName: u, unlinkChart: h } = e, p = {
      chartId: c,
      pivotChart: this.model.pivotChart,
      chartType: d != null ? d : this.model.chartType,
      chartThemeName: u != null ? u : this.model.chartThemeName,
      unlinkChart: h != null ? h : this.model.unlinked,
      cellRange: this.model.suppliedCellRange,
      aggFunc: this.model.aggFunc,
      seriesChartTypes: void 0,
      suppressChartRanges: !1,
      crossFiltering: !1
    };
    let f = Object.assign({}, p);
    switch (e.type) {
      case "rangeChartUpdate":
        f.cellRange = (t = this.createCellRange(e)) !== null && t !== void 0 ? t : this.model.suppliedCellRange, f.aggFunc = (i = e.aggFunc) !== null && i !== void 0 ? i : this.model.aggFunc, f.seriesChartTypes = e.seriesChartTypes, f.suppressChartRanges = (r = e.suppressChartRanges) !== null && r !== void 0 ? r : this.model.suppressChartRanges;
        break;
      case "crossFilterChartUpdate":
        f.cellRange = (n = this.createCellRange(e)) !== null && n !== void 0 ? n : this.model.suppliedCellRange, f.aggFunc = (s = e.aggFunc) !== null && s !== void 0 ? s : this.model.aggFunc, f.crossFiltering = !0, f.suppressChartRanges = (a = e.suppressChartRanges) !== null && a !== void 0 ? a : this.model.suppressChartRanges;
        break;
    }
    return this.model.updateModel(f), f.unlinkChart || f.suppressChartRanges ? (l = this.rangeService) === null || l === void 0 || l.setCellRanges([]) : this.setChartRange(), !0;
  }
  updateForGridChange() {
    this.model.unlinked || (this.model.updateCellRanges(), this.model.updateData(), this.setChartRange());
  }
  updateForDataChange() {
    this.model.unlinked || (this.model.updateData(), this.raiseChartModelUpdateEvent());
  }
  updateForRangeChange() {
    this.updateForGridChange(), this.raiseChartRangeSelectionChangedEvent();
  }
  updateForPanelChange(e) {
    this.model.updateCellRanges(e), this.model.updateData(), this.setChartRange(), this.raiseChartRangeSelectionChangedEvent();
  }
  getChartUpdateParams(e) {
    const i = this.getSelectedValueColState().map((s) => ({ colId: s.colId, displayName: s.displayName })), r = this.getChartData(), n = this.getSelectedDimension();
    return {
      data: r,
      grouping: this.isGrouping(),
      category: {
        id: n.colId,
        name: n.displayName,
        chartDataType: this.model.getChartDataType(n.colId)
      },
      fields: i,
      chartId: this.getChartId(),
      getCrossFilteringContext: () => ({ lastSelectedChartId: "xxx" }),
      seriesChartTypes: this.getSeriesChartTypes(),
      updatedOverrides: e
    };
  }
  getChartModel() {
    const e = this.model.pivotChart ? "pivot" : "range", t = this.isComboChart() ? this.model.comboChartModel.seriesChartTypes : void 0;
    return {
      modelType: e,
      chartId: this.model.chartId,
      chartType: this.model.chartType,
      chartThemeName: this.getChartThemeName(),
      chartOptions: this.chartProxy.getChartThemeOverrides(),
      chartPalette: this.chartProxy.getChartPalette(),
      cellRange: this.getCellRangeParams(),
      suppressChartRanges: this.model.suppressChartRanges,
      aggFunc: this.model.aggFunc,
      unlinkChart: this.model.unlinked,
      seriesChartTypes: t
    };
  }
  getChartId() {
    return this.model.chartId;
  }
  getChartData() {
    return this.model.chartData;
  }
  getChartType() {
    return this.model.chartType;
  }
  setChartType(e) {
    this.model.chartType = e, this.model.comboChartModel.updateSeriesChartTypes(), this.raiseChartModelUpdateEvent(), this.raiseChartOptionsChangedEvent();
  }
  setChartThemeName(e) {
    this.model.chartThemeName = e, this.raiseChartModelUpdateEvent(), this.raiseChartOptionsChangedEvent();
  }
  getChartThemeName() {
    return this.model.chartThemeName;
  }
  isPivotChart() {
    return this.model.pivotChart;
  }
  isPivotMode() {
    return this.model.isPivotMode();
  }
  isGrouping() {
    return this.model.isGrouping();
  }
  isCrossFilterChart() {
    return this.model.crossFiltering;
  }
  getThemes() {
    return this.gridOptionsService.get("chartThemes") || kO;
  }
  getPalettes() {
    return this.getThemes().map((t) => {
      const r = FO(t) ? t : this.chartProxy.lookupCustomChartTheme(t);
      return Cf(r).palette;
    });
  }
  getValueColState() {
    return this.model.valueColState.map(this.displayNameMapper.bind(this));
  }
  getSelectedValueColState() {
    return this.getValueColState().filter((e) => e.selected);
  }
  getSelectedDimension() {
    return this.model.getSelectedDimension();
  }
  displayNameMapper(e) {
    const t = this.model.columnNames[e.colId];
    return e.displayName = t ? t.join(" - ") : this.model.getColDisplayName(e.column), e;
  }
  getColStateForMenu() {
    return { dimensionCols: this.model.dimensionColState, valueCols: this.getValueColState() };
  }
  setChartRange(e = !1) {
    this.rangeService && !this.model.suppressChartRanges && !this.model.unlinked && this.rangeService.setCellRanges(this.getCellRanges()), e || this.raiseChartModelUpdateEvent();
  }
  detachChartRange() {
    this.model.unlinked = !this.model.unlinked, this.model.unlinked ? this.rangeService && this.rangeService.setCellRanges([]) : this.updateForGridChange();
  }
  setChartProxy(e) {
    this.chartProxy = e;
  }
  getChartProxy() {
    return this.chartProxy;
  }
  isActiveXYChart() {
    return x.includes(["scatter", "bubble"], this.getChartType());
  }
  isChartLinked() {
    return !this.model.unlinked;
  }
  customComboExists() {
    const e = this.model.comboChartModel.savedCustomSeriesChartTypes;
    return e && e.length > 0;
  }
  getSeriesChartTypes() {
    return this.model.comboChartModel.seriesChartTypes;
  }
  isComboChart() {
    return this.model.isComboChart();
  }
  updateSeriesChartType(e, t, i) {
    const r = this.model.comboChartModel.seriesChartTypes.find((n) => n.colId === e);
    if (r) {
      const n = this.model.chartType !== "customCombo";
      n && (this.model.chartType = "customCombo");
      const s = r.chartType;
      t != null && (r.chartType = t), i != null && (r.secondaryAxis = i), this.model.comboChartModel.savedCustomSeriesChartTypes = this.model.comboChartModel.seriesChartTypes, this.model.comboChartModel.updateSeriesChartTypes(), this.updateForDataChange(), n && this.dispatchEvent({
        type: Rt.EVENT_CHART_TYPE_CHANGED
      }), s !== t && this.dispatchEvent({
        type: Rt.EVENT_CHART_SERIES_CHART_TYPE_CHANGED
      }), this.raiseChartOptionsChangedEvent();
    }
  }
  getActiveSeriesChartTypes() {
    const e = this.getSelectedValueColState().map((t) => t.colId);
    return this.getSeriesChartTypes().filter((t) => e.includes(t.colId));
  }
  getChartSeriesTypes() {
    const e = ["line", "column", "area"];
    return this.isComboChart() ? e : [pn(this.getChartType())];
  }
  getCellRanges() {
    return [this.model.dimensionCellRange, this.model.valueCellRange].filter((e) => e);
  }
  createCellRange(e) {
    var t;
    return e.cellRange && ((t = this.rangeService) === null || t === void 0 ? void 0 : t.createCellRangeFromCellRangeParams(e.cellRange));
  }
  validUpdateType(e) {
    var t;
    if (!e.type)
      return console.warn("AG Grid - Unable to update chart as the 'type' is missing. It must be either 'rangeChartUpdate', 'pivotChartUpdate', or 'crossFilterChartUpdate'."), !1;
    const i = {
      "Range Chart": () => !this.isPivotChart() && !this.isCrossFilterChart(),
      "Pivot Chart": () => this.isPivotChart(),
      "Cross Filter Chart": () => this.isCrossFilterChart()
    }, r = (t = Object.keys(i).find((s) => i[s]())) !== null && t !== void 0 ? t : "Range Chart", n = e.type === `${r[0].toLowerCase()}${r.slice(1).replace(/ /g, "")}Update`;
    return n || console.warn(`AG Grid - Unable to update chart as a '${e.type}' update type is not permitted on a ${r}.`), n;
  }
  getCellRangeParams() {
    const e = this.getCellRanges(), t = e[0], i = t && t.startRow || null, r = t && t.endRow || null;
    return {
      rowStartIndex: i && i.rowIndex,
      rowStartPinned: i && i.rowPinned,
      rowEndIndex: r && r.rowIndex,
      rowEndPinned: r && r.rowPinned,
      columns: e.reduce((n, s) => n.concat(s.columns.map((a) => a.getId())), [])
    };
  }
  raiseChartModelUpdateEvent() {
    const e = {
      type: Rt.EVENT_CHART_MODEL_UPDATE
    };
    this.dispatchEvent(e);
  }
  raiseChartUpdatedEvent() {
    const e = {
      type: Rt.EVENT_CHART_UPDATED
    };
    this.dispatchEvent(e);
  }
  raiseChartApiUpdateEvent() {
    const e = {
      type: Rt.EVENT_CHART_API_UPDATE
    };
    this.dispatchEvent(e);
  }
  raiseChartOptionsChangedEvent() {
    const { chartId: e, chartType: t } = this.getChartModel(), i = {
      type: w.EVENT_CHART_OPTIONS_CHANGED,
      chartId: e,
      chartType: t,
      chartThemeName: this.getChartThemeName(),
      chartOptions: this.chartProxy.getChartThemeOverrides()
    };
    this.eventService.dispatchEvent(i);
  }
  raiseChartRangeSelectionChangedEvent() {
    const e = {
      type: w.EVENT_CHART_RANGE_SELECTION_CHANGED,
      id: this.model.chartId,
      chartId: this.model.chartId,
      cellRange: this.getCellRangeParams()
    };
    this.eventService.dispatchEvent(e);
  }
  destroy() {
    super.destroy(), this.rangeService && this.rangeService.setCellRanges([]);
  }
}
Rt.EVENT_CHART_UPDATED = "chartUpdated";
Rt.EVENT_CHART_API_UPDATE = "chartApiUpdate";
Rt.EVENT_CHART_MODEL_UPDATE = "chartModelUpdate";
Rt.EVENT_CHART_TYPE_CHANGED = "chartTypeChanged";
Rt.EVENT_CHART_SERIES_CHART_TYPE_CHANGED = "chartSeriesChartTypeChanged";
GO([
  S("rangeService")
], Rt.prototype, "rangeService", void 0);
GO([
  B
], Rt.prototype, "init", null);
var mw = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const Z$ = {
  groups: [
    { type: "categories", isOpen: !0 },
    { type: "series", isOpen: !0 },
    { type: "seriesChartType", isOpen: !0 }
  ]
};
class Cc extends X {
  constructor(e, t) {
    super(Cc.TEMPLATE), this.chartController = e, this.chartOptionsService = t, this.columnComps = /* @__PURE__ */ new Map();
  }
  init() {
    this.updatePanels(), this.addManagedListener(this.chartController, Rt.EVENT_CHART_MODEL_UPDATE, this.updatePanels.bind(this)), this.addManagedListener(this.chartController, Rt.EVENT_CHART_API_UPDATE, this.updatePanels.bind(this)), this.createAutoScrollService();
  }
  destroy() {
    this.clearComponents(), super.destroy();
  }
  updatePanels() {
    var e, t;
    const i = this.chartType, { dimensionCols: r, valueCols: n } = this.chartController.getColStateForMenu(), s = r.map((l) => l.colId).concat(n.map((l) => l.colId));
    this.chartType = this.chartController.getChartType();
    const a = this.getGroupExpandedState();
    if (x.areEqual(x.keys(this.columnComps), s) && this.chartType === i) {
      if ([...r, ...n].forEach((c) => {
        this.columnComps.get(c.colId).setValue(c.selected, !0);
      }), this.chartController.isActiveXYChart()) {
        const c = this.generateGetSeriesLabel();
        n.forEach((d) => {
          this.columnComps.get(d.colId).setLabel(c(d));
        });
      }
      x.removeFromParent(this.getGui().querySelector("#seriesChartTypeGroup")), this.seriesChartTypeGroupComp = this.destroyBean(this.seriesChartTypeGroupComp);
      const l = (e = this.getDataPanelDef().groups) === null || e === void 0 ? void 0 : e.reduce((c, { type: d }, u) => d === "seriesChartType" ? u : c, -1);
      l !== -1 && this.createSeriesChartTypeGroup(n, l);
    } else
      this.clearComponents(), (t = this.getDataPanelDef().groups) === null || t === void 0 || t.forEach(({ type: l }) => {
        l === "categories" ? this.createCategoriesGroup(r) : l === "series" ? this.createSeriesGroup(n) : l === "seriesChartType" ? this.createSeriesChartTypeGroup(n) : console.warn(`AG Grid: invalid charts data panel group name supplied: '${l}'`);
      });
    this.restoreGroupExpandedState(a);
  }
  getGroupExpandedState() {
    return [
      { groupType: "categories", comp: this.categoriesGroupComp },
      { groupType: "series", comp: this.seriesGroupComp },
      { groupType: "seriesChartType", comp: this.seriesChartTypeGroupComp }
    ].map(({ groupType: t, comp: i }) => {
      var r, n;
      const s = !!(!((n = (r = this.getDataPanelDef().groups) === null || r === void 0 ? void 0 : r.find(({ type: a }) => a === t)) === null || n === void 0) && n.isOpen);
      return i ? i.isExpanded() : s;
    });
  }
  restoreGroupExpandedState(e) {
    [
      this.categoriesGroupComp,
      this.seriesGroupComp,
      this.seriesChartTypeGroupComp
    ].forEach((t, i) => {
      t && t.toggleGroupExpand(e[i]);
    });
  }
  createAutoScrollService() {
    const e = this.getGui();
    this.autoScrollService = new Xv({
      scrollContainer: e,
      scrollAxis: "y",
      getVerticalPosition: () => e.scrollTop,
      setVerticalPosition: (t) => e.scrollTop = t
    });
  }
  createComponent(e, t) {
    const i = document.createElement("div");
    return i.id = t, i.className = "ag-chart-data-section", i.appendChild(e.getGui()), i;
  }
  addComponent(e, t, i) {
    const r = this.createComponent(t, i);
    e.appendChild(r);
  }
  addComponentAtIndex(e, t, i, r) {
    const n = this.createComponent(t, i);
    e.insertBefore(n, e.children[r]);
  }
  addChangeListener(e, t) {
    this.addManagedListener(e, ir.EVENT_CHANGED, () => {
      t.selected = e.getValue(), this.chartController.updateForPanelChange(t);
    });
  }
  createCategoriesGroup(e) {
    this.categoriesGroupComp = this.createBean(new Tt({
      title: this.getCategoryGroupTitle(),
      enabled: !0,
      suppressEnabledCheckbox: !0,
      suppressOpenCloseIcons: !1,
      cssIdentifier: "charts-data"
    }));
    const t = `chartDimension${this.getCompId()}`;
    e.forEach((i) => {
      const r = this.categoriesGroupComp.createManagedBean(new ZS());
      r.setLabel(x.escapeString(i.displayName)), r.setValue(i.selected), r.setInputName(t), this.addChangeListener(r, i), this.categoriesGroupComp.addItem(r), this.columnComps.set(i.colId, r);
    }), this.addComponent(this.getGui(), this.categoriesGroupComp, "categoriesGroup");
  }
  createSeriesGroup(e) {
    if (this.seriesGroupComp = this.createManagedBean(new Tt({
      title: this.getSeriesGroupTitle(),
      enabled: !0,
      suppressEnabledCheckbox: !0,
      suppressOpenCloseIcons: !1,
      cssIdentifier: "charts-data"
    })), this.chartController.isActiveXYChart()) {
      const s = this.seriesGroupComp.createManagedBean(new Rb());
      s.setLabel(this.chartTranslationService.translate("paired")).setLabelAlignment("left").setLabelWidth("flex").setInputWidth(45).setValue(this.chartOptionsService.getPairedMode()).onValueChange((a) => {
        this.chartOptionsService.setPairedMode(!!a), this.chartController.updateForGridChange();
      }), this.seriesGroupComp.addItem(s);
    }
    const t = this.generateGetSeriesLabel();
    e.forEach((s) => {
      const a = this.seriesGroupComp.createManagedBean(new rr());
      a.addCssClass("ag-data-select-checkbox");
      const l = t(s);
      a.setLabel(l), a.setValue(s.selected), this.addChangeListener(a, s), this.seriesGroupComp.addItem(a), this.columnComps.set(s.colId, a), this.addDragHandle(a, s);
    });
    const i = this.getGui(), r = this.seriesGroupComp.getGui();
    this.addComponent(i, this.seriesGroupComp, "seriesGroup");
    const n = {
      getIconName: () => Te.ICON_MOVE,
      getContainer: () => r,
      onDragging: (s) => this.onDragging(s),
      onDragLeave: () => this.onDragLeave(),
      isInterestedIn: this.isInterestedIn.bind(this),
      targetContainsSource: !0
    };
    this.dragAndDropService.addDropTarget(n), this.addDestroyFunc(() => this.dragAndDropService.removeDropTarget(n));
  }
  createSeriesChartTypeGroup(e, t) {
    if (!this.chartController.isComboChart())
      return;
    this.seriesChartTypeGroupComp = this.createManagedBean(new Tt({
      title: this.chartTranslationService.translate("seriesChartType"),
      enabled: !0,
      suppressEnabledCheckbox: !0,
      suppressOpenCloseIcons: !1,
      cssIdentifier: "charts-data"
    }));
    const i = this.chartController.getSeriesChartTypes();
    e.forEach((r) => {
      if (!r.selected)
        return;
      const n = i.filter((u) => u.colId === r.colId)[0];
      if (!n)
        return;
      const s = this.seriesChartTypeGroupComp.createManagedBean(new Tt({
        title: r.displayName,
        enabled: !0,
        suppressEnabledCheckbox: !0,
        suppressOpenCloseIcons: !0,
        cssIdentifier: "charts-format-sub-level"
      })), a = this.seriesChartTypeGroupComp.createManagedBean(new rr()).setLabel(this.chartTranslationService.translate("secondaryAxis")).setLabelWidth("flex").setDisabled(["groupedColumn", "stackedColumn", "stackedArea"].includes(n.chartType)).setValue(!!n.secondaryAxis).onValueChange((u) => this.chartController.updateSeriesChartType(r.colId, void 0, u));
      s.addItem(a);
      const l = (u, h) => this.chartTranslationService.translate(u, h), c = [
        { value: "line", text: l("line", "Line") },
        { value: "area", text: l("area", "Area") },
        { value: "stackedArea", text: l("stackedArea", "StackedArea") },
        { value: "groupedColumn", text: l("groupedColumn", "Grouped Column") },
        { value: "stackedColumn", text: l("stackedColumn", "Stacked Column") }
      ], d = s.createManagedBean(new zn());
      d.setLabelAlignment("left").setLabelWidth("flex").addOptions(c).setValue(n.chartType).onValueChange((u) => this.chartController.updateSeriesChartType(r.colId, u)), s.addItem(d), this.seriesChartTypeGroupComp.addItem(s);
    }), t === void 0 ? this.addComponent(this.getGui(), this.seriesChartTypeGroupComp, "seriesChartTypeGroup") : this.addComponentAtIndex(this.getGui(), this.seriesChartTypeGroupComp, "seriesChartTypeGroup", t);
  }
  addDragHandle(e, t) {
    const i = x.createIconNoSpan("columnDrag", this.gridOptionsService);
    i.classList.add("ag-drag-handle", "ag-chart-data-column-drag-handle"), e.getGui().insertAdjacentElement("beforeend", i);
    const r = {
      type: Dt.ChartPanel,
      eElement: i,
      dragItemName: t.displayName,
      getDragItem: () => ({ columns: [t.column] }),
      onDragStopped: () => this.onDragStop()
    };
    this.dragAndDropService.addDragSource(r, !0), this.addDestroyFunc(() => this.dragAndDropService.removeDragSource(r));
  }
  generateGetSeriesLabel() {
    if (!this.chartController.isActiveXYChart())
      return (n) => x.escapeString(n.displayName);
    const e = this.chartType === "bubble", t = this.isInPairedMode();
    let i = 0;
    const r = /* @__PURE__ */ new Map();
    return r.set(0, "X"), r.set(1, "Y"), r.set(2, "size"), (n) => {
      const s = x.escapeString(n.displayName);
      if (!n.selected)
        return s;
      let a;
      return t ? a = r.get(i % (e ? 3 : 2)) : i === 0 ? a = "X" : a = e && i % 2 === 0 ? "size" : "Y", i++, `${s} (${a})`;
    };
  }
  getCategoryGroupTitle() {
    return this.chartTranslationService.translate(this.chartController.isActiveXYChart() ? "labels" : "categories");
  }
  getSeriesGroupTitle() {
    return this.chartTranslationService.translate(this.chartController.isActiveXYChart() ? "xyValues" : "series");
  }
  getDataPanelDef() {
    var e;
    const t = (e = this.gridOptionsService.get("chartToolPanelsDef")) === null || e === void 0 ? void 0 : e.dataPanel;
    return t || Z$;
  }
  isInPairedMode() {
    return this.chartController.isActiveXYChart() && this.chartOptionsService.getSeriesOption("paired", "scatter");
  }
  clearComponents() {
    x.clearElement(this.getGui()), this.categoriesGroupComp = this.destroyBean(this.categoriesGroupComp), this.seriesGroupComp = this.destroyBean(this.seriesGroupComp), this.seriesChartTypeGroupComp = this.destroyBean(this.seriesChartTypeGroupComp), this.columnComps.clear();
  }
  onDragging(e) {
    const t = this.checkHoveredItem(e);
    if (!t)
      return;
    this.lastDraggedColumn = e.dragItem.columns[0];
    const { comp: i, position: r } = t, { comp: n, position: s } = this.lastHoveredItem || {};
    if (i === n && r === s)
      return;
    this.autoScrollService.check(e.event), this.clearHoveredItems(), this.lastHoveredItem = { comp: i, position: r }, i.getGui().classList.add("ag-list-item-hovered", `ag-item-highlight-${r}`);
  }
  checkHoveredItem(e) {
    if (x.missing(e.vDirection))
      return null;
    const t = e.event;
    for (const i of this.columnComps.values()) {
      const r = i.getGui();
      if (!r.querySelector(".ag-chart-data-column-drag-handle"))
        continue;
      const n = r.getBoundingClientRect();
      if (t.clientY >= n.top && t.clientY <= n.bottom) {
        const a = r.clientHeight, l = t.clientY > n.top + a / 2 ? "bottom" : "top";
        return { comp: i, position: l };
      }
    }
    return null;
  }
  onDragLeave() {
    this.clearHoveredItems();
  }
  onDragStop() {
    if (this.lastHoveredItem) {
      const { dimensionCols: e, valueCols: t } = this.chartController.getColStateForMenu(), i = [...e, ...t].find((r) => r.column === this.lastDraggedColumn);
      if (i) {
        let r = Array.from(this.columnComps.values()).indexOf(this.lastHoveredItem.comp);
        this.lastHoveredItem.position === "bottom" && r++, i.order = r, this.chartController.updateForPanelChange(i);
      }
    }
    this.clearHoveredItems(), this.lastDraggedColumn = void 0, this.autoScrollService.ensureCleared();
  }
  clearHoveredItems() {
    this.columnComps.forEach((e) => {
      e.getGui().classList.remove("ag-list-item-hovered", "ag-item-highlight-top", "ag-item-highlight-bottom");
    }), this.lastHoveredItem = void 0;
  }
  isInterestedIn(e) {
    return e === Dt.ChartPanel;
  }
}
Cc.TEMPLATE = '<div class="ag-chart-data-wrapper ag-scrollable-container"></div>';
mw([
  S("dragAndDropService")
], Cc.prototype, "dragAndDropService", void 0);
mw([
  S("chartTranslationService")
], Cc.prototype, "chartTranslationService", void 0);
mw([
  B
], Cc.prototype, "init", null);
var Sc = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Qi extends X {
  constructor(e) {
    super(), this.activeComps = [], this.params = e;
  }
  init() {
    const e = {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical",
      suppressOpenCloseIcons: !0
    };
    this.setTemplate(Qi.TEMPLATE, { fontGroup: e }), this.initGroup(), this.initFontFamilySelect(), this.initFontWeightStyleSelect(), this.initFontSizeSelect(), this.initFontColorPicker();
  }
  addCompToPanel(e) {
    this.fontGroup.addItem(e), this.activeComps.push(e);
  }
  setEnabled(e) {
    this.fontGroup.setEnabled(e);
  }
  initGroup() {
    this.fontGroup.setTitle(this.params.name || this.chartTranslationService.translate("font")).setEnabled(this.params.enabled).hideEnabledCheckbox(!!this.params.suppressEnabledCheckbox).hideOpenCloseIcons(!0).onEnableChange((e) => {
      this.params.setEnabled && this.params.setEnabled(e);
    });
  }
  initFontFamilySelect() {
    const e = [
      "Arial, sans-serif",
      "Aria Black, sans-serif",
      "Book Antiqua,  serif",
      "Charcoal, sans-serif",
      "Comic Sans MS, cursive",
      "Courier, monospace",
      "Courier New, monospace",
      "Gadget, sans-serif",
      "Geneva, sans-serif",
      "Helvetica, sans-serif",
      "Impact, sans-serif",
      "Lucida Console, monospace",
      "Lucida Grande, sans-serif",
      "Lucida Sans Unicode,  sans-serif",
      "Monaco, monospace",
      "Palatino Linotype, serif",
      "Palatino, serif",
      "Times New Roman, serif",
      "Times, serif",
      "Verdana, sans-serif"
    ], { family: t } = this.params.initialFont;
    let i = e[0];
    if (t) {
      const s = e.map((a) => a.toLowerCase()).indexOf(t.toLowerCase());
      if (s >= 0)
        i = e[s];
      else {
        const a = x.capitalise(t);
        e.push(a), i = a;
      }
    }
    const r = e.sort().map((n) => ({ value: n, text: n }));
    this.familySelect.addOptions(r).setInputWidth("flex").setValue(`${i}`).onValueChange((n) => this.params.setFont({ family: n }));
  }
  initFontSizeSelect() {
    const e = [8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36], { size: t } = this.params.initialFont;
    x.includes(e, t) || e.push(t);
    const i = e.sort((r, n) => r - n).map((r) => ({ value: `${r}`, text: `${r}` }));
    this.sizeSelect.addOptions(i).setInputWidth("flex").setValue(`${t}`).onValueChange((r) => this.params.setFont({ size: parseInt(r, 10) })), this.sizeSelect.setLabel(this.chartTranslationService.translate("size"));
  }
  initFontWeightStyleSelect() {
    const { weight: e = "normal", style: t = "normal" } = this.params.initialFont, i = [
      { name: "normal", weight: "normal", style: "normal" },
      { name: "bold", weight: "bold", style: "normal" },
      { name: "italic", weight: "normal", style: "italic" },
      { name: "boldItalic", weight: "bold", style: "italic" }
    ];
    let r = i.find((s) => s.weight === e && s.style === t);
    r || (r = { name: "predefined", weight: e, style: t }, i.unshift(r));
    const n = i.map((s) => ({
      value: s.name,
      text: this.chartTranslationService.translate(s.name)
    }));
    this.weightStyleSelect.addOptions(n).setInputWidth("flex").setValue(r.name).onValueChange((s) => {
      const a = i.find((l) => l.name === s);
      this.params.setFont({ weight: a.weight, style: a.style });
    });
  }
  initFontColorPicker() {
    this.colorPicker.setLabel(this.chartTranslationService.translate("color")).setInputWidth(45).setValue(`${this.params.initialFont.color}`).onValueChange((e) => this.params.setFont({ color: e }));
  }
  addItemToPanel(e) {
    this.fontGroup.addItem(e), this.activeComps.push(e);
  }
  destroyActiveComps() {
    this.activeComps.forEach((e) => {
      x.removeFromParent(e.getGui()), this.destroyBean(e);
    });
  }
  destroy() {
    this.destroyActiveComps(), super.destroy();
  }
}
Qi.TEMPLATE = `<div class="ag-font-panel">
            <ag-group-component ref="fontGroup">
                <ag-select ref="familySelect"></ag-select>
                <ag-select ref="weightStyleSelect"></ag-select>
                <div class="ag-charts-font-size-color">
                    <ag-select ref="sizeSelect"></ag-select>
                    <ag-color-picker ref="colorPicker"></ag-color-picker>
                </div>
            </ag-group-component>
        </div>`;
Sc([
  L("fontGroup")
], Qi.prototype, "fontGroup", void 0);
Sc([
  L("familySelect")
], Qi.prototype, "familySelect", void 0);
Sc([
  L("weightStyleSelect")
], Qi.prototype, "weightStyleSelect", void 0);
Sc([
  L("sizeSelect")
], Qi.prototype, "sizeSelect", void 0);
Sc([
  L("colorPicker")
], Qi.prototype, "colorPicker", void 0);
Sc([
  S("chartTranslationService")
], Qi.prototype, "chartTranslationService", void 0);
Sc([
  B
], Qi.prototype, "init", null);
var zo = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class dr extends X {
  constructor({ chartOptionsService: e, isExpandedOnInit: t = !1 }) {
    super(), this.activePanels = [], this.chartOptionsService = e, this.isExpandedOnInit = t;
  }
  init() {
    const e = {
      cssIdentifier: "charts-format-top-level",
      direction: "vertical"
    };
    this.setTemplate(dr.TEMPLATE, { legendGroup: e }), this.initLegendGroup(), this.initLegendPosition(), this.initLegendPadding(), this.initLegendItems(), this.initLabelPanel();
  }
  initLegendGroup() {
    this.legendGroup.setTitle(this.chartTranslationService.translate("legend")).hideEnabledCheckbox(!1).setEnabled(this.chartOptionsService.getChartOption("legend.enabled") || !1).toggleGroupExpand(this.isExpandedOnInit).onEnableChange((e) => {
      this.chartOptionsService.setChartOption("legend.enabled", e), this.legendGroup.toggleGroupExpand(!0);
    });
  }
  initLegendPosition() {
    const e = ["top", "right", "bottom", "left"];
    this.legendPositionSelect.setLabel(this.chartTranslationService.translate("position")).setLabelWidth("flex").setInputWidth(80).addOptions(e.map((t) => ({
      value: t,
      text: this.chartTranslationService.translate(t)
    }))).setValue(this.chartOptionsService.getChartOption("legend.position")).onValueChange((t) => this.chartOptionsService.setChartOption("legend.position", t));
  }
  initLegendPadding() {
    const e = this.chartOptionsService.getChartOption("legend.spacing");
    this.legendPaddingSlider.setLabel(this.chartTranslationService.translate("spacing")).setMaxValue(yi(e, 200)).setValue(`${e}`).setTextFieldWidth(45).onValueChange((t) => this.chartOptionsService.setChartOption("legend.spacing", t));
  }
  initLegendItems() {
    const e = (t, i, r, n) => {
      const s = this.chartOptionsService.getChartOption(`legend.${t}`);
      r.setLabel(this.chartTranslationService.translate(i)).setMaxValue(yi(s, n)).setValue(`${s}`).setTextFieldWidth(45).onValueChange((a) => {
        this.chartOptionsService.setChartOption(`legend.${t}`, a);
      });
    };
    e("item.marker.size", "markerSize", this.markerSizeSlider, 40), e("item.marker.strokeWidth", "markerStroke", this.markerStrokeSlider, 10), e("item.marker.padding", "itemSpacing", this.markerPaddingSlider, 20), e("item.paddingX", "layoutHorizontalSpacing", this.itemPaddingXSlider, 50), e("item.paddingY", "layoutVerticalSpacing", this.itemPaddingYSlider, 50);
  }
  initLabelPanel() {
    const e = this.chartOptionsService, r = {
      enabled: !0,
      suppressEnabledCheckbox: !0,
      initialFont: {
        family: e.getChartOption("legend.item.label.fontFamily"),
        style: e.getChartOption("legend.item.label.fontStyle"),
        weight: e.getChartOption("legend.item.label.fontWeight"),
        size: e.getChartOption("legend.item.label.fontSize"),
        color: e.getChartOption("legend.item.label.color")
      },
      setFont: (s) => {
        const a = this.chartOptionsService;
        s.family && a.setChartOption("legend.item.label.fontFamily", s.family), s.weight && a.setChartOption("legend.item.label.fontWeight", s.weight), s.style && a.setChartOption("legend.item.label.fontStyle", s.style), s.size && a.setChartOption("legend.item.label.fontSize", s.size), s.color && a.setChartOption("legend.item.label.color", s.color);
      }
    }, n = this.createBean(new Qi(r));
    this.legendGroup.addItem(n), this.activePanels.push(n);
  }
  destroyActivePanels() {
    this.activePanels.forEach((e) => {
      x.removeFromParent(e.getGui()), this.destroyBean(e);
    });
  }
  destroy() {
    this.destroyActivePanels(), super.destroy();
  }
}
dr.TEMPLATE = `<div>
            <ag-group-component ref="legendGroup">
                <ag-select ref="legendPositionSelect"></ag-select>
                <ag-slider ref="legendPaddingSlider"></ag-slider>
                <ag-slider ref="markerSizeSlider"></ag-slider>
                <ag-slider ref="markerStrokeSlider"></ag-slider>
                <ag-slider ref="markerPaddingSlider"></ag-slider>
                <ag-slider ref="itemPaddingXSlider"></ag-slider>
                <ag-slider ref="itemPaddingYSlider"></ag-slider>
            </ag-group-component>
        </div>`;
zo([
  L("legendGroup")
], dr.prototype, "legendGroup", void 0);
zo([
  L("legendPositionSelect")
], dr.prototype, "legendPositionSelect", void 0);
zo([
  L("legendPaddingSlider")
], dr.prototype, "legendPaddingSlider", void 0);
zo([
  L("markerSizeSlider")
], dr.prototype, "markerSizeSlider", void 0);
zo([
  L("markerStrokeSlider")
], dr.prototype, "markerStrokeSlider", void 0);
zo([
  L("markerPaddingSlider")
], dr.prototype, "markerPaddingSlider", void 0);
zo([
  L("itemPaddingXSlider")
], dr.prototype, "itemPaddingXSlider", void 0);
zo([
  L("itemPaddingYSlider")
], dr.prototype, "itemPaddingYSlider", void 0);
zo([
  S("chartTranslationService")
], dr.prototype, "chartTranslationService", void 0);
zo([
  B
], dr.prototype, "init", null);
var Nu = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Ko extends X {
  constructor(e) {
    super(), this.chartOptionsService = e;
  }
  init() {
    const e = {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical",
      suppressOpenCloseIcons: !0
    };
    this.setTemplate(Ko.TEMPLATE, { axisTicksGroup: e }), this.initAxisTicks();
  }
  initAxisTicks() {
    this.axisTicksGroup.setTitle(this.chartTranslationService.translate("ticks")).hideOpenCloseIcons(!0).hideEnabledCheckbox(!0), this.axisTicksColorPicker.setLabel(this.chartTranslationService.translate("color")).setLabelWidth("flex").setInputWidth(45).setValue(this.chartOptionsService.getAxisProperty("tick.color")).onValueChange((t) => this.chartOptionsService.setAxisProperty("tick.color", t));
    const e = (t, i, r, n) => {
      const s = this.chartOptionsService.getAxisProperty(t);
      i.setLabel(r).setMaxValue(yi(s, n)).setValue(`${s}`).setTextFieldWidth(45).onValueChange((a) => this.chartOptionsService.setAxisProperty(t, a));
    };
    e("tick.width", this.axisTicksWidthSlider, this.chartTranslationService.translate("width"), 10), e("tick.size", this.axisTicksSizeSlider, this.chartTranslationService.translate("length"), 30);
  }
}
Ko.TEMPLATE = `<div>
            <ag-group-component ref="axisTicksGroup">
                <ag-color-picker ref="axisTicksColorPicker"></ag-color-picker>
                <ag-slider ref="axisTicksWidthSlider"></ag-slider>
                <ag-slider ref="axisTicksSizeSlider"></ag-slider>
            </ag-group-component>
        </div>`;
Nu([
  L("axisTicksGroup")
], Ko.prototype, "axisTicksGroup", void 0);
Nu([
  L("axisTicksColorPicker")
], Ko.prototype, "axisTicksColorPicker", void 0);
Nu([
  L("axisTicksWidthSlider")
], Ko.prototype, "axisTicksWidthSlider", void 0);
Nu([
  L("axisTicksSizeSlider")
], Ko.prototype, "axisTicksSizeSlider", void 0);
Nu([
  S("chartTranslationService")
], Ko.prototype, "chartTranslationService", void 0);
Nu([
  B
], Ko.prototype, "init", null);
var bf = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Yo extends Wv {
  constructor(e) {
    super(e, Yo.TEMPLATE), this.radius = 0, this.offsetX = 0, this.offsetY = 0;
  }
  postConstruct() {
    super.postConstruct(), this.dragListener = {
      eElement: this.eParentCircle,
      dragStartPixels: 0,
      onDragStart: (e) => {
        this.parentCircleRect = this.eParentCircle.getBoundingClientRect();
      },
      onDragging: (e) => this.calculateAngleDrag(e),
      onDragStop: () => {
      }
    }, this.dragService.addDragSource(this.dragListener), this.eAngleValue.setLabel("").setLabelWidth(5).setInputWidth(45).setMin(0).setMax(360).setValue(`${this.degrees}`).onValueChange((e) => {
      (e == null || e === "") && (e = "0"), e = this.eAngleValue.normalizeValue(e);
      let t = parseFloat(e);
      t > 180 && (t = t - 360), this.setValue(t);
    }), this.updateNumberInput(), x.exists(this.getValue()) && this.eAngleValue.setValue(this.normalizeNegativeValue(this.getValue()).toString()), this.addManagedListener(this, ir.EVENT_CHANGED, () => {
      const e = this.gridOptionsService.getDocument();
      this.eAngleValue.getInputElement().contains(e.activeElement) || this.updateNumberInput();
    });
  }
  updateNumberInput() {
    const e = this.normalizeNegativeValue(this.getValue());
    this.eAngleValue.setValue(e.toString());
  }
  positionChildCircle(e) {
    const t = this.parentCircleRect || { width: 24, height: 24 }, i = this.eChildCircle, r = t.width / 2, n = t.height / 2;
    i.style.left = `${r + Math.cos(e) * 8}px`, i.style.top = `${n + Math.sin(e) * 8}px`;
  }
  calculatePolar() {
    const e = this.offsetX, t = this.offsetY, i = Math.atan2(t, e);
    this.degrees = this.toDegrees(i), this.radius = Math.sqrt(e * e + t * t), this.positionChildCircle(i);
  }
  calculateCartesian() {
    const e = this.toRadians(this.getValue()), t = this.getRadius();
    this.setOffsetX(Math.cos(e) * t).setOffsetY(Math.sin(e) * t);
  }
  setOffsetX(e) {
    return this.offsetX !== e && (this.offsetX = e, this.calculatePolar()), this;
  }
  setOffsetY(e) {
    return this.offsetY !== e && (this.offsetY = e, this.calculatePolar()), this;
  }
  calculateAngleDrag(e) {
    const t = this.parentCircleRect, i = t.width / 2, r = t.height / 2, n = e.clientX - t.left, s = e.clientY - t.top, a = n - i, l = s - r, c = Math.atan2(l, a);
    this.setValue(c, !0);
  }
  toDegrees(e) {
    return e / Math.PI * 180;
  }
  toRadians(e) {
    return e / 180 * Math.PI;
  }
  normalizeNegativeValue(e) {
    return e < 0 ? 360 + e : e;
  }
  normalizeAngle180(e) {
    return e %= Math.PI * 2, e < -Math.PI ? e += Math.PI * 2 : e >= Math.PI && (e -= Math.PI * 2), e;
  }
  getRadius() {
    return this.radius;
  }
  setRadius(e) {
    return this.radius === e ? this : (this.radius = e, this.calculateCartesian(), this);
  }
  onValueChange(e) {
    return this.addManagedListener(this, ir.EVENT_CHANGED, () => {
      e(this.degrees);
    }), this;
  }
  getValue(e) {
    return e ? this.toRadians(this.degrees) : this.degrees;
  }
  setValue(e, t) {
    let i;
    return t ? i = e : i = this.normalizeAngle180(this.toRadians(e)), e = this.toDegrees(i), this.degrees !== e && (this.degrees = Math.floor(e), this.calculateCartesian(), this.positionChildCircle(i), this.dispatchEvent({ type: ir.EVENT_CHANGED })), this;
  }
  setWidth(e) {
    return x.setFixedWidth(this.getGui(), e), this;
  }
  setDisabled(e) {
    return super.setDisabled(e), this.eAngleValue.setDisabled(e), this;
  }
  destroy() {
    this.dragService.removeDragSource(this.dragListener), super.destroy();
  }
}
Yo.TEMPLATE = `<div class="ag-angle-select">
            <div ref="eLabel"></div>
            <div class="ag-wrapper ag-angle-select-wrapper">
                <div ref="eAngleSelectField" class="ag-angle-select-field">
                    <div ref="eParentCircle" class="ag-angle-select-parent-circle">
                        <div ref="eChildCircle" class="ag-angle-select-child-circle"></div>
                    </div>
                </div>
                <ag-input-number-field ref="eAngleValue"></ag-input-number-field>
            </div>
        </div>`;
bf([
  L("eLabel")
], Yo.prototype, "eLabel", void 0);
bf([
  L("eParentCircle")
], Yo.prototype, "eParentCircle", void 0);
bf([
  L("eChildCircle")
], Yo.prototype, "eChildCircle", void 0);
bf([
  L("eAngleValue")
], Yo.prototype, "eAngleValue", void 0);
bf([
  S("dragService")
], Yo.prototype, "dragService", void 0);
var wf = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Bs extends X {
  constructor({ chartController: e, chartOptionsService: t, isExpandedOnInit: i = !1 }) {
    super(), this.activePanels = [], this.axisLabelUpdateFuncs = [], this.prevXRotation = 0, this.prevYRotation = 0, this.chartController = e, this.chartOptionsService = t, this.isExpandedOnInit = i;
  }
  init() {
    const e = {
      cssIdentifier: "charts-format-top-level",
      direction: "vertical"
    };
    this.setTemplate(Bs.TEMPLATE, { axisGroup: e }), this.initAxis(), this.initAxisTicks(), this.initAxisLabels();
    const t = () => this.axisLabelUpdateFuncs.forEach((i) => i());
    this.addManagedListener(this.chartController, Rt.EVENT_CHART_UPDATED, t);
  }
  initAxis() {
    this.axisGroup.setTitle(this.translate("axis")).toggleGroupExpand(this.isExpandedOnInit).hideEnabledCheckbox(!0), this.axisColorInput.setLabel(this.translate("color")).setLabelWidth("flex").setInputWidth(45).setValue(this.chartOptionsService.getAxisProperty("line.color")).onValueChange((t) => this.chartOptionsService.setAxisProperty("line.color", t));
    const e = this.chartOptionsService.getAxisProperty("line.width");
    this.axisLineWidthSlider.setMaxValue(yi(e, 10)).setLabel(this.translate("thickness")).setTextFieldWidth(45).setValue(`${e}`).onValueChange((t) => this.chartOptionsService.setAxisProperty("line.width", t));
  }
  initAxisTicks() {
    const e = this.createBean(new Ko(this.chartOptionsService));
    this.axisGroup.addItem(e), this.activePanels.push(e);
  }
  initAxisLabels() {
    const e = {
      family: this.chartOptionsService.getAxisProperty("label.fontFamily"),
      style: this.chartOptionsService.getAxisProperty("label.fontStyle"),
      weight: this.chartOptionsService.getAxisProperty("label.fontWeight"),
      size: this.chartOptionsService.getAxisProperty("label.fontSize"),
      color: this.chartOptionsService.getAxisProperty("label.color")
    }, t = (n) => {
      n.family && this.chartOptionsService.setAxisProperty("label.fontFamily", n.family), n.weight && this.chartOptionsService.setAxisProperty("label.fontWeight", n.weight), n.style && this.chartOptionsService.setAxisProperty("label.fontStyle", n.style), n.size && this.chartOptionsService.setAxisProperty("label.fontSize", n.size), n.color && this.chartOptionsService.setAxisProperty("label.color", n.color);
    }, i = {
      name: this.translate("labels"),
      enabled: !0,
      suppressEnabledCheckbox: !0,
      initialFont: e,
      setFont: t
    }, r = this.createBean(new Qi(i));
    this.axisGroup.addItem(r), this.activePanels.push(r), this.addAdditionalLabelComps(r);
  }
  addAdditionalLabelComps(e) {
    this.addLabelPadding(e);
    const { xRotationComp: t, yRotationComp: i } = this.createRotationWidgets(), r = this.initLabelRotations(t, i);
    e.addCompToPanel(r), e.addCompToPanel(t), e.addCompToPanel(i);
  }
  initLabelRotations(e, t) {
    const i = (c) => this.chartOptionsService.getLabelRotation(c), r = (c, d) => {
      this.chartOptionsService.setLabelRotation(c, d);
    }, n = (c) => {
      this.chartOptionsService.setAxisProperty("label.autoRotate", c), c ? (this.prevXRotation = i("xAxis"), this.prevYRotation = i("yAxis"), r("xAxis", void 0), r("yAxis", void 0)) : (r("xAxis", this.prevXRotation), r("yAxis", this.prevYRotation)), e.setDisabled(c), t.setDisabled(c);
    }, a = (() => {
      const c = i("xAxis"), d = i("yAxis");
      return c == null && d == null ? this.chartOptionsService.getAxisProperty("label.autoRotate") : !1;
    })(), l = this.createBean(new rr()).setLabel(this.translate("autoRotate")).setValue(a).onValueChange(n);
    return e.setDisabled(a), t.setDisabled(a), l;
  }
  createRotationWidgets() {
    const e = String.fromCharCode(176), t = (i, r) => {
      const n = `${this.chartTranslationService.translate(i)} ${e}`, s = this.chartOptionsService.getLabelRotation(r), a = new Yo().setLabel(n).setLabelWidth("flex").setValue(s || 0).onValueChange((l) => this.chartOptionsService.setLabelRotation(r, l));
      return this.axisLabelUpdateFuncs.push(() => {
        const l = this.chartOptionsService.getLabelRotation(r);
        a.setValue(l || 0);
      }), this.createBean(a);
    };
    return {
      xRotationComp: t("xRotation", "xAxis"),
      yRotationComp: t("yRotation", "yAxis")
    };
  }
  addLabelPadding(e) {
    const t = this.createBean(new mi()), i = this.chartOptionsService.getAxisProperty("label.padding");
    t.setLabel(this.chartTranslationService.translate("padding")).setMaxValue(yi(i, 30)).setValue(`${i}`).setTextFieldWidth(45).onValueChange((r) => this.chartOptionsService.setAxisProperty("label.padding", r)), e.addCompToPanel(t);
  }
  translate(e, t) {
    return this.chartTranslationService.translate(e, t);
  }
  destroyActivePanels() {
    this.activePanels.forEach((e) => {
      x.removeFromParent(e.getGui()), this.destroyBean(e);
    });
  }
  destroy() {
    this.destroyActivePanels(), super.destroy();
  }
}
Bs.TEMPLATE = `<div>
            <ag-group-component ref="axisGroup">
                <ag-color-picker ref="axisColorInput"></ag-color-picker>
                <ag-slider ref="axisLineWidthSlider"></ag-slider>
            </ag-group-component>
        </div>`;
wf([
  L("axisGroup")
], Bs.prototype, "axisGroup", void 0);
wf([
  L("axisColorInput")
], Bs.prototype, "axisColorInput", void 0);
wf([
  L("axisLineWidthSlider")
], Bs.prototype, "axisLineWidthSlider", void 0);
wf([
  S("chartTranslationService")
], Bs.prototype, "chartTranslationService", void 0);
wf([
  B
], Bs.prototype, "init", null);
var Jm = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class rl extends X {
  constructor({ chartOptionsService: e, isExpandedOnInit: t = !1 }) {
    super(), this.chartOptionsService = e, this.isExpandedOnInit = t;
  }
  init() {
    const e = {
      cssIdentifier: "charts-format-top-level",
      direction: "vertical"
    };
    this.setTemplate(rl.TEMPLATE, { navigatorGroup: e }), this.initNavigator();
  }
  initNavigator() {
    const { chartTranslationService: e } = this;
    this.navigatorGroup.setTitle(e.translate("navigator")).hideEnabledCheckbox(!1).setEnabled(this.chartOptionsService.getChartOption("navigator.enabled") || !1).onEnableChange((i) => {
      this.chartOptionsService.setChartOption("navigator.enabled", i), this.navigatorGroup.toggleGroupExpand(!0);
    }).toggleGroupExpand(this.isExpandedOnInit);
    const t = this.chartOptionsService.getChartOption("navigator.height");
    this.navigatorHeightSlider.setLabel(e.translate("height")).setMinValue(10).setMaxValue(yi(t, 60)).setTextFieldWidth(45).setValue(`${t || 30}`).onValueChange((i) => this.chartOptionsService.setChartOption("navigator.height", i));
  }
  destroy() {
    super.destroy();
  }
}
rl.TEMPLATE = `<div>
            <ag-group-component ref="navigatorGroup">
                <ag-slider ref="navigatorHeightSlider"></ag-slider>
            </ag-group-component>
        </div>`;
Jm([
  L("navigatorGroup")
], rl.prototype, "navigatorGroup", void 0);
Jm([
  L("navigatorHeightSlider")
], rl.prototype, "navigatorHeightSlider", void 0);
Jm([
  S("chartTranslationService")
], rl.prototype, "chartTranslationService", void 0);
Jm([
  B
], rl.prototype, "init", null);
var bc = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Zn extends X {
  constructor(e, t) {
    super(), this.chartOptionsService = e, this.chartController = t;
  }
  init() {
    const e = {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical",
      suppressOpenCloseIcons: !0
    };
    this.setTemplate(Zn.TEMPLATE, { chartPaddingGroup: e }), this.addManagedListener(this.eventService, w.EVENT_CHART_OPTIONS_CHANGED, (t) => {
      this.updateTopPadding(t.chartOptions);
    }), this.initGroup(), this.initChartPaddingItems();
  }
  initGroup() {
    this.chartPaddingGroup.setTitle(this.chartTranslationService.translate("padding")).hideOpenCloseIcons(!0).hideEnabledCheckbox(!0);
  }
  initChartPaddingItems() {
    const e = (t, i) => {
      const r = this.chartOptionsService.getChartOption("padding." + t);
      i.setLabel(this.chartTranslationService.translate(t)).setMaxValue(yi(r, 200)).setValue(`${r}`).setTextFieldWidth(45).onValueChange((n) => this.chartOptionsService.setChartOption("padding." + t, n));
    };
    e("top", this.paddingTopSlider), e("right", this.paddingRightSlider), e("bottom", this.paddingBottomSlider), e("left", this.paddingLeftSlider);
  }
  updateTopPadding(e) {
    var t, i;
    const r = this.chartController.getChartSeriesTypes()[0], n = (i = (t = e[r]) === null || t === void 0 ? void 0 : t.padding) === null || i === void 0 ? void 0 : i.top;
    n != null && this.paddingTopSlider.setValue(n);
  }
}
Zn.TEMPLATE = `<div>
            <ag-group-component ref="chartPaddingGroup">
                <ag-slider ref="paddingTopSlider"></ag-slider>
                <ag-slider ref="paddingRightSlider"></ag-slider>
                <ag-slider ref="paddingBottomSlider"></ag-slider>
                <ag-slider ref="paddingLeftSlider"></ag-slider>
            </ag-group-component>
        <div>`;
bc([
  L("chartPaddingGroup")
], Zn.prototype, "chartPaddingGroup", void 0);
bc([
  L("paddingTopSlider")
], Zn.prototype, "paddingTopSlider", void 0);
bc([
  L("paddingRightSlider")
], Zn.prototype, "paddingRightSlider", void 0);
bc([
  L("paddingBottomSlider")
], Zn.prototype, "paddingBottomSlider", void 0);
bc([
  L("paddingLeftSlider")
], Zn.prototype, "paddingLeftSlider", void 0);
bc([
  S("chartTranslationService")
], Zn.prototype, "chartTranslationService", void 0);
bc([
  B
], Zn.prototype, "init", null);
var ey = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class nl extends X {
  constructor(e) {
    super(), this.chartOptionsService = e;
  }
  init() {
    const e = {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical",
      suppressOpenCloseIcons: !0
    };
    this.setTemplate(nl.TEMPLATE, { chartBackgroundGroup: e }), this.initGroup(), this.initColorPicker();
  }
  initGroup() {
    this.group.setTitle(this.chartTranslationService.translate("background")).setEnabled(this.chartOptionsService.getChartOption("background.visible")).hideOpenCloseIcons(!0).hideEnabledCheckbox(!1).onEnableChange((e) => this.chartOptionsService.setChartOption("background.visible", e));
  }
  initColorPicker() {
    this.colorPicker.setLabel(this.chartTranslationService.translate("color")).setLabelWidth("flex").setInputWidth(45).setValue(this.chartOptionsService.getChartOption("background.fill")).onValueChange((e) => this.chartOptionsService.setChartOption("background.fill", e));
  }
}
nl.TEMPLATE = `<div>
            <ag-group-component ref="chartBackgroundGroup">
                <ag-color-picker ref="colorPicker"></ag-color-picker>
            </ag-group-component>
        <div>`;
ey([
  L("chartBackgroundGroup")
], nl.prototype, "group", void 0);
ey([
  L("colorPicker")
], nl.prototype, "colorPicker", void 0);
ey([
  S("chartTranslationService")
], nl.prototype, "chartTranslationService", void 0);
ey([
  B
], nl.prototype, "init", null);
var VO = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Gu extends X {
  constructor(e) {
    super(Gu.TEMPLATE), this.chartOptionsService = e, this.activePanels = [];
  }
  init() {
    this.initFontPanel(), this.titlePlaceholder = this.chartTranslationService.translate("titlePlaceholder");
  }
  hasTitle() {
    const e = this.getOption("title");
    return e && e.enabled && e.text && e.text.length > 0;
  }
  initFontPanel() {
    const e = this.hasTitle(), t = (s, a) => {
      s.family && this.setOption("title.fontFamily", s.family, a), s.weight && this.setOption("title.fontWeight", s.weight, a), s.style && this.setOption("title.fontStyle", s.style, a), s.size && this.setOption("title.fontSize", s.size, a), s.color && this.setOption("title.color", s.color, a);
    }, i = {
      family: this.getOption("title.fontFamily"),
      style: this.getOption("title.fontStyle"),
      weight: this.getOption("title.fontWeight"),
      size: this.getOption("title.fontSize"),
      color: this.getOption("title.color")
    };
    e || t(i, !0);
    const r = {
      name: this.chartTranslationService.translate("title"),
      enabled: e,
      suppressEnabledCheckbox: !1,
      initialFont: i,
      setFont: t,
      setEnabled: (s) => {
        if (this.toolbarExists()) {
          const c = this.getOption("padding.top");
          this.setOption("padding.top", s ? c - 20 : c + 20);
        }
        this.setOption("title.enabled", s);
        const a = this.getOption("title.text"), l = a === "Title" || (a == null ? void 0 : a.trim().length) === 0;
        s && l && this.setOption("title.text", this.titlePlaceholder);
      }
    }, n = this.createBean(new Qi(r));
    n.addItemToPanel(this.createSpacingSlicer()), this.getGui().appendChild(n.getGui()), this.activePanels.push(n), this.addManagedListener(this.eventService, "chartTitleEdit", () => {
      n.setEnabled(this.hasTitle());
    });
  }
  createSpacingSlicer() {
    const e = this.createBean(new mi()), t = this.chartOptionsService.getChartOption("title.spacing");
    return e.setLabel(this.chartTranslationService.translate("spacing")).setMaxValue(Math.max(t, 100)).setValue(`${t}`).setTextFieldWidth(45).onValueChange((i) => this.chartOptionsService.setChartOption("title.spacing", i)), e;
  }
  toolbarExists() {
    const e = this.gridOptionsService.getCallback("getChartToolbarItems");
    if (!e)
      return !0;
    const t = {
      defaultItems: ["chartUnlink", "chartDownload"]
    };
    return ["chartLink", "chartUnlink", "chartDownload"].some((r) => {
      var n;
      return (n = e && e(t)) === null || n === void 0 ? void 0 : n.includes(r);
    });
  }
  getOption(e) {
    return this.chartOptionsService.getChartOption(e);
  }
  setOption(e, t, i) {
    this.chartOptionsService.setChartOption(e, t, i);
  }
  destroyActivePanels() {
    this.activePanels.forEach((e) => {
      x.removeFromParent(e.getGui()), this.destroyBean(e);
    });
  }
  destroy() {
    this.destroyActivePanels(), super.destroy();
  }
}
Gu.TEMPLATE = "<div></div>";
VO([
  S("chartTranslationService")
], Gu.prototype, "chartTranslationService", void 0);
VO([
  B
], Gu.prototype, "init", null);
var yw = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class wc extends X {
  constructor({ chartController: e, chartOptionsService: t, isExpandedOnInit: i = !1 }) {
    super(), this.activePanels = [], this.chartController = e, this.chartOptionsService = t, this.isExpandedOnInit = i;
  }
  init() {
    const e = {
      cssIdentifier: "charts-format-top-level",
      direction: "vertical"
    };
    this.setTemplate(wc.TEMPLATE, { chartGroup: e }), this.initGroup(), this.initTitles(), this.initPaddingPanel(), this.initBackgroundPanel();
  }
  initGroup() {
    this.chartGroup.setTitle(this.chartTranslationService.translate("chart")).toggleGroupExpand(this.isExpandedOnInit).hideEnabledCheckbox(!0);
  }
  initTitles() {
    const e = this.createBean(new Gu(this.chartOptionsService));
    this.chartGroup.addItem(e), this.activePanels.push(e);
  }
  initPaddingPanel() {
    const e = this.createBean(new Zn(this.chartOptionsService, this.chartController));
    this.chartGroup.addItem(e), this.activePanels.push(e);
  }
  initBackgroundPanel() {
    const e = this.createBean(new nl(this.chartOptionsService));
    this.chartGroup.addItem(e), this.activePanels.push(e);
  }
  destroyActivePanels() {
    this.activePanels.forEach((e) => {
      x.removeFromParent(e.getGui()), this.destroyBean(e);
    });
  }
  destroy() {
    this.destroyActivePanels(), super.destroy();
  }
}
wc.TEMPLATE = `<div>
            <ag-group-component ref="chartGroup"></ag-group-component>
        </div>`;
yw([
  L("chartGroup")
], wc.prototype, "chartGroup", void 0);
yw([
  S("chartTranslationService")
], wc.prototype, "chartTranslationService", void 0);
yw([
  B
], wc.prototype, "init", null);
var Ec = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Qn extends X {
  constructor(e, t) {
    super(), this.chartOptionsService = e, this.getSelectedSeries = t;
  }
  init() {
    const e = {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical",
      suppressOpenCloseIcons: !0
    };
    this.setTemplate(Qn.TEMPLATE, { shadowGroup: e }), this.shadowBlurSlider.setTextFieldWidth(45), this.shadowXOffsetSlider.setTextFieldWidth(45), this.shadowYOffsetSlider.setTextFieldWidth(45), this.initSeriesShadow();
  }
  initSeriesShadow() {
    this.shadowGroup.setTitle(this.chartTranslationService.translate("shadow")).setEnabled(this.chartOptionsService.getSeriesOption("shadow.enabled", this.getSelectedSeries())).hideOpenCloseIcons(!0).hideEnabledCheckbox(!1).onEnableChange((t) => this.chartOptionsService.setSeriesOption("shadow.enabled", t, this.getSelectedSeries())), this.shadowColorPicker.setLabel(this.chartTranslationService.translate("color")).setLabelWidth("flex").setInputWidth(45).setValue(this.chartOptionsService.getSeriesOption("shadow.color", this.getSelectedSeries())).onValueChange((t) => this.chartOptionsService.setSeriesOption("shadow.color", t, this.getSelectedSeries()));
    const e = (t, i, r, n) => {
      const s = this.chartOptionsService.getSeriesOption(`shadow.${i}`, this.getSelectedSeries());
      t.setLabel(this.chartTranslationService.translate(i)).setMinValue(r).setMaxValue(yi(s, n)).setValue(`${s}`).onValueChange((a) => this.chartOptionsService.setSeriesOption(`shadow.${i}`, a, this.getSelectedSeries()));
    };
    e(this.shadowBlurSlider, "blur", 0, 20), e(this.shadowXOffsetSlider, "xOffset", -10, 10), e(this.shadowYOffsetSlider, "yOffset", -10, 10);
  }
}
Qn.TEMPLATE = `<div>
            <ag-group-component ref="shadowGroup">
                <ag-color-picker ref="shadowColorPicker"></ag-color-picker>
                <ag-slider ref="shadowBlurSlider"></ag-slider>
                <ag-slider ref="shadowXOffsetSlider"></ag-slider>
                <ag-slider ref="shadowYOffsetSlider"></ag-slider>
            </ag-group-component>
        </div>`;
Ec([
  L("shadowGroup")
], Qn.prototype, "shadowGroup", void 0);
Ec([
  L("shadowColorPicker")
], Qn.prototype, "shadowColorPicker", void 0);
Ec([
  L("shadowBlurSlider")
], Qn.prototype, "shadowBlurSlider", void 0);
Ec([
  L("shadowXOffsetSlider")
], Qn.prototype, "shadowXOffsetSlider", void 0);
Ec([
  L("shadowYOffsetSlider")
], Qn.prototype, "shadowYOffsetSlider", void 0);
Ec([
  S("chartTranslationService")
], Qn.prototype, "chartTranslationService", void 0);
Ec([
  B
], Qn.prototype, "init", null);
function jE({ labelName: o, chartOptionsService: e, getSelectedSeries: t, seriesOptionLabelProperty: i }) {
  const r = (d) => `${i}.${d}`, n = (d) => {
    const u = r(d);
    return e.getSeriesOption(u, t());
  }, s = (d, u) => {
    const h = r(d);
    e.setSeriesOption(h, u, t());
  }, a = {
    family: n("fontFamily"),
    style: n("fontStyle"),
    weight: n("fontWeight"),
    size: n("fontSize"),
    color: n("color")
  }, l = (d) => {
    d.family && s("fontFamily", d.family), d.weight && s("fontWeight", d.weight), d.style && s("fontStyle", d.style), d.size && s("fontSize", d.size), d.color && s("color", d.color);
  };
  return {
    name: o,
    enabled: n("enabled") || !1,
    setEnabled: (d) => s("enabled", d),
    suppressEnabledCheckbox: !1,
    initialFont: a,
    setFont: l
  };
}
var Rc = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Jn extends X {
  constructor(e, t) {
    super(), this.chartOptionsService = e, this.getSelectedSeries = t;
  }
  init() {
    const e = {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical"
    };
    this.setTemplate(Jn.TEMPLATE, { seriesMarkersGroup: e }), this.initMarkers();
  }
  initMarkers() {
    const e = [
      {
        value: "square",
        text: "Square"
      },
      {
        value: "circle",
        text: "Circle"
      },
      {
        value: "cross",
        text: "Cross"
      },
      {
        value: "diamond",
        text: "Diamond"
      },
      {
        value: "plus",
        text: "Plus"
      },
      {
        value: "triangle",
        text: "Triangle"
      },
      {
        value: "heart",
        text: "Heart"
      }
    ];
    this.seriesMarkerShapeSelect.addOptions(e).setLabel(this.chartTranslationService.translate("shape")).setValue(this.getSeriesOption("marker.shape")).onValueChange((n) => this.setSeriesOption("marker.shape", n));
    const t = this.chartOptionsService.getChartType(), i = x.includes(["scatter", "bubble"], t);
    this.seriesMarkersGroup.setTitle(this.chartTranslationService.translate("markers")).hideEnabledCheckbox(i).setEnabled(this.getSeriesOption("marker.enabled") || !1).hideOpenCloseIcons(!0).onEnableChange((n) => this.setSeriesOption("marker.enabled", n));
    const r = (n, s, a, l) => {
      const c = this.getSeriesOption(n);
      s.setLabel(this.chartTranslationService.translate(a)).setMaxValue(yi(c, l)).setValue(`${c}`).setTextFieldWidth(45).onValueChange((d) => this.setSeriesOption(n, d));
    };
    t === "bubble" ? (r("marker.maxSize", this.seriesMarkerMinSizeSlider, "maxSize", 60), r("marker.size", this.seriesMarkerSizeSlider, "minSize", 60)) : (this.seriesMarkerMinSizeSlider.setDisplayed(!1), r("marker.size", this.seriesMarkerSizeSlider, "size", 60)), r("marker.strokeWidth", this.seriesMarkerStrokeWidthSlider, "strokeWidth", 10);
  }
  getSeriesOption(e) {
    return this.chartOptionsService.getSeriesOption(e, this.getSelectedSeries());
  }
  setSeriesOption(e, t) {
    this.chartOptionsService.setSeriesOption(e, t, this.getSelectedSeries());
  }
}
Jn.TEMPLATE = `<div>
            <ag-group-component ref="seriesMarkersGroup">
                <ag-select ref="seriesMarkerShapeSelect"></ag-select>
                <ag-slider ref="seriesMarkerMinSizeSlider"></ag-slider>
                <ag-slider ref="seriesMarkerSizeSlider"></ag-slider>
                <ag-slider ref="seriesMarkerStrokeWidthSlider"></ag-slider>
            </ag-group-component>
        </div>`;
Rc([
  L("seriesMarkersGroup")
], Jn.prototype, "seriesMarkersGroup", void 0);
Rc([
  L("seriesMarkerShapeSelect")
], Jn.prototype, "seriesMarkerShapeSelect", void 0);
Rc([
  L("seriesMarkerSizeSlider")
], Jn.prototype, "seriesMarkerSizeSlider", void 0);
Rc([
  L("seriesMarkerMinSizeSlider")
], Jn.prototype, "seriesMarkerMinSizeSlider", void 0);
Rc([
  L("seriesMarkerStrokeWidthSlider")
], Jn.prototype, "seriesMarkerStrokeWidthSlider", void 0);
Rc([
  S("chartTranslationService")
], Jn.prototype, "chartTranslationService", void 0);
Rc([
  B
], Jn.prototype, "init", null);
var ku = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Xo extends X {
  constructor(e, t) {
    super(), this.chartOptionsService = e, this.getSelectedSeries = t;
  }
  init() {
    const e = {
      cssIdentifier: "charts-format-sub-level",
      direction: "vertical"
    };
    this.setTemplate(Xo.TEMPLATE, { calloutGroup: e }), this.initCalloutOptions();
  }
  initCalloutOptions() {
    this.calloutGroup.setTitle(this.chartTranslationService.translate("callout")).setEnabled(!0).hideOpenCloseIcons(!0).hideEnabledCheckbox(!0);
    const e = (t, i, r, n) => {
      const s = this.chartOptionsService.getSeriesOption(t, this.getSelectedSeries());
      i.setLabel(this.chartTranslationService.translate(r)).setMaxValue(yi(s, n)).setValue(`${s}`).setTextFieldWidth(45).onValueChange((a) => this.chartOptionsService.setSeriesOption(t, a, this.getSelectedSeries()));
    };
    e("calloutLine.length", this.calloutLengthSlider, "length", 40), e("calloutLine.strokeWidth", this.calloutStrokeWidthSlider, "strokeWidth", 10), e("calloutLabel.offset", this.labelOffsetSlider, "offset", 30);
  }
}
Xo.TEMPLATE = `<div>
            <ag-group-component ref="calloutGroup">
                <ag-slider ref="calloutLengthSlider"></ag-slider>
                <ag-slider ref="calloutStrokeWidthSlider"></ag-slider>
                <ag-slider ref="labelOffsetSlider"></ag-slider>
            </ag-group-component>
        </div>`;
ku([
  L("calloutGroup")
], Xo.prototype, "calloutGroup", void 0);
ku([
  L("calloutLengthSlider")
], Xo.prototype, "calloutLengthSlider", void 0);
ku([
  L("calloutStrokeWidthSlider")
], Xo.prototype, "calloutStrokeWidthSlider", void 0);
ku([
  L("labelOffsetSlider")
], Xo.prototype, "labelOffsetSlider", void 0);
ku([
  S("chartTranslationService")
], Xo.prototype, "chartTranslationService", void 0);
ku([
  B
], Xo.prototype, "init", null);
var Cw = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Tc extends X {
  constructor({ chartController: e, chartOptionsService: t, seriesType: i, isExpandedOnInit: r = !1 }) {
    super(), this.activePanels = [], this.widgetFuncs = {
      lineWidth: () => this.initLineWidth(),
      strokeWidth: () => this.initStrokeWidth(),
      lineDash: () => this.initLineDash(),
      lineOpacity: () => this.initLineOpacity(),
      fillOpacity: () => this.initFillOpacity(),
      markers: () => this.initMarkers(),
      labels: () => this.initLabels(),
      shadow: () => this.initShadow(),
      tooltips: () => this.initTooltips(),
      bins: () => this.initBins()
    }, this.seriesWidgetMappings = {
      area: ["tooltips", "lineWidth", "lineDash", "lineOpacity", "fillOpacity", "markers", "labels", "shadow"],
      bar: ["tooltips", "strokeWidth", "lineDash", "lineOpacity", "fillOpacity", "labels", "shadow"],
      column: ["tooltips", "strokeWidth", "lineDash", "lineOpacity", "fillOpacity", "labels", "shadow"],
      line: ["tooltips", "lineWidth", "lineDash", "lineOpacity", "markers", "labels"],
      histogram: ["tooltips", "bins", "strokeWidth", "lineDash", "lineOpacity", "fillOpacity", "labels", "shadow"],
      scatter: ["tooltips", "markers", "labels"],
      pie: ["tooltips", "strokeWidth", "lineOpacity", "fillOpacity", "labels", "shadow"]
    }, this.chartController = e, this.chartOptionsService = t, this.seriesType = i || this.getChartSeriesType(), this.isExpandedOnInit = r;
  }
  init() {
    const e = {
      cssIdentifier: "charts-format-top-level",
      direction: "vertical"
    };
    this.setTemplate(Tc.TEMPLATE, { seriesGroup: e }), this.seriesGroup.setTitle(this.translate("series")).toggleGroupExpand(this.isExpandedOnInit).hideEnabledCheckbox(!0), this.addManagedListener(this.chartController, Rt.EVENT_CHART_SERIES_CHART_TYPE_CHANGED, this.refreshWidgets.bind(this)), this.refreshWidgets();
  }
  refreshWidgets() {
    this.destroyActivePanels(), this.chartController.getChartProxy().getChart().waitForUpdate().then(() => {
      this.chartController.isComboChart() && (this.updateSeriesType(), this.initSeriesSelect()), this.seriesWidgetMappings[this.seriesType].forEach((t) => this.widgetFuncs[t]());
    }).catch((t) => console.error("AG Grid - chart rendering failed", t));
  }
  initSeriesSelect() {
    const e = this.seriesGroup.createManagedBean(new zn());
    e.setLabel(this.translate("seriesType")).setLabelAlignment("left").setLabelWidth("flex").setInputWidth(100).addOptions(this.getSeriesSelectOptions()).setValue(`${this.seriesType}`).onValueChange((t) => {
      this.seriesType = t, this.refreshWidgets();
    }), this.seriesGroup.addItem(e), this.activePanels.push(e);
  }
  initTooltips() {
    const e = this.createBean(new Rb());
    e.setLabel(this.translate("tooltips")).setLabelAlignment("left").setLabelWidth("flex").setInputWidth(45).setValue(this.getSeriesOption("tooltip.enabled") || !1).onValueChange((t) => this.setSeriesOption("tooltip.enabled", t)), this.addWidget(e);
  }
  initStrokeWidth() {
    const e = this.getSeriesOption("strokeWidth"), t = this.createBean(new mi());
    t.setLabel(this.translate("strokeWidth")).setMaxValue(yi(e, 10)).setTextFieldWidth(45).setValue(`${e}`).onValueChange((i) => this.setSeriesOption("strokeWidth", i)), this.addWidget(t);
  }
  initLineWidth() {
    const e = this.getSeriesOption("strokeWidth"), t = this.createBean(new mi());
    t.setLabel(this.translate("lineWidth")).setMaxValue(yi(e, 10)).setTextFieldWidth(45).setValue(`${e}`).onValueChange((i) => this.setSeriesOption("strokeWidth", i)), this.addWidget(t);
  }
  initLineDash() {
    const e = this.getSeriesOption("lineDash"), t = e ? e[0] : 0, i = this.createBean(new mi());
    i.setLabel(this.translate("lineDash")).setMaxValue(yi(t, 30)).setTextFieldWidth(45).setValue(`${t}`).onValueChange((r) => this.setSeriesOption("lineDash", [r])), this.addWidget(i);
  }
  initLineOpacity() {
    const e = this.getSeriesOption("strokeOpacity"), t = this.createBean(new mi());
    t.setLabel(this.translate("strokeOpacity")).setStep(0.05).setMaxValue(yi(e, 1)).setTextFieldWidth(45).setValue(`${e}`).onValueChange((i) => this.setSeriesOption("strokeOpacity", i)), this.addWidget(t);
  }
  initFillOpacity() {
    const e = this.getSeriesOption("fillOpacity"), t = this.createBean(new mi());
    t.setLabel(this.translate("fillOpacity")).setStep(0.05).setMaxValue(yi(e, 1)).setTextFieldWidth(45).setValue(`${e}`).onValueChange((i) => this.setSeriesOption("fillOpacity", i)), this.addWidget(t);
  }
  initLabels() {
    const e = this.seriesType === "pie" ? "calloutLabel" : "label", t = this.seriesType === "pie" ? this.chartTranslationService.translate("calloutLabels") : this.chartTranslationService.translate("labels"), i = jE({
      labelName: t,
      chartOptionsService: this.chartOptionsService,
      getSelectedSeries: () => this.seriesType,
      seriesOptionLabelProperty: e
    }), r = this.createBean(new Qi(i));
    if (this.seriesType === "pie") {
      const n = this.createBean(new Xo(this.chartOptionsService, () => this.seriesType));
      r.addCompToPanel(n), this.activePanels.push(n);
    }
    if (this.addWidget(r), this.seriesType === "pie") {
      const n = jE({
        labelName: this.chartTranslationService.translate("sectorLabels"),
        chartOptionsService: this.chartOptionsService,
        getSelectedSeries: () => this.seriesType,
        seriesOptionLabelProperty: "sectorLabel"
      }), s = this.createBean(new Qi(n)), a = this.getSectorLabelPositionRatio();
      s.addCompToPanel(a), this.addWidget(s);
    }
  }
  getSectorLabelPositionRatio() {
    const e = "sectorLabel.positionRatio", t = this.chartOptionsService.getSeriesOption(e, this.seriesType);
    return this.createBean(new mi()).setLabel(this.translate("positionRatio")).setStep(0.05).setMaxValue(yi(t, 1)).setTextFieldWidth(45).setValue(`${t}`).onValueChange((r) => this.chartOptionsService.setSeriesOption(e, r, this.seriesType));
  }
  initShadow() {
    const e = this.createBean(new Qn(this.chartOptionsService, () => this.seriesType));
    this.addWidget(e);
  }
  initMarkers() {
    const e = this.createBean(new Jn(this.chartOptionsService, () => this.seriesType));
    this.addWidget(e);
  }
  initBins() {
    var e;
    const t = ((e = this.getSeriesOption("bins")) !== null && e !== void 0 ? e : this.getSeriesOption("calculatedBins")).length, i = this.createBean(new mi());
    i.setLabel(this.translate("histogramBinCount")).setMinValue(0).setMaxValue(yi(t, 20)).setTextFieldWidth(45).setValue(`${t}`).onValueChange((r) => this.setSeriesOption("binCount", r)), this.addWidget(i);
  }
  addWidget(e) {
    this.seriesGroup.addItem(e), this.activePanels.push(e);
  }
  getSeriesOption(e) {
    return this.chartOptionsService.getSeriesOption(e, this.seriesType);
  }
  setSeriesOption(e, t) {
    this.chartOptionsService.setSeriesOption(e, t, this.seriesType);
  }
  getChartSeriesType() {
    if (this.chartController.getSeriesChartTypes().length === 0)
      return "column";
    const e = this.chartController.getSeriesChartTypes()[0].chartType;
    return e === "columnLineCombo" ? "column" : e === "areaColumnCombo" ? "area" : pn(e);
  }
  getSeriesSelectOptions() {
    this.seriesSelectOptions || (this.seriesSelectOptions = /* @__PURE__ */ new Map([
      ["area", { value: "area", text: this.translate("area", "Area") }],
      ["bar", { value: "bar", text: this.translate("bar", "Bar") }],
      ["column", { value: "column", text: this.translate("column", "Column") }],
      ["line", { value: "line", text: this.translate("line", "Line") }],
      ["scatter", { value: "scatter", text: this.translate("scatter", "Scatter") }],
      ["histogram", { value: "histogram", text: this.translate("histogram", "Histogram") }],
      ["pie", { value: "pie", text: this.translate("pie", "Pie") }]
    ]));
    const e = /* @__PURE__ */ new Set();
    return this.chartController.getActiveSeriesChartTypes().forEach((t) => {
      const i = pn(t.chartType);
      e.add(this.seriesSelectOptions.get(i));
    }), Array.from(e);
  }
  updateSeriesType() {
    const e = this.chartController.getActiveSeriesChartTypes().map((i) => pn(i.chartType));
    !e.includes(this.seriesType) && e.length > 0 && (this.seriesType = e[0]);
  }
  translate(e, t) {
    return this.chartTranslationService.translate(e, t);
  }
  destroyActivePanels() {
    this.activePanels.forEach((e) => {
      x.removeFromParent(e.getGui()), this.destroyBean(e);
    });
  }
  destroy() {
    this.destroyActivePanels(), super.destroy();
  }
}
Tc.TEMPLATE = `<div>
            <ag-group-component ref="seriesGroup">
            </ag-group-component>
        </div>`;
Cw([
  L("seriesGroup")
], Tc.prototype, "seriesGroup", void 0);
Cw([
  S("chartTranslationService")
], Tc.prototype, "chartTranslationService", void 0);
Cw([
  B
], Tc.prototype, "init", null);
var Q$ = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
function yi(o, e) {
  return Math.max(o, e);
}
const J$ = {
  groups: [
    { type: "chart" },
    { type: "legend" },
    { type: "series" },
    { type: "axis" },
    { type: "navigator" }
  ]
};
class Ef extends X {
  constructor(e, t) {
    super(Ef.TEMPLATE), this.chartController = e, this.chartOptionsService = t, this.panels = [], this.isGroupPanelShownInSeries = (i, r) => {
      if (["chart", "legend", "series"].includes(i))
        return !0;
      const s = ["axis", "navigator"], a = ["bar", "column", "line", "area", "scatter", "histogram", "cartesian"];
      return !!(s.includes(i) && a.includes(r));
    };
  }
  init() {
    this.createPanels(), this.addManagedListener(this.chartController, Rt.EVENT_CHART_UPDATED, () => this.createPanels(!0)), this.addManagedListener(this.chartController, Rt.EVENT_CHART_API_UPDATE, () => this.createPanels(!1));
  }
  createPanels(e) {
    var t;
    const i = this.chartController.getChartType(), r = this.chartController.isGrouping(), n = pn(i);
    e && i === this.chartType && r === this.isGrouping || (this.destroyPanels(), (t = this.getFormatPanelDef().groups) === null || t === void 0 || t.forEach((s) => {
      const a = s.type;
      if (!this.isGroupPanelShownInSeries(a, n))
        return;
      const l = {
        chartController: this.chartController,
        chartOptionsService: this.chartOptionsService,
        isExpandedOnInit: s.isOpen,
        seriesType: n
      };
      a === "chart" ? this.addComponent(new wc(l)) : a === "legend" ? this.addComponent(new dr(l)) : a === "axis" ? this.addComponent(new Bs(l)) : a === "series" ? this.addComponent(new Tc(l)) : a === "navigator" ? this.addComponent(new rl(l)) : console.warn(`AG Grid: invalid charts format panel group name supplied: '${s.type}'`);
    }), this.chartType = i, this.isGrouping = r);
  }
  getFormatPanelDef() {
    var e;
    const t = (e = this.gridOptionsService.get("chartToolPanelsDef")) === null || e === void 0 ? void 0 : e.formatPanel;
    return t || J$;
  }
  addComponent(e) {
    this.createBean(e), this.panels.push(e), e.addCssClass("ag-chart-format-section"), this.getGui().appendChild(e.getGui());
  }
  destroyPanels() {
    this.panels.forEach((e) => {
      x.removeFromParent(e.getGui()), this.destroyBean(e);
    });
  }
  destroy() {
    this.destroyPanels(), super.destroy();
  }
}
Ef.TEMPLATE = '<div class="ag-chart-format-wrapper"></div>';
Q$([
  B
], Ef.prototype, "init", null);
var BO = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Rf extends X {
  constructor(e, t) {
    super(), this.size = 58, this.padding = 5, this.root = new we();
    const i = new zb({ document: window.document, width: this.size, height: this.size });
    i.canvas.element.classList.add("ag-chart-mini-thumbnail-canvas"), i.root = this.root, i.container = e, this.scene = i, this.tooltipName = t;
  }
  init() {
    this.scene.canvas.element.title = this.chartTranslationService.translate(this.tooltipName), this.scene.render().catch((e) => console.error("AG Grid - chart update failed", e));
  }
}
BO([
  S("chartTranslationService")
], Rf.prototype, "chartTranslationService", void 0);
BO([
  B
], Rf.prototype, "init", null);
var ez = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class $r extends Rf {
  constructor(e, t) {
    super(e, t), this.stroke = "gray", this.axisOvershoot = 3;
  }
  addAxes() {
    const e = this.size, t = this.padding, i = new Qt();
    i.x1 = t, i.y1 = t, i.x2 = t, i.y2 = e - t + this.axisOvershoot, i.stroke = this.stroke;
    const r = new Qt();
    r.x1 = t - this.axisOvershoot + 1, r.y1 = e - t, r.x2 = e - t + 1, r.y2 = e - t, r.stroke = this.stroke;
    const n = this.root;
    n.append(i), n.append(r);
  }
}
ez([
  B
], $r.prototype, "addAxes", null);
function Tf(o) {
  const { stacked: e, size: t, padding: i, xScalePadding: r, xScaleDomain: n, yScaleDomain: s } = o, a = new $n();
  a.domain = n, a.range = [i, t - i], a.paddingInner = r, a.paddingOuter = r;
  const l = new ri();
  l.domain = s, l.range = [t - i, i];
  const c = (d, u, h) => d.map((p, f) => {
    const g = h.convert(p), v = new kn();
    return v.x = u.convert(f), v.y = g, v.width = u.bandwidth, v.height = h.convert(0) - g, v.strokeWidth = 1, v.crisp = !0, v;
  });
  return e ? o.data.map((d) => c(d, a, l)) : c(o.data, a, l);
}
function Sw(o, e, t, i) {
  const r = new ri();
  r.domain = [0, 4], r.range = [i, t - i];
  const n = new ri();
  n.domain = [0, 10], n.range = [t - i, i];
  const s = e.map((l) => {
    const c = new Zi();
    return c.strokeWidth = 3, c.lineCap = "round", c.fill = void 0, l.forEach((d, u) => {
      c.path[u > 0 ? "lineTo" : "moveTo"](r.convert(u), n.convert(d));
    }), c;
  }), a = new we();
  return a.setClipRectInGroupCoordinateSpace(new nt(i, i, t - i * 2, t - i * 2)), a.append(s), o.append(a), s;
}
class HO extends $r {
  constructor(e, t, i) {
    super(e, "groupedColumnTooltip"), this.columnData = [2, 3, 4];
    const { root: r, columnData: n, size: s, padding: a } = this;
    this.columns = Tf({
      stacked: !1,
      root: r,
      data: n,
      size: s,
      padding: a,
      xScaleDomain: [0, 1, 2],
      yScaleDomain: [0, 4],
      xScalePadding: 0.3
    }), r.append(this.columns), this.updateColors(t, i);
  }
  updateColors(e, t) {
    this.columns.forEach((i, r) => {
      i.fill = e[r], i.stroke = t[r];
    });
  }
}
HO.chartType = "groupedColumn";
class Vu extends $r {
  constructor(e, t, i, r = Vu.data, n = [0, 16], s = "stackedColumnTooltip") {
    super(e, s);
    const { root: a, size: l, padding: c } = this;
    this.stackedColumns = Tf({
      stacked: !0,
      root: a,
      data: r,
      size: l,
      padding: c,
      xScaleDomain: [0, 1, 2],
      yScaleDomain: n,
      xScalePadding: 0.3
    }), a.append([].concat.apply([], this.stackedColumns)), this.updateColors(t, i);
  }
  updateColors(e, t) {
    this.stackedColumns.forEach((i, r) => i.forEach((n) => {
      n.fill = e[r], n.stroke = t[r];
    }));
  }
}
Vu.chartType = "stackedColumn";
Vu.data = [
  [8, 12, 16],
  [6, 9, 12],
  [2, 3, 4]
];
class xf extends Vu {
  constructor(e, t, i) {
    super(e, t, i, xf.data, [0, 10], "normalizedColumnTooltip");
  }
}
xf.chartType = "normalizedColumn";
xf.data = [
  [10, 10, 10],
  [6, 7, 8],
  [2, 4, 6]
];
class WO extends $r {
  constructor(e, t, i) {
    super(e, "groupedBarTooltip");
    const r = this.padding, n = this.size, s = [2, 3, 4], a = new $n();
    a.domain = [0, 1, 2], a.range = [r, n - r], a.paddingInner = 0.3, a.paddingOuter = 0.3;
    const l = new ri();
    l.domain = [0, 4], l.range = [n - r, r];
    const c = l.convert(0), d = a.bandwidth;
    this.bars = s.map((u, h) => {
      const p = new kn();
      return p.x = r, p.y = a.convert(h), p.width = c - l.convert(u), p.height = d, p.strokeWidth = 1, p.crisp = !0, p;
    }), this.updateColors(t, i), this.root.append(this.bars);
  }
  updateColors(e, t) {
    this.bars.forEach((i, r) => {
      i.fill = e[r], i.stroke = t[r];
    });
  }
}
WO.chartType = "groupedBar";
class Bu extends $r {
  constructor(e, t, i, r = Bu.data, n = [0, 16], s = "stackedBarTooltip") {
    super(e, s);
    const a = this.size, l = this.padding, c = new $n();
    c.domain = [0, 1, 2], c.range = [l, a - l], c.paddingInner = 0.3, c.paddingOuter = 0.3;
    const d = new ri();
    d.domain = n, d.range = [a - l, l];
    const u = d.convert(0), h = c.bandwidth;
    this.bars = r.map((p) => p.map((f, g) => {
      const v = new kn();
      return v.x = l, v.y = c.convert(g), v.width = u - d.convert(f), v.height = h, v.strokeWidth = 1, v.crisp = !0, v;
    })), this.updateColors(t, i), this.root.append([].concat.apply([], this.bars));
  }
  updateColors(e, t) {
    this.bars.forEach((i, r) => i.forEach((n) => {
      n.fill = e[r], n.stroke = t[r];
    }));
  }
}
Bu.chartType = "stackedBar";
Bu.data = [
  [8, 12, 16],
  [6, 9, 12],
  [2, 3, 4]
];
class Df extends Bu {
  constructor(e, t, i) {
    super(e, t, i, Df.data, [0, 10], "normalizedBarTooltip");
  }
}
Df.chartType = "normalizedBar";
Df.data = [
  [10, 10, 10],
  [6, 7, 8],
  [2, 4, 6]
];
const Jr = xr;
class bw extends Rf {
  constructor(e, t, i, r = 0.6, n = "doughnutTooltip") {
    super(e, n);
    const s = (this.size - this.padding * 2) / 2, a = s + this.padding, l = [
      [Jr(-90), Jr(30)],
      [Jr(30), Jr(120)],
      [Jr(120), Jr(180)],
      [Jr(180), Jr(210)],
      [Jr(210), Jr(240)],
      [Jr(240), Jr(270)]
    ];
    this.sectors = l.map(([c, d]) => {
      const u = new ZD();
      return u.centerX = a, u.centerY = a, u.innerRadius = s * r, u.outerRadius = s, u.startAngle = c, u.endAngle = d, u.stroke = void 0, u.strokeWidth = 1, u;
    }), this.updateColors(t, i), this.root.append(this.sectors);
  }
  updateColors(e, t) {
    this.sectors.forEach((i, r) => {
      i.fill = e[r % e.length], i.stroke = t[r % t.length];
    });
  }
}
bw.chartType = "doughnut";
class jO extends bw {
  constructor(e, t, i) {
    super(e, t, i, 0, "pieTooltip");
  }
}
jO.chartType = "pie";
class UO extends $r {
  constructor(e, t, i) {
    super(e, "lineTooltip"), this.data = [
      [9, 7, 8, 5, 6],
      [5, 6, 3, 4, 1],
      [1, 3, 4, 8, 7]
    ], this.lines = Sw(this.root, this.data, this.size, this.padding), this.updateColors(t, i);
  }
  updateColors(e, t) {
    this.lines.forEach((i, r) => {
      i.stroke = e[r];
    });
  }
}
UO.chartType = "line";
class $O extends $r {
  constructor(e, t, i) {
    super(e, "scatterTooltip");
    const r = this.size, n = this.padding, s = [
      [[0.3, 3], [1.1, 0.9], [2, 0.4], [3.4, 2.4]],
      [[0, 0.3], [1, 2], [2.4, 1.4], [3, 0]]
    ], a = new ri();
    a.domain = [-0.5, 4], a.range = [n * 2, r - n];
    const l = new ri();
    l.domain = [-0.5, 3.5], l.range = [r - n, n];
    const c = [];
    s.forEach((u) => {
      u.forEach(([h, p]) => {
        const f = new _O();
        f.strokeWidth = 1, f.centerX = a.convert(h), f.centerY = l.convert(p), f.radius = 2.5, c.push(f);
      });
    }), this.points = c, this.updateColors(t, i);
    const d = new we();
    d.setClipRectInGroupCoordinateSpace(new nt(n, n, r - n * 2, r - n * 2)), d.append(this.points), this.root.append(d);
  }
  updateColors(e, t) {
    this.points.forEach((i, r) => {
      i.stroke = t[r % t.length], i.fill = e[r % e.length];
    });
  }
}
$O.chartType = "scatter";
class zO extends $r {
  constructor(e, t, i) {
    super(e, "bubbleTooltip");
    const r = this.size, n = this.padding, s = [
      [[0.1, 0.3, 5], [0.5, 0.4, 7], [0.2, 0.8, 7]],
      [[0.8, 0.7, 5], [0.7, 0.3, 9]]
    ], a = new ri();
    a.domain = [0, 1], a.range = [n * 2, r - n];
    const l = new ri();
    l.domain = [0, 1], l.range = [r - n, n];
    const c = [];
    s.forEach((u) => {
      u.forEach(([h, p, f]) => {
        const g = new _O();
        g.strokeWidth = 1, g.centerX = a.convert(h), g.centerY = l.convert(p), g.radius = f, g.fillOpacity = 0.7, c.push(g);
      });
    }), this.points = c, this.updateColors(t, i);
    const d = new we();
    d.setClipRectInGroupCoordinateSpace(new nt(n, n, r - n * 2, r - n * 2)), d.append(this.points), this.root.append(d);
  }
  updateColors(e, t) {
    this.points.forEach((i, r) => {
      i.stroke = t[r % t.length], i.fill = e[r % e.length];
    });
  }
}
zO.chartType = "bubble";
class Of extends $r {
  constructor(e, t, i, r = Of.data) {
    super(e, "groupedAreaTooltip");
    const n = this.size, s = this.padding, a = new $n();
    a.domain = [0, 1, 2], a.paddingInner = 1, a.paddingOuter = 0, a.range = [s + 0.5, n - s - 0.5];
    const l = new ri();
    l.domain = [0, 6], l.range = [n - s + 0.5, s];
    const d = r.length * 2 - 1, u = [], h = l.convert(0);
    r.forEach((p, f) => {
      const g = a.convert(f);
      p.forEach((v, y) => {
        const m = l.convert(v), C = u[y] || (u[y] = []);
        C[f] = {
          x: g,
          y: m
        }, C[d - f] = {
          x: g,
          y: h
        };
      });
    }), this.areas = u.reverse().map((p) => {
      const f = new Zi();
      f.strokeWidth = 1, f.fillOpacity = 0.7;
      const g = f.path;
      return g.clear(), p.forEach((v, y) => g[y > 0 ? "lineTo" : "moveTo"](v.x, v.y)), g.closePath(), f;
    }), this.updateColors(t, i), this.root.append(this.areas);
  }
  updateColors(e, t) {
    this.areas.forEach((i, r) => {
      i.fill = e[r], i.stroke = t[r];
    });
  }
}
Of.chartType = "area";
Of.data = [
  [1, 3, 5],
  [2, 6, 4],
  [5, 3, 1]
];
class xc extends $r {
  constructor(e, t, i, r = xc.data, n = "stackedAreaTooltip") {
    super(e, n);
    const s = this.size, a = this.padding, l = new $n();
    l.domain = [0, 1, 2], l.paddingInner = 1, l.paddingOuter = 0, l.range = [a + 0.5, s - a - 0.5];
    const c = new ri();
    c.domain = [0, 16], c.range = [s - a + 0.5, a + 0.5];
    const u = r.length * 2 - 1, h = [];
    r.forEach((p, f) => {
      const g = l.convert(f);
      let v = 0;
      p.forEach((y, m) => {
        const C = c.convert(v + y), R = h[m] || (h[m] = []);
        R[f] = {
          x: g,
          y: C
        }, R[u - f] = {
          x: g,
          y: c.convert(v)
          // bottom y
        }, v += y;
      });
    }), this.areas = h.map((p) => {
      const f = new Zi();
      f.strokeWidth = 1;
      const g = f.path;
      return g.clear(), p.forEach((v, y) => g[y > 0 ? "lineTo" : "moveTo"](v.x, v.y)), g.closePath(), f;
    }), this.updateColors(t, i), this.root.append(this.areas);
  }
  updateColors(e, t) {
    this.areas.forEach((i, r) => {
      i.fill = e[r], i.stroke = t[r];
    });
  }
}
xc.chartType = "stackedArea";
xc.data = [
  [2, 3, 2],
  [3, 6, 5],
  [6, 2, 2]
];
class Pf extends xc {
  constructor(e, t, i, r = Pf.data) {
    super(e, t, i, r, "normalizedAreaTooltip");
  }
}
Pf.chartType = "normalizedArea";
Pf.data = xc.data.map((o) => {
  const e = o.reduce((t, i) => t + i, 0);
  return o.map((t) => t / e * 16);
});
class KO extends $r {
  constructor(e, t, i) {
    super(e, "histogramTooltip");
    const r = this.padding, n = this.size, s = [2, 5, 11, 13, 10, 6, 1], a = new ri();
    a.domain = [0, s.length], a.range = [r, n - r];
    const l = new ri();
    l.domain = [0, s.reduce((d, u) => Math.max(d, u), 0)], l.range = [n - r, r];
    const c = l.convert(0);
    this.bars = s.map((d, u) => {
      const h = l.convert(d), p = a.convert(u), f = a.convert(u + 1), g = new kn();
      return g.x = p, g.y = h, g.width = f - p, g.height = c - h, g.strokeWidth = 1, g.crisp = !0, g;
    }), this.updateColors(t, i), this.root.append(this.bars);
  }
  updateColors([e], [t]) {
    this.bars.forEach((i) => {
      i.fill = e, i.stroke = t;
    });
  }
}
KO.chartType = "histogram";
class YO extends $r {
  constructor(e, t, i) {
    super(e, "columnLineComboTooltip"), this.columnData = [3, 4], this.lineData = [
      [5, 4, 6, 5, 4]
    ];
    const { root: r, columnData: n, lineData: s, size: a, padding: l } = this;
    this.columns = Tf({
      stacked: !1,
      root: r,
      data: n,
      size: a,
      padding: l,
      xScaleDomain: [0, 1],
      yScaleDomain: [0, 4],
      xScalePadding: 0.5
    }), r.append(this.columns), this.lines = Sw(r, s, a, l), this.updateColors(t, i);
  }
  updateColors(e, t) {
    this.columns.forEach((i, r) => {
      i.fill = e[r], i.stroke = t[r];
    }), this.lines.forEach((i, r) => {
      i.stroke = e[r + 2];
    });
  }
}
YO.chartType = "columnLineCombo";
class XO extends $r {
  constructor(e, t, i) {
    super(e, "areaColumnComboTooltip"), this.columnData = [3, 4.5], this.areaData = [
      [5, 4, 6, 5, 4]
    ];
    const { root: r, columnData: n, areaData: s, size: a, padding: l } = this;
    this.columns = Tf({
      stacked: !1,
      root: r,
      data: n,
      size: a,
      padding: l,
      xScaleDomain: [0, 1],
      yScaleDomain: [0, 6],
      xScalePadding: 0.5
    });
    const c = new $n();
    c.range = [l, a - l], c.domain = [0, 1, 2, 3, 4], c.paddingInner = 1, c.paddingOuter = 0;
    const d = new ri();
    d.range = [a - l, l], d.domain = [0, 6];
    const u = [], h = d.convert(0), p = c.convert(0);
    s.forEach((f, g) => {
      const v = u[g] || (u[g] = []);
      f.forEach((m, C) => {
        const R = m, E = C, b = c.convert(E), T = d.convert(R);
        v[C] = { x: b, y: T };
      });
      const y = c.convert(f.length - 1);
      u[g].push({
        x: y,
        y: h
      }, {
        x: p,
        y: h
      });
    }), this.areas = u.map((f) => {
      const g = new Zi();
      g.strokeWidth = 1, g.fillOpacity = 0.8;
      const v = g.path;
      return f.forEach((y, m) => v[m > 0 ? "lineTo" : "moveTo"](y.x, y.y)), g;
    }), r.append(this.areas), r.append([].concat.apply([], this.columns)), this.updateColors(t, i);
  }
  updateColors(e, t) {
    this.areas.forEach((i, r) => {
      i.fill = e[r], i.stroke = t[r];
    }), this.columns.forEach((i, r) => {
      i.fill = e[r + 1], i.stroke = t[r + 1];
    });
  }
}
XO.chartType = "areaColumnCombo";
class qO extends Rf {
  constructor(e, t, i) {
    super(e, "customComboTooltip"), this.columnData = [3, 4], this.lineData = [[5, 4, 6, 5, 4]];
    const { root: r, columnData: n, lineData: s, size: a, padding: l } = this;
    this.columns = Tf({
      stacked: !1,
      root: r,
      data: n,
      size: a,
      padding: l,
      xScaleDomain: [0, 1],
      yScaleDomain: [0, 4],
      xScalePadding: 0.5
    }), r.append(this.columns), this.lines = Sw(r, s, a, l);
    const c = "grey", d = 3, u = new Qt();
    u.x1 = l, u.y1 = l, u.x2 = l, u.y2 = a - l + d, u.stroke = c;
    const h = new Qt();
    h.x1 = l - d + 1, h.y1 = a - l, h.x2 = a - l + 1, h.y2 = a - l, h.stroke = c;
    const p = new Zi();
    this.buildPenIconPath(p), p.fill = "whitesmoke", p.stroke = "darkslategrey", p.strokeWidth = 1, r.append([h, u, p]), this.updateColors(t, i);
  }
  updateColors(e, t) {
    this.columns.forEach((i, r) => {
      i.fill = e[r], i.stroke = t[r];
    }), this.lines.forEach((i, r) => {
      i.stroke = e[r + 2];
    });
  }
  buildPenIconPath(e) {
    const { path: t } = e;
    t.moveTo(25.76, 43.46), t.lineTo(31.27, 48.53), t.moveTo(49.86, 22), t.lineTo(49.86, 22), t.cubicCurveTo(49.01994659053345, 21.317514933510974, 47.89593834348529, 21.09645997825817, 46.86, 21.41), t.lineTo(46.86, 21.41), t.cubicCurveTo(45.55460035985361, 21.77260167850787, 44.38777081121966, 22.517979360321792, 43.51, 23.55), t.lineTo(25.51, 43.8), t.lineTo(25.43, 43.89), t.lineTo(23.01, 51.89), t.lineTo(22.83, 52.46), t.lineTo(31.02, 48.86), t.lineTo(49.02, 28.52), t.lineTo(49.02, 28.52), t.cubicCurveTo(49.940716461596224, 27.521914221246085, 50.54302631059587, 26.2720342455763, 50.75, 24.93), t.lineTo(50.75, 24.93), t.cubicCurveTo(50.95363374988308, 23.866379846512814, 50.62080640232334, 22.77066734274871, 49.86, 22), t.closePath(), t.moveTo(41.76, 25.5), t.lineTo(47.34, 30.5), t.moveTo(40.74, 26.65), t.lineTo(46.25, 31.71);
  }
}
qO.chartType = "customCombo";
var ZO = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const UE = {
  columnGroup: {
    column: HO,
    stackedColumn: Vu,
    normalizedColumn: xf
  },
  barGroup: {
    bar: WO,
    stackedBar: Bu,
    normalizedBar: Df
  },
  pieGroup: {
    pie: jO,
    doughnut: bw
  },
  lineGroup: {
    line: UO
  },
  scatterGroup: {
    scatter: $O,
    bubble: zO
  },
  areaGroup: {
    area: Of,
    stackedArea: xc,
    normalizedArea: Pf
  },
  histogramGroup: {
    histogram: KO
  },
  combinationGroup: {
    columnLineCombo: YO,
    areaColumnCombo: XO,
    customCombo: qO
  }
};
class Hu extends X {
  constructor(e, t, i, r = eG) {
    super(Hu.TEMPLATE), this.wrappers = {}, this.chartController = e, this.fills = t, this.strokes = i, this.chartGroups = Object.assign({}, r);
  }
  init() {
    !this.chartController.customComboExists() && this.chartGroups.combinationGroup && (this.chartGroups.combinationGroup = this.chartGroups.combinationGroup.filter((t) => t !== "customCombo"));
    const e = this.getGui();
    Object.keys(this.chartGroups).forEach((t) => {
      const i = this.chartGroups[t], r = this.createBean(new Tt({
        title: this.chartTranslationService.translate(t),
        suppressEnabledCheckbox: !0,
        enabled: !0,
        suppressOpenCloseIcons: !0,
        cssIdentifier: "charts-settings",
        direction: "horizontal"
      }));
      i.forEach((n) => {
        var s;
        const a = (s = UE[t]) === null || s === void 0 ? void 0 : s[n];
        if (!a) {
          UE[t] ? x.doOnce(() => console.warn(`AG Grid - invalid chartGroupsDef config '${t}.${n}'`), `invalid_chartGroupsDef${n}_${t}`) : x.doOnce(() => console.warn(`AG Grid - invalid chartGroupsDef config '${t}'`), `invalid_chartGroupsDef${t}`);
          return;
        }
        const l = document.createElement("div");
        l.classList.add("ag-chart-mini-thumbnail");
        const c = a.chartType;
        this.addManagedListener(l, "click", () => {
          this.chartController.setChartType(c), this.updateSelectedMiniChart();
        }), this.wrappers[c] = l, this.createBean(new a(l, this.fills, this.strokes)), r.addItem(l);
      }), e.appendChild(r.getGui());
    }), this.updateSelectedMiniChart();
  }
  updateSelectedMiniChart() {
    const e = this.chartController.getChartType();
    for (const t in this.wrappers) {
      const i = this.wrappers[t], r = t === e;
      i.classList.toggle("ag-selected", r);
    }
  }
}
Hu.TEMPLATE = '<div class="ag-chart-settings-mini-wrapper"></div>';
ZO([
  S("chartTranslationService")
], Hu.prototype, "chartTranslationService", void 0);
ZO([
  B
], Hu.prototype, "init", null);
var Dc = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class eo extends X {
  constructor(e) {
    super(eo.TEMPLATE), this.miniChartsContainers = [], this.cardItems = [], this.activePaletteIndex = 0, this.palettes = [], this.themes = [], this.chartController = e;
  }
  postConstruct() {
    this.resetPalettes(), this.ePrevBtn.insertAdjacentElement("afterbegin", x.createIconNoSpan("previous", this.gridOptionsService)), this.eNextBtn.insertAdjacentElement("afterbegin", x.createIconNoSpan("next", this.gridOptionsService)), this.addManagedListener(this.ePrevBtn, "click", () => this.setActivePalette(this.getPrev(), "left")), this.addManagedListener(this.eNextBtn, "click", () => this.setActivePalette(this.getNext(), "right")), this.addManagedListener(this.chartController, Rt.EVENT_CHART_TYPE_CHANGED, () => this.resetPalettes(!0)), this.addManagedListener(this.chartController, Rt.EVENT_CHART_API_UPDATE, () => this.resetPalettes(!0)), this.scrollSelectedIntoView();
  }
  scrollSelectedIntoView() {
    setTimeout(() => {
      const e = (r) => !r.getGui().classList.contains("ag-hidden"), i = this.miniChartsContainers.find(e).getGui().querySelector(".ag-selected");
      if (i) {
        const r = i.offsetParent;
        r && this.eMiniChartsContainer.scrollTo(0, r.offsetTop);
      }
    }, 250);
  }
  resetPalettes(e) {
    var t, i;
    const r = this.chartController.getPalettes(), n = (i = (t = this.gridOptionsService.get("chartToolPanelsDef")) === null || t === void 0 ? void 0 : t.settingsPanel) === null || i === void 0 ? void 0 : i.chartGroupsDef;
    x.shallowCompare(r, this.palettes) && !e || this.isAnimating || (this.palettes = r, this.themes = this.chartController.getThemes(), this.activePaletteIndex = this.themes.findIndex((s) => s === this.chartController.getChartThemeName()), this.cardItems = [], x.clearElement(this.eCardSelector), this.destroyMiniCharts(), this.palettes.forEach((s, a) => {
      const l = this.activePaletteIndex === a, { fills: c, strokes: d } = s, u = this.createBean(new Hu(this.chartController, c, d, n));
      this.miniChartsContainers.push(u), this.eMiniChartsContainer.appendChild(u.getGui()), this.addCardLink(a), l ? u.updateSelectedMiniChart() : u.setDisplayed(!1);
    }), x.setDisplayed(this.eNavBar, this.palettes.length > 1), x.radioCssClass(this.cardItems[this.activePaletteIndex], "ag-selected", "ag-not-selected"));
  }
  addCardLink(e) {
    const t = document.createElement("div");
    t.classList.add("ag-chart-settings-card-item"), this.addManagedListener(t, "click", () => {
      this.setActivePalette(e, e < this.activePaletteIndex ? "left" : "right");
    }), this.eCardSelector.appendChild(t), this.cardItems.push(t);
  }
  getPrev() {
    let e = this.activePaletteIndex - 1;
    return e < 0 && (e = this.palettes.length - 1), e;
  }
  getNext() {
    let e = this.activePaletteIndex + 1;
    return e >= this.palettes.length && (e = 0), e;
  }
  setActivePalette(e, t) {
    if (this.isAnimating || this.activePaletteIndex === e)
      return;
    x.radioCssClass(this.cardItems[e], "ag-selected", "ag-not-selected");
    const i = this.miniChartsContainers[this.activePaletteIndex], r = i.getGui(), n = this.miniChartsContainers[e], s = n.getGui();
    i.updateSelectedMiniChart(), n.updateSelectedMiniChart();
    const a = t === "left" ? -1 : 1, l = s.style.left = `${x.getAbsoluteWidth(this.getGui()) * a}px`;
    this.activePaletteIndex = e, this.isAnimating = !0;
    const c = "ag-animating";
    n.setDisplayed(!0), i.addCssClass(c), n.addCssClass(c), this.chartController.setChartThemeName(this.themes[e]), window.setTimeout(() => {
      r.style.left = `${-parseFloat(l)}px`, s.style.left = "0px";
    }, 0), window.setTimeout(() => {
      this.isAnimating = !1, i.removeCssClass(c), n.removeCssClass(c), i.setDisplayed(!1);
    }, 300);
  }
  destroyMiniCharts() {
    x.clearElement(this.eMiniChartsContainer), this.miniChartsContainers = this.destroyBeans(this.miniChartsContainers);
  }
  destroy() {
    this.destroyMiniCharts(), super.destroy();
  }
}
eo.TEMPLATE = `<div class="ag-chart-settings-wrapper">
            <div ref="eMiniChartsContainer" class="ag-chart-settings-mini-charts-container ag-scrollable-container"></div>
            <div ref="eNavBar" class="ag-chart-settings-nav-bar">
                <div ref="ePrevBtn" class="ag-chart-settings-prev">
                    <button type="button" class="ag-button ag-chart-settings-prev-button"></button>
                </div>
                <div ref="eCardSelector" class="ag-chart-settings-card-selector"></div>
                <div ref="eNextBtn" class="ag-chart-settings-next">
                    <button type="button" class="ag-button ag-chart-settings-next-button"></button>
                </div>
            </div>
        </div>`;
Dc([
  S("resizeObserverService")
], eo.prototype, "resizeObserverService", void 0);
Dc([
  L("eMiniChartsContainer")
], eo.prototype, "eMiniChartsContainer", void 0);
Dc([
  L("eNavBar")
], eo.prototype, "eNavBar", void 0);
Dc([
  L("eCardSelector")
], eo.prototype, "eCardSelector", void 0);
Dc([
  L("ePrevBtn")
], eo.prototype, "ePrevBtn", void 0);
Dc([
  L("eNextBtn")
], eo.prototype, "eNextBtn", void 0);
Dc([
  B
], eo.prototype, "postConstruct", null);
var QO = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Ea extends X {
  constructor(e) {
    super(), this.tabs = [];
    const { controller: t, panels: i, chartOptionsService: r } = e;
    this.chartController = t, this.chartOptionsService = r, this.panels = i;
  }
  init() {
    this.panels.forEach((e) => {
      const t = e.replace("chart", "").toLowerCase(), { comp: i, tab: r } = this.createTab(e, t, this.getPanelClass(t));
      this.tabs.push(r), this.addDestroyFunc(() => this.destroyBean(i));
    }), this.tabbedLayout = new Ba({
      items: this.tabs,
      cssClass: "ag-chart-tabbed-menu",
      keepScrollPosition: !0
    }), this.getContext().createBean(this.tabbedLayout);
  }
  createTab(e, t, i) {
    const r = document.createElement("div");
    r.classList.add("ag-chart-tab", `ag-chart-${t}`);
    const n = new i(this.chartController, this.chartOptionsService);
    this.getContext().createBean(n), r.appendChild(n.getGui());
    const s = document.createElement("div"), a = this.chartTranslationService.translate(t);
    return s.innerText = a, {
      comp: n,
      tab: {
        title: s,
        titleLabel: a,
        bodyPromise: Qe.resolve(r),
        getScrollableContainer: () => r.querySelector(".ag-scrollable-container") || r,
        name: e
      }
    };
  }
  showTab(e) {
    const t = this.tabs[e];
    this.tabbedLayout.showItem(t);
  }
  getGui() {
    return this.tabbedLayout && this.tabbedLayout.getGui();
  }
  destroy() {
    this.parentComponent && this.parentComponent.isAlive() && this.destroyBean(this.parentComponent), super.destroy();
  }
  getPanelClass(e) {
    switch (e) {
      case Ea.TAB_DATA:
        return Cc;
      case Ea.TAB_FORMAT:
        return Ef;
      default:
        return eo;
    }
  }
}
Ea.TAB_DATA = "data";
Ea.TAB_FORMAT = "format";
QO([
  S("chartTranslationService")
], Ea.prototype, "chartTranslationService", void 0);
QO([
  B
], Ea.prototype, "init", null);
var Af = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class mn extends X {
  constructor(e, t, i, r) {
    super(mn.TEMPLATE), this.eChartContainer = e, this.eMenuPanelContainer = t, this.chartController = i, this.chartOptionsService = r, this.buttons = {
      chartSettings: ["menu", () => this.showMenu(this.defaultPanel)],
      chartData: ["menu", () => this.showMenu("chartData")],
      chartFormat: ["menu", () => this.showMenu("chartFormat")],
      chartLink: ["linked", (n) => this.toggleDetached(n)],
      chartUnlink: ["unlinked", (n) => this.toggleDetached(n)],
      chartDownload: ["save", () => this.saveChart()]
    }, this.panels = [], this.buttonListenersDestroyFuncs = [], this.menuVisible = !1;
  }
  postConstruct() {
    this.createButtons(), this.addManagedListener(this.eventService, w.EVENT_CHART_CREATED, (e) => {
      var t;
      e.chartId === this.chartController.getChartId() && (!((t = this.gridOptionsService.get("chartToolPanelsDef")) === null || t === void 0) && t.defaultToolPanel) && this.showMenu(this.defaultPanel, !1);
    }), this.refreshMenuClasses(), !this.gridOptionsService.is("suppressChartToolPanelsButton") && this.panels.length > 0 && (this.getGui().classList.add("ag-chart-tool-panel-button-enable"), this.addManagedListener(this.eHideButton, "click", this.toggleMenu.bind(this))), this.addManagedListener(this.chartController, Rt.EVENT_CHART_API_UPDATE, this.createButtons.bind(this));
  }
  isVisible() {
    return this.menuVisible;
  }
  getExtraPaddingDirections() {
    const e = ["chartLink", "chartUnlink", "chartDownload"], t = ["chartSettings", "chartData", "chartFormat"], i = [];
    return e.some((r) => this.chartToolbarOptions.includes(r)) && i.push("top"), t.some((r) => this.chartToolbarOptions.includes(r)) && i.push(this.gridOptionsService.is("enableRtl") ? "left" : "right"), i;
  }
  getToolbarOptions() {
    var e, t, i;
    if (!!this.gridOptionsService.get("chartToolPanelsDef")) {
      const n = [
        this.chartController.isChartLinked() ? "chartLink" : "chartUnlink",
        "chartDownload"
      ], s = this.gridOptionsService.getCallback("getChartToolbarItems");
      let l = s ? s({
        defaultItems: n
      }).filter((u) => {
        if (!o0.includes(u)) {
          const h = Oy.includes(u) ? `AG Grid: '${u}' is a Chart Tool Panel option and will be ignored since 'chartToolPanelsDef' is used. Please use 'chartToolPanelsDef.panels' grid option instead` : `AG Grid: '${u}' is not a valid Chart Toolbar Option`;
          return console.warn(h), !1;
        }
        return !0;
      }) : n;
      const c = (t = (e = this.gridOptionsService.get("chartToolPanelsDef")) === null || e === void 0 ? void 0 : e.panels) === null || t === void 0 ? void 0 : t.map((u) => {
        const h = fg[u];
        return h || console.warn(`AG Grid - invalid panel in chartToolPanelsDef.panels: '${u}'`), h;
      }).filter((u) => !!u);
      this.panels = c || Object.values(fg), this.chartController.isPivotChart() && (this.panels = this.panels.filter((u) => u !== "chartData"));
      const d = (i = this.gridOptionsService.get("chartToolPanelsDef")) === null || i === void 0 ? void 0 : i.defaultToolPanel;
      return this.defaultPanel = d && fg[d] || this.panels[0], this.panels.length > 0 ? [this.panels[0], ...l] : l;
    } else {
      let n = [
        "chartSettings",
        "chartData",
        "chartFormat",
        this.chartController.isChartLinked() ? "chartLink" : "chartUnlink",
        "chartDownload"
      ];
      const s = this.gridOptionsService.getCallback("getChartToolbarItems");
      if (s) {
        const l = this.gridOptionsService.is("suppressChartToolPanelsButton");
        n = s({
          defaultItems: l ? n : o0
        }).filter((d) => {
          if (this.buttons[d]) {
            if (!l && Oy.includes(d)) {
              const u = `AG Grid: '${d}' is a Chart Tool Panel option and will be ignored. Please use 'chartToolPanelsDef.panels' grid option instead`;
              return console.warn(u), !1;
            }
          } else
            return console.warn(`AG Grid: '${d}' is not a valid Chart Toolbar Option`), !1;
          return !0;
        }), l || (n = n.concat(Oy));
      }
      this.chartController.isPivotChart() && (n = n.filter((l) => l !== "chartData"));
      const a = ["chartUnlink", "chartLink", "chartDownload"];
      return this.panels = n.filter((l) => a.indexOf(l) === -1), this.defaultPanel = this.panels[0], n.filter((l) => a.indexOf(l) !== -1 || this.panels.length && l === this.panels[0]);
    }
  }
  toggleDetached(e) {
    const t = e.target, i = t.classList.contains("ag-icon-linked");
    t.classList.toggle("ag-icon-linked", !i), t.classList.toggle("ag-icon-unlinked", i);
    const r = i ? "chartUnlinkToolbarTooltip" : "chartLinkToolbarTooltip", n = this.chartTranslationService.translate(r);
    n && (t.title = n), this.chartController.detachChartRange();
  }
  createButtons() {
    this.buttonListenersDestroyFuncs.forEach((t) => t()), this.buttonListenersDestroyFuncs = [], this.chartToolbarOptions = this.getToolbarOptions();
    const e = this.eMenu;
    x.clearElement(e), this.chartToolbarOptions.forEach((t) => {
      const i = this.buttons[t], [r, n] = i, s = x.createIconNoSpan(r, this.gridOptionsService, void 0, !0);
      s.classList.add("ag-chart-menu-icon");
      const a = this.chartTranslationService.translate(t + "ToolbarTooltip");
      a && s instanceof HTMLElement && (s.title = a), this.buttonListenersDestroyFuncs.push(this.addManagedListener(s, "click", n)), e.appendChild(s);
    });
  }
  saveChart() {
    const e = { type: mn.EVENT_DOWNLOAD_CHART };
    this.dispatchEvent(e);
  }
  createMenuPanel(e) {
    const t = this.environment.chartMenuPanelWidth(), i = this.menuPanel = this.createBean(new gn({
      minWidth: t,
      width: t,
      height: "100%",
      closable: !0,
      hideTitleBar: !0,
      cssIdentifier: "chart-menu"
    }));
    return i.setParentComponent(this), this.eMenuPanelContainer.appendChild(i.getGui()), this.tabbedMenu = this.createBean(new Ea({
      controller: this.chartController,
      type: this.chartController.getChartType(),
      panels: this.panels,
      chartOptionsService: this.chartOptionsService
    })), this.addManagedListener(i, X.EVENT_DESTROYED, () => this.destroyBean(this.tabbedMenu)), new Qe((r) => {
      window.setTimeout(() => {
        i.setBodyComponent(this.tabbedMenu), this.tabbedMenu.showTab(e), r(i), this.addManagedListener(this.eChartContainer, "click", (n) => {
          this.getGui().contains(n.target) || this.menuVisible && this.hideMenu();
        });
      }, 100);
    });
  }
  showContainer() {
    this.menuPanel && (this.menuVisible = !0, this.showParent(this.menuPanel.getWidth()), this.refreshMenuClasses());
  }
  toggleMenu() {
    this.menuVisible ? this.hideMenu() : this.showMenu();
  }
  showMenu(e, t = !0) {
    if (t || this.eMenuPanelContainer.classList.add("ag-no-transition"), this.menuPanel && !e)
      this.showContainer();
    else {
      const i = e || this.defaultPanel;
      let r = this.panels.indexOf(i);
      r < 0 && (console.warn(`AG Grid: '${e}' is not a valid Chart Tool Panel name`), r = this.panels.indexOf(this.defaultPanel)), this.menuPanel ? (this.tabbedMenu.showTab(r), this.showContainer()) : this.createMenuPanel(r).then(this.showContainer.bind(this));
    }
    t || setTimeout(() => {
      this.isAlive() && this.eMenuPanelContainer.classList.remove("ag-no-transition");
    }, 500);
  }
  hideMenu() {
    this.hideParent(), window.setTimeout(() => {
      this.menuVisible = !1, this.refreshMenuClasses();
    }, 500);
  }
  refreshMenuClasses() {
    this.eChartContainer.classList.toggle("ag-chart-menu-visible", this.menuVisible), this.eChartContainer.classList.toggle("ag-chart-menu-hidden", !this.menuVisible), this.gridOptionsService.is("suppressChartToolPanelsButton") || (this.eHideButtonIcon.classList.toggle("ag-icon-contracted", this.menuVisible), this.eHideButtonIcon.classList.toggle("ag-icon-expanded", !this.menuVisible));
  }
  showParent(e) {
    this.eMenuPanelContainer.style.minWidth = `${e}px`;
  }
  hideParent() {
    this.eMenuPanelContainer.style.minWidth = "0";
  }
  destroy() {
    super.destroy(), this.menuPanel && this.menuPanel.isAlive() && this.destroyBean(this.menuPanel), this.tabbedMenu && this.tabbedMenu.isAlive() && this.destroyBean(this.tabbedMenu);
  }
}
mn.EVENT_DOWNLOAD_CHART = "downloadChart";
mn.TEMPLATE = `<div>
        <div class="ag-chart-menu" ref="eMenu"></div>
        <button class="ag-button ag-chart-menu-close" ref="eHideButton">
            <span class="ag-icon ag-icon-contracted" ref="eHideButtonIcon"></span>
        </button>
    </div>`;
Af([
  S("chartTranslationService")
], mn.prototype, "chartTranslationService", void 0);
Af([
  L("eMenu")
], mn.prototype, "eMenu", void 0);
Af([
  L("eHideButton")
], mn.prototype, "eHideButton", void 0);
Af([
  L("eHideButtonIcon")
], mn.prototype, "eHideButtonIcon", void 0);
Af([
  B
], mn.prototype, "postConstruct", null);
var JO = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Wu extends X {
  constructor(e) {
    super(Wu.TEMPLATE), this.chartMenu = e, this.destroyableChartListeners = [], this.editing = !1;
  }
  init() {
    this.addManagedListener(this.getGui(), "keydown", (e) => {
      this.editing && e.key === "Enter" && !e.shiftKey && (this.handleEndEditing(), e.preventDefault());
    }), this.addManagedListener(this.getGui(), "input", () => {
      this.editing && this.updateHeight();
    }), this.addManagedListener(this.getGui(), "blur", () => this.endEditing());
  }
  /* should be called when the containing component changes to a new chart proxy */
  refreshTitle(e, t) {
    this.chartController = e, this.chartOptionsService = t;
    for (const c of this.destroyableChartListeners)
      c();
    this.destroyableChartListeners = [];
    const r = this.chartController.getChartProxy().getChart(), n = r.scene.canvas.element, s = this.addManagedListener(n, "dblclick", (c) => {
      const { title: d } = r;
      if (d && d.node.containsPoint(c.offsetX, c.offsetY)) {
        const u = d.node.computeBBox(), h = d.node.inverseTransformPoint(u.x, u.y);
        this.startEditing(Object.assign(Object.assign({}, u), h), n.width);
      }
    });
    let a = !1;
    const l = this.addManagedListener(n, "mousemove", (c) => {
      const { title: d } = r, u = !!(d && d.enabled && d.node.containsPoint(c.offsetX, c.offsetY));
      a !== u && (n.style.cursor = u ? "pointer" : ""), a = u;
    });
    this.destroyableChartListeners = [
      s,
      l
    ];
  }
  startEditing(e, t) {
    if (this.chartMenu && this.chartMenu.isVisible() || this.editing)
      return;
    this.editing = !0;
    const i = 300, r = Math.max(Math.min(e.width + 20, t), i), n = this.getGui();
    n.classList.add("currently-editing");
    const s = n.style;
    s.fontFamily = this.chartOptionsService.getChartOption("title.fontFamily"), s.fontWeight = this.chartOptionsService.getChartOption("title.fontWeight"), s.fontStyle = this.chartOptionsService.getChartOption("title.fontStyle"), s.fontSize = this.chartOptionsService.getChartOption("title.fontSize") + "px", s.color = this.chartOptionsService.getChartOption("title.color");
    const a = this.chartOptionsService.getChartOption("title.text"), l = a === this.chartTranslationService.translate("titlePlaceholder");
    n.value = l ? "" : a;
    const c = a.split(/\r?\n/g).length;
    s.left = Math.round(e.x + e.width / 2 - r / 2 - 1) + "px", s.top = Math.round(e.y + e.height / 2 - c * this.getLineHeight() / 2 - 2) + "px", s.width = Math.round(r) + "px", s.lineHeight = this.getLineHeight() + "px", this.updateHeight(), n.focus();
  }
  updateHeight() {
    const e = this.getGui(), t = this.chartOptionsService.getChartOption("title.text").split(/\r?\n/g).length, i = e.value.split(/\r?\n/g).length;
    e.style.height = Math.round(Math.max(t, i) * this.getLineHeight()) + 4 + "px";
  }
  getLineHeight() {
    const e = this.chartOptionsService.getChartOption("title.lineHeight");
    return e ? parseInt(e) : Math.round(parseInt(this.chartOptionsService.getChartOption("title.fontSize")) * 1.2);
  }
  handleEndEditing() {
    const e = this.chartOptionsService.getChartOption("title.color"), t = "rgba(0, 0, 0, 0)";
    this.chartOptionsService.setChartOption("title.color", t), this.chartOptionsService.awaitChartOptionUpdate(() => this.endEditing()), this.chartOptionsService.awaitChartOptionUpdate(() => {
      this.chartOptionsService.setChartOption("title.color", e);
    });
  }
  endEditing() {
    if (!this.editing)
      return;
    this.editing = !1;
    const e = this.getGui().value;
    e && e.trim() !== "" ? (this.chartOptionsService.setChartOption("title.text", e), this.chartOptionsService.setChartOption("title.enabled", !0)) : (this.chartOptionsService.setChartOption("title.text", ""), this.chartOptionsService.setChartOption("title.enabled", !1)), this.getGui().classList.remove("currently-editing"), this.chartOptionsService.awaitChartOptionUpdate(() => {
      this.eventService.dispatchEvent({ type: "chartTitleEdit" });
    });
  }
}
Wu.TEMPLATE = `<textarea
             class="ag-chart-title-edit"
             style="padding:0; border:none; border-radius: 0; min-height: 0; text-align: center; resize: none;" />
        `;
JO([
  S("chartTranslationService")
], Wu.prototype, "chartTranslationService", void 0);
JO([
  B
], Wu.prototype, "init", null);
var ju = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Hs extends H {
  getData(e) {
    if (e.crossFiltering) {
      if (e.grouping)
        return console.warn("AG Grid: crossing filtering with row grouping is not supported."), { chartData: [], columnNames: {} };
      if (!this.gridOptionsService.isRowModelType("clientSide"))
        return console.warn("AG Grid: crossing filtering is only supported in the client side row model."), { chartData: [], columnNames: {} };
    }
    this.gridOptionsService.isRowModelType("serverSide") && e.pivoting && this.updatePivotKeysForSSRM();
    const i = this.extractRowsFromGridRowModel(e);
    return i.chartData = this.aggregateRowsByDimension(e, i.chartData), i;
  }
  extractRowsFromGridRowModel(e) {
    let t = [];
    const i = {}, r = {}, n = {};
    let s = {}, a = [], l;
    if (e.crossFiltering)
      s = this.getFilteredRowNodes(), a = this.getAllRowNodes(), l = a.length;
    else {
      const c = this.gridRowModel.getRowCount() - 1;
      l = (e.endRow >= 0 ? Math.min(e.endRow, c) : c) - e.startRow + 1;
    }
    for (let c = 0; c < l; c++) {
      const d = {}, u = e.crossFiltering ? a[c] : this.gridRowModel.getRow(c + e.startRow);
      e.dimensionCols.forEach((h) => {
        const p = h.colId, f = this.columnModel.getGridColumn(p);
        if (f) {
          const g = this.valueService.getValue(f, u);
          if (e.grouping) {
            const v = g && g.toString ? String(g.toString()) : "", y = Hs.getGroupLabels(u, v);
            d[p] = {
              labels: y,
              toString: function() {
                return this.labels.filter((C) => !!C).reverse().join(" - ");
              }
            }, u.group && (r[y.toString()] = c);
            const m = y.slice(1, y.length).toString();
            m && (n[m] = r[m]);
          } else
            d[p] = g;
        } else
          d[Io.DEFAULT_CATEGORY] = c + 1;
      }), e.valueCols.forEach((h) => {
        let p = [];
        const f = h.getColDef().pivotKeys;
        f && (p = f.slice());
        const g = h.getColDef().headerName;
        g && p.push(g), p.length > 0 && (i[h.getId()] = p);
        const v = h.getColId();
        if (e.crossFiltering) {
          const y = v + "-filtered-out", m = this.valueService.getValue(h, u), C = m != null && typeof m.toNumber == "function" ? m.toNumber() : m;
          s[u.id] ? (d[v] = C, d[y] = e.aggFunc || e.isScatter ? void 0 : 0) : (d[v] = e.aggFunc || e.isScatter ? void 0 : 0, d[y] = C);
        } else {
          let y = this.valueService.getValue(h, u);
          y && y.hasOwnProperty("toString") && (y = parseFloat(y.toString())), d[v] = y != null && typeof y.toNumber == "function" ? y.toNumber() : y;
        }
      }), u.footer && (d.footer = !0), t.push(d);
    }
    if (e.grouping) {
      const c = x.values(n), d = (u, h) => !u.footer && !x.includes(c, h);
      t = t.filter(d);
    }
    return { chartData: t, columnNames: i };
  }
  aggregateRowsByDimension(e, t) {
    const i = e.dimensionCols;
    if (!e.aggFunc || i.length === 0)
      return t;
    const r = x.last(i), n = r && r.colId, s = {}, a = [];
    return t.forEach((l) => {
      let c = s;
      i.forEach((d) => {
        const u = d.colId, h = l[u];
        if (u === n) {
          let p = c[h];
          p || (p = { __children: [] }, i.forEach((f) => {
            const g = f.colId;
            p[g] = l[g];
          }), c[h] = p, a.push(p)), p.__children.push(l);
        } else
          c[h] || (c[h] = {}), c = c[h];
      });
    }), Z.__assertRegistered(Q.RowGroupingModule, "Charting Aggregation", this.context.getGridId()) && a.forEach((l) => e.valueCols.forEach((c) => {
      if (e.crossFiltering)
        e.valueCols.forEach((d) => {
          const u = d.getColId(), h = l.__children.filter((y) => typeof y[u] != "undefined").map((y) => y[u]);
          let p = this.aggregationStage.aggregateValues(h, e.aggFunc);
          l[d.getId()] = p && typeof p.value != "undefined" ? p.value : p;
          const f = `${u}-filtered-out`, g = l.__children.filter((y) => typeof y[f] != "undefined").map((y) => y[f]);
          let v = this.aggregationStage.aggregateValues(g, e.aggFunc);
          l[f] = v && typeof v.value != "undefined" ? v.value : v;
        });
      else {
        const d = l.__children.map((h) => h[c.getId()]);
        let u = 0;
        Z.__assertRegistered(Q.RowGroupingModule, "Charting Aggregation", this.context.getGridId()) && (u = this.aggregationStage.aggregateValues(d, e.aggFunc)), l[c.getId()] = u && typeof u.value != "undefined" ? u.value : u;
      }
    })), a;
  }
  updatePivotKeysForSSRM() {
    const e = this.columnModel.getSecondaryColumns();
    if (!e)
      return;
    const t = this.extractPivotKeySeparator(e);
    e.forEach((i) => {
      if (t === "")
        i.getColDef().pivotKeys = [];
      else {
        const r = i.getColId().split(t);
        i.getColDef().pivotKeys = r.slice(0, r.length - 1);
      }
    });
  }
  extractPivotKeySeparator(e) {
    if (e.length === 0)
      return "";
    const t = (r, n) => {
      const s = r.getGroupId();
      return r.getParent() ? t(r.getParent(), s) : n.split(s)[1][0];
    }, i = e[0];
    return i.getParent() == null ? "" : t(i.getParent(), i.getColId());
  }
  static getGroupLabels(e, t) {
    const i = [t];
    for (; e && e.level !== 0; )
      e = e.parent, e && i.push(e.key);
    return i;
  }
  getFilteredRowNodes() {
    const e = {};
    return this.gridRowModel.forEachNodeAfterFilterAndSort((t) => {
      e[t.id] = t;
    }), e;
  }
  getAllRowNodes() {
    let e = [];
    return this.gridRowModel.forEachNode((t) => {
      e.push(t);
    }), this.sortRowNodes(e);
  }
  sortRowNodes(e) {
    const t = this.sortController.getSortOptions();
    return !t || t.length == 0 ? e : this.rowNodeSorter.doFullSort(e, t);
  }
}
ju([
  S("rowModel")
], Hs.prototype, "gridRowModel", void 0);
ju([
  S("valueService")
], Hs.prototype, "valueService", void 0);
ju([
  S("columnModel")
], Hs.prototype, "columnModel", void 0);
ju([
  S("rowNodeSorter")
], Hs.prototype, "rowNodeSorter", void 0);
ju([
  S("sortController")
], Hs.prototype, "sortController", void 0);
ju([
  Ve("aggregationStage")
], Hs.prototype, "aggregationStage", void 0);
var ty = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let tu = class extends H {
  getColumn(e) {
    return this.columnModel.getPrimaryColumn(e);
  }
  getAllDisplayedColumns() {
    return this.columnModel.getAllDisplayedColumns();
  }
  getColDisplayName(e) {
    return this.columnModel.getDisplayNameForColumn(e, "chart");
  }
  getRowGroupColumns() {
    return this.columnModel.getRowGroupColumns();
  }
  getGroupDisplayColumns() {
    return this.columnModel.getGroupDisplayColumns();
  }
  isPivotMode() {
    return this.columnModel.isPivotMode();
  }
  isPivotActive() {
    return this.columnModel.isPivotActive();
  }
  getChartColumns() {
    const e = this.columnModel.getAllDisplayedColumns(), t = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
    return e.forEach((r) => {
      const n = r.getColDef(), s = n.chartDataType;
      if (s)
        switch (s) {
          case "category":
          case "time":
            t.add(r);
            return;
          case "series":
            i.add(r);
            return;
          case "excluded":
            return;
          default:
            console.warn(`AG Grid: unexpected chartDataType value '${s}' supplied, instead use 'category', 'series' or 'excluded'`);
            break;
        }
      if (n.colId === "ag-Grid-AutoColumn") {
        t.add(r);
        return;
      }
      if (!r.isPrimary()) {
        i.add(r);
        return;
      }
      (this.isNumberCol(r) ? i : t).add(r);
    }), { dimensionCols: t, valueCols: i };
  }
  isNumberCol(e) {
    if (e.getColId() === "ag-Grid-AutoColumn")
      return !1;
    const t = this.rowRenderer.getRowNode({ rowIndex: 0, rowPinned: null });
    if (!t)
      return !1;
    let i = this.valueService.getValue(e, t);
    return i == null && (i = this.extractLeafData(t, e)), i != null && typeof i.toNumber == "function" && (i = i.toNumber()), typeof i == "number";
  }
  extractLeafData(e, t) {
    if (!e.allLeafChildren)
      return null;
    for (let i = 0; i < e.allLeafChildren.length; i++) {
      const r = e.allLeafChildren[i], n = this.valueService.getValue(t, r);
      if (n != null)
        return n;
    }
    return null;
  }
};
ty([
  S("columnModel")
], tu.prototype, "columnModel", void 0);
ty([
  S("valueService")
], tu.prototype, "valueService", void 0);
ty([
  S("rowRenderer")
], tu.prototype, "rowRenderer", void 0);
tu = ty([
  q("chartColumnService")
], tu);
var tz = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Mf extends H {
  constructor(e) {
    var t;
    super(), this.suppressComboChartWarnings = !1, this.chartDataModel = e, this.seriesChartTypes = (t = e.params.seriesChartTypes) !== null && t !== void 0 ? t : [];
  }
  init() {
    this.initComboCharts();
  }
  update(e) {
    this.seriesChartTypes = e != null ? e : this.seriesChartTypes, this.initComboCharts(), this.updateSeriesChartTypes();
  }
  initComboCharts() {
    const e = this.seriesChartTypes && this.seriesChartTypes.length > 0;
    (this.chartDataModel.chartType === "customCombo" || e) && (this.chartDataModel.chartType = "customCombo", this.savedCustomSeriesChartTypes = this.seriesChartTypes || []);
  }
  updateSeriesChartTypes() {
    if (this.chartDataModel.isComboChart()) {
      if (this.seriesChartTypes = this.seriesChartTypes.map((e) => {
        const t = ["groupedColumn", "stackedColumn", "stackedArea"].includes(e.chartType);
        return e.secondaryAxis = t ? !1 : e.secondaryAxis, e;
      }), this.chartDataModel.chartType === "customCombo") {
        this.updateSeriesChartTypesForCustomCombo();
        return;
      }
      this.updateChartSeriesTypesForBuiltInCombos();
    }
  }
  updateSeriesChartTypesForCustomCombo() {
    !(this.seriesChartTypes && this.seriesChartTypes.length > 0) && !this.suppressComboChartWarnings && console.warn("AG Grid: 'seriesChartTypes' are required when the 'customCombo' chart type is specified."), this.seriesChartTypes = this.seriesChartTypes.map((r) => (Mf.SUPPORTED_COMBO_CHART_TYPES.includes(r.chartType) || (console.warn(`AG Grid: invalid chartType '${r.chartType}' supplied in 'seriesChartTypes', converting to 'line' instead.`), r.chartType = "line"), r));
    const t = (r) => {
      (!this.savedCustomSeriesChartTypes || this.savedCustomSeriesChartTypes.length === 0) && (this.savedCustomSeriesChartTypes = this.seriesChartTypes);
      const n = this.savedCustomSeriesChartTypes.find((s) => s.colId === r.colId);
      return n || (r.selected && !this.suppressComboChartWarnings && console.warn(`AG Grid: no 'seriesChartType' found for colId = '${r.colId}', defaulting to 'line'.`), {
        colId: r.colId,
        chartType: "line",
        secondaryAxis: !1
      });
    }, i = this.chartDataModel.valueColState.map(t);
    this.seriesChartTypes = i, this.savedCustomSeriesChartTypes = i, this.suppressComboChartWarnings = !0;
  }
  updateChartSeriesTypesForBuiltInCombos() {
    const { chartType: e, valueColState: t } = this.chartDataModel;
    let i = e === "columnLineCombo" ? "groupedColumn" : "stackedArea", r = e === "columnLineCombo" ? "line" : "groupedColumn";
    const n = t.filter((a) => a.selected), s = Math.ceil(n.length / 2);
    this.seriesChartTypes = n.map((a, l) => {
      const c = l >= s ? r : i;
      return { colId: a.colId, chartType: c, secondaryAxis: !1 };
    });
  }
}
Mf.SUPPORTED_COMBO_CHART_TYPES = ["line", "groupedColumn", "stackedColumn", "area", "stackedArea"];
tz([
  B
], Mf.prototype, "init", null);
var ww = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Io extends H {
  constructor(e) {
    super(), this.unlinked = !1, this.chartData = [], this.valueColState = [], this.dimensionColState = [], this.columnNames = {}, this.crossFiltering = !1, this.grouping = !1, this.params = e, this.chartId = e.chartId, this.chartType = e.chartType, this.pivotChart = e.pivotChart, this.chartThemeName = e.chartThemeName, this.aggFunc = e.aggFunc, this.referenceCellRange = e.cellRange, this.suppliedCellRange = e.cellRange, this.suppressChartRanges = e.suppressChartRanges, this.unlinked = !!e.unlinkChart, this.crossFiltering = !!e.crossFiltering;
  }
  init() {
    this.datasource = this.createManagedBean(new Hs()), this.chartColumnService = this.createManagedBean(new tu()), this.comboChartModel = this.createManagedBean(new Mf(this)), this.updateCellRanges(), this.updateData();
  }
  updateModel(e) {
    const { cellRange: t, chartType: i, pivotChart: r, chartThemeName: n, aggFunc: s, suppressChartRanges: a, unlinkChart: l, crossFiltering: c, seriesChartTypes: d } = e;
    t !== this.suppliedCellRange && (this.dimensionCellRange = void 0, this.valueCellRange = void 0), this.chartType = i, this.pivotChart = r, this.chartThemeName = n, this.aggFunc = s, this.referenceCellRange = t, this.suppliedCellRange = t, this.suppressChartRanges = a, this.unlinked = !!l, this.crossFiltering = !!c, this.updateSelectedDimension(t == null ? void 0 : t.columns), this.updateCellRanges(), (this.isComboChart() || d) && this.comboChartModel.update(d), this.unlinked || this.updateData();
  }
  updateCellRanges(e) {
    this.valueCellRange && (this.referenceCellRange = this.valueCellRange);
    const { dimensionCols: t, valueCols: i } = this.chartColumnService.getChartColumns(), r = this.getAllColumnsFromRanges();
    e && this.updateColumnState(e), this.setDimensionCellRange(t, r, e), this.setValueCellRange(i, r, e), e || (this.resetColumnState(), this.syncDimensionCellRange()), this.comboChartModel.updateSeriesChartTypes();
  }
  updateData() {
    const { startRow: e, endRow: t } = this.getRowIndexes();
    this.pivotChart && this.resetColumnState(), this.grouping = this.isGrouping();
    const i = {
      aggFunc: this.aggFunc,
      dimensionCols: [this.getSelectedDimension()],
      grouping: this.grouping,
      pivoting: this.isPivotActive(),
      crossFiltering: this.crossFiltering,
      valueCols: this.getSelectedValueCols(),
      startRow: e,
      endRow: t,
      isScatter: x.includes(["scatter", "bubble"], this.chartType)
    }, { chartData: r, columnNames: n } = this.datasource.getData(i);
    this.chartData = r, this.columnNames = n;
  }
  isGrouping() {
    const e = this.gridOptionsService.isTreeData(), t = e ? null : this.chartColumnService.getRowGroupColumns(), i = e || t && t.length > 0, r = this.getSelectedDimension().colId, s = this.chartColumnService.getGroupDisplayColumns().map((a) => a.getColId()).some((a) => a === r);
    return !!i && s;
  }
  getSelectedValueCols() {
    return this.valueColState.filter((e) => e.selected).map((e) => e.column);
  }
  getSelectedDimension() {
    return this.dimensionColState.filter((e) => e.selected)[0];
  }
  getColDisplayName(e) {
    return this.chartColumnService.getColDisplayName(e);
  }
  isPivotMode() {
    return this.chartColumnService.isPivotMode();
  }
  getChartDataType(e) {
    const t = this.chartColumnService.getColumn(e);
    return t ? t.getColDef().chartDataType : void 0;
  }
  isPivotActive() {
    return this.chartColumnService.isPivotActive();
  }
  createCellRange(e, ...t) {
    return {
      id: this.chartId,
      startRow: this.referenceCellRange.startRow,
      endRow: this.referenceCellRange.endRow,
      columns: t,
      startColumn: e === wr.DIMENSION ? t[0] : this.referenceCellRange.startColumn,
      type: e
    };
  }
  getAllColumnsFromRanges() {
    if (this.pivotChart)
      return x.convertToSet(this.chartColumnService.getAllDisplayedColumns());
    const e = this.dimensionCellRange || this.valueCellRange ? [] : this.referenceCellRange.columns;
    return this.dimensionCellRange && e.push(...this.dimensionCellRange.columns), this.valueCellRange && e.push(...this.valueCellRange.columns), x.convertToSet(e);
  }
  getRowIndexes() {
    let e = 0, t = 0;
    const { rangeService: i, valueCellRange: r } = this;
    if (i && r) {
      e = i.getRangeStartRow(r).rowIndex;
      const n = i.getRangeEndRow(r);
      t = n.rowPinned === "bottom" ? -1 : n.rowIndex;
    }
    return { startRow: e, endRow: t };
  }
  resetColumnState() {
    const { dimensionCols: e, valueCols: t } = this.chartColumnService.getChartColumns(), i = this.getAllColumnsFromRanges(), r = this.valueColState.length < 1;
    this.dimensionColState = [], this.valueColState = [];
    let n = !1, s = 1;
    const a = this.suppliedCellRange.columns[0];
    e.forEach((d) => {
      const u = d.getColId() === "ag-Grid-AutoColumn";
      let h = !1;
      this.crossFiltering && this.aggFunc ? a.getColId() === d.getColId() && (h = !0) : h = u ? !0 : !n && i.has(d), this.dimensionColState.push({
        column: d,
        colId: d.getColId(),
        displayName: this.getColDisplayName(d),
        selected: h,
        order: s++
      }), h && (n = !0);
    });
    const l = {
      colId: Io.DEFAULT_CATEGORY,
      displayName: this.chartTranslationService.translate("defaultCategory"),
      selected: !n,
      order: 0
    };
    this.dimensionColState.unshift(l);
    const c = this.referenceCellRange.columns.filter((d) => t.has(d));
    t.forEach((d) => {
      r && x.includes(this.referenceCellRange.columns, d) && (d = c.shift()), this.valueColState.push({
        column: d,
        colId: d.getColId(),
        displayName: this.getColDisplayName(d),
        selected: i.has(d),
        order: s++
      });
    });
  }
  updateColumnState(e) {
    const t = (a) => a.colId === e.colId, { dimensionColState: i, valueColState: r } = this;
    i.filter(t).length > 0 ? i.forEach((a) => a.selected = t(a)) : r.filter(t).forEach((a) => a.selected = e.selected);
    const n = [...i, ...r], s = [];
    n.forEach((a, l) => {
      l === e.order && s.push(e.colId), a.colId !== e.colId && s.push(a.colId);
    }), n.forEach((a) => {
      const l = s.indexOf(a.colId);
      a.order = l >= 0 ? s.indexOf(a.colId) : n.length - 1;
    }), this.reorderColState();
  }
  reorderColState() {
    const e = (t, i) => t.order - i.order;
    this.dimensionColState.sort(e), this.valueColState.sort(e);
  }
  setDimensionCellRange(e, t, i) {
    if (this.dimensionCellRange = void 0, !i && !this.dimensionColState.length) {
      e.forEach((n) => {
        this.dimensionCellRange || !t.has(n) || (this.dimensionCellRange = this.createCellRange(wr.DIMENSION, n));
      });
      return;
    }
    let r = i;
    if (this.crossFiltering && this.aggFunc) {
      const n = this.suppliedCellRange.columns[0];
      r = this.dimensionColState.filter((s) => s.colId === n.getColId())[0];
    } else
      (!r || !e.has(r.column)) && (r = this.dimensionColState.filter((n) => n.selected)[0]);
    r && r.colId !== Io.DEFAULT_CATEGORY && (this.dimensionCellRange = this.createCellRange(wr.DIMENSION, r.column));
  }
  setValueCellRange(e, t, i) {
    this.valueCellRange = void 0;
    const r = [];
    if (e.forEach((n) => {
      i && i.colId === n.getColId() ? i.selected && r.push(i.column) : t.has(n) && r.push(n);
    }), r.length > 0) {
      let n = [];
      this.valueColState.length > 0 ? n = this.valueColState.map((s) => s.colId) : t.forEach((s) => n.push(s.getColId())), r.sort((s, a) => n.indexOf(s.getColId()) - n.indexOf(a.getColId())), this.valueCellRange = this.createCellRange(wr.VALUE, ...r);
    }
  }
  updateSelectedDimension(e) {
    const t = new Set(e.map((r) => r.getColId())), i = this.dimensionColState.find((r) => t.has(r.colId)) || this.dimensionColState[0];
    this.dimensionColState = this.dimensionColState.map((r) => Object.assign(Object.assign({}, r), { selected: r.colId === i.colId }));
  }
  syncDimensionCellRange() {
    const e = this.getSelectedDimension();
    e && e.column && (this.dimensionCellRange = this.createCellRange(wr.DIMENSION, e.column));
  }
  isComboChart() {
    return ["columnLineCombo", "areaColumnCombo", "customCombo"].includes(this.chartType);
  }
}
Io.DEFAULT_CATEGORY = "AG-GRID-DEFAULT-CATEGORY";
ww([
  S("rangeService")
], Io.prototype, "rangeService", void 0);
ww([
  S("chartTranslationService")
], Io.prototype, "chartTranslationService", void 0);
ww([
  B
], Io.prototype, "init", null);
function $E(o) {
  return o.chart != null ? o.chart : o;
}
class eP {
  constructor(e) {
    this.chartProxyParams = e, this.clearThemeOverrides = !1, this.chart = e.chartInstance, this.chartType = e.chartType, this.crossFiltering = e.crossFiltering, this.crossFilterCallback = e.crossFilterCallback, this.standaloneChartType = pn(this.chartType), this.chart == null ? this.chart = Od.create(this.getCommonChartOptions()) : this.clearThemeOverrides = !0;
  }
  getChart() {
    return $E(this.chart);
  }
  getChartRef() {
    return this.chart;
  }
  downloadChart(e, t, i) {
    const { chart: r } = this, n = $E(r), s = t || (n.title ? n.title.text : "chart"), { width: a, height: l } = e || {};
    Od.download(r, { width: a, height: l, fileName: s, fileFormat: i });
  }
  getChartImageDataURL(e) {
    return this.getChart().scene.getDataURL(e);
  }
  getChartOptions() {
    return this.chart.getOptions();
  }
  getChartThemeOverrides() {
    var e;
    return (e = this.getChartOptions().theme.overrides) !== null && e !== void 0 ? e : {};
  }
  getChartPalette() {
    return Cf(this.getChartOptions().theme).palette;
  }
  setPaired(e) {
    const t = pn(this.chartProxyParams.chartType);
    Od.updateDelta(this.chart, { theme: { overrides: { [t]: { paired: e } } } });
  }
  isPaired() {
    const e = pn(this.chartProxyParams.chartType);
    return x.get(this.getChartThemeOverrides(), `${e}.paired`, !0);
  }
  lookupCustomChartTheme(e) {
    return LO(this.chartProxyParams, e);
  }
  transformData(e, t, i) {
    return i ? e.map((r, n) => {
      const s = r[t], a = s && s.toString ? s.toString() : "", l = Object.assign({}, r);
      return l[t] = { id: n, value: s, toString: () => a }, l;
    }) : e;
  }
  getCommonChartOptions(e) {
    var t, i;
    const r = this.clearThemeOverrides ? {} : (i = (t = this.chart) === null || t === void 0 ? void 0 : t.getOptions()) !== null && i !== void 0 ? i : {}, n = this.chart != null ? { overrides: this.getActiveFormattingPanelOverrides() } : {};
    return this.clearThemeOverrides = !1, Object.assign(Object.assign({}, r), { theme: Object.assign(Object.assign({}, U$(this.chartProxyParams, this)), e ? { overrides: e } : n), container: this.chartProxyParams.parentElement, mode: "integrated" });
  }
  getActiveFormattingPanelOverrides() {
    var e, t;
    if (this.clearThemeOverrides)
      return {};
    const i = (e = this.chart) === null || e === void 0 ? void 0 : e.getOptions().theme;
    return (t = i == null ? void 0 : i.overrides) !== null && t !== void 0 ? t : {};
  }
  destroy({ keepChartInstance: e = !1 } = {}) {
    if (e)
      return this.chart;
    this.destroyChart();
  }
  destroyChart() {
    this.chart && (this.chart.destroy(), this.chart = void 0);
  }
}
class ol extends eP {
  constructor(e) {
    super(e), this.crossFilteringAllPoints = /* @__PURE__ */ new Set(), this.crossFilteringSelectedPoints = [];
  }
  update(e) {
    const t = this.getAxes(e), i = Object.assign(Object.assign({}, this.getCommonChartOptions(e.updatedOverrides)), { data: this.getData(e, t), axes: t, series: this.getSeries(e) });
    Od.update(this.getChartRef(), i);
  }
  getData(e, t) {
    var i;
    const r = ["area", "line"].includes(this.standaloneChartType), n = this.standaloneChartType === "bar" ? "left" : "bottom", s = ((i = t.find((a) => a.position === n)) === null || i === void 0 ? void 0 : i.type) === "category";
    return this.crossFiltering && r ? this.getCrossFilterData(e) : this.getDataTransformedData(e, s);
  }
  getDataTransformedData(e, t) {
    return this.transformData(e.data, e.category.id, t);
  }
  getXAxisType(e) {
    return e.grouping ? "groupedCategory" : ol.isTimeAxis(e) ? "time" : "category";
  }
  static isTimeAxis(e) {
    if (e.category && e.category.chartDataType)
      return e.category.chartDataType === "time";
    const t = e.data[0];
    return (t && t[e.category.id]) instanceof Date;
  }
  crossFilteringReset() {
    this.crossFilteringSelectedPoints = [], this.crossFilteringAllPoints.clear();
  }
  crossFilteringPointSelected(e) {
    return this.crossFilteringSelectedPoints.length == 0 || this.crossFilteringSelectedPoints.includes(e);
  }
  crossFilteringDeselectedPoints() {
    return this.crossFilteringSelectedPoints.length > 0 && this.crossFilteringAllPoints.size !== this.crossFilteringSelectedPoints.length;
  }
  extractLineAreaCrossFilterSeries(e, t) {
    const i = (r) => this.standaloneChartType === "area" ? t.getCrossFilteringContext().lastSelectedChartId === t.chartId ? r + "-total" : r : r + "-total";
    return e.map((r) => (r.yKey = i(r.yKey), r.listeners = {
      nodeClick: (n) => {
        const s = n.datum[r.xKey], a = n.event.metaKey || n.event.ctrlKey;
        this.crossFilteringAddSelectedPoint(a, s), this.crossFilterCallback(n);
      }
    }, r.marker = {
      formatter: (n) => {
        const s = n.datum[t.category.id];
        return {
          fill: n.highlighted ? "yellow" : n.fill,
          size: n.highlighted ? 14 : this.crossFilteringPointSelected(s) ? 8 : 0
        };
      }
    }, this.standaloneChartType === "area" && (r.fillOpacity = this.crossFilteringDeselectedPoints() ? 0.3 : 1), this.standaloneChartType === "line" && (r.strokeOpacity = this.crossFilteringDeselectedPoints() ? 0.3 : 1), r));
  }
  getCrossFilterData(e) {
    this.crossFilteringAllPoints.clear();
    const t = e.fields[0].colId, i = `${t}-filtered-out`, r = e.getCrossFilteringContext().lastSelectedChartId;
    return e.data.map((n) => {
      const s = n[e.category.id];
      this.crossFilteringAllPoints.add(s);
      const a = this.crossFilteringPointSelected(s);
      return this.standaloneChartType === "area" && r === e.chartId && (n[`${t}-total`] = a ? n[t] : n[t] + n[i]), this.standaloneChartType === "line" && (n[`${t}-total`] = a ? n[t] : n[t] + n[i]), n;
    });
  }
  crossFilteringAddSelectedPoint(e, t) {
    e ? this.crossFilteringSelectedPoints.push(t) : this.crossFilteringSelectedPoints = [t];
  }
}
function iz(o) {
  return Array.isArray(o) ? [] : {};
}
function mp(o, e) {
  return e.clone !== !1 && e.isMergeableObject(o) ? zl(iz(o), o, e) : o;
}
function rz(o, e, t) {
  return o.concat(e).map(function(i) {
    return mp(i, t);
  });
}
function nz(o, e) {
  if (!e.customMerge)
    return zl;
  const t = e.customMerge(o);
  return typeof t == "function" ? t : zl;
}
function oz(o) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(o).filter(function(e) {
    return o.propertyIsEnumerable(e);
  }) : [];
}
function zE(o) {
  return Object.keys(o).concat(oz(o));
}
function tP(o, e) {
  try {
    return e in o;
  } catch (t) {
    return !1;
  }
}
function sz(o, e) {
  return tP(o, e) && !(Object.hasOwnProperty.call(o, e) && Object.propertyIsEnumerable.call(o, e));
}
function az(o = {}, e = {}, t) {
  const i = {};
  return t.isMergeableObject(o) && zE(o).forEach(function(r) {
    i[r] = mp(o[r], t);
  }), zE(e).forEach(function(r) {
    sz(o, r) || (tP(o, r) && t.isMergeableObject(e[r]) ? i[r] = nz(r, t)(o[r], e[r], t) : i[r] = mp(e[r], t));
  }), i;
}
function lz(o) {
  return cz(o) && !dz(o);
}
function cz(o) {
  return !!o && typeof o == "object";
}
function dz(o) {
  const e = Object.prototype.toString.call(o);
  return e === "[object RegExp]" || e === "[object Date]";
}
function zl(o, e, t) {
  t = t || {}, t.arrayMerge = t.arrayMerge || rz, t.isMergeableObject = t.isMergeableObject || lz, t.cloneUnlessOtherwiseSpecified = mp;
  const i = Array.isArray(e), r = Array.isArray(o);
  return i === r ? i ? t.arrayMerge(o, e, t) : az(o, e, t) : mp(e, t);
}
function KE(o, e) {
  const t = parseInt(o.slice(1, 3), 16), i = parseInt(o.slice(3, 5), 16), r = parseInt(o.slice(5, 7), 16);
  return e ? `rgba(${t}, ${i}, ${r}, ${e})` : `rgba(${t}, ${i}, ${r})`;
}
function YE(o, e) {
  return o.map((t) => {
    const i = Kt.fromString(t);
    return new Kt(i.r, i.g, i.b, e).toHexString();
  });
}
class uz extends ol {
  constructor(e) {
    super(e);
  }
  getAxes(e) {
    const t = this.standaloneChartType === "bar", i = [
      {
        type: this.getXAxisType(e),
        position: t ? "left" : "bottom"
      },
      {
        type: "number",
        position: t ? "bottom" : "left"
      }
    ];
    if (this.isNormalised()) {
      const r = i[1];
      r.label = Object.assign(Object.assign({}, r.label), { formatter: (n) => Math.round(n.value) + "%" });
    }
    return i;
  }
  getSeries(e) {
    const t = ["groupedColumn", "groupedBar"], i = !this.crossFiltering && x.includes(t, this.chartType), r = e.fields.map((n) => ({
      type: this.standaloneChartType,
      grouped: i,
      stacked: ["stackedColumn", "normalizedColumn", "stackedBar", "normalizedBar"].includes(this.chartType),
      normalizedTo: this.isNormalised() ? 100 : void 0,
      xKey: e.category.id,
      xName: e.category.name,
      yKey: n.colId,
      yName: n.displayName
    }));
    return this.crossFiltering ? this.extractCrossFilterSeries(r) : r;
  }
  extractCrossFilterSeries(e) {
    const t = this.getChartPalette(), i = (s, a) => Object.assign(Object.assign({}, s), { highlightStyle: { item: { fill: void 0 } }, fill: t == null ? void 0 : t.fills[a], stroke: t == null ? void 0 : t.strokes[a], listeners: {
      nodeClick: this.crossFilterCallback
    } }), r = (s) => {
      const a = s.yKey + "-filtered-out";
      return Object.assign(Object.assign({}, zl({}, s)), { yKey: a, fill: KE(s.fill, "0.3"), stroke: KE(s.stroke, "0.3"), showInLegend: !1 });
    }, n = [];
    for (let s = 0; s < e.length; s++) {
      const a = i(e[s], s);
      n.push(a), n.push(r(a));
    }
    return n;
  }
  isNormalised() {
    const e = ["normalizedColumn", "normalizedBar"];
    return !this.crossFiltering && x.includes(e, this.chartType);
  }
}
class hz extends ol {
  constructor(e) {
    super(e);
  }
  getAxes(e) {
    const t = [
      {
        type: this.getXAxisType(e),
        position: "bottom"
      },
      {
        type: "number",
        position: "left"
      }
    ];
    if (this.isNormalised()) {
      const i = t[1];
      i.label = Object.assign(Object.assign({}, i.label), { formatter: (r) => Math.round(r.value) + "%" });
    }
    return t;
  }
  getSeries(e) {
    const t = e.fields.map((i) => ({
      type: this.standaloneChartType,
      xKey: e.category.id,
      xName: e.category.name,
      yKey: i.colId,
      yName: i.displayName,
      normalizedTo: this.chartType === "normalizedArea" ? 100 : void 0,
      stacked: ["normalizedArea", "stackedArea"].includes(this.chartType)
    }));
    return this.crossFiltering ? this.extractLineAreaCrossFilterSeries(t, e) : t;
  }
  isNormalised() {
    return !this.crossFiltering && this.chartType === "normalizedArea";
  }
}
class pz extends ol {
  constructor(e) {
    super(e);
  }
  getAxes(e) {
    return [
      {
        type: this.getXAxisType(e),
        position: "bottom"
      },
      {
        type: "number",
        position: "left"
      }
    ];
  }
  getSeries(e) {
    const t = e.fields.map((i) => ({
      type: this.standaloneChartType,
      xKey: e.category.id,
      xName: e.category.name,
      yKey: i.colId,
      yName: i.displayName
    }));
    return this.crossFiltering ? this.extractLineAreaCrossFilterSeries(t, e) : t;
  }
}
class Ew extends eP {
  constructor(e) {
    super(e);
  }
  update(e) {
    const { data: t, category: i } = e, r = Object.assign(Object.assign({}, this.getCommonChartOptions(e.updatedOverrides)), { data: this.crossFiltering ? this.getCrossFilterData(e) : this.transformData(t, i.id), series: this.getSeries(e) });
    Od.update(this.getChartRef(), r);
  }
  getSeries(e) {
    const t = e.fields.length, i = {
      currentOffset: 0,
      offsetAmount: t > 1 ? 20 : 40
    }, r = this.getFields(e).map((n) => {
      var s;
      const a = {
        type: this.standaloneChartType,
        angleKey: n.colId,
        angleName: n.displayName,
        sectorLabelKey: n.colId,
        calloutLabelKey: e.category.id,
        calloutLabelName: e.category.name
      };
      if (this.chartType === "doughnut") {
        const { outerRadiusOffset: l, innerRadiusOffset: c } = Ew.calculateOffsets(i), d = n.displayName ? {
          title: { text: n.displayName, showInLegend: t > 1 }
        } : void 0;
        return Object.assign(Object.assign(Object.assign(Object.assign({}, a), {
          outerRadiusOffset: l,
          innerRadiusOffset: c
        }), d), { calloutLine: {
          colors: (s = this.getChartPalette()) === null || s === void 0 ? void 0 : s.strokes
        } });
      }
      return a;
    });
    return this.crossFiltering ? this.extractCrossFilterSeries(r) : r;
  }
  getCrossFilterData(e) {
    const t = e.fields[0].colId, i = `${t}-filtered-out`;
    return e.data.map((r) => {
      const n = r[t] + r[i];
      return r[`${t}-total`] = n, r[i] = 1, r[t] = r[t] / n, r;
    });
  }
  extractCrossFilterSeries(e) {
    const t = this.getChartPalette(), i = (l) => Object.assign(Object.assign({}, l), { calloutLabel: { enabled: !1 }, highlightStyle: { item: { fill: void 0 } }, radiusKey: l.angleKey, angleKey: l.angleKey + "-total", radiusMin: 0, radiusMax: 1, listeners: {
      nodeClick: this.crossFilterCallback
    } }), r = (l, c) => {
      var d, u;
      return Object.assign(Object.assign({}, zl({}, a)), { radiusKey: c + "-filtered-out", fills: YE((d = l.fills) !== null && d !== void 0 ? d : t.fills, 0.3), strokes: YE((u = l.strokes) !== null && u !== void 0 ? u : t.strokes, 0.3), showInLegend: !1 });
    }, n = e[0], s = n.angleKey, a = i(n);
    return [
      r(n, s),
      a
    ];
  }
  static calculateOffsets(e) {
    const t = e.currentOffset;
    e.currentOffset -= e.offsetAmount;
    const i = e.currentOffset;
    return e.currentOffset -= e.offsetAmount, { outerRadiusOffset: t, innerRadiusOffset: i };
  }
  getFields(e) {
    return this.chartType === "pie" ? e.fields.slice(0, 1) : e.fields;
  }
  crossFilteringReset() {
  }
}
class fz extends ol {
  constructor(e) {
    super(e);
  }
  getAxes(e) {
    return [
      {
        type: "number",
        position: "bottom"
      },
      {
        type: "number",
        position: "left"
      }
    ];
  }
  getSeries(e) {
    const t = this.isPaired(), i = this.getSeriesDefinitions(e.fields, t), r = e.category.id === Io.DEFAULT_CATEGORY ? void 0 : e.category, n = i.map((s) => ({
      type: this.standaloneChartType,
      xKey: s.xField.colId,
      xName: s.xField.displayName,
      yKey: s.yField.colId,
      yName: s.yField.displayName,
      title: `${s.yField.displayName} vs ${s.xField.displayName}`,
      sizeKey: s.sizeField ? s.sizeField.colId : void 0,
      sizeName: s.sizeField ? s.sizeField.displayName : void 0,
      labelKey: r ? r.id : s.yField.colId,
      labelName: r ? r.name : void 0
    }));
    return this.crossFiltering ? this.extractCrossFilterSeries(n, e) : n;
  }
  extractCrossFilterSeries(e, t) {
    const { data: i } = t, r = this.getChartPalette(), n = (d) => `${d}-filtered-out`, s = (d, u) => {
      var h;
      const p = [1 / 0, -1 / 0];
      if (u != null)
        for (const f of d) {
          const g = (h = f[u]) !== null && h !== void 0 ? h : f[n(u)];
          g < p[0] && (p[0] = g), g > p[1] && (p[1] = g);
        }
      if (p[0] <= p[1])
        return p;
    }, a = (d, u) => {
      const { sizeKey: h } = d, p = r == null ? void 0 : r.fills[u], f = r == null ? void 0 : r.strokes[u];
      let g = s(i, h);
      const v = Object.assign(Object.assign({}, d.marker), {
        fill: p,
        stroke: f,
        domain: g
      });
      return Object.assign(Object.assign({}, d), { marker: v, highlightStyle: { item: { fill: "yellow" } }, listeners: Object.assign(Object.assign({}, d.listeners), { nodeClick: this.crossFilterCallback }) });
    }, l = (d) => {
      let { sizeKey: u, yKey: h, xKey: p } = d;
      return u != null && (u = n(u)), Object.assign(Object.assign({}, d), { yKey: n(h), xKey: n(p), marker: Object.assign(Object.assign({}, d.marker), { fillOpacity: 0.3, strokeOpacity: 0.3 }), sizeKey: u, showInLegend: !1, listeners: Object.assign(Object.assign({}, d.listeners), { nodeClick: (f) => {
        const g = f.datum[n(p)], v = Object.assign(Object.assign({}, f), { xKey: p, datum: Object.assign(Object.assign({}, f.datum), { [p]: g }) });
        this.crossFilterCallback(v);
      } }) });
    }, c = e.map(a);
    return [
      ...c,
      ...c.map(l)
    ];
  }
  getSeriesDefinitions(e, t) {
    if (e.length < 2)
      return [];
    const i = this.chartType === "bubble";
    if (t)
      return i ? e.map((n, s) => s % 3 === 0 ? {
        xField: n,
        yField: e[s + 1],
        sizeField: e[s + 2]
      } : null).filter((n) => n && n.yField && n.sizeField) : e.map((n, s) => s % 2 === 0 ? {
        xField: n,
        yField: e[s + 1]
      } : null).filter((n) => n && n.yField);
    const r = e[0];
    return i ? e.map((n, s) => s % 2 === 1 ? {
      xField: r,
      yField: n,
      sizeField: e[s + 1]
    } : null).filter((n) => n && n.sizeField) : e.filter((n, s) => s > 0).map((n) => ({ xField: r, yField: n }));
  }
}
class gz extends ol {
  constructor(e) {
    super(e);
  }
  getSeries(e) {
    const t = e.fields[0];
    return [
      {
        type: this.standaloneChartType,
        xKey: t.colId,
        xName: t.displayName,
        yName: this.chartProxyParams.translate("histogramFrequency"),
        areaPlot: !1
        // only constant width is supported via integrated charts
      }
    ];
  }
  getAxes(e) {
    return [
      {
        type: "number",
        position: "bottom"
      },
      {
        type: "number",
        position: "left"
      }
    ];
  }
}
class Rw extends H {
  constructor(e) {
    super(), this.chartController = e;
  }
  getChartOption(e) {
    return x.get(this.getChart(), e, void 0);
  }
  setChartOption(e, t, i) {
    const r = this.chartController.getChartSeriesTypes();
    this.chartController.isComboChart() && r.push("cartesian");
    let n = {};
    r.forEach((s) => {
      n = zl(n, this.createChartOptions({
        seriesType: s,
        expression: e,
        value: t
      }));
    }), this.updateChart(n), i || this.raiseChartOptionsChangedEvent();
  }
  awaitChartOptionUpdate(e) {
    this.chartController.getChartProxy().getChart().waitForUpdate().then(() => e()).catch((i) => console.error("AG Grid - chart update failed", i));
  }
  getAxisProperty(e) {
    var t;
    return x.get((t = this.getChart().axes) === null || t === void 0 ? void 0 : t[0], e, void 0);
  }
  setAxisProperty(e, t) {
    var i;
    const r = this.getChart();
    let n = {};
    (i = r.axes) === null || i === void 0 || i.forEach((s) => {
      n = zl(n, this.getUpdateAxisOptions(s, e, t));
    }), this.updateChart(n), this.raiseChartOptionsChangedEvent();
  }
  getLabelRotation(e) {
    const t = this.getAxis(e);
    return x.get(t, "label.rotation", void 0);
  }
  setLabelRotation(e, t) {
    const i = this.getAxis(e);
    if (i) {
      const r = this.getUpdateAxisOptions(i, "label.rotation", t);
      this.updateChart(r), this.raiseChartOptionsChangedEvent();
    }
  }
  getSeriesOption(e, t) {
    const i = this.getChart().series.find((r) => Rw.isMatchingSeries(t, r));
    return x.get(i, e, void 0);
  }
  setSeriesOption(e, t, i) {
    const r = this.createChartOptions({
      seriesType: i,
      expression: `series.${e}`,
      value: t
    });
    this.updateChart(r), this.raiseChartOptionsChangedEvent();
  }
  getPairedMode() {
    return this.chartController.getChartProxy().isPaired();
  }
  setPairedMode(e) {
    this.chartController.getChartProxy().setPaired(e);
  }
  getAxis(e) {
    const t = this.getChart();
    if (!(!t.axes || t.axes.length < 1))
      return e === "xAxis" ? t.axes && t.axes[0].direction === "x" ? t.axes[0] : t.axes[1] : t.axes && t.axes[1].direction === "y" ? t.axes[1] : t.axes[0];
  }
  getUpdateAxisOptions(e, t, i) {
    const r = pn(this.getChartType());
    return ["number", "category", "time", "groupedCategory"].includes(e.type) ? this.createChartOptions({
      seriesType: r,
      expression: `axes.${e.type}.${t}`,
      value: i
    }) : {};
  }
  getChartType() {
    return this.chartController.getChartType();
  }
  getChart() {
    return this.chartController.getChartProxy().getChart();
  }
  updateChart(e) {
    const t = this.chartController.getChartProxy().getChartRef();
    Od.updateDelta(t, e);
  }
  createChartOptions({ seriesType: e, expression: t, value: i }) {
    const r = {}, n = {
      theme: {
        overrides: r
      }
    };
    return x.set(r, `${e}.${t}`, i), n;
  }
  raiseChartOptionsChangedEvent() {
    const e = this.chartController.getChartModel(), t = {
      type: w.EVENT_CHART_OPTIONS_CHANGED,
      chartId: e.chartId,
      chartType: e.chartType,
      chartThemeName: this.chartController.getChartThemeName(),
      chartOptions: e.chartOptions
    };
    this.eventService.dispatchEvent(t);
  }
  static isMatchingSeries(e, t) {
    return W$.includes(e) && t.type === e;
  }
  destroy() {
    super.destroy();
  }
}
class vz extends ol {
  constructor(e) {
    super(e);
  }
  getAxes(e) {
    const t = e ? e.fields : [], i = new Map(t.map((a) => [a.colId, a])), { primaryYKeys: r, secondaryYKeys: n } = this.getYKeys(t, e.seriesChartTypes), s = [
      {
        type: this.getXAxisType(e),
        position: "bottom",
        gridStyle: [{ stroke: void 0 }]
      }
    ];
    return r.length > 0 && s.push({
      type: "number",
      keys: r,
      position: "left"
    }), n.length > 0 && n.forEach((a, l) => {
      const c = i.get(a);
      if (!(c && c.colId === a))
        return;
      const u = {
        type: "number",
        keys: [a],
        position: "right"
      }, h = r.some((f) => !!i.get(f)), p = l === n.length - 1;
      !h && p || (u.gridStyle = [{ stroke: void 0 }]), s.push(u);
    }), s;
  }
  getSeries(e) {
    const { fields: t, category: i, seriesChartTypes: r } = e;
    return t.map((n) => {
      const s = r.find((a) => a.colId === n.colId);
      if (s) {
        const a = s.chartType, c = ["groupedColumn", "groupedBar"].includes(a) ? { grouped: !0 } : {};
        return Object.assign({ type: pn(a), xKey: i.id, yKey: n.colId, yName: n.displayName, stacked: ["stackedArea", "stackedColumn"].includes(a) }, c);
      }
    });
  }
  getYKeys(e, t) {
    const i = [], r = [];
    return e.forEach((n) => {
      const s = n.colId, a = t.find((l) => l.colId === s);
      a && (a.secondaryAxis ? r.push(s) : i.push(s));
    }), { primaryYKeys: i, secondaryYKeys: r };
  }
}
var qo = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Wi extends X {
  constructor(e) {
    super(Wi.TEMPLATE), this.params = e;
  }
  init() {
    const e = this.gridOptionsService.get("chartThemes") || kO;
    if (e.length < 1)
      throw new Error("Cannot create chart: no chart themes are available to be used.");
    let { chartThemeName: t } = this.params;
    x.includes(e, t) || (t = e[0]);
    const i = {
      chartId: this.params.chartId,
      pivotChart: this.params.pivotChart,
      chartType: this.params.chartType,
      chartThemeName: t,
      aggFunc: this.params.aggFunc,
      cellRange: this.params.cellRange,
      suppressChartRanges: this.params.suppressChartRanges,
      unlinkChart: this.params.unlinkChart,
      crossFiltering: this.params.crossFiltering,
      seriesChartTypes: this.params.seriesChartTypes
    }, r = this.gridOptionsService.is("enableRtl");
    this.addCssClass(r ? "ag-rtl" : "ag-ltr");
    const n = this.createBean(new Io(i));
    this.chartController = this.createManagedBean(new Rt(n)), this.validateCustomThemes(), this.createChart(), this.params.insideDialog && this.addDialog(), this.addMenu(), this.addTitleEditComp(), this.addManagedListener(this.getGui(), "focusin", this.setActiveChartCellRange.bind(this)), this.addManagedListener(this.chartController, Rt.EVENT_CHART_MODEL_UPDATE, this.update.bind(this)), this.chartMenu && this.addManagedListener(this.chartMenu, mn.EVENT_DOWNLOAD_CHART, () => this.downloadChart()), this.update(), this.raiseChartCreatedEvent();
  }
  validateCustomThemes() {
    const e = this.getChartThemes(), t = this.gridOptionsService.get("customChartThemes");
    t && x.getAllKeysInObjects([t]).forEach((i) => {
      x.includes(e, i) || console.warn("AG Grid: a custom chart theme with the name '" + i + "' has been supplied but not added to the 'chartThemes' list");
    });
  }
  createChart() {
    let e;
    this.chartProxy && (e = this.chartProxy.destroy({ keepChartInstance: !0 }));
    const t = (s, a) => {
      const l = this.params.crossFilteringContext;
      l.lastSelectedChartId = a ? "" : this.chartController.getChartId(), a && this.params.crossFilteringResetCallback(), this.crossFilterService.filter(s, a);
    }, i = this.chartController.getChartType(), r = {
      chartType: i,
      chartInstance: e,
      getChartThemeName: this.getChartThemeName.bind(this),
      getChartThemes: this.getChartThemes.bind(this),
      customChartThemes: this.gridOptionsService.get("customChartThemes"),
      getGridOptionsChartThemeOverrides: () => this.getGridOptionsChartThemeOverrides(),
      getExtraPaddingDirections: () => {
        var s, a;
        return (a = (s = this.chartMenu) === null || s === void 0 ? void 0 : s.getExtraPaddingDirections()) !== null && a !== void 0 ? a : [];
      },
      apiChartThemeOverrides: this.params.chartThemeOverrides,
      crossFiltering: this.params.crossFiltering,
      crossFilterCallback: t,
      parentElement: this.eChart,
      grouping: this.chartController.isGrouping(),
      chartThemeToRestore: this.params.chartThemeName,
      chartOptionsToRestore: this.params.chartOptionsToRestore,
      chartPaletteToRestore: this.params.chartPaletteToRestore,
      seriesChartTypes: this.chartController.getSeriesChartTypes(),
      translate: (s, a) => this.chartTranslationService.translate(s, a)
    };
    if (this.params.chartOptionsToRestore = void 0, this.chartType = i, this.chartThemeName = this.chartController.getChartThemeName(), this.chartProxy = Wi.createChartProxy(r), !this.chartProxy) {
      console.warn("AG Grid: invalid chart type supplied: ", r.chartType);
      return;
    }
    const n = this.eChart.querySelector("canvas");
    n && n.classList.add("ag-charts-canvas"), this.chartController.setChartProxy(this.chartProxy), this.chartOptionsService = this.createBean(new Rw(this.chartController)), this.titleEdit && this.titleEdit.refreshTitle(this.chartController, this.chartOptionsService);
  }
  getChartThemeName() {
    return this.chartController.getChartThemeName();
  }
  getChartThemes() {
    return this.chartController.getThemes();
  }
  getGridOptionsChartThemeOverrides() {
    return this.gridOptionsService.get("chartThemeOverrides");
  }
  static createChartProxy(e) {
    switch (e.chartType) {
      case "column":
      case "bar":
      case "groupedColumn":
      case "stackedColumn":
      case "normalizedColumn":
      case "groupedBar":
      case "stackedBar":
      case "normalizedBar":
        return new uz(e);
      case "pie":
      case "doughnut":
        return new Ew(e);
      case "area":
      case "stackedArea":
      case "normalizedArea":
        return new hz(e);
      case "line":
        return new pz(e);
      case "scatter":
      case "bubble":
        return new fz(e);
      case "histogram":
        return new gz(e);
      case "columnLineCombo":
      case "areaColumnCombo":
      case "customCombo":
        return new vz(e);
      default:
        throw `AG Grid: Unable to create chart as an invalid chartType = '${e.chartType}' was supplied.`;
    }
  }
  addDialog() {
    const e = this.chartTranslationService.translate(this.params.pivotChart ? "pivotChartTitle" : "rangeChartTitle"), { width: t, height: i } = this.getBestDialogSize();
    this.chartDialog = new Kh({
      resizable: !0,
      movable: !0,
      maximizable: !0,
      title: e,
      width: t,
      height: i,
      component: this,
      centered: !0,
      closable: !0
    }), this.getContext().createBean(this.chartDialog), this.chartDialog.addEventListener(Kh.EVENT_DESTROYED, () => this.destroy());
  }
  getBestDialogSize() {
    const e = this.popupService.getPopupParent(), t = x.getAbsoluteWidth(e) * 0.75, i = x.getAbsoluteHeight(e) * 0.75, r = 0.553, n = this.chartProxy.getChart();
    let s = this.params.insideDialog ? 850 : n.width, a = this.params.insideDialog ? 470 : n.height;
    return (s > t || a > i) && (s = Math.min(s, t), a = Math.round(s * r), a > i && (a = i, s = Math.min(s, Math.round(a / r)))), { width: s, height: a };
  }
  addMenu() {
    this.params.crossFiltering || (this.chartMenu = this.createBean(new mn(this.eChartContainer, this.eMenuContainer, this.chartController, this.chartOptionsService)), this.eChartContainer.appendChild(this.chartMenu.getGui()));
  }
  addTitleEditComp() {
    this.titleEdit = this.createBean(new Wu(this.chartMenu)), this.eTitleEditContainer.appendChild(this.titleEdit.getGui()), this.chartProxy && this.titleEdit.refreshTitle(this.chartController, this.chartOptionsService);
  }
  update(e) {
    if (e != null && e.chartId && !this.chartController.update(e))
      return;
    this.chartTypeChanged(e) && this.createChart(), this.updateChart(e == null ? void 0 : e.chartThemeOverrides), e != null && e.chartId && this.chartProxy.getChart().waitForUpdate().then(() => {
      this.chartController.raiseChartApiUpdateEvent();
    });
  }
  updateChart(e) {
    const { chartProxy: t } = this, r = this.chartController.getSelectedValueColState().map((l) => ({ colId: l.colId, displayName: l.displayName })), n = this.chartController.getChartData();
    if (this.handleEmptyChart(n, r))
      return;
    let a = this.chartController.getChartUpdateParams(e);
    t.update(a), this.chartProxy.getChart().waitForUpdate().then(() => {
      this.chartController.raiseChartUpdatedEvent();
    }), this.titleEdit.refreshTitle(this.chartController, this.chartOptionsService);
  }
  chartTypeChanged(e) {
    const [t, i] = [this.chartController.getChartType(), e == null ? void 0 : e.chartType];
    return this.chartType !== t || !!i && this.chartType !== i;
  }
  getChartModel() {
    return this.chartController.getChartModel();
  }
  getChartImageDataURL(e) {
    return this.chartProxy.getChartImageDataURL(e);
  }
  handleEmptyChart(e, t) {
    const i = this.chartController.isPivotChart() && !this.chartController.isPivotMode();
    let r = 1;
    this.chartController.isActiveXYChart() && (r = this.chartController.getChartType() === "bubble" ? 3 : 2);
    const n = t.length < r || e.length === 0;
    if (this.eChart) {
      const s = i || n;
      x.setDisplayed(this.eChart, !s), x.setDisplayed(this.eEmpty, s);
    }
    return i ? (this.eEmpty.innerText = this.chartTranslationService.translate("pivotChartRequiresPivotMode"), !0) : n ? (this.eEmpty.innerText = this.chartTranslationService.translate("noDataToChart"), !0) : !1;
  }
  downloadChart(e, t, i) {
    this.chartProxy.downloadChart(e, t, i);
  }
  openChartToolPanel(e) {
    const t = e && fg[e];
    this.chartMenu.showMenu(t);
  }
  closeChartToolPanel() {
    this.chartMenu.hideMenu();
  }
  getChartId() {
    return this.chartController.getChartId();
  }
  getUnderlyingChart() {
    return this.chartProxy.getChartRef();
  }
  crossFilteringReset() {
    this.chartProxy.crossFilteringReset();
  }
  setActiveChartCellRange(e) {
    this.getGui().contains(e.relatedTarget) || (this.chartController.setChartRange(!0), this.gridApi.focusService.clearFocusedCell());
  }
  raiseChartCreatedEvent() {
    const e = {
      type: w.EVENT_CHART_CREATED,
      chartId: this.chartController.getChartId()
    };
    this.chartProxy.getChart().waitForUpdate().then(() => {
      this.eventService.dispatchEvent(e);
    });
  }
  raiseChartDestroyedEvent() {
    const e = {
      type: w.EVENT_CHART_DESTROYED,
      chartId: this.chartController.getChartId()
    };
    this.eventService.dispatchEvent(e);
  }
  destroy() {
    super.destroy(), this.chartProxy && this.chartProxy.destroy(), this.destroyBean(this.chartMenu), this.destroyBean(this.titleEdit), this.chartDialog && this.chartDialog.isAlive() && this.destroyBean(this.chartDialog);
    const e = this.getGui();
    x.clearElement(e), x.removeFromParent(e), this.raiseChartDestroyedEvent();
  }
}
Wi.TEMPLATE = `<div class="ag-chart" tabindex="-1">
            <div ref="eChartContainer" tabindex="-1" class="ag-chart-components-wrapper">
                <div ref="eChart" class="ag-chart-canvas-wrapper"></div>
                <div ref="eEmpty" class="ag-chart-empty-text ag-unselectable"></div>
            </div>
            <div ref="eTitleEditContainer"></div>
            <div ref="eMenuContainer" class="ag-chart-docked-container"></div>
        </div>`;
qo([
  L("eChart")
], Wi.prototype, "eChart", void 0);
qo([
  L("eChartContainer")
], Wi.prototype, "eChartContainer", void 0);
qo([
  L("eMenuContainer")
], Wi.prototype, "eMenuContainer", void 0);
qo([
  L("eEmpty")
], Wi.prototype, "eEmpty", void 0);
qo([
  L("eTitleEditContainer")
], Wi.prototype, "eTitleEditContainer", void 0);
qo([
  S("chartCrossFilterService")
], Wi.prototype, "crossFilterService", void 0);
qo([
  S("chartTranslationService")
], Wi.prototype, "chartTranslationService", void 0);
qo([
  S("gridApi")
], Wi.prototype, "gridApi", void 0);
qo([
  S("popupService")
], Wi.prototype, "popupService", void 0);
qo([
  B
], Wi.prototype, "init", null);
const yp = "30.0.5";
var ha = function(o, e) {
  var t = {};
  for (var i in o)
    Object.prototype.hasOwnProperty.call(o, i) && e.indexOf(i) < 0 && (t[i] = o[i]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(o); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(o, i[r]) && (t[i[r]] = o[i[r]]);
  return t;
};
function mz(o) {
  return o.version, o.version == null && (o.version = Pz(o)), o = gr("23.0.0", o, yz), o = gr("24.0.0", o, Cz), o = gr("25.1.0", o, Sz), o = gr("26.0.0", o, bz), o = gr("26.1.0", o, wz), o = gr("26.2.0", o, Ez), o = gr("28.0.0", o, Rz), o = gr("28.2.0", o, Tz), o = gr("29.0.0", o, xz), o = gr("29.1.0", o, iP), o = gr("29.2.0", o, rP), o = gr("30.0.0", o, Dz), o = Oz(o), o = gr(yp, o, (e) => e), o;
}
function yz(o) {
  return o = wo("chartOptions.legend.item.marker.type", "shape", o), o = wo("chartOptions.seriesDefaults.marker.type", "shape", o), o = wo("chartOptions.legend.padding", "spacing", o), o;
}
function Cz(o) {
  var e;
  o = Gi("chartOptions.seriesDefaults.marker.minSize", o);
  const t = o, { chartType: i, chartPalette: r } = t, n = t.chartOptions, { xAxis: s, yAxis: a } = n, l = ha(n, ["xAxis", "yAxis"]), c = ha(t, ["chartType", "chartPalette", "chartOptions"]), d = j$(i), u = d == null ? void 0 : d.map((h, p) => Object.assign({ type: h }, p === 0 ? s : a));
  return Object.assign({ chartType: i, chartThemeName: (e = Mz[r]) !== null && e !== void 0 ? e : "ag-default", chartOptions: Object.assign(Object.assign({}, l), {
    axes: u,
    xAxis: s,
    yAxis: a
  }) }, c);
}
function Sz(o) {
  return o = wo("chartOptions.seriesDefaults.label.minRequiredAngle", "minAngle", o), o;
}
function bz(o) {
  return o = gs("chartOptions.seriesDefaults.highlightStyle", o, (t) => {
    var { dimOpacity: i } = t, r = ha(t, ["dimOpacity"]);
    return Object.assign(Object.assign({}, r), i != null ? { series: { dimOpacity: i } } : {});
  }), o = Gi("chart", o), o = Gi("chartOptions.seriesDefaults.tooltipClass", o), o = Gi("chartOptions.seriesDefaults.tooltipTracking", o), o = qE("chartOptions.axes[].label.rotation", 0, o), o = qE("chartOptions.axes[].label.rotation", 335, o), o;
}
function wz(o) {
  const e = (t) => {
    var { item: i, series: r } = t, n = ha(t, ["item", "series"]);
    return Object.assign({ item: Object.assign(Object.assign({}, n), i) }, r ? { series: r } : {});
  };
  return o = gs("chartOptions.seriesDefaults.highlightStyle", o, e), o = gs("chartOptions.series[].highlightStyle", o, e), o;
}
function Ez(o) {
  o = Sg("chartOptions.seriesDefaults.fill.opacity", "chartOptions.seriesDefaults.fillOpacity", o), o = Sg("chartOptions.seriesDefaults.stroke.opacity", "chartOptions.seriesDefaults.strokeOpacity", o), o = Sg("chartOptions.seriesDefaults.stroke.width", "chartOptions.seriesDefaults.strokeWidth", o), o = Gi("chartOptions.seriesDefaults.fill", o), o = Gi("chartOptions.seriesDefaults.stroke", o), o = Gi("chartOptions.seriesDefaults.callout.colors", o), o = Gi("chartOptions.xAxis", o), o = Gi("chartOptions.yAxis", o);
  const e = o, { chartType: t } = e, i = e.chartOptions, { axes: r, series: n, seriesDefaults: s } = i, a = ha(i, ["axes", "series", "seriesDefaults"]), l = ha(e, ["chartType", "chartOptions"]), c = [pn(t)], d = {};
  if (!c.includes("pie")) {
    const h = { top: {}, bottom: {}, left: {}, right: {} }, p = r.map((f) => {
      var { type: g } = f, v = ha(f, ["type"]);
      return {
        [g]: Object.assign(Object.assign({}, h), v)
      };
    }).reduce(ZE, {});
    IO.filter((f) => p[f] == null).forEach((f) => {
      p[f] = Object.assign({}, h);
    }), d.axes = p;
  }
  const u = c.map((h) => ({
    [h]: Object.assign(Object.assign(Object.assign({}, d), { series: s }), a)
  })).reduce(ZE, {});
  return o = Object.assign(Object.assign({}, l), { chartType: t, chartOptions: u }), o;
}
function Rz(o) {
  return o = Gi("chartOptions.*.title.padding", o), o = Gi("chartOptions.*.subtitle.padding", o), o = Gi("chartOptions.*.axes.*.title.padding", o), o = Tw("chartOptions.*.axes.*.title.enabled", !1, o), o;
}
function Tz(o) {
  return o = wo("chartOptions.pie.series.callout", "calloutLine", o), o = wo("chartOptions.pie.series.label", "calloutLabel", o), o = wo("chartOptions.pie.series.labelKey", "sectorLabelKey", o), o = wo("chartOptions.pie.series.labelName", "sectorLabelName", o), o;
}
function xz(o) {
  return o = hh("chartOptions.scatter.series.fill", "chartOptions.scatter.series.marker.fill", o), o = hh("chartOptions.scatter.series.fillOpacity", "chartOptions.scatter.series.marker.fillOpacity", o), o = hh("chartOptions.scatter.series.stroke", "chartOptions.scatter.series.marker.stroke", o), o = hh("chartOptions.scatter.series.strokeOpacity", "chartOptions.scatter.series.marker.strokeOpacity", o), o = hh("chartOptions.scatter.series.strokeWidth", "chartOptions.scatter.series.marker.strokeWidth", o), o = Sg("chartOptions.scatter.series.paired", "chartOptions.scatter.paired", o), o;
}
function iP(o) {
  return o = Gi("chartOptions.axes[].tick.count", o), o;
}
function rP(o) {
  return o = gs("chartOptions.*.tooltip", o, (t) => {
    var i, r, n, s, { tracking: a } = t, l = ha(t, ["tracking"]);
    const c = Object.assign({}, l);
    return a === !1 ? ((i = c.position) !== null && i !== void 0 || (c.position = { type: "pointer" }), (r = c.range) !== null && r !== void 0 || (c.range = "nearest")) : a === !0 && ((n = c.position) !== null && n !== void 0 || (c.position = { type: "node" }), (s = c.range) !== null && s !== void 0 || (c.range = "nearest")), c;
  }), o;
}
function Dz(o) {
  return o = wo("chartOptions.pie.series.labelKey", "sectorLabelKey", o), o = wo("chartOptions.pie.series.labelName", "sectorLabelName", o), o = iP(o), o = rP(o), o = Gi("chartOptions.*.series.flipXY", o), o = nP("chartOptions.common.legend.enabled", !0, o), o = Tw("chartOptions.common.legend.position", "right", o), o;
}
function Oz(o) {
  return o = Gi("chartOptions.*.width", o), o = Gi("chartOptions.*.height", o), o = Tw("chartOptions.*.axes.category.label.autoRotate", !0, o), o;
}
function Pz(o) {
  var e, t;
  const i = o;
  if (o.version != null)
    return o.version;
  const r = (u, ...h) => Object.keys(u || {}).some((p) => h.includes(p)), n = i.chartOptions, s = r(n, "seriesDefaults") ? n == null ? void 0 : n.seriesDefaults : n == null ? void 0 : n[Object.keys(n)[0]], a = {
    "27.0.0": r(i, "seriesChartTypes"),
    "26.2.0": !r(n, "seriesDefaults"),
    "26.1.0": r(s == null ? void 0 : s.highlightStyle, "item"),
    "26.0.0": r(s == null ? void 0 : s.highlightStyle, "series"),
    // '26.0.0': modelAny.chart === undefined,
    "25.1.0": r(s == null ? void 0 : s.label, "minAngle"),
    "25.0.0": r(i, "modelType", "aggFunc", "unlinkChart", "suppressChartRanges") || r(s, "lineDash", "lineDashOffset"),
    "24.0.0": r(i, "chartThemeName", "chart") || r(n, "series"),
    "23.2.0": r(n, "navigator"),
    "23.0.0": r((t = (e = n == null ? void 0 : n.legend) === null || e === void 0 ? void 0 : e.item) === null || t === void 0 ? void 0 : t.marker, "shape"),
    "22.1.0": r(i, "chartPalette", "chartType")
  }, l = "27.1.0", c = Object.entries(a).filter(([u, h]) => h), [d = l] = c[0];
  return d;
}
function gr(o, e, t) {
  if (XE(o) > XE(e.version)) {
    const i = t(e);
    return i.version = o, i;
  }
  return e;
}
function Az(o) {
  const e = typeof o == "string" ? o.split(".").map((t) => Number(t)) : [];
  if (e.length !== 3 || e.some((t) => isNaN(t)))
    throw new Error("AG Grid - Illegal version string: " + o);
  return {
    major: e[0],
    minor: e[1],
    patch: e[2]
  };
}
function XE(o) {
  const { major: e, minor: t, patch: i } = Az(o);
  return e * 1e4 + t * 100 + i;
}
function qE(o, e, t) {
  return Ra(o, !0, t, (i, r) => {
    i[r] === e && delete i[r];
  });
}
function Tw(o, e, t) {
  return Ra(o, !1, t, (i, r) => {
    i[r] == null && (i[r] = e);
  });
}
function nP(o, e, t) {
  var i;
  typeof o == "string" && (o = o.split("."));
  const r = o[0];
  return o.length > 1 && (t[r] = nP(o.slice(1), e, (i = t[r]) !== null && i !== void 0 ? i : {})), Object.keys(t).includes(r) || (t[r] = e), t;
}
function Sg(o, e, t) {
  let i, r = !1;
  return t = Ra(o, !0, t, (n, s) => {
    r = !0, i = n[s], delete n[s];
  }), r ? Ra(e, !1, t, (n, s) => {
    n[s] = i;
  }) : t;
}
function hh(o, e, t) {
  let i, r = !1;
  return t = Ra(o, !0, t, (n, s) => {
    r = !0, i = n[s], delete n[s];
  }), r ? Ra(e, !1, t, (n, s) => {
    n[s] === void 0 && (n[s] = i);
  }) : t;
}
function wo(o, e, t) {
  return Ra(o, !0, t, (i, r) => {
    i[e] = i[r], delete i[r];
  });
}
function Gi(o, e) {
  return Ra(o, !0, e, (t, i) => delete t[i]);
}
function Ra(o, e, t, i) {
  const r = o instanceof Array ? o : o.split("."), n = r.slice(0, r.length - 1), s = r[r.length - 1];
  return gs(n, t, (a) => {
    const l = Object.keys(a).includes(s);
    if (e && !l)
      return a;
    const c = Object.assign({}, a);
    return i(c, s), c;
  });
}
function gs(o, e, t) {
  const i = o instanceof Array ? o : o.split(".");
  if (e = Object.assign({}, e), i.length === 0)
    return t(e);
  if (i[0].startsWith("{")) {
    const r = i[0].substring(1, i[0].lastIndexOf("}")).split(",");
    for (const n of r)
      e[n] != null && (e[n] = gs(i.slice(1), e[n], t));
  } else if (i[0].endsWith("[]")) {
    const r = i[0].substring(0, o[0].indexOf("["));
    e[r] instanceof Array && (e[r] = e[r].map((n) => gs(i.slice(1), n, t)));
  } else if (i[0] === "*")
    for (const r in e)
      e[r] = gs(i.slice(1), e[r], t);
  else
    e[i[0]] != null && (e[i[0]] = gs(i.slice(1), e[i[0]], t));
  return e;
}
const ZE = (o, e) => Object.assign(Object.assign({}, o), e), Mz = {
  borneo: "ag-default",
  material: "ag-material",
  pastel: "ag-pastel",
  bright: "ag-vivid",
  flat: "ag-solar"
};
var iy = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Ta = class extends H {
  constructor() {
    super(...arguments), this.activeCharts = /* @__PURE__ */ new Set(), this.activeChartComps = /* @__PURE__ */ new Set(), this.crossFilteringContext = {
      lastSelectedChartId: ""
    };
  }
  updateChart(e) {
    if (this.activeChartComps.size === 0) {
      console.warn("AG Grid - No active charts to update.");
      return;
    }
    const t = [...this.activeChartComps].find((i) => i.getChartId() === e.chartId);
    if (!t) {
      console.warn(`AG Grid - Unable to update chart. No active chart found with ID: ${e.chartId}.`);
      return;
    }
    t.update(e);
  }
  getChartModels() {
    const e = [], t = (i) => Object.assign(Object.assign({}, i), { version: yp });
    return this.activeChartComps.forEach((i) => e.push(t(i.getChartModel()))), e;
  }
  getChartRef(e) {
    let t;
    return this.activeCharts.forEach((i) => {
      i.chartId === e && (t = i);
    }), t;
  }
  getChartComp(e) {
    let t;
    return this.activeChartComps.forEach((i) => {
      i.getChartId() === e && (t = i);
    }), t;
  }
  getChartImageDataURL(e) {
    let t;
    return this.activeChartComps.forEach((i) => {
      i.getChartId() === e.chartId && (t = i.getChartImageDataURL(e.fileFormat));
    }), t;
  }
  downloadChart(e) {
    const t = Array.from(this.activeChartComps).find((i) => i.getChartId() === e.chartId);
    t == null || t.downloadChart(e.dimensions, e.fileName, e.fileFormat);
  }
  openChartToolPanel(e) {
    const t = Array.from(this.activeChartComps).find((i) => i.getChartId() === e.chartId);
    t == null || t.openChartToolPanel(e.panel);
  }
  closeChartToolPanel(e) {
    const t = Array.from(this.activeChartComps).find((i) => i.getChartId() === e);
    t == null || t.closeChartToolPanel();
  }
  createChartFromCurrentRange(e = "groupedColumn") {
    const t = this.getSelectedRange();
    return this.createChart(t, e);
  }
  restoreChart(e, t) {
    if (!e) {
      console.warn("AG Grid - unable to restore chart as no chart model is provided");
      return;
    }
    e.version !== yp && (e = mz(e));
    const i = {
      cellRange: e.cellRange,
      chartType: e.chartType,
      chartThemeName: e.chartThemeName,
      chartContainer: t,
      suppressChartRanges: e.suppressChartRanges,
      aggFunc: e.aggFunc,
      unlinkChart: e.unlinkChart,
      seriesChartTypes: e.seriesChartTypes
    }, r = (s) => this.rangeService ? this.rangeService.createCellRangeFromCellRangeParams(s) : void 0;
    if (e.modelType === "pivot") {
      this.columnModel.isPivotMode() || this.columnModel.setPivotMode(!0, "pivotChart");
      const a = {
        rowStartIndex: null,
        rowStartPinned: void 0,
        rowEndIndex: null,
        rowEndPinned: void 0,
        columns: this.columnModel.getAllDisplayedColumns().map((c) => c.getColId())
      }, l = r(a);
      if (!l) {
        console.warn("AG Grid - unable to create chart as there are no columns in the grid.");
        return;
      }
      return this.createChart(l, i.chartType, i.chartThemeName, !0, !0, i.chartContainer, void 0, void 0, i.unlinkChart, !1, e.chartOptions);
    }
    const n = r(i.cellRange);
    if (!n) {
      console.warn("AG Grid - unable to create chart as no range is selected");
      return;
    }
    return this.createChart(n, i.chartType, i.chartThemeName, !1, i.suppressChartRanges, i.chartContainer, i.aggFunc, void 0, i.unlinkChart, !1, e.chartOptions, e.chartPalette, i.seriesChartTypes);
  }
  createRangeChart(e) {
    var t;
    const i = (t = this.rangeService) === null || t === void 0 ? void 0 : t.createCellRangeFromCellRangeParams(e.cellRange);
    if (!i) {
      console.warn("AG Grid - unable to create chart as no range is selected");
      return;
    }
    return this.createChart(i, e.chartType, e.chartThemeName, !1, e.suppressChartRanges, e.chartContainer, e.aggFunc, e.chartThemeOverrides, e.unlinkChart, void 0, void 0, void 0, e.seriesChartTypes);
  }
  createPivotChart(e) {
    this.columnModel.isPivotMode() || this.columnModel.setPivotMode(!0, "pivotChart");
    const t = {
      rowStartIndex: null,
      rowStartPinned: void 0,
      rowEndIndex: null,
      rowEndPinned: void 0,
      columns: this.columnModel.getAllDisplayedColumns().map((r) => r.getColId())
    }, i = this.rangeService ? this.rangeService.createCellRangeFromCellRangeParams(t) : void 0;
    if (!i) {
      console.warn("AG Grid - unable to create chart as there are no columns in the grid.");
      return;
    }
    return this.createChart(i, e.chartType, e.chartThemeName, !0, !0, e.chartContainer, void 0, e.chartThemeOverrides, e.unlinkChart);
  }
  createCrossFilterChart(e) {
    var t;
    const i = (t = this.rangeService) === null || t === void 0 ? void 0 : t.createCellRangeFromCellRangeParams(e.cellRange);
    if (!i) {
      console.warn("AG Grid - unable to create chart as no range is selected");
      return;
    }
    const r = !0, s = typeof e.suppressChartRanges != "undefined" && e.suppressChartRanges !== null ? e.suppressChartRanges : !0;
    return this.createChart(i, e.chartType, e.chartThemeName, !1, s, e.chartContainer, e.aggFunc, e.chartThemeOverrides, e.unlinkChart, r);
  }
  createChart(e, t, i, r = !1, n = !1, s, a, l, c = !1, d = !1, u, h, p) {
    const f = this.gridOptionsService.getCallback("createChartContainer"), g = {
      chartId: this.generateId(),
      pivotChart: r,
      cellRange: e,
      chartType: t,
      chartThemeName: i,
      insideDialog: !(s || f),
      suppressChartRanges: n,
      aggFunc: a,
      chartThemeOverrides: l,
      unlinkChart: c,
      crossFiltering: d,
      crossFilteringContext: this.crossFilteringContext,
      chartOptionsToRestore: u,
      chartPaletteToRestore: h,
      seriesChartTypes: p,
      crossFilteringResetCallback: () => this.activeChartComps.forEach((m) => m.crossFilteringReset())
    }, v = new Wi(g);
    this.context.createBean(v);
    const y = this.createChartRef(v);
    if (s) {
      s.appendChild(v.getGui());
      const m = this.environment.getTheme();
      m.el && !m.el.contains(s) && s.classList.add(m.theme);
    } else
      f ? f(y) : v.addEventListener(Wi.EVENT_DESTROYED, () => {
        this.activeChartComps.delete(v), this.activeCharts.delete(y);
      });
    return y;
  }
  createChartRef(e) {
    const t = {
      destroyChart: () => {
        this.activeCharts.has(t) && (this.context.destroyBean(e), this.activeChartComps.delete(e), this.activeCharts.delete(t));
      },
      chartElement: e.getGui(),
      chart: e.getUnderlyingChart(),
      chartId: e.getChartModel().chartId
    };
    return this.activeCharts.add(t), this.activeChartComps.add(e), t;
  }
  getSelectedRange() {
    const e = this.rangeService.getCellRanges();
    return e.length > 0 ? e[0] : {};
  }
  generateId() {
    return `id-${Math.random().toString(36).substring(2, 18)}`;
  }
  destroyAllActiveCharts() {
    this.activeCharts.forEach((e) => e.destroyChart());
  }
};
Ta.CHARTS_VERSION = G$;
iy([
  Ve("rangeService")
], Ta.prototype, "rangeService", void 0);
iy([
  S("columnModel")
], Ta.prototype, "columnModel", void 0);
iy([
  dt
], Ta.prototype, "destroyAllActiveCharts", null);
Ta = iy([
  q("chartService")
], Ta);
var _z = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, nS;
let Sv = nS = class extends H {
  translate(e, t) {
    const i = this.localeService.getLocaleTextFunc(), r = nS.DEFAULT_TRANSLATIONS[e] || t;
    return i(e, r);
  }
};
Sv.DEFAULT_TRANSLATIONS = {
  pivotChartTitle: "Pivot Chart",
  rangeChartTitle: "Range Chart",
  settings: "Settings",
  data: "Data",
  format: "Format",
  categories: "Categories",
  defaultCategory: "(None)",
  series: "Series",
  xyValues: "X Y Values",
  paired: "Paired Mode",
  axis: "Axis",
  navigator: "Navigator",
  color: "Color",
  thickness: "Thickness",
  xType: "X Type",
  automatic: "Automatic",
  category: "Category",
  number: "Number",
  time: "Time",
  autoRotate: "Auto Rotate",
  xRotation: "X Rotation",
  yRotation: "Y Rotation",
  ticks: "Ticks",
  width: "Width",
  height: "Height",
  length: "Length",
  padding: "Padding",
  spacing: "Spacing",
  chart: "Chart",
  title: "Title",
  titlePlaceholder: "Chart title - double click to edit",
  background: "Background",
  font: "Font",
  top: "Top",
  right: "Right",
  bottom: "Bottom",
  left: "Left",
  labels: "Labels",
  calloutLabels: "Callout Labels",
  sectorLabels: "Sector Labels",
  positionRatio: "Position Ratio",
  size: "Size",
  shape: "Shape",
  minSize: "Minimum Size",
  maxSize: "Maximum Size",
  legend: "Legend",
  position: "Position",
  markerSize: "Marker Size",
  markerStroke: "Marker Stroke",
  markerPadding: "Marker Padding",
  itemSpacing: "Item Spacing",
  itemPaddingX: "Item Padding X",
  itemPaddingY: "Item Padding Y",
  layoutHorizontalSpacing: "Horizontal Spacing",
  layoutVerticalSpacing: "Vertical Spacing",
  strokeWidth: "Stroke Width",
  offset: "Offset",
  offsets: "Offsets",
  tooltips: "Tooltips",
  callout: "Callout",
  markers: "Markers",
  shadow: "Shadow",
  blur: "Blur",
  xOffset: "X Offset",
  yOffset: "Y Offset",
  lineWidth: "Line Width",
  lineDash: "Line Dash",
  normal: "Normal",
  bold: "Bold",
  italic: "Italic",
  boldItalic: "Bold Italic",
  predefined: "Predefined",
  fillOpacity: "Fill Opacity",
  strokeOpacity: "Line Opacity",
  histogramBinCount: "Bin count",
  columnGroup: "Column",
  barGroup: "Bar",
  pieGroup: "Pie",
  lineGroup: "Line",
  scatterGroup: "X Y (Scatter)",
  areaGroup: "Area",
  histogramGroup: "Histogram",
  combinationGroup: "Combination",
  groupedColumnTooltip: "Grouped",
  stackedColumnTooltip: "Stacked",
  normalizedColumnTooltip: "100% Stacked",
  groupedBarTooltip: "Grouped",
  stackedBarTooltip: "Stacked",
  normalizedBarTooltip: "100% Stacked",
  pieTooltip: "Pie",
  doughnutTooltip: "Doughnut",
  lineTooltip: "Line",
  groupedAreaTooltip: "Area",
  stackedAreaTooltip: "Stacked",
  normalizedAreaTooltip: "100% Stacked",
  scatterTooltip: "Scatter",
  bubbleTooltip: "Bubble",
  histogramTooltip: "Histogram",
  columnLineComboTooltip: "Column & Line",
  areaColumnComboTooltip: "Area & Column",
  customComboTooltip: "Custom Combination",
  noDataToChart: "No data available to be charted.",
  pivotChartRequiresPivotMode: "Pivot Chart requires Pivot Mode enabled.",
  chartSettingsToolbarTooltip: "Menu",
  chartLinkToolbarTooltip: "Linked to Grid",
  chartUnlinkToolbarTooltip: "Unlinked from Grid",
  chartDownloadToolbarTooltip: "Download Chart",
  histogramFrequency: "Frequency",
  seriesChartType: "Series Chart Type",
  seriesType: "Series Type",
  secondaryAxis: "Secondary Axis"
};
Sv = nS = _z([
  q("chartTranslationService")
], Sv);
var ry = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, bg;
let iu = bg = class extends H {
  filter(e, t = !1) {
    const i = this.gridApi.getFilterModel();
    if (t) {
      this.resetFilters(i);
      return;
    }
    let r = bg.extractFilterColId(e);
    this.isValidColumnFilter(r) ? this.updateFilters(i, e, r) : console.warn("AG Grid: cross filtering requires a 'agSetColumnFilter' or 'agMultiColumnFilter' to be defined on the column with id: '" + r + "'");
  }
  resetFilters(e) {
    Object.keys(e).length > 0 && (this.gridApi.setFilterModel(null), this.gridApi.onFilterChanged());
  }
  updateFilters(e, t, i) {
    let r = bg.extractFilterColId(t), n = t.datum[r];
    if (n === void 0)
      return;
    let s = n.toString();
    if (t.event.metaKey || t.event.ctrlKey) {
      const a = this.getCurrentGridValuesForCategory(i), l = x.includes(a, s);
      let c;
      l ? c = a.filter((d) => d !== s) : (c = a, c.push(s)), e[i] = this.getUpdatedFilterModel(i, c);
    } else {
      const a = [s];
      e = { [i]: this.getUpdatedFilterModel(i, a) };
    }
    this.gridApi.setFilterModel(e);
  }
  getUpdatedFilterModel(e, t) {
    return this.getColumnFilterType(e) === "agMultiColumnFilter" ? { filterType: "multi", filterModels: [null, { filterType: "set", values: t }] } : { filterType: "set", values: t };
  }
  getCurrentGridValuesForCategory(e) {
    let t = [];
    const i = this.getColumnById(e);
    return this.gridApi.forEachNodeAfterFilter((r) => {
      if (i && !r.group) {
        const n = this.valueService.getValue(i, r) + "";
        t.includes(n) || t.push(n);
      }
    }), t;
  }
  static extractFilterColId(e) {
    return e.xKey || e.calloutLabelKey;
  }
  isValidColumnFilter(e) {
    e.indexOf("-filtered-out") && (e = e.replace("-filtered-out", ""));
    let t = this.getColumnFilterType(e);
    return typeof t == "boolean" ? t : x.includes(["agSetColumnFilter", "agMultiColumnFilter"], t);
  }
  getColumnFilterType(e) {
    let t = this.getColumnById(e);
    if (t)
      return t.getColDef().filter;
  }
  getColumnById(e) {
    return this.columnModel.getGridColumn(e);
  }
};
ry([
  S("gridApi")
], iu.prototype, "gridApi", void 0);
ry([
  S("columnModel")
], iu.prototype, "columnModel", void 0);
ry([
  S("valueService")
], iu.prototype, "valueService", void 0);
iu = bg = ry([
  q("chartCrossFilterService")
], iu);
var Zo = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let yn = class extends H {
  constructor() {
    super(...arguments), this.cellRanges = [], this.bodyScrollListener = this.onBodyScroll.bind(this), this.dragging = !1, this.intersectionRange = !1;
  }
  init() {
    this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, () => this.onColumnsChanged()), this.addManagedListener(this.eventService, w.EVENT_COLUMN_VISIBLE, this.onColumnsChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_VALUE_CHANGED, this.onColumnsChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_MODE_CHANGED, () => this.removeAllCellRanges()), this.addManagedListener(this.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.removeAllCellRanges()), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_CHANGED, () => this.removeAllCellRanges()), this.addManagedListener(this.eventService, w.EVENT_COLUMN_GROUP_OPENED, this.refreshLastRangeStart.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_MOVED, this.refreshLastRangeStart.bind(this)), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PINNED, this.refreshLastRangeStart.bind(this)), this.ctrlsService.whenReady(() => {
      const e = this.ctrlsService.getGridBodyCtrl();
      this.autoScrollService = new Xv({
        scrollContainer: e.getBodyViewportElement(),
        scrollAxis: "xy",
        getVerticalPosition: () => e.getScrollFeature().getVScrollPosition().top,
        setVerticalPosition: (t) => e.getScrollFeature().setVerticalScrollPosition(t),
        getHorizontalPosition: () => e.getScrollFeature().getHScrollPosition().left,
        setHorizontalPosition: (t) => e.getScrollFeature().setHorizontalScrollPosition(t),
        shouldSkipVerticalScroll: () => !this.gridOptionsService.isDomLayout("normal"),
        shouldSkipHorizontalScroll: () => !e.getScrollFeature().isHorizontalScrollShowing()
      });
    });
  }
  // Called for both columns loaded & column visibility events
  onColumnsChanged() {
    this.refreshLastRangeStart();
    const e = this.columnModel.getAllDisplayedColumns();
    this.cellRanges.forEach((i) => {
      const r = i.columns;
      i.columns = i.columns.filter((s) => s.isVisible() && e.indexOf(s) !== -1), !x.areEqual(r, i.columns) && this.dispatchChangedEvent(!1, !0, i.id);
    });
    const t = this.cellRanges.length;
    this.cellRanges = this.cellRanges.filter((i) => i.columns.length > 0), t > this.cellRanges.length && this.dispatchChangedEvent(!1, !0);
  }
  refreshLastRangeStart() {
    const e = x.last(this.cellRanges);
    e && this.refreshRangeStart(e);
  }
  isContiguousRange(e) {
    const t = e.columns;
    if (!t.length)
      return !1;
    const i = this.columnModel.getAllDisplayedColumns(), r = t.map((n) => i.indexOf(n)).sort((n, s) => n - s);
    return x.last(r) - r[0] + 1 === t.length;
  }
  getRangeStartRow(e) {
    return e.startRow && e.endRow ? this.rowPositionUtils.before(e.startRow, e.endRow) ? e.startRow : e.endRow : { rowIndex: 0, rowPinned: this.pinnedRowModel.getPinnedTopRowCount() > 0 ? "top" : null };
  }
  getRangeEndRow(e) {
    if (e.startRow && e.endRow)
      return this.rowPositionUtils.before(e.startRow, e.endRow) ? e.endRow : e.startRow;
    const t = this.pinnedRowModel.getPinnedBottomRowCount();
    return t > 0 ? {
      rowIndex: t - 1,
      rowPinned: "bottom"
    } : {
      rowIndex: this.rowModel.getRowCount() - 1,
      rowPinned: null
    };
  }
  setRangeToCell(e, t = !1) {
    if (!this.gridOptionsService.isEnableRangeSelection())
      return;
    const i = this.calculateColumnsBetween(e.column, e.column);
    if (!i)
      return;
    (this.gridOptionsService.is("suppressMultiRangeSelection") || !t || x.missing(this.cellRanges)) && this.removeAllCellRanges(!0);
    const n = {
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned
    }, s = {
      startRow: n,
      endRow: n,
      columns: i,
      startColumn: e.column
    };
    this.cellRanges.push(s), this.setNewestRangeStartCell(e), this.onDragStop(), this.dispatchChangedEvent(!0, !0);
  }
  extendLatestRangeToCell(e) {
    if (this.isEmpty() || !this.newestRangeStartCell)
      return;
    const t = x.last(this.cellRanges);
    this.updateRangeEnd(t, e);
  }
  updateRangeEnd(e, t, i = !1) {
    const r = t.column, n = this.calculateColumnsBetween(e.startColumn, r);
    !n || this.isLastCellOfRange(e, t) || (e.columns = n, e.endRow = { rowIndex: t.rowIndex, rowPinned: t.rowPinned }, i || this.dispatchChangedEvent(!0, !0, e.id));
  }
  refreshRangeStart(e) {
    const { startColumn: t, columns: i } = e, r = (c, d) => {
      const u = e.columns.filter((h) => h !== c);
      c ? (e.startColumn = c, e.columns = d ? [c, ...u] : [...u, c]) : e.columns = u;
    }, { left: n, right: s } = this.getRangeEdgeColumns(e);
    if (t === i[0] && t !== n) {
      r(n, !0);
      return;
    }
    if (t === x.last(i) && t === s) {
      r(s, !1);
      return;
    }
  }
  getRangeEdgeColumns(e) {
    const t = this.columnModel.getAllDisplayedColumns(), i = e.columns.map((r) => t.indexOf(r)).filter((r) => r > -1).sort((r, n) => r - n);
    return {
      left: t[i[0]],
      right: t[x.last(i)]
    };
  }
  // returns true if successful, false if not successful
  extendLatestRangeInDirection(e) {
    if (this.isEmpty() || !this.newestRangeStartCell)
      return;
    const t = e.key, i = e.ctrlKey || e.metaKey, r = x.last(this.cellRanges), n = this.newestRangeStartCell, s = r.columns[0], a = x.last(r.columns), l = r.endRow.rowIndex, c = r.endRow.rowPinned, u = { column: n.column === s ? a : s, rowIndex: l, rowPinned: c }, h = this.cellNavigationService.getNextCellToFocus(t, u, i);
    if (h)
      return this.setCellRange({
        rowStartIndex: n.rowIndex,
        rowStartPinned: n.rowPinned,
        rowEndIndex: h.rowIndex,
        rowEndPinned: h.rowPinned,
        columnStart: n.column,
        columnEnd: h.column
      }), h;
  }
  setCellRange(e) {
    this.gridOptionsService.isEnableRangeSelection() && (this.removeAllCellRanges(!0), this.addCellRange(e));
  }
  setCellRanges(e) {
    x.shallowCompare(this.cellRanges, e) || (this.removeAllCellRanges(!0), e.forEach((t) => {
      t.columns && t.startRow && this.setNewestRangeStartCell({
        rowIndex: t.startRow.rowIndex,
        rowPinned: t.startRow.rowPinned,
        column: t.columns[0]
      }), this.cellRanges.push(t);
    }), this.dispatchChangedEvent(!1, !0));
  }
  setNewestRangeStartCell(e) {
    this.newestRangeStartCell = e;
  }
  clearCellRangeCellValues(e) {
    let { cellRanges: t } = e;
    const { cellEventSource: i = "rangeService", dispatchWrapperEvents: r, wrapperEventSource: n = "deleteKey" } = e;
    if (r) {
      const s = {
        type: w.EVENT_RANGE_DELETE_START,
        source: n
      };
      this.eventService.dispatchEvent(s);
    }
    if (t || (t = this.cellRanges), t.forEach((s) => {
      this.forEachRowInRange(s, (a) => {
        const l = this.rowPositionUtils.getRowNode(a);
        if (l)
          for (let c = 0; c < s.columns.length; c++) {
            const d = this.columnModel.getGridColumn(s.columns[c]);
            if (!d || !d.isCellEditable(l))
              return;
            l.setDataValue(d, null, i);
          }
      });
    }), r) {
      const s = {
        type: w.EVENT_RANGE_DELETE_END,
        source: n
      };
      this.eventService.dispatchEvent(s);
    }
  }
  createCellRangeFromCellRangeParams(e) {
    let t, i = !1;
    if (e.columns)
      t = e.columns.map((s) => this.columnModel.getColumnWithValidation(s)).filter((s) => s);
    else {
      const s = this.columnModel.getColumnWithValidation(e.columnStart), a = this.columnModel.getColumnWithValidation(e.columnEnd);
      if (!s || !a)
        return;
      t = this.calculateColumnsBetween(s, a), t && t.length && (i = t[0] !== s);
    }
    if (!t)
      return;
    const r = e.rowStartIndex != null ? {
      rowIndex: e.rowStartIndex,
      rowPinned: e.rowStartPinned || null
    } : void 0, n = e.rowEndIndex != null ? {
      rowIndex: e.rowEndIndex,
      rowPinned: e.rowEndPinned || null
    } : void 0;
    return {
      startRow: r,
      endRow: n,
      columns: t,
      startColumn: i ? x.last(t) : t[0]
    };
  }
  addCellRange(e) {
    if (!this.gridOptionsService.isEnableRangeSelection())
      return;
    const t = this.createCellRangeFromCellRangeParams(e);
    t && (t.startRow && this.setNewestRangeStartCell({
      rowIndex: t.startRow.rowIndex,
      rowPinned: t.startRow.rowPinned,
      column: t.startColumn
    }), this.cellRanges.push(t), this.dispatchChangedEvent(!1, !0, t.id));
  }
  getCellRanges() {
    return this.cellRanges;
  }
  isEmpty() {
    return this.cellRanges.length === 0;
  }
  isMoreThanOneCell() {
    const e = this.cellRanges.length;
    if (e === 0)
      return !1;
    if (e > 1)
      return !0;
    const t = this.cellRanges[0], i = this.getRangeStartRow(t), r = this.getRangeEndRow(t);
    return i.rowPinned !== r.rowPinned || i.rowIndex !== r.rowIndex || t.columns.length !== 1;
  }
  areAllRangesAbleToMerge() {
    const e = /* @__PURE__ */ new Map();
    if (this.cellRanges.length <= 1)
      return !0;
    this.cellRanges.forEach((r) => {
      this.forEachRowInRange(r, (n) => {
        const s = `${n.rowPinned || "normal"}_${n.rowIndex}`, a = e.get(s), l = r.columns.map((c) => c.getId());
        if (a) {
          const c = l.filter((d) => a.indexOf(d) === -1);
          a.push(...c);
        } else
          e.set(s, l);
      });
    });
    let i;
    for (const r of e.values()) {
      const n = r.sort().join();
      if (i === void 0) {
        i = n;
        continue;
      }
      if (i !== n)
        return !1;
    }
    return !0;
  }
  forEachRowInRange(e, t) {
    const i = this.getRangeStartRow(e), r = this.getRangeEndRow(e);
    let n = i;
    for (; n && (t(n), !this.rowPositionUtils.sameRow(n, r)); )
      n = this.cellNavigationService.getRowBelow(n);
  }
  removeAllCellRanges(e) {
    this.isEmpty() || (this.onDragStop(), this.cellRanges.length = 0, e || this.dispatchChangedEvent(!1, !0));
  }
  // as the user is dragging outside of the panel, the div starts to scroll, which in turn
  // means we are selection more (or less) cells, but the mouse isn't moving, so we recalculate
  // the selection my mimicking a new mouse event
  onBodyScroll() {
    this.dragging && this.lastMouseEvent && this.onDragging(this.lastMouseEvent);
  }
  isCellInAnyRange(e) {
    return this.getCellRangeCount(e) > 0;
  }
  isCellInSpecificRange(e, t) {
    const i = t.columns !== null && x.includes(t.columns, e.column), r = this.isRowInRange(e.rowIndex, e.rowPinned, t);
    return i && r;
  }
  isLastCellOfRange(e, t) {
    const { startRow: i, endRow: r } = e, n = this.rowPositionUtils.before(i, r) ? r : i, s = t.rowIndex === n.rowIndex && t.rowPinned === n.rowPinned, a = e.columns[0], l = x.last(e.columns), c = e.startColumn === a ? l : a;
    return t.column === c && s;
  }
  isBottomRightCell(e, t) {
    const i = this.columnModel.getAllDisplayedColumns(), r = e.columns.map((d) => i.indexOf(d)).sort((d, u) => d - u), { startRow: n, endRow: s } = e, a = this.rowPositionUtils.before(n, s) ? s : n, l = i.indexOf(t.column) === x.last(r), c = t.rowIndex === a.rowIndex && x.makeNull(t.rowPinned) === x.makeNull(a.rowPinned);
    return l && c;
  }
  // returns the number of ranges this cell is in
  getCellRangeCount(e) {
    return this.isEmpty() ? 0 : this.cellRanges.filter((t) => this.isCellInSpecificRange(e, t)).length;
  }
  isRowInRange(e, t, i) {
    const r = this.getRangeStartRow(i), n = this.getRangeEndRow(i), s = { rowIndex: e, rowPinned: t || null }, a = s.rowIndex === r.rowIndex && s.rowPinned == r.rowPinned, l = s.rowIndex === n.rowIndex && s.rowPinned == n.rowPinned;
    if (a || l)
      return !0;
    const c = !this.rowPositionUtils.before(s, r), d = this.rowPositionUtils.before(s, n);
    return c && d;
  }
  getDraggingRange() {
    return this.draggingRange;
  }
  onDragStart(e) {
    if (!this.gridOptionsService.isEnableRangeSelection())
      return;
    const { ctrlKey: t, metaKey: i, shiftKey: r } = e, n = t || i, a = !this.gridOptionsService.is("suppressMultiRangeSelection") ? n : !1, l = r && x.existsAndNotEmpty(this.cellRanges);
    !a && (!l || x.exists(x.last(this.cellRanges).type)) && this.removeAllCellRanges(!0);
    const c = this.dragService.getStartTarget();
    if (c && this.updateValuesOnMove(c), !!this.lastCellHovered) {
      if (this.dragging = !0, this.lastMouseEvent = e, this.intersectionRange = a && this.getCellRangeCount(this.lastCellHovered) > 1, l || this.setNewestRangeStartCell(this.lastCellHovered), this.cellRanges.length > 0)
        this.draggingRange = x.last(this.cellRanges);
      else {
        const d = {
          rowIndex: this.lastCellHovered.rowIndex,
          rowPinned: this.lastCellHovered.rowPinned
        };
        this.draggingRange = {
          startRow: d,
          endRow: d,
          columns: [this.lastCellHovered.column],
          startColumn: this.newestRangeStartCell.column
        }, this.cellRanges.push(this.draggingRange);
      }
      this.ctrlsService.getGridBodyCtrl().addScrollEventListener(this.bodyScrollListener), this.dispatchChangedEvent(!0, !1, this.draggingRange.id);
    }
  }
  intersectLastRange(e) {
    if (e && this.dragging || this.gridOptionsService.is("suppressMultiRangeSelection") || this.isEmpty())
      return;
    const t = x.last(this.cellRanges), i = this.getRangeStartRow(t), r = this.getRangeEndRow(t), n = [];
    this.cellRanges.slice(0, -1).forEach((s) => {
      const a = this.getRangeStartRow(s), l = this.getRangeEndRow(s), c = s.columns, d = c.filter((h) => t.columns.indexOf(h) === -1);
      if (d.length === c.length) {
        n.push(s);
        return;
      }
      if (this.rowPositionUtils.before(r, a) || this.rowPositionUtils.before(l, i)) {
        n.push(s);
        return;
      }
      const u = n.length;
      if (this.rowPositionUtils.before(a, i)) {
        const h = {
          columns: [...c],
          startColumn: t.startColumn,
          startRow: Object.assign({}, a),
          endRow: this.cellNavigationService.getRowAbove(i)
        };
        n.push(h);
      }
      if (d.length > 0) {
        const h = {
          columns: d,
          startColumn: x.includes(d, t.startColumn) ? t.startColumn : d[0],
          startRow: this.rowPositionUtils.rowMax([Object.assign({}, i), Object.assign({}, a)]),
          endRow: this.rowPositionUtils.rowMin([Object.assign({}, r), Object.assign({}, l)])
        };
        n.push(h);
      }
      this.rowPositionUtils.before(r, l) && n.push({
        columns: [...c],
        startColumn: t.startColumn,
        startRow: this.cellNavigationService.getRowBelow(r),
        endRow: Object.assign({}, l)
      }), n.length - u === 1 && (n[n.length - 1].id = s.id);
    }), this.cellRanges = n, e && this.dispatchChangedEvent(!1, !0);
  }
  updateValuesOnMove(e) {
    const t = x.getCtrlForEventTarget(this.gridOptionsService, e, un.DOM_DATA_KEY_CELL_CTRL), i = t == null ? void 0 : t.getCellPosition();
    this.cellHasChanged = !1, !(!i || this.lastCellHovered && this.cellPositionUtils.equals(i, this.lastCellHovered)) && (this.lastCellHovered && (this.cellHasChanged = !0), this.lastCellHovered = i);
  }
  onDragging(e) {
    if (!this.dragging || !e)
      return;
    this.updateValuesOnMove(e.target), this.lastMouseEvent = e;
    const t = this.lastCellHovered, i = (s) => t && t.rowPinned === s && this.newestRangeStartCell.rowPinned === s, r = i("top") || i("bottom");
    if (this.autoScrollService.check(e, r), !this.cellHasChanged)
      return;
    const n = this.calculateColumnsBetween(this.newestRangeStartCell.column, t.column);
    n && (this.draggingRange.endRow = {
      rowIndex: t.rowIndex,
      rowPinned: t.rowPinned
    }, this.draggingRange.columns = n, this.dispatchChangedEvent(!1, !1, this.draggingRange.id));
  }
  onDragStop() {
    if (!this.dragging)
      return;
    const { id: e } = this.draggingRange;
    this.autoScrollService.ensureCleared(), this.ctrlsService.getGridBodyCtrl().removeScrollEventListener(this.bodyScrollListener), this.lastMouseEvent = null, this.dragging = !1, this.draggingRange = void 0, this.lastCellHovered = void 0, this.intersectionRange && (this.intersectionRange = !1, this.intersectLastRange()), this.dispatchChangedEvent(!1, !0, e);
  }
  dispatchChangedEvent(e, t, i) {
    const r = {
      type: w.EVENT_RANGE_SELECTION_CHANGED,
      started: e,
      finished: t,
      id: i
    };
    this.eventService.dispatchEvent(r);
  }
  calculateColumnsBetween(e, t) {
    const i = this.columnModel.getAllDisplayedColumns(), r = e === t, n = i.indexOf(e);
    if (n < 0) {
      console.warn(`AG Grid: column ${e.getId()} is not visible`);
      return;
    }
    const s = r ? n : i.indexOf(t);
    if (s < 0) {
      console.warn(`AG Grid: column ${t.getId()} is not visible`);
      return;
    }
    if (r)
      return [e];
    const a = Math.min(n, s), l = a === n ? s : n, c = [];
    for (let d = a; d <= l; d++)
      c.push(i[d]);
    return c;
  }
};
Zo([
  S("rowModel")
], yn.prototype, "rowModel", void 0);
Zo([
  S("dragService")
], yn.prototype, "dragService", void 0);
Zo([
  S("columnModel")
], yn.prototype, "columnModel", void 0);
Zo([
  S("cellNavigationService")
], yn.prototype, "cellNavigationService", void 0);
Zo([
  S("pinnedRowModel")
], yn.prototype, "pinnedRowModel", void 0);
Zo([
  S("rowPositionUtils")
], yn.prototype, "rowPositionUtils", void 0);
Zo([
  S("cellPositionUtils")
], yn.prototype, "cellPositionUtils", void 0);
Zo([
  S("ctrlsService")
], yn.prototype, "ctrlsService", void 0);
Zo([
  B
], yn.prototype, "init", null);
yn = Zo([
  q("rangeService")
], yn);
var to = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class zr extends X {
  constructor() {
    super(...arguments), this.changedCalculatedValues = !1, this.dragging = !1, this.shouldDestroyOnEndDragging = !1;
  }
  init() {
    this.dragService.addDragSource({
      dragStartPixels: 0,
      eElement: this.getGui(),
      onDragStart: this.onDragStart.bind(this),
      onDragging: (e) => {
        this.dragging = !0, this.rangeService.autoScrollService.check(e), this.changedCalculatedValues && (this.onDrag(e), this.changedCalculatedValues = !1);
      },
      onDragStop: (e) => {
        this.dragging = !1, this.onDragEnd(e), this.clearValues(), this.rangeService.autoScrollService.ensureCleared(), document.body.classList.remove(this.getDraggingCssClass()), this.shouldDestroyOnEndDragging && this.destroy();
      }
    }), this.addManagedListener(this.getGui(), "mousedown", this.preventRangeExtension.bind(this));
  }
  isDragging() {
    return this.dragging;
  }
  getCellCtrl() {
    return this.cellCtrl;
  }
  setCellCtrl(e) {
    this.cellCtrl = e;
  }
  getCellRange() {
    return this.cellRange;
  }
  setCellRange(e) {
    this.cellRange = e;
  }
  getRangeStartRow() {
    return this.rangeStartRow;
  }
  setRangeStartRow(e) {
    this.rangeStartRow = e;
  }
  getRangeEndRow() {
    return this.rangeEndRow;
  }
  setRangeEndRow(e) {
    this.rangeEndRow = e;
  }
  getLastCellHovered() {
    return this.lastCellHovered;
  }
  preventRangeExtension(e) {
    e.stopPropagation();
  }
  onDragStart(e) {
    this.cellHoverListener = this.addManagedListener(this.ctrlsService.getGridCtrl().getGui(), "mousemove", this.updateValuesOnMove.bind(this)), document.body.classList.add(this.getDraggingCssClass());
  }
  getDraggingCssClass() {
    return `ag-dragging-${this.type === ga.FILL ? "fill" : "range"}-handle`;
  }
  updateValuesOnMove(e) {
    const t = this.mouseEventService.getCellPositionForEvent(e);
    !t || this.lastCellHovered && this.cellPositionUtils.equals(t, this.lastCellHovered) || (this.lastCellHovered = t, this.changedCalculatedValues = !0);
  }
  getType() {
    return this.type;
  }
  refresh(e) {
    const t = this.getCellCtrl(), i = this.getGui(), r = x.last(this.rangeService.getCellRanges()), n = r.startRow, s = r.endRow;
    if (n && s && (this.rowPositionUtils.before(s, n) ? (this.setRangeStartRow(s), this.setRangeEndRow(n)) : (this.setRangeStartRow(n), this.setRangeEndRow(s))), t !== e || !x.isVisible(i)) {
      this.setCellCtrl(e);
      const a = e.getComp().getParentOfValue();
      a && a.appendChild(i);
    }
    this.setCellRange(r);
  }
  clearValues() {
    this.lastCellHovered = void 0, this.removeListeners();
  }
  removeListeners() {
    this.cellHoverListener && (this.cellHoverListener(), this.cellHoverListener = void 0);
  }
  destroy() {
    if (!this.shouldDestroyOnEndDragging && this.isDragging()) {
      x.setDisplayed(this.getGui(), !1), this.shouldDestroyOnEndDragging = !0;
      return;
    }
    this.shouldDestroyOnEndDragging = !1, super.destroy(), this.removeListeners();
    const e = this.getGui();
    e.parentElement && e.parentElement.removeChild(e);
  }
}
to([
  S("rowRenderer")
], zr.prototype, "rowRenderer", void 0);
to([
  S("dragService")
], zr.prototype, "dragService", void 0);
to([
  S("rangeService")
], zr.prototype, "rangeService", void 0);
to([
  S("mouseEventService")
], zr.prototype, "mouseEventService", void 0);
to([
  S("columnModel")
], zr.prototype, "columnModel", void 0);
to([
  S("cellNavigationService")
], zr.prototype, "cellNavigationService", void 0);
to([
  S("navigationService")
], zr.prototype, "navigationService", void 0);
to([
  S("rowPositionUtils")
], zr.prototype, "rowPositionUtils", void 0);
to([
  S("cellPositionUtils")
], zr.prototype, "cellPositionUtils", void 0);
to([
  S("ctrlsService")
], zr.prototype, "ctrlsService", void 0);
to([
  B
], zr.prototype, "init", null);
function Iz(o) {
  const e = o.length;
  let t = 0;
  if (e <= 1)
    return o;
  for (let u = 0; u < o.length; u++) {
    const h = o[u], p = h.toString().split("e-");
    if (p.length > 1) {
      t = Math.max(t, parseInt(p[1], 10));
      continue;
    }
    Math.floor(h) !== h && (t = Math.max(t, h.toString().split(".")[1].length));
  }
  let i = 0, r = 0, n = 0, s = 0, a = 0;
  for (let u = 0; u < e; u++)
    a = o[u], i += u, r += a, s += u * u, n += u * a;
  const l = (e * n - i * r) / (e * s - i * i), c = r / e - l * i / e, d = [];
  for (let u = 0; u <= e; u++)
    d.push(parseFloat((u * l + c).toFixed(t)));
  return d;
}
var xw = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class sl extends zr {
  constructor() {
    super(sl.TEMPLATE), this.markedCells = [], this.cellValues = [], this.isUp = !1, this.isLeft = !1, this.isReduce = !1, this.type = ga.FILL;
  }
  updateValuesOnMove(e) {
    super.updateValuesOnMove(e), this.initialXY || (this.initialXY = this.mouseEventService.getNormalisedPosition(e));
    const { x: t, y: i } = this.initialXY, { x: r, y: n } = this.mouseEventService.getNormalisedPosition(e), s = Math.abs(t - r), a = Math.abs(i - n), l = this.getFillHandleDirection();
    let c;
    l === "xy" ? c = s > a ? "x" : "y" : c = l, c !== this.dragAxis && (this.dragAxis = c, this.changedCalculatedValues = !0);
  }
  onDrag(e) {
    if (!this.initialPosition) {
      const i = this.getCellCtrl();
      if (!i)
        return;
      this.initialPosition = i.getCellPosition();
    }
    const t = this.getLastCellHovered();
    t && this.markPathFrom(this.initialPosition, t);
  }
  onDragEnd(e) {
    if (this.initialXY = null, !this.markedCells.length)
      return;
    const t = this.dragAxis === "x", i = this.getCellRange(), r = i.columns.length, n = this.getRangeStartRow(), s = this.getRangeEndRow();
    let a;
    if (!this.isUp && !this.isLeft)
      a = this.rangeService.createCellRangeFromCellRangeParams({
        rowStartIndex: n.rowIndex,
        rowStartPinned: n.rowPinned,
        columnStart: i.columns[0],
        rowEndIndex: t ? s.rowIndex : this.lastCellMarked.rowIndex,
        rowEndPinned: t ? s.rowPinned : this.lastCellMarked.rowPinned,
        columnEnd: t ? this.lastCellMarked.column : i.columns[r - 1]
      });
    else {
      const l = t ? n : this.lastCellMarked;
      a = this.rangeService.createCellRangeFromCellRangeParams({
        rowStartIndex: l.rowIndex,
        rowStartPinned: l.rowPinned,
        columnStart: t ? this.lastCellMarked.column : i.columns[0],
        rowEndIndex: s.rowIndex,
        rowEndPinned: s.rowPinned,
        columnEnd: i.columns[r - 1]
      });
    }
    a && (this.raiseFillStartEvent(), this.handleValueChanged(i, a, e), this.rangeService.setCellRanges([a]), this.raiseFillEndEvent(i, a));
  }
  getFillHandleDirection() {
    const e = this.gridOptionsService.get("fillHandleDirection");
    return e ? e !== "x" && e !== "y" && e !== "xy" ? (x.doOnce(() => console.warn("AG Grid: valid values for fillHandleDirection are 'x', 'y' and 'xy'. Default to 'xy'."), "warn invalid fill direction"), "xy") : e : "xy";
  }
  raiseFillStartEvent() {
    const e = {
      type: w.EVENT_FILL_START
    };
    this.eventService.dispatchEvent(e);
  }
  raiseFillEndEvent(e, t) {
    const i = {
      type: w.EVENT_FILL_END,
      initialRange: e,
      finalRange: t
    };
    this.eventService.dispatchEvent(i);
  }
  handleValueChanged(e, t, i) {
    const r = this.rangeService.getRangeEndRow(e), n = this.rangeService.getRangeStartRow(e), s = this.rangeService.getRangeEndRow(t), a = this.rangeService.getRangeStartRow(t), l = this.dragAxis === "y";
    if (this.isReduce && !this.gridOptionsService.is("suppressClearOnFillReduction")) {
      const v = l ? e.columns : e.columns.filter((m) => t.columns.indexOf(m) < 0), y = l ? this.cellNavigationService.getRowBelow(s) : a;
      y && this.clearCellsInRange(y, r, v);
      return;
    }
    let c = !0;
    const d = [], u = [];
    let h = 0;
    const p = () => {
      d.length = 0, u.length = 0, h = 0;
    }, f = (v, y) => {
      let m = this.isUp ? r : n, C = !1;
      for (l && (c = !0, p()); !C && m; ) {
        const R = this.rowPositionUtils.getRowNode(m);
        if (!R)
          break;
        l && v ? g(d, v, R, () => !this.rowPositionUtils.sameRow(m, this.isUp ? n : r)) : y && (c = !0, p(), y.forEach((E) => g(d, E, R, () => E !== (this.isLeft ? e.columns[0] : x.last(e.columns))))), C = this.rowPositionUtils.sameRow(m, this.isUp ? a : s), m = this.isUp ? this.cellNavigationService.getRowAbove(m) : this.cellNavigationService.getRowBelow(m);
      }
    }, g = (v, y, m, C) => {
      var R, E;
      let b, T = !1;
      if (c)
        b = this.valueService.getValue(y, m), u.push(b), c = C();
      else {
        const { value: D, fromUserFunction: P, sourceCol: O, sourceRowNode: M } = this.processValues(i, v, u, y, m, h++);
        if (b = D, y.isCellEditable(m)) {
          const _ = this.valueService.getValue(y, m);
          P || (!((R = O == null ? void 0 : O.getColDef()) === null || R === void 0) && R.useValueFormatterForExport && (b = (E = this.valueFormatterService.formatValue(O, M, b)) !== null && E !== void 0 ? E : b), y.getColDef().useValueParserForImport && (b = this.valueParserService.parseValue(
            y,
            m,
            // if no sourceCol, then currentValue is a number
            O ? b : x.toStringOrNull(b),
            _
          ))), !P || _ !== b ? m.setDataValue(y, b, "rangeService") : T = !0;
        }
      }
      T || v.push({
        value: b,
        column: y,
        rowNode: m
      });
    };
    if (l)
      e.columns.forEach((v) => {
        f(v);
      });
    else {
      const v = this.isLeft ? [...t.columns].reverse() : t.columns;
      f(void 0, v);
    }
  }
  clearCellsInRange(e, t, i) {
    const r = {
      startRow: e,
      endRow: t,
      columns: i,
      startColumn: i[0]
    };
    this.rangeService.clearCellRangeCellValues({ cellRanges: [r] });
  }
  processValues(e, t, i, r, n, s) {
    const a = this.gridOptionsService.getCallback("fillOperation"), l = this.dragAxis === "y";
    let c;
    if (l ? c = this.isUp ? "up" : "down" : c = this.isLeft ? "left" : "right", a) {
      const u = {
        event: e,
        values: t.map(({ value: p }) => p),
        initialValues: i,
        currentIndex: s,
        currentCellValue: this.valueService.getValue(r, n),
        direction: c,
        column: r,
        rowNode: n
      }, h = a(u);
      if (h !== !1)
        return { value: h, fromUserFunction: !0 };
    }
    const d = !t.some(({ value: u }) => {
      const h = parseFloat(u);
      return isNaN(h) || h.toString() !== u.toString();
    });
    if (e.altKey || !d) {
      if (d && i.length === 1) {
        const f = this.isUp || this.isLeft ? -1 : 1;
        return { value: parseFloat(x.last(t).value) + 1 * f, fromUserFunction: !1 };
      }
      const { value: u, column: h, rowNode: p } = t[s % t.length];
      return { value: u, fromUserFunction: !1, sourceCol: h, sourceRowNode: p };
    }
    return { value: x.last(Iz(t.map(({ value: u }) => Number(u)))), fromUserFunction: !1 };
  }
  clearValues() {
    this.clearMarkedPath(), this.clearCellValues(), this.lastCellMarked = void 0, super.clearValues();
  }
  clearMarkedPath() {
    this.markedCells.forEach((e) => {
      if (!e.isAlive())
        return;
      const t = e.getComp();
      t.addOrRemoveCssClass("ag-selection-fill-top", !1), t.addOrRemoveCssClass("ag-selection-fill-right", !1), t.addOrRemoveCssClass("ag-selection-fill-bottom", !1), t.addOrRemoveCssClass("ag-selection-fill-left", !1);
    }), this.markedCells.length = 0, this.isUp = !1, this.isLeft = !1, this.isReduce = !1;
  }
  clearCellValues() {
    this.cellValues.length = 0;
  }
  markPathFrom(e, t) {
    if (this.clearMarkedPath(), this.clearCellValues(), this.dragAxis === "y") {
      if (this.rowPositionUtils.sameRow(t, e))
        return;
      const i = this.rowPositionUtils.before(t, e), r = this.getRangeStartRow(), n = this.getRangeEndRow();
      i && (t.rowPinned == r.rowPinned && t.rowIndex >= r.rowIndex || r.rowPinned != n.rowPinned && t.rowPinned == n.rowPinned && t.rowIndex <= n.rowIndex) ? (this.reduceVertical(e, t), this.isReduce = !0) : (this.extendVertical(e, t, i), this.isReduce = !1);
    } else {
      const i = e.column, r = t.column;
      if (i === r)
        return;
      const n = this.columnModel.getAllDisplayedColumns(), s = n.indexOf(i), a = n.indexOf(r);
      a <= s && a >= n.indexOf(this.getCellRange().columns[0]) ? (this.reduceHorizontal(e, t), this.isReduce = !0) : (this.extendHorizontal(e, t, a < s), this.isReduce = !1);
    }
    this.lastCellMarked = t;
  }
  extendVertical(e, t, i) {
    const { navigationService: r, rangeService: n } = this;
    let s = e;
    do {
      const a = this.getCellRange(), l = a.columns.length;
      for (let c = 0; c < l; c++) {
        const d = a.columns[c], u = { rowIndex: s.rowIndex, rowPinned: s.rowPinned }, h = Object.assign(Object.assign({}, u), { column: d }), p = n.isCellInSpecificRange(h, a), f = this.rowPositionUtils.sameRow(s, e);
        if (i && (this.isUp = !0), !f) {
          const g = r.getCellByPosition(h);
          if (g) {
            this.markedCells.push(g);
            const v = g.getComp();
            p || (v.addOrRemoveCssClass("ag-selection-fill-left", c === 0), v.addOrRemoveCssClass("ag-selection-fill-right", c === l - 1)), v.addOrRemoveCssClass(i ? "ag-selection-fill-top" : "ag-selection-fill-bottom", this.rowPositionUtils.sameRow(s, t));
          }
        }
      }
      if (this.rowPositionUtils.sameRow(s, t))
        break;
    } while (
      // tslint:disable-next-line
      s = i ? this.cellNavigationService.getRowAbove(s) : this.cellNavigationService.getRowBelow(s)
    );
  }
  reduceVertical(e, t) {
    let i = e;
    do {
      const r = this.getCellRange(), n = r.columns.length, s = this.rowPositionUtils.sameRow(i, t);
      for (let a = 0; a < n; a++) {
        const l = { rowIndex: i.rowIndex, rowPinned: i.rowPinned }, c = Object.assign(Object.assign({}, l), { column: r.columns[a] }), d = this.navigationService.getCellByPosition(c);
        d && (this.markedCells.push(d), d.getComp().addOrRemoveCssClass("ag-selection-fill-bottom", this.rowPositionUtils.sameRow(i, t)));
      }
      if (s)
        break;
    } while (i = this.cellNavigationService.getRowAbove(i));
  }
  extendHorizontal(e, t, i) {
    const r = this.columnModel.getAllDisplayedColumns(), n = r.indexOf(i ? t.column : e.column), s = r.indexOf(i ? this.getCellRange().columns[0] : t.column), a = i ? 0 : 1, l = r.slice(n + a, s + a), c = this.getRangeStartRow(), d = this.getRangeEndRow();
    l.forEach((u) => {
      let h = c, p = !1;
      do {
        p = this.rowPositionUtils.sameRow(h, d);
        const f = this.navigationService.getCellByPosition({
          rowIndex: h.rowIndex,
          rowPinned: h.rowPinned,
          column: u
        });
        if (f) {
          this.markedCells.push(f);
          const g = f.getComp();
          g.addOrRemoveCssClass("ag-selection-fill-top", this.rowPositionUtils.sameRow(h, c)), g.addOrRemoveCssClass("ag-selection-fill-bottom", this.rowPositionUtils.sameRow(h, d)), i ? (this.isLeft = !0, g.addOrRemoveCssClass("ag-selection-fill-left", u === l[0])) : g.addOrRemoveCssClass("ag-selection-fill-right", u === x.last(l));
        }
        h = this.cellNavigationService.getRowBelow(h);
      } while (!p);
    });
  }
  reduceHorizontal(e, t) {
    const i = this.columnModel.getAllDisplayedColumns(), r = i.indexOf(t.column), n = i.indexOf(e.column), s = i.slice(r, n), a = this.getRangeStartRow(), l = this.getRangeEndRow();
    s.forEach((c) => {
      let d = a, u = !1;
      do {
        u = this.rowPositionUtils.sameRow(d, l);
        const h = this.navigationService.getCellByPosition({
          rowIndex: d.rowIndex,
          rowPinned: d.rowPinned,
          column: c
        });
        h && (this.markedCells.push(h), h.getComp().addOrRemoveCssClass("ag-selection-fill-right", c === s[0])), d = this.cellNavigationService.getRowBelow(d);
      } while (!u);
    });
  }
  refresh(e) {
    const t = this.rangeService.getCellRanges()[0];
    if (!t.startRow || !t.endRow) {
      this.destroy();
      return;
    }
    super.refresh(e);
  }
}
sl.TEMPLATE = '<div class="ag-fill-handle"></div>';
xw([
  S("valueService")
], sl.prototype, "valueService", void 0);
xw([
  S("valueParserService")
], sl.prototype, "valueParserService", void 0);
xw([
  S("valueFormatterService")
], sl.prototype, "valueFormatterService", void 0);
class _f extends zr {
  constructor() {
    super(_f.TEMPLATE), this.type = ga.RANGE, this.rangeFixed = !1;
  }
  onDrag(e) {
    const t = this.getLastCellHovered();
    if (!t)
      return;
    const i = this.rangeService.getCellRanges(), r = x.last(i);
    this.rangeFixed || (this.fixRangeStartEnd(r), this.rangeFixed = !0), this.endPosition = {
      rowIndex: t.rowIndex,
      rowPinned: t.rowPinned,
      column: t.column
    }, i.length === 2 && i[0].type === wr.DIMENSION && r.type === wr.VALUE && !this.rowPositionUtils.sameRow(this.endPosition, this.rangeService.getRangeEndRow(r)) && this.rangeService.updateRangeEnd(i[0], Object.assign(Object.assign({}, this.endPosition), { column: i[0].columns[0] }), !0), this.rangeService.extendLatestRangeToCell(this.endPosition);
  }
  onDragEnd(e) {
    const t = x.last(this.rangeService.getCellRanges());
    this.fixRangeStartEnd(t), this.rangeFixed = !1;
  }
  fixRangeStartEnd(e) {
    const t = this.rangeService.getRangeStartRow(e), i = this.rangeService.getRangeEndRow(e), r = e.columns[0];
    e.startRow = t, e.endRow = i, e.startColumn = r;
  }
}
_f.TEMPLATE = '<div class="ag-range-handle"></div>';
var Fz = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let oS = class extends H {
  createSelectionHandle(e) {
    return this.createBean(e === ga.RANGE ? new _f() : new sl());
  }
};
oS = Fz([
  q("selectionHandleFactory")
], oS);
const Lz = "30.0.5", oP = {
  version: Lz,
  moduleName: Q.RangeSelectionModule,
  beans: [yn, oS],
  agStackComponents: [
    { componentName: "AgFillHandle", componentClass: sl },
    { componentName: "AgRangeHandle", componentClass: _f }
  ],
  dependantModules: [
    Pi
  ]
};
var Ws = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Nt extends X {
  constructor(e) {
    super(Nt.TEMPLATE), this.H = 1, this.S = 1, this.B = 1, this.A = 1, this.isSpectrumDragging = !1, this.isSpectrumHueDragging = !1, this.isSpectrumAlphaDragging = !1, this.colorChanged = !1, this.picker = e.picker;
  }
  postConstruct() {
    const e = this.getGui();
    this.initRecentColors(), this.addManagedListener(this.spectrumVal, "mousedown", this.onSpectrumDraggerDown.bind(this)), this.addManagedListener(e, "mousemove", this.onSpectrumDraggerMove.bind(this)), this.addManagedListener(this.spectrumHue, "mousedown", this.onSpectrumHueDown.bind(this)), this.addManagedListener(e, "mousemove", this.onSpectrumHueMove.bind(this)), this.addManagedListener(this.spectrumAlpha, "mousedown", this.onSpectrumAlphaDown.bind(this)), this.addManagedListener(e, "mousemove", this.onSpectrumAlphaMove.bind(this)), this.addManagedListener(document, "mouseup", this.onMouseUp.bind(this)), this.addManagedListener(this.recentColors, "click", this.onRecentColorClick.bind(this));
  }
  refreshSpectrumRect() {
    return this.spectrumValRect = this.spectrumVal.getBoundingClientRect();
  }
  refreshHueRect() {
    return this.spectrumHueRect = this.spectrumHue.getBoundingClientRect();
  }
  refreshAlphaRect() {
    return this.spectrumAlphaRect = this.spectrumAlpha.getBoundingClientRect();
  }
  onSpectrumDraggerDown(e) {
    this.refreshSpectrumRect(), this.isSpectrumDragging = !0, this.moveDragger(e);
  }
  onSpectrumDraggerMove(e) {
    this.isSpectrumDragging && this.moveDragger(e);
  }
  onSpectrumHueDown(e) {
    this.refreshHueRect(), this.isSpectrumHueDragging = !0, this.moveHueSlider(e);
  }
  onSpectrumHueMove(e) {
    this.isSpectrumHueDragging && this.moveHueSlider(e);
  }
  onSpectrumAlphaDown(e) {
    this.refreshAlphaRect(), this.isSpectrumAlphaDragging = !0, this.moveAlphaSlider(e);
  }
  onSpectrumAlphaMove(e) {
    this.isSpectrumAlphaDragging && this.moveAlphaSlider(e);
  }
  onMouseUp() {
    this.isSpectrumDragging = !1, this.isSpectrumHueDragging = !1, this.isSpectrumAlphaDragging = !1;
  }
  moveDragger(e) {
    const t = this.spectrumValRect;
    if (t) {
      let i = e.clientX - t.left, r = e.clientY - t.top;
      i = Math.max(i, 0), i = Math.min(i, t.width), r = Math.max(r, 0), r = Math.min(r, t.height), this.setSpectrumValue(i / t.width, 1 - r / t.height);
    }
  }
  moveHueSlider(e) {
    const t = this.spectrumHueRect;
    if (t) {
      const i = this.spectrumHueSlider, r = i.getBoundingClientRect();
      let n = e.clientX - t.left;
      n = Math.max(n, 0), n = Math.min(n, t.width), this.H = 1 - n / t.width, i.style.left = n + r.width / 2 + "px", this.update();
    }
  }
  moveAlphaSlider(e) {
    const t = this.spectrumAlphaRect;
    if (t) {
      const i = this.spectrumAlphaSlider, r = i.getBoundingClientRect();
      let n = e.clientX - t.left;
      n = Math.max(n, 0), n = Math.min(n, t.width), this.A = n / t.width, i.style.left = n + r.width / 2 + "px", this.update();
    }
  }
  update() {
    const e = Kt.fromHSB(this.H * 360, this.S, this.B, this.A), t = Kt.fromHSB(this.H * 360, 1, 1), i = e.toRgbaString(), r = this.picker;
    Kt.fromString(r.getValue()).toRgbaString() !== i && (this.colorChanged = !0), r.setValue(i), this.spectrumColor.style.backgroundColor = t.toRgbaString(), this.spectrumDragger.style.backgroundColor = i;
  }
  /**
   * @param saturation In the [0, 1] interval.
   * @param brightness In the [0, 1] interval.
   */
  setSpectrumValue(e, t) {
    const i = this.spectrumValRect || this.refreshSpectrumRect();
    if (i) {
      const r = this.spectrumDragger, n = r.getBoundingClientRect();
      e = Math.max(0, e), e = Math.min(1, e), t = Math.max(0, t), t = Math.min(1, t), this.S = e, this.B = t, r.style.left = e * i.width - n.width / 2 + "px", r.style.top = (1 - t) * i.height - n.height / 2 + "px", this.update();
    }
  }
  initRecentColors() {
    const t = Nt.recentColors.map((i, r) => `<div class="ag-recent-color" id=${r} style="background-color: ${i}; width: 15px; height: 15px;" recent-color="${i}"></div>`);
    this.recentColors.innerHTML = t.join("");
  }
  setValue(e) {
    const t = Kt.fromString(e), [i, r, n] = t.toHSB();
    this.H = (isNaN(i) ? 0 : i) / 360, this.A = t.a;
    const s = this.spectrumHueRect || this.refreshHueRect(), a = this.spectrumAlphaRect || this.refreshAlphaRect();
    this.spectrumHueSlider.style.left = `${(this.H - 1) * -s.width}px`, this.spectrumAlphaSlider.style.left = `${this.A * a.width}px`, this.setSpectrumValue(r, n);
  }
  onRecentColorClick(e) {
    const t = e.target;
    if (!x.exists(t.id))
      return;
    const i = parseInt(t.id, 10);
    this.setValue(Nt.recentColors[i]), this.destroy();
  }
  addRecentColor() {
    const t = Kt.fromHSB(this.H * 360, this.S, this.B, this.A).toRgbaString();
    let i = Nt.recentColors;
    !this.colorChanged || i[0] === t || (i = i.filter((r) => r != t), i = [t].concat(i), i.length > Nt.maxRecentColors && (i = i.slice(0, Nt.maxRecentColors)), Nt.recentColors = i);
  }
  destroy() {
    this.addRecentColor(), super.destroy();
  }
}
Nt.maxRecentColors = 8;
Nt.recentColors = [];
Nt.TEMPLATE = `<div class="ag-color-panel">
            <div ref="spectrumColor" class="ag-spectrum-color">
                <div class="ag-spectrum-sat ag-spectrum-fill">
                    <div ref="spectrumVal" class="ag-spectrum-val ag-spectrum-fill">
                        <div ref="spectrumDragger" class="ag-spectrum-dragger"></div>
                    </div>
                </div>
            </div>
            <div class="ag-spectrum-tools">
                <div ref="spectrumHue" class="ag-spectrum-hue ag-spectrum-tool">
                    <div class="ag-spectrum-hue-background"></div>
                    <div ref="spectrumHueSlider" class="ag-spectrum-slider"></div>
                </div>
                <div ref="spectrumAlpha" class="ag-spectrum-alpha ag-spectrum-tool">
                    <div class="ag-spectrum-alpha-background"></div>
                    <div ref="spectrumAlphaSlider" class="ag-spectrum-slider"></div>
                </div>
                <div ref="recentColors" class="ag-recent-colors"></div>
            </div>
        </div>`;
Ws([
  L("spectrumColor")
], Nt.prototype, "spectrumColor", void 0);
Ws([
  L("spectrumVal")
], Nt.prototype, "spectrumVal", void 0);
Ws([
  L("spectrumDragger")
], Nt.prototype, "spectrumDragger", void 0);
Ws([
  L("spectrumHue")
], Nt.prototype, "spectrumHue", void 0);
Ws([
  L("spectrumHueSlider")
], Nt.prototype, "spectrumHueSlider", void 0);
Ws([
  L("spectrumAlpha")
], Nt.prototype, "spectrumAlpha", void 0);
Ws([
  L("spectrumAlphaSlider")
], Nt.prototype, "spectrumAlphaSlider", void 0);
Ws([
  L("recentColors")
], Nt.prototype, "recentColors", void 0);
Ws([
  B
], Nt.prototype, "postConstruct", null);
class Nz extends au {
  constructor(e) {
    super(e, "ag-color-picker", "colorPicker"), e && e.color && (this.value = e.color);
  }
  postConstruct() {
    super.postConstruct(), this.value && this.setValue(this.value);
  }
  showPicker() {
    const e = this.getGui().getBoundingClientRect(), t = this.createBean(new Kh({
      closable: !1,
      modal: !0,
      hideTitleBar: !0,
      minWidth: 190,
      width: 190,
      height: 250,
      x: e.right - 190,
      y: e.top - 250
    }));
    this.isPickerDisplayed = !0, t.addCssClass("ag-color-dialog"), x.setAriaExpanded(this.eWrapper, !0);
    const i = this.createBean(new Nt({ picker: this }));
    return i.addDestroyFunc(() => {
      t.isAlive() && this.destroyBean(t);
    }), t.setParentComponent(this), t.setBodyComponent(i), i.setValue(this.getValue()), t.addDestroyFunc(() => {
      this.isDestroyingPicker ? this.isDestroyingPicker = !1 : (this.isDestroyingPicker = !0, i.isAlive() && this.destroyBean(i)), this.isAlive() && (x.setAriaExpanded(this.eWrapper, !1), this.getFocusableElement().focus()), this.isPickerDisplayed = !1;
    }), t;
  }
  setValue(e) {
    return this.value === e ? this : (this.eDisplayField.style.backgroundColor = e, super.setValue(e));
  }
  getValue() {
    return this.value;
  }
}
const sP = 28, aP = 6;
function sS(o) {
  return o && o.match(/\d+\.\d+\.\d+/);
}
function Gz({ gridMajorVersion: o, chartsMajorVersion: e }) {
  const t = parseInt(o, 10), i = parseInt(e, 10), r = t - sP, n = i - aP, s = r >= 0;
  return r === n && s;
}
function kz(o) {
  if (!o || !sS(o))
    return;
  const [e, t] = o.split(".") || [], i = `${e}.${t}.x`, n = parseInt(e, 10) - sP + aP;
  if (n < 0)
    return;
  const a = `${n}.${t}.x`;
  return {
    gridMajorMinor: i,
    chartsMajorMinor: a
  };
}
function cg({ type: o, gridVersion: e, chartsVersion: t }) {
  const i = "AG Grid: AG Grid version is incompatible. Please see https://www.ag-grid.com/javascript-data-grid/modules/ for more information.";
  if (!e)
    return i;
  const r = kz(e);
  if (!r)
    return i;
  const { gridMajorMinor: n, chartsMajorMinor: s } = r;
  return o === "incompatible" ? `AG Grid version ${e} and AG Charts version ${t} is not supported. AG Grid version ${n} should be used with AG Chart ${s}. Please see https://www.ag-grid.com/javascript-data-grid/modules/ for more information.` : o === "invalidCharts" ? `AG Grid version ${n} should be used with AG Chart ${s}. Please see https://www.ag-grid.com/javascript-data-grid/modules/ for more information.` : i;
}
function Vz({ gridVersion: o, chartsVersion: e }) {
  if (!sS(e))
    return {
      isValid: !1,
      message: cg({ type: "invalidCharts", gridVersion: o, chartsVersion: e })
    };
  if (!sS(o))
    return {
      isValid: !1,
      message: cg({ type: "invalidGrid", gridVersion: o, chartsVersion: e })
    };
  const [t, i] = o.split(".") || [], [r, n] = e.split(".") || [], s = Gz({
    gridMajorVersion: t,
    chartsMajorVersion: r
  });
  return s && i === n ? {
    isValid: !0
  } : !s || i !== n ? {
    isValid: !1,
    message: cg({ type: "incompatible", gridVersion: o, chartsVersion: e })
  } : {
    isValid: !1,
    message: cg({ type: "invalid", gridVersion: o, chartsVersion: e })
  };
}
const Bz = {
  version: yp,
  validate: () => Vz({
    gridVersion: yp,
    chartsVersion: Ta.CHARTS_VERSION
  }),
  moduleName: Q.GridChartsModule,
  beans: [
    Ta,
    Sv,
    iu
  ],
  agStackComponents: [
    { componentName: "AgColorPicker", componentClass: Nz },
    { componentName: "AgAngleSelect", componentClass: Yo }
  ],
  dependantModules: [
    oP,
    Pi
  ]
};
var lP = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class ny extends H {
  constructor() {
    super(...arguments), this.loadRowDataVersion = 0;
  }
  init(e, t) {
    this.params = t, this.comp = e, t.pinned == null && (this.setAutoHeightClasses(), this.setupRefreshStrategy(), this.addThemeToDetailGrid(), this.createDetailGrid(), this.loadRowData(), this.addManagedListener(this.eventService, w.EVENT_FULL_WIDTH_ROW_FOCUSED, this.onFullWidthRowFocused.bind(this)));
  }
  onFullWidthRowFocused(e) {
    const t = this.params, i = { rowIndex: t.node.rowIndex, rowPinned: t.node.rowPinned }, r = { rowIndex: e.rowIndex, rowPinned: e.rowPinned };
    this.rowPositionUtils.sameRow(i, r) && this.focusService.focusInto(this.comp.getGui(), e.fromBelow);
  }
  setAutoHeightClasses() {
    const e = this.gridOptionsService.is("detailRowAutoHeight"), t = e ? "ag-details-row-auto-height" : "ag-details-row-fixed-height", i = e ? "ag-details-grid-auto-height" : "ag-details-grid-fixed-height";
    this.comp.addOrRemoveCssClass(t, !0), this.comp.addOrRemoveDetailGridCssClass(i, !0);
  }
  setupRefreshStrategy() {
    const e = this.params.refreshStrategy;
    if (e == "everything" || e == "nothing" || e == "rows") {
      this.refreshStrategy = e;
      return;
    }
    e != null && console.warn("AG Grid: invalid cellRendererParams.refreshStrategy = '" + e + "' supplied, defaulting to refreshStrategy = 'rows'."), this.refreshStrategy = "rows";
  }
  addThemeToDetailGrid() {
    const { theme: e } = this.environment.getTheme();
    e && this.comp.addOrRemoveDetailGridCssClass(e, !0);
  }
  createDetailGrid() {
    if (x.missing(this.params.detailGridOptions)) {
      console.warn("AG Grid: could not find detail grid options for master detail, please set gridOptions.detailCellRendererParams.detailGridOptions");
      return;
    }
    const e = this.gridOptionsService.is("detailRowAutoHeight"), t = Object.assign({}, this.params.detailGridOptions);
    e && (t.domLayout = "autoHeight"), this.comp.setDetailGrid(t);
  }
  registerDetailWithMaster(e, t) {
    const i = this.params.node.id, r = this.params.api, n = {
      id: i,
      api: e,
      columnApi: t
    }, s = this.params.node;
    r.addDetailGridInfo(i, n), s.detailGridInfo = n, this.addDestroyFunc(() => {
      s.detailGridInfo === n && (r.removeDetailGridInfo(i), s.detailGridInfo = null);
    });
  }
  loadRowData() {
    this.loadRowDataVersion++;
    const e = this.loadRowDataVersion, t = this.params.getDetailRowData;
    if (!t) {
      console.warn("AG Grid: could not find getDetailRowData for master / detail, please set gridOptions.detailCellRendererParams.getDetailRowData");
      return;
    }
    const i = (n) => {
      this.loadRowDataVersion === e && this.comp.setRowData(n);
    }, r = {
      node: this.params.node,
      // we take data from node, rather than params.data
      // as the data could have been updated with new instance
      data: this.params.node.data,
      successCallback: i,
      context: this.gridOptionsService.context
    };
    t(r);
  }
  refresh() {
    switch (this.refreshStrategy) {
      case "nothing":
        return !0;
      case "everything":
        return !1;
    }
    return this.loadRowData(), !0;
  }
}
lP([
  S("rowPositionUtils")
], ny.prototype, "rowPositionUtils", void 0);
lP([
  S("focusService")
], ny.prototype, "focusService", void 0);
var Hz = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class If extends X {
  init(e) {
    this.params = e, this.selectAndSetTemplate();
    const t = {
      addOrRemoveCssClass: (i, r) => this.addOrRemoveCssClass(i, r),
      addOrRemoveDetailGridCssClass: (i, r) => this.eDetailGrid.classList.toggle(i, r),
      setDetailGrid: (i) => this.setDetailGrid(i),
      setRowData: (i) => this.setRowData(i),
      getGui: () => this.eDetailGrid
    };
    this.ctrl = this.createManagedBean(new ny()), this.ctrl.init(t, e);
  }
  refresh() {
    return this.ctrl && this.ctrl.refresh();
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  selectAndSetTemplate() {
    if (this.params.pinned) {
      this.setTemplate('<div class="ag-details-row"></div>');
      return;
    }
    const e = () => {
      this.setTemplate(If.TEMPLATE);
    };
    if (x.missing(this.params.template))
      e();
    else if (typeof this.params.template == "string")
      this.setTemplate(this.params.template);
    else if (typeof this.params.template == "function") {
      const t = this.params.template, i = t(this.params);
      this.setTemplate(i);
    } else
      console.warn("AG Grid: detailCellRendererParams.template should be function or string"), e();
    this.eDetailGrid == null && console.warn('AG Grid: reference to eDetailGrid was missing from the details template. Please add ref="eDetailGrid" to the template.');
  }
  setDetailGrid(e) {
    if (!this.eDetailGrid)
      return;
    const t = this.context.getBean("agGridReact"), i = t ? x.cloneObject(t) : void 0, r = this.context.getBean("frameworkComponentWrapper"), n = this.getFrameworkOverrides();
    new _x(this.eDetailGrid, e, {
      frameworkOverrides: n,
      providedBeanInstances: {
        agGridReact: i,
        frameworkComponentWrapper: r
      },
      modules: Z.__getGridRegisteredModules(this.params.api.getGridId())
    }), this.detailApi = e.api, this.ctrl.registerDetailWithMaster(e.api, e.columnApi), this.addDestroyFunc(() => {
      e.api && e.api.destroy();
    });
  }
  setRowData(e) {
    this.detailApi && this.detailApi.setRowData(e);
  }
}
If.TEMPLATE = `<div class="ag-details-row" role="gridcell">
            <div ref="eDetailGrid" class="ag-details-grid" role="presentation"></div>
        </div>`;
Hz([
  L("eDetailGrid")
], If.prototype, "eDetailGrid", void 0);
const Wz = "30.0.5", jz = {
  version: Wz,
  moduleName: Q.MasterDetailModule,
  beans: [],
  userComponents: [
    { componentName: "agDetailCellRenderer", componentClass: If }
  ],
  controllers: [
    { controllerName: "detailCellRenderer", controllerClass: ny }
  ],
  dependantModules: [
    Pi
  ]
};
var ur = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let xa = class extends H {
  hideActiveMenu() {
    this.destroyBean(this.activeMenu);
  }
  showMenuAfterMouseEvent(e, t, i) {
    this.showMenu(e, (r) => {
      const n = r.getGui();
      this.popupService.positionPopupUnderMouseEvent({
        type: "columnMenu",
        column: e,
        mouseEvent: t,
        ePopup: n
      }), i && r.showTab(i);
    }, "columnMenu", i, void 0, t.target);
  }
  showMenuAfterButtonClick(e, t, i, r, n) {
    let s = -1, a = "left";
    this.gridOptionsService.is("enableRtl") && (s = 1, a = "right"), this.showMenu(e, (l) => {
      const c = l.getGui();
      this.popupService.positionPopupByComponent({
        type: i,
        column: e,
        eventSource: t,
        ePopup: c,
        alignSide: a,
        nudgeX: 9 * s,
        nudgeY: -23,
        position: "under",
        keepWithinBounds: !0
      }), r && l.showTab(r);
    }, i, r, n, t);
  }
  showMenu(e, t, i, r, n, s) {
    const { menu: a, eMenuGui: l, currentHeaderPosition: c, currentColumnIndex: d, anchorToElement: u } = this.getMenuParams(e, n, s), h = [];
    h.push(this.getClosedCallback(e, a, c, d, s));
    const p = this.localeService.getLocaleTextFunc();
    this.popupService.addPopup({
      modal: !0,
      eChild: l,
      closeOnEsc: !0,
      closedCallback: (g) => {
        h.forEach((v) => v(g));
      },
      afterGuiAttached: (g) => a.afterGuiAttached(Object.assign({}, { container: i }, g)),
      // if defaultTab is not present, positionCallback will be called
      // after `showTabBasedOnPreviousSelection` is called.
      positionCallback: r ? () => t(a) : void 0,
      ariaLabel: p("ariaLabelColumnMenu", "Column Menu")
    }), r || (a.showTabBasedOnPreviousSelection(), t(a));
    const f = this.popupService.setPopupPositionRelatedToElement(l, u);
    f && this.addStopAnchoring(f, e, h), a.addEventListener(Ae.EVENT_TAB_SELECTED, (g) => {
      this.lastSelectedTab = g.key;
    }), e.setMenuVisible(!0, "contextMenu"), this.activeMenu = a, a.addEventListener(H.EVENT_DESTROYED, () => {
      this.activeMenu === a && (this.activeMenu = null);
    });
  }
  addStopAnchoring(e, t, i) {
    e.then((r) => {
      t.addEventListener("leftChanged", r), t.addEventListener("visibleChanged", r), i.push(() => {
        t.removeEventListener("leftChanged", r), t.removeEventListener("visibleChanged", r);
      });
    });
  }
  getClosedCallback(e, t, i, r, n) {
    return (s) => {
      if (this.destroyBean(t), e.setMenuVisible(!1, "contextMenu"), !(!(s instanceof KeyboardEvent) || !n)) {
        if (x.isVisible(n)) {
          const l = this.focusService.findTabbableParent(n);
          l && (e && this.headerNavigationService.scrollToColumn(e), l.focus());
        } else if (i && r !== -1) {
          const l = this.columnModel.getAllDisplayedColumns(), c = l[r] || x.last(l);
          c && this.focusService.focusHeaderPosition({
            headerPosition: {
              headerRowIndex: i.headerRowIndex,
              column: c
            }
          });
        }
      }
    };
  }
  getMenuParams(e, t, i) {
    const r = this.createBean(new Ae(e, this.lastSelectedTab, t));
    return {
      menu: r,
      eMenuGui: r.getGui(),
      currentHeaderPosition: this.focusService.getFocusedHeader(),
      currentColumnIndex: this.columnModel.getAllDisplayedColumns().indexOf(e),
      anchorToElement: i || this.ctrlsService.getGridBodyCtrl().getGui()
    };
  }
  isMenuEnabled(e) {
    return e.getMenuTabs(Ae.TABS_DEFAULT).length > 0;
  }
};
ur([
  S("popupService")
], xa.prototype, "popupService", void 0);
ur([
  S("focusService")
], xa.prototype, "focusService", void 0);
ur([
  S("headerNavigationService")
], xa.prototype, "headerNavigationService", void 0);
ur([
  S("ctrlsService")
], xa.prototype, "ctrlsService", void 0);
ur([
  S("columnModel")
], xa.prototype, "columnModel", void 0);
xa = ur([
  q("menuFactory")
], xa);
class Ae extends H {
  constructor(e, t, i) {
    super(), this.tabFactories = {}, this.includeChecks = {}, this.column = e, this.initialSelection = t, this.tabFactories[Ae.TAB_GENERAL] = this.createMainPanel.bind(this), this.tabFactories[Ae.TAB_FILTER] = this.createFilterPanel.bind(this), this.tabFactories[Ae.TAB_COLUMNS] = this.createColumnsPanel.bind(this), this.includeChecks[Ae.TAB_GENERAL] = () => !0, this.includeChecks[Ae.TAB_FILTER] = () => this.filterManager.isFilterAllowed(e), this.includeChecks[Ae.TAB_COLUMNS] = () => !0, this.restrictTo = i;
  }
  init() {
    const e = this.getTabsToCreate().map((t) => this.createTab(t));
    this.tabbedLayout = new Ba({
      items: e,
      cssClass: "ag-menu",
      onActiveItemClicked: this.onHidePopup.bind(this),
      onItemClicked: this.onTabItemClicked.bind(this)
    }), this.createBean(this.tabbedLayout), this.mainMenuList && this.mainMenuList.setParentComponent(this.tabbedLayout), this.addDestroyFunc(() => this.destroyBean(this.tabbedLayout));
  }
  getTabsToCreate() {
    return this.restrictTo ? this.restrictTo : this.column.getMenuTabs(Ae.TABS_DEFAULT).filter((e) => this.isValidMenuTabItem(e)).filter((e) => this.isNotSuppressed(e)).filter((e) => this.isModuleLoaded(e));
  }
  isModuleLoaded(e) {
    return e === Ae.TAB_COLUMNS ? Z.__isRegistered(Q.ColumnsToolPanelModule, this.context.getGridId()) : !0;
  }
  isValidMenuTabItem(e) {
    let t = !0, i = Ae.TABS_DEFAULT;
    return this.restrictTo != null && (t = this.restrictTo.indexOf(e) > -1, i = this.restrictTo), t = t && Ae.TABS_DEFAULT.indexOf(e) > -1, t || console.warn(`AG Grid: Trying to render an invalid menu item '${e}'. Check that your 'menuTabs' contains one of [${i}]`), t;
  }
  isNotSuppressed(e) {
    return this.includeChecks[e]();
  }
  createTab(e) {
    return this.tabFactories[e]();
  }
  showTabBasedOnPreviousSelection() {
    this.showTab(this.initialSelection);
  }
  showTab(e) {
    this.tabItemColumns && e === Ae.TAB_COLUMNS ? this.tabbedLayout.showItem(this.tabItemColumns) : this.tabItemFilter && e === Ae.TAB_FILTER ? this.tabbedLayout.showItem(this.tabItemFilter) : this.tabItemGeneral && e === Ae.TAB_GENERAL ? this.tabbedLayout.showItem(this.tabItemGeneral) : this.tabbedLayout.showFirstItem();
  }
  onTabItemClicked(e) {
    let t = null;
    switch (e.item) {
      case this.tabItemColumns:
        t = Ae.TAB_COLUMNS;
        break;
      case this.tabItemFilter:
        t = Ae.TAB_FILTER;
        break;
      case this.tabItemGeneral:
        t = Ae.TAB_GENERAL;
        break;
    }
    t && this.activateTab(t);
  }
  activateTab(e) {
    const t = {
      type: Ae.EVENT_TAB_SELECTED,
      key: e
    };
    this.dispatchEvent(t);
  }
  getMenuItems() {
    const e = this.getDefaultMenuOptions();
    let t;
    const i = this.gridOptionsService.getCallback("getMainMenuItems");
    return i ? t = i({
      column: this.column,
      defaultItems: e
    }) : t = e, x.removeRepeatsFromArray(t, Ae.MENU_ITEM_SEPARATOR), t;
  }
  getDefaultMenuOptions() {
    const e = [], t = !this.column.getColDef().lockPinned, i = this.columnModel.getRowGroupColumns().length, r = i > 0, n = this.columnModel.getRowGroupColumns().indexOf(this.column) >= 0, s = this.column.isAllowValue(), a = this.column.isAllowRowGroup(), l = this.column.isPrimary(), c = this.columnModel.isPivotMode(), d = this.rowModel.getType() === "clientSide", u = this.gridOptionsService.isTreeData(), h = (
      // if primary, then only allow aggValue if grouping and it's a value columns
      l && r && s || !l
    );
    return t && e.push("pinSubMenu"), h && e.push("valueAggSubMenu"), (t || h) && e.push(Ae.MENU_ITEM_SEPARATOR), e.push("autoSizeThis"), e.push("autoSizeAll"), e.push(Ae.MENU_ITEM_SEPARATOR), a && this.column.isPrimary() && (n ? e.push("rowUnGroup") : e.push("rowGroup")), e.push(Ae.MENU_ITEM_SEPARATOR), e.push("resetColumns"), d && (u || i > (c ? 1 : 0)) && (e.push("expandAll"), e.push("contractAll")), e;
  }
  createMainPanel() {
    this.mainMenuList = this.createManagedBean(new Ro());
    const e = this.getMenuItems(), t = this.menuItemMapper.mapWithStockItems(e, this.column);
    return this.mainMenuList.addMenuItems(t), this.mainMenuList.addEventListener(_t.EVENT_MENU_ITEM_SELECTED, this.onHidePopup.bind(this)), this.tabItemGeneral = {
      title: x.createIconNoSpan("menu", this.gridOptionsService, this.column),
      titleLabel: Ae.TAB_GENERAL.replace("MenuTab", ""),
      bodyPromise: Qe.resolve(this.mainMenuList.getGui()),
      name: Ae.TAB_GENERAL
    }, this.tabItemGeneral;
  }
  onHidePopup(e) {
    let t;
    e && e.event && e.event instanceof KeyboardEvent && (t = e.event), this.hidePopupFunc(t && { keyboardEvent: t });
    const i = this.focusService.getFocusedCell(), r = this.gridOptionsService.getDocument();
    if (r.activeElement === r.body && i) {
      const { rowIndex: n, rowPinned: s, column: a } = i;
      this.focusService.setFocusedCell({ rowIndex: n, column: a, rowPinned: s, forceBrowserFocus: !0, preventScrollOnBrowserFocus: !0 });
    }
  }
  createFilterPanel() {
    const e = this.filterManager.getOrCreateFilterWrapper(this.column, "COLUMN_MENU");
    if (!e)
      throw new Error("AG Grid - Unable to instantiate filter");
    const t = (r) => {
      e != null && e.filterPromise && e.filterPromise.then((n) => {
        n && n.afterGuiAttached && n.afterGuiAttached(r);
      });
    }, i = () => {
      var r;
      return (r = e == null ? void 0 : e.filterPromise) === null || r === void 0 ? void 0 : r.then((n) => {
        var s;
        return (s = n == null ? void 0 : n.afterGuiDetached) === null || s === void 0 ? void 0 : s.call(n);
      });
    };
    return this.tabItemFilter = {
      title: x.createIconNoSpan("filter", this.gridOptionsService, this.column),
      titleLabel: Ae.TAB_FILTER.replace("MenuTab", ""),
      bodyPromise: e == null ? void 0 : e.guiPromise,
      afterAttachedCallback: t,
      afterDetachedCallback: i,
      name: Ae.TAB_FILTER
    }, this.tabItemFilter;
  }
  createColumnsPanel() {
    const e = document.createElement("div");
    e.classList.add("ag-menu-column-select-wrapper");
    const t = this.createManagedBean(new Ya());
    let i = this.column.getColDef().columnsMenuParams;
    i || (i = {});
    const { contractColumnSelection: r, suppressColumnExpandAll: n, suppressColumnFilter: s, suppressColumnSelectAll: a, suppressSyncLayoutWithGrid: l, columnLayout: c } = i;
    t.init(!1, {
      suppressColumnMove: !1,
      suppressValues: !1,
      suppressPivots: !1,
      suppressRowGroups: !1,
      suppressPivotMode: !1,
      contractColumnSelection: !!r,
      suppressColumnExpandAll: !!n,
      suppressColumnFilter: !!s,
      suppressColumnSelectAll: !!a,
      suppressSyncLayoutWithGrid: !!c || !!l,
      api: this.gridApi,
      columnApi: this.columnApi,
      context: this.gridOptionsService.context
    }, "columnMenu"), c && t.setColumnLayout(c);
    const d = t.getGui();
    return d.classList.add("ag-menu-column-select"), e.appendChild(d), this.tabItemColumns = {
      title: x.createIconNoSpan("columns", this.gridOptionsService, this.column),
      titleLabel: Ae.TAB_COLUMNS.replace("MenuTab", ""),
      bodyPromise: Qe.resolve(e),
      name: Ae.TAB_COLUMNS
    }, this.tabItemColumns;
  }
  afterGuiAttached(e) {
    const { container: t, hidePopup: i } = e;
    this.tabbedLayout.setAfterAttachedParams({ container: t, hidePopup: i }), i && (this.hidePopupFunc = i, this.addDestroyFunc(i));
  }
  getGui() {
    return this.tabbedLayout.getGui();
  }
}
Ae.EVENT_TAB_SELECTED = "tabSelected";
Ae.TAB_FILTER = "filterMenuTab";
Ae.TAB_GENERAL = "generalMenuTab";
Ae.TAB_COLUMNS = "columnsMenuTab";
Ae.TABS_DEFAULT = [Ae.TAB_GENERAL, Ae.TAB_FILTER, Ae.TAB_COLUMNS];
Ae.MENU_ITEM_SEPARATOR = "separator";
ur([
  S("columnModel")
], Ae.prototype, "columnModel", void 0);
ur([
  S("filterManager")
], Ae.prototype, "filterManager", void 0);
ur([
  S("gridApi")
], Ae.prototype, "gridApi", void 0);
ur([
  S("columnApi")
], Ae.prototype, "columnApi", void 0);
ur([
  S("menuItemMapper")
], Ae.prototype, "menuItemMapper", void 0);
ur([
  S("rowModel")
], Ae.prototype, "rowModel", void 0);
ur([
  S("focusService")
], Ae.prototype, "focusService", void 0);
ur([
  B
], Ae.prototype, "init", null);
var js = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const Uz = "ag-menu", QE = "ag-context-menu-open";
let Kl = class extends H {
  hideActiveMenu() {
    this.destroyBean(this.activeMenu);
  }
  getMenuItems(e, t, i) {
    const r = [];
    if (x.exists(e) && Z.__isRegistered(Q.ClipboardModule, this.context.getGridId()) && t && (this.gridOptionsService.is("suppressCutToClipboard") || r.push("cut"), r.push("copy", "copyWithHeaders", "copyWithGroupHeaders", "paste", "separator")), this.gridOptionsService.is("enableCharts") && Z.__isRegistered(Q.GridChartsModule, this.context.getGridId()) && (this.columnModel.isPivotMode() && r.push("pivotChart"), this.rangeService && !this.rangeService.isEmpty() && r.push("chartRange")), x.exists(e)) {
      const s = !Z.__isRegistered(Q.CsvExportModule, this.context.getGridId()), a = !Z.__isRegistered(Q.ExcelExportModule, this.context.getGridId()), l = this.gridOptionsService.is("suppressExcelExport") || a, c = this.gridOptionsService.is("suppressCsvExport") || s;
      !x.isIOSUserAgent() && (!l || !c) && r.push("export");
    }
    const n = this.gridOptionsService.getCallback("getContextMenuItems");
    if (n) {
      const s = {
        node: e,
        column: t,
        value: i,
        defaultItems: r.length ? r : void 0
      };
      return n(s);
    }
    return r;
  }
  onContextMenu(e, t, i, r, n, s) {
    if (!this.gridOptionsService.is("allowContextMenuWithControlKey") && e && (e.ctrlKey || e.metaKey) || (e && this.blockMiddleClickScrollsIfNeeded(e), this.gridOptionsService.is("suppressContextMenu")))
      return;
    const a = e || t.touches[0];
    this.showMenu(i, r, n, a, s) && (e || t).preventDefault();
  }
  blockMiddleClickScrollsIfNeeded(e) {
    const { gridOptionsService: t } = this, { which: i } = e;
    t.is("suppressMiddleClickScrolls") && i === 2 && e.preventDefault();
  }
  showMenu(e, t, i, r, n) {
    const s = this.getMenuItems(e, t, i), a = this.ctrlsService.getGridBodyCtrl().getGui();
    if (s === void 0 || x.missingOrEmpty(s))
      return !1;
    const l = new Ff(s);
    this.createBean(l);
    const c = l.getGui(), d = {
      column: t,
      rowNode: e,
      type: "contextMenu",
      mouseEvent: r,
      ePopup: c,
      // move one pixel away so that accidentally double clicking
      // won't show the browser's contextmenu
      nudgeY: 1
    }, u = this.localeService.getLocaleTextFunc(), h = this.popupService.addPopup({
      modal: !0,
      eChild: c,
      closeOnEsc: !0,
      closedCallback: () => {
        a.classList.remove(QE), this.destroyBean(l);
      },
      click: r,
      positionCallback: () => {
        const p = this.gridOptionsService.is("enableRtl");
        this.popupService.positionPopupUnderMouseEvent(Object.assign(Object.assign({}, d), { nudgeX: p ? (c.offsetWidth + 1) * -1 : 1 }));
      },
      // so when browser is scrolled down, or grid is scrolled, context menu stays with cell
      anchorToElement: n,
      ariaLabel: u("ariaLabelContextMenu", "Context Menu")
    });
    return h && (a.classList.add(QE), l.afterGuiAttached({ container: "contextMenu", hidePopup: h.hideFunc })), this.activeMenu && this.hideActiveMenu(), this.activeMenu = l, l.addEventListener(H.EVENT_DESTROYED, () => {
      this.activeMenu === l && (this.activeMenu = null);
    }), h && l.addEventListener(_t.EVENT_MENU_ITEM_SELECTED, h.hideFunc), !0;
  }
};
js([
  S("popupService")
], Kl.prototype, "popupService", void 0);
js([
  Ve("rangeService")
], Kl.prototype, "rangeService", void 0);
js([
  S("ctrlsService")
], Kl.prototype, "ctrlsService", void 0);
js([
  S("columnModel")
], Kl.prototype, "columnModel", void 0);
Kl = js([
  q("contextMenuFactory")
], Kl);
class Ff extends X {
  constructor(e) {
    super(
      /* html */
      `<div class="${Uz}" role="presentation"></div>`
    ), this.menuList = null, this.focusedCell = null, this.menuItems = e;
  }
  addMenuItems() {
    const e = this.createManagedBean(new Ro()), t = this.menuItemMapper.mapWithStockItems(this.menuItems, null);
    e.addMenuItems(t), this.appendChild(e), this.menuList = e, e.addEventListener(_t.EVENT_MENU_ITEM_SELECTED, (i) => this.dispatchEvent(i));
  }
  afterGuiAttached(e) {
    e.hidePopup && this.addDestroyFunc(e.hidePopup), this.focusedCell = this.focusService.getFocusedCell(), this.menuList && this.focusService.focusInto(this.menuList.getGui());
  }
  restoreFocusedCell() {
    const e = this.focusService.getFocusedCell();
    if (e && this.focusedCell && this.cellPositionUtils.equals(e, this.focusedCell)) {
      const { rowIndex: t, rowPinned: i, column: r } = this.focusedCell, n = this.gridOptionsService.getDocument();
      n.activeElement === n.body && this.focusService.setFocusedCell({ rowIndex: t, column: r, rowPinned: i, forceBrowserFocus: !0 });
    }
  }
  destroy() {
    this.restoreFocusedCell(), super.destroy();
  }
}
js([
  S("menuItemMapper")
], Ff.prototype, "menuItemMapper", void 0);
js([
  S("focusService")
], Ff.prototype, "focusService", void 0);
js([
  S("cellPositionUtils")
], Ff.prototype, "cellPositionUtils", void 0);
js([
  B
], Ff.prototype, "addMenuItems", null);
var al = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Fo = class extends H {
  mapWithStockItems(e, t) {
    if (!e)
      return [];
    const i = [];
    return e.forEach((r) => {
      let n;
      if (typeof r == "string" ? n = this.getStockMenuItem(r, t) : n = Object.assign({}, r), !n)
        return;
      const s = n, { subMenu: a } = s;
      a && a instanceof Array && (s.subMenu = this.mapWithStockItems(a, t)), n != null && i.push(n);
    }), i;
  }
  getStockMenuItem(e, t) {
    var i;
    const r = this.localeService.getLocaleTextFunc(), n = this.gridOptionsService.is("skipHeaderOnAutoSize");
    switch (e) {
      case "pinSubMenu":
        return {
          name: r("pinColumn", "Pin Column"),
          icon: x.createIconNoSpan("menuPin", this.gridOptionsService, null),
          subMenu: ["clearPinned", "pinLeft", "pinRight"]
        };
      case "pinLeft":
        return {
          name: r("pinLeft", "Pin Left"),
          action: () => this.columnModel.setColumnPinned(t, "left", "contextMenu"),
          checked: !!t && t.isPinnedLeft()
        };
      case "pinRight":
        return {
          name: r("pinRight", "Pin Right"),
          action: () => this.columnModel.setColumnPinned(t, "right", "contextMenu"),
          checked: !!t && t.isPinnedRight()
        };
      case "clearPinned":
        return {
          name: r("noPin", "No Pin"),
          action: () => this.columnModel.setColumnPinned(t, null, "contextMenu"),
          checked: !!t && !t.isPinned()
        };
      case "valueAggSubMenu":
        return Z.__assertRegistered(Q.RowGroupingModule, "Aggregation from Menu", this.context.getGridId()) ? !(t != null && t.isPrimary()) && !(t != null && t.getColDef().pivotValueColumn) ? null : {
          name: r("valueAggregation", "Value Aggregation"),
          icon: x.createIconNoSpan("menuValue", this.gridOptionsService, null),
          subMenu: this.createAggregationSubMenu(t)
        } : null;
      case "autoSizeThis":
        return {
          name: r("autosizeThiscolumn", "Autosize This Column"),
          action: () => this.columnModel.autoSizeColumn(t, n, "contextMenu")
        };
      case "autoSizeAll":
        return {
          name: r("autosizeAllColumns", "Autosize All Columns"),
          action: () => this.columnModel.autoSizeAllColumns(n, "contextMenu")
        };
      case "rowGroup":
        return {
          name: r("groupBy", "Group by") + " " + x.escapeString(this.columnModel.getDisplayNameForColumn(t, "header")),
          disabled: (t == null ? void 0 : t.isRowGroupActive()) || !(t != null && t.getColDef().enableRowGroup),
          action: () => this.columnModel.addRowGroupColumn(t, "contextMenu"),
          icon: x.createIconNoSpan("menuAddRowGroup", this.gridOptionsService, null)
        };
      case "rowUnGroup":
        return {
          name: r("ungroupBy", "Un-Group by") + " " + x.escapeString(this.columnModel.getDisplayNameForColumn(t, "header")),
          disabled: !(t != null && t.isRowGroupActive()) || !(t != null && t.getColDef().enableRowGroup),
          action: () => this.columnModel.removeRowGroupColumn(t, "contextMenu"),
          icon: x.createIconNoSpan("menuRemoveRowGroup", this.gridOptionsService, null)
        };
      case "resetColumns":
        return {
          name: r("resetColumns", "Reset Columns"),
          action: () => this.columnModel.resetColumnState("contextMenu")
        };
      case "expandAll":
        return {
          name: r("expandAll", "Expand All Row Groups"),
          action: () => this.gridApi.expandAll()
        };
      case "contractAll":
        return {
          name: r("collapseAll", "Collapse All Row Groups"),
          action: () => this.gridApi.collapseAll()
        };
      case "copy":
        return Z.__assertRegistered(Q.ClipboardModule, "Copy from Menu", this.context.getGridId()) ? {
          name: r("copy", "Copy"),
          shortcut: r("ctrlC", "Ctrl+C"),
          icon: x.createIconNoSpan("clipboardCopy", this.gridOptionsService, null),
          action: () => this.clipboardService.copyToClipboard()
        } : null;
      case "copyWithHeaders":
        return Z.__assertRegistered(Q.ClipboardModule, "Copy with Headers from Menu", this.context.getGridId()) ? {
          name: r("copyWithHeaders", "Copy with Headers"),
          // shortcut: localeTextFunc('ctrlC','Ctrl+C'),
          icon: x.createIconNoSpan("clipboardCopy", this.gridOptionsService, null),
          action: () => this.clipboardService.copyToClipboard({ includeHeaders: !0 })
        } : null;
      case "copyWithGroupHeaders":
        return Z.__assertRegistered(Q.ClipboardModule, "Copy with Group Headers from Menu", this.context.getGridId()) ? {
          name: r("copyWithGroupHeaders", "Copy with Group Headers"),
          // shortcut: localeTextFunc('ctrlC','Ctrl+C'),
          icon: x.createIconNoSpan("clipboardCopy", this.gridOptionsService, null),
          action: () => this.clipboardService.copyToClipboard({ includeHeaders: !0, includeGroupHeaders: !0 })
        } : null;
      case "cut":
        if (Z.__assertRegistered(Q.ClipboardModule, "Cut from Menu", this.context.getGridId())) {
          const c = this.focusService.getFocusedCell(), d = c ? this.rowPositionUtils.getRowNode(c) : null, u = d ? c == null ? void 0 : c.column.isCellEditable(d) : !1;
          return {
            name: r("cut", "Cut"),
            shortcut: r("ctrlX", "Ctrl+X"),
            icon: x.createIconNoSpan("clipboardCut", this.gridOptionsService, null),
            disabled: !u || this.gridOptionsService.is("suppressCutToClipboard"),
            action: () => this.clipboardService.cutToClipboard(void 0, "contextMenu")
          };
        } else
          return null;
      case "paste":
        return Z.__assertRegistered(Q.ClipboardModule, "Paste from Clipboard", this.context.getGridId()) ? {
          name: r("paste", "Paste"),
          shortcut: r("ctrlV", "Ctrl+V"),
          disabled: !0,
          icon: x.createIconNoSpan("clipboardPaste", this.gridOptionsService, null),
          action: () => this.clipboardService.pasteFromClipboard()
        } : null;
      case "export":
        const s = [], a = Z.__isRegistered(Q.CsvExportModule, this.context.getGridId()), l = Z.__isRegistered(Q.ExcelExportModule, this.context.getGridId());
        return !this.gridOptionsService.is("suppressCsvExport") && a && s.push("csvExport"), !this.gridOptionsService.is("suppressExcelExport") && l && s.push("excelExport"), {
          name: r("export", "Export"),
          subMenu: s,
          icon: x.createIconNoSpan("save", this.gridOptionsService, null)
        };
      case "csvExport":
        return {
          name: r("csvExport", "CSV Export"),
          icon: x.createIconNoSpan("csvExport", this.gridOptionsService, null),
          action: () => this.gridApi.exportDataAsCsv({})
        };
      case "excelExport":
        return {
          name: r("excelExport", "Excel Export"),
          icon: x.createIconNoSpan("excelExport", this.gridOptionsService, null),
          action: () => this.gridApi.exportDataAsExcel()
        };
      case "separator":
        return "separator";
      case "pivotChart":
      case "chartRange":
        return (i = this.chartMenuItemMapper.getChartItems(e)) !== null && i !== void 0 ? i : null;
      default:
        return console.warn(`AG Grid: unknown menu item type ${e}`), null;
    }
  }
  createAggregationSubMenu(e) {
    const t = this.localeService.getLocaleTextFunc();
    let i;
    if (e.isPrimary())
      i = e;
    else {
      const n = e.getColDef().pivotValueColumn;
      i = x.exists(n) ? n : void 0;
    }
    const r = [];
    if (i) {
      const n = i.isValueActive(), s = this.aggFuncService.getFuncNames(i);
      r.push({
        name: t("noAggregation", "None"),
        action: () => {
          this.columnModel.removeValueColumn(i, "contextMenu"), this.columnModel.setColumnAggFunc(i, void 0, "contextMenu");
        },
        checked: !n
      }), s.forEach((a) => {
        r.push({
          name: t(a, x.capitalise(a)),
          action: () => {
            this.columnModel.setColumnAggFunc(i, a, "contextMenu"), this.columnModel.addValueColumn(i, "contextMenu");
          },
          checked: n && i.getAggFunc() === a
        });
      });
    }
    return r;
  }
};
al([
  S("columnModel")
], Fo.prototype, "columnModel", void 0);
al([
  S("gridApi")
], Fo.prototype, "gridApi", void 0);
al([
  Ve("clipboardService")
], Fo.prototype, "clipboardService", void 0);
al([
  Ve("aggFuncService")
], Fo.prototype, "aggFuncService", void 0);
al([
  S("focusService")
], Fo.prototype, "focusService", void 0);
al([
  S("rowPositionUtils")
], Fo.prototype, "rowPositionUtils", void 0);
al([
  S("chartMenuItemMapper")
], Fo.prototype, "chartMenuItemMapper", void 0);
Fo = al([
  q("menuItemMapper")
], Fo);
const $z = "30.0.5";
var cP = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, aS;
let bv = aS = class extends H {
  getChartItems(e) {
    var t, i;
    if (!this.chartService) {
      Z.__assertRegistered(Q.GridChartsModule, `the Context Menu key "${e}"`, this.context.getGridId());
      return;
    }
    const r = e === "pivotChart" ? new zz(this.gridOptionsService, this.chartService, this.localeService) : new Kz(this.gridOptionsService, this.chartService, this.localeService);
    let n = r.getMenuItem();
    const s = (i = (t = this.gridOptionsService.get("chartToolPanelsDef")) === null || t === void 0 ? void 0 : t.settingsPanel) === null || i === void 0 ? void 0 : i.chartGroupsDef;
    return s && (n = aS.filterAndOrderChartMenu(n, s, r.getConfigLookup())), this.cleanInternals(n);
  }
  // Remove our internal _key properties so this does not leak out of the class on the menu items.
  cleanInternals(e) {
    if (!e)
      return e;
    const t = (i) => {
      var r;
      return i == null || delete i._key, (r = i == null ? void 0 : i.subMenu) === null || r === void 0 || r.forEach((n) => t(n)), i;
    };
    return t(e);
  }
  static buildLookup(e) {
    let t = {};
    const i = (r) => {
      t[r._key] = r, r.subMenu && r.subMenu.forEach((n) => i(n));
    };
    return i(e), t;
  }
  /**
   * Make the MenuItem match the charts provided and their ordering on the ChartGroupsDef config object as provided by the user.
   */
  static filterAndOrderChartMenu(e, t, i) {
    var r;
    const n = this.buildLookup(e);
    let s = Object.assign(Object.assign({}, e), { subMenu: [] });
    if (Object.entries(t).forEach(([a, l]) => {
      var c, d;
      const u = i[a];
      if (u == null) {
        x.doOnce(() => console.warn(`AG Grid - invalid chartGroupsDef config '${a}'`), `invalid_chartGroupsDef${a}`);
        return;
      }
      const h = n[u._key];
      if (h)
        if (h.subMenu) {
          const p = l.map((f) => {
            const g = u[f];
            if (g == null) {
              x.doOnce(() => console.warn(`AG Grid - invalid chartGroupsDef config '${a}.${f}'`), `invalid_chartGroupsDef${f}_${a}`);
              return;
            }
            return n[g];
          }).filter((f) => f !== void 0);
          p.length > 0 && (h.subMenu = p, (c = s.subMenu) === null || c === void 0 || c.push(h));
        } else
          (d = s.subMenu) === null || d === void 0 || d.push(h);
    }), ((r = s.subMenu) === null || r === void 0 ? void 0 : r.length) != 0)
      return s;
  }
};
cP([
  Ve("chartService")
], bv.prototype, "chartService", void 0);
bv = aS = cP([
  q("chartMenuItemMapper")
], bv);
class zz {
  constructor(e, t, i) {
    this.gridOptionsService = e, this.chartService = t, this.localeService = i;
  }
  getMenuItem() {
    const e = this.localeService.getLocaleTextFunc(), t = (i, r, n, s) => ({
      name: e(i, r),
      action: () => this.chartService.createPivotChart({ chartType: n }),
      _key: s
    });
    return {
      name: e("pivotChart", "Pivot Chart"),
      _key: "pivotChart",
      subMenu: [
        {
          _key: "pivotColumnChart",
          name: e("columnChart", "Column"),
          subMenu: [
            t("groupedColumn", "Grouped&lrm;", "groupedColumn", "pivotGroupedColumn"),
            t("stackedColumn", "Stacked&lrm;", "stackedColumn", "pivotStackedColumn"),
            t("normalizedColumn", "100% Stacked&lrm;", "normalizedColumn", "pivotNormalizedColumn")
          ]
        },
        {
          _key: "pivotBarChart",
          name: e("barChart", "Bar"),
          subMenu: [
            t("groupedBar", "Grouped&lrm;", "groupedBar", "pivotGroupedBar"),
            t("stackedBar", "Stacked&lrm;", "stackedBar", "pivotStackedBar"),
            t("normalizedBar", "100% Stacked&lrm;", "normalizedBar", "pivotNormalizedBar")
          ]
        },
        {
          _key: "pivotPieChart",
          name: e("pieChart", "Pie"),
          subMenu: [
            t("pie", "Pie&lrm;", "pie", "pivotPie"),
            t("doughnut", "Doughnut&lrm;", "doughnut", "pivotDoughnut")
          ]
        },
        t("line", "Line&lrm;", "line", "pivotLineChart"),
        {
          _key: "pivotXYChart",
          name: e("xyChart", "X Y (Scatter)"),
          subMenu: [
            t("scatter", "Scatter&lrm;", "scatter", "pivotScatter"),
            t("bubble", "Bubble&lrm;", "bubble", "pivotBubble")
          ]
        },
        {
          _key: "pivotAreaChart",
          name: e("areaChart", "Area"),
          subMenu: [
            t("area", "Area&lrm;", "area", "pivotArea"),
            t("stackedArea", "Stacked&lrm;", "stackedArea", "pivotStackedArea"),
            t("normalizedArea", "100% Stacked&lrm;", "normalizedArea", "pivotNormalizedArea")
          ]
        },
        t("histogramChart", "Histogram&lrm;", "histogram", "pivotHistogramChart"),
        {
          _key: "pivotCombinationChart",
          name: e("combinationChart", "Combination"),
          subMenu: [
            t("columnLineCombo", "Column & Line&lrm;", "columnLineCombo", "pivotColumnLineCombo"),
            t("AreaColumnCombo", "Area & Column&lrm;", "areaColumnCombo", "pivotAreaColumnCombo")
          ]
        }
      ],
      icon: x.createIconNoSpan("chart", this.gridOptionsService, void 0)
    };
  }
  getConfigLookup() {
    return {
      columnGroup: {
        _key: "pivotColumnChart",
        column: "pivotGroupedColumn",
        stackedColumn: "pivotStackedColumn",
        normalizedColumn: "pivotNormalizedColumn"
      },
      barGroup: {
        _key: "pivotBarChart",
        bar: "pivotGroupedBar",
        stackedBar: "pivotStackedBar",
        normalizedBar: "pivotNormalizedBar"
      },
      pieGroup: {
        _key: "pivotPieChart",
        pie: "pivotPie",
        doughnut: "pivotDoughnut"
      },
      lineGroup: {
        _key: "pivotLineChart",
        line: "pivotLineChart"
      },
      scatterGroup: {
        _key: "pivotXYChart",
        bubble: "pivotBubble",
        scatter: "pivotScatter"
      },
      areaGroup: {
        _key: "pivotAreaChart",
        area: "pivotArea",
        stackedArea: "pivotStackedArea",
        normalizedArea: "pivotNormalizedArea"
      },
      histogramGroup: {
        _key: "pivotHistogramChart",
        histogram: "pivotHistogramChart"
      },
      combinationGroup: {
        _key: "pivotCombinationChart",
        columnLineCombo: "pivotColumnLineCombo",
        areaColumnCombo: "pivotAreaColumnCombo",
        customCombo: ""
        // Not currently supported but needs a value to separate from a missing value
      }
    };
  }
}
class Kz {
  constructor(e, t, i) {
    this.gridOptionsService = e, this.chartService = t, this.localeService = i;
  }
  getMenuItem() {
    const e = this.localeService.getLocaleTextFunc(), t = (i, r, n, s) => ({
      name: e(i, r),
      action: () => this.chartService.createChartFromCurrentRange(n),
      _key: s
    });
    return {
      name: e("chartRange", "Chart Range"),
      _key: "chartRange",
      subMenu: [
        {
          name: e("columnChart", "Column"),
          subMenu: [
            t("groupedColumn", "Grouped&lrm;", "groupedColumn", "rangeGroupedColumn"),
            t("stackedColumn", "Stacked&lrm;", "stackedColumn", "rangeStackedColumn"),
            t("normalizedColumn", "100% Stacked&lrm;", "normalizedColumn", "rangeNormalizedColumn")
          ],
          _key: "rangeColumnChart"
        },
        {
          name: e("barChart", "Bar"),
          subMenu: [
            t("groupedBar", "Grouped&lrm;", "groupedBar", "rangeGroupedBar"),
            t("stackedBar", "Stacked&lrm;", "stackedBar", "rangeStackedBar"),
            t("normalizedBar", "100% Stacked&lrm;", "normalizedBar", "rangeNormalizedBar")
          ],
          _key: "rangeBarChart"
        },
        {
          name: e("pieChart", "Pie"),
          subMenu: [
            t("pie", "Pie&lrm;", "pie", "rangePie"),
            t("doughnut", "Doughnut&lrm;", "doughnut", "rangeDoughnut")
          ],
          _key: "rangePieChart"
        },
        t("line", "Line&lrm;", "line", "rangeLineChart"),
        {
          name: e("xyChart", "X Y (Scatter)"),
          subMenu: [
            t("scatter", "Scatter&lrm;", "scatter", "rangeScatter"),
            t("bubble", "Bubble&lrm;", "bubble", "rangeBubble")
          ],
          _key: "rangeXYChart"
        },
        {
          name: e("areaChart", "Area"),
          subMenu: [
            t("area", "Area&lrm;", "area", "rangeArea"),
            t("stackedArea", "Stacked&lrm;", "stackedArea", "rangeStackedArea"),
            t("normalizedArea", "100% Stacked&lrm;", "normalizedArea", "rangeNormalizedArea")
          ],
          _key: "rangeAreaChart"
        },
        t("histogramChart", "Histogram&lrm;", "histogram", "rangeHistogramChart"),
        {
          name: e("combinationChart", "Combination"),
          subMenu: [
            t("columnLineCombo", "Column & Line&lrm;", "columnLineCombo", "rangeColumnLineCombo"),
            t("AreaColumnCombo", "Area & Column&lrm;", "areaColumnCombo", "rangeAreaColumnCombo")
          ],
          _key: "rangeCombinationChart"
        }
      ],
      icon: x.createIconNoSpan("chart", this.gridOptionsService, void 0)
    };
  }
  getConfigLookup() {
    return {
      columnGroup: {
        _key: "rangeColumnChart",
        column: "rangeGroupedColumn",
        stackedColumn: "rangeStackedColumn",
        normalizedColumn: "rangeNormalizedColumn"
      },
      barGroup: {
        _key: "rangeBarChart",
        bar: "rangeGroupedBar",
        stackedBar: "rangeStackedBar",
        normalizedBar: "rangeNormalizedBar"
      },
      pieGroup: {
        _key: "rangePieChart",
        pie: "rangePie",
        doughnut: "rangeDoughnut"
      },
      lineGroup: {
        _key: "rangeLineChart",
        line: "rangeLineChart"
      },
      scatterGroup: {
        _key: "rangeXYChart",
        bubble: "rangeBubble",
        scatter: "rangeScatter"
      },
      areaGroup: {
        _key: "rangeAreaChart",
        area: "rangeArea",
        stackedArea: "rangeStackedArea",
        normalizedArea: "rangeNormalizedArea"
      },
      histogramGroup: {
        _key: "rangeHistogramChart",
        histogram: "rangeHistogramChart"
      },
      combinationGroup: {
        _key: "rangeCombinationChart",
        columnLineCombo: "rangeColumnLineCombo",
        areaColumnCombo: "rangeAreaColumnCombo",
        customCombo: ""
        // Not currently supported but needs a value to separate from a missing value
      }
    };
  }
}
const Yz = {
  version: $z,
  moduleName: Q.MenuModule,
  beans: [xa, Kl, Fo, bv],
  dependantModules: [
    Pi
  ]
};
var Dw = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Da extends mu {
  constructor() {
    super(
      /* html */
      '<div class="ag-multi-filter ag-menu-list-compact"></div>'
    ), this.filterDefs = [], this.filters = [], this.guiDestroyFuncs = [], this.activeFilterIndices = [], this.lastActivatedMenuItem = null, this.afterFiltersReadyFuncs = [];
  }
  postConstruct() {
    this.initialiseTabGuard({
      onFocusIn: (e) => this.onFocusIn(e)
    });
  }
  static getFilterDefs(e) {
    const { filters: t } = e;
    return t && t.length > 0 ? t : [{ filter: "agTextColumnFilter" }, { filter: "agSetColumnFilter" }];
  }
  init(e) {
    this.params = e, this.filterDefs = Da.getFilterDefs(e);
    const { column: t, filterChangedCallback: i } = e;
    this.column = t, this.filterChangedCallback = i;
    const r = [];
    return this.filterDefs.forEach((n, s) => {
      const a = this.createFilter(n, s);
      a != null && r.push(a);
    }), Qe.all(r).then((n) => {
      this.filters = n, this.refreshGui("columnMenu"), this.afterFiltersReadyFuncs.forEach((s) => s()), this.afterFiltersReadyFuncs.length = 0;
    });
  }
  refreshGui(e) {
    e !== this.lastOpenedInContainer && (this.removeAllChildrenExceptTabGuards(), this.destroyChildren(), this.filters.forEach((t, i) => {
      i > 0 && this.appendChild(x.loadTemplate(
        /* html */
        '<div class="ag-filter-separator"></div>'
      ));
      const r = this.filterDefs[i], n = this.getFilterTitle(t, r);
      let s;
      r.display === "subMenu" && e !== "toolPanel" ? s = this.insertFilterMenu(t, n).getGui() : r.display === "subMenu" || r.display === "accordion" ? s = this.insertFilterGroup(t, n).getGui() : s = t.getGui(), this.appendChild(s);
    }), this.lastOpenedInContainer = e);
  }
  getFilterTitle(e, t) {
    if (t.title != null)
      return t.title;
    const i = e;
    return typeof i.getFilterTitle == "function" ? i.getFilterTitle() : "Filter";
  }
  destroyChildren() {
    this.guiDestroyFuncs.forEach((e) => e()), this.guiDestroyFuncs.length = 0;
  }
  insertFilterMenu(e, t) {
    const i = this.createBean(new _t({
      name: t,
      subMenu: e,
      cssClasses: ["ag-multi-filter-menu-item"],
      isCompact: !0,
      isAnotherSubMenuOpen: () => !1
    }));
    return i.setParentComponent(this), this.guiDestroyFuncs.push(() => this.destroyBean(i)), this.addManagedListener(i, _t.EVENT_MENU_ITEM_ACTIVATED, (r) => {
      this.lastActivatedMenuItem && this.lastActivatedMenuItem !== r.menuItem && this.lastActivatedMenuItem.deactivate(), this.lastActivatedMenuItem = r.menuItem;
    }), i.addGuiEventListener("focusin", () => i.activate()), i.addGuiEventListener("focusout", () => {
      i.isSubMenuOpen() || i.deactivate();
    }), i;
  }
  insertFilterGroup(e, t) {
    const i = this.createBean(new Tt({
      title: t,
      cssIdentifier: "multi-filter"
    }));
    return this.guiDestroyFuncs.push(() => this.destroyBean(i)), i.addItem(e.getGui()), i.toggleGroupExpand(!1), e.afterGuiAttached && i.addManagedListener(i, Tt.EVENT_EXPANDED, () => e.afterGuiAttached({
      container: this.lastOpenedInContainer,
      suppressFocus: !0,
      hidePopup: this.hidePopup
    })), i;
  }
  isFilterActive() {
    return this.filters.some((e) => e.isFilterActive());
  }
  getLastActiveFilterIndex() {
    return this.activeFilterIndices.length > 0 ? this.activeFilterIndices[this.activeFilterIndices.length - 1] : null;
  }
  doesFilterPass(e, t) {
    let i = !0;
    return this.filters.forEach((r) => {
      !i || r === t || !r.isFilterActive() || (i = r.doesFilterPass(e));
    }), i;
  }
  getFilterType() {
    return "multi";
  }
  getModelFromUi() {
    return {
      filterType: this.getFilterType(),
      filterModels: this.filters.map((t) => {
        const i = t;
        return typeof i.getModelFromUi == "function" ? i.getModelFromUi() : null;
      })
    };
  }
  getModel() {
    return this.isFilterActive() ? {
      filterType: this.getFilterType(),
      filterModels: this.filters.map((t) => t.isFilterActive() ? t.getModel() : null)
    } : null;
  }
  setModel(e) {
    const t = (r, n) => new Qe((s) => {
      const a = r.setModel(n);
      a ? a.then(() => s()) : s();
    });
    let i = [];
    return e == null ? i = this.filters.map((r, n) => t(r, null).then(() => {
      this.updateActiveList(n);
    })) : this.filters.forEach((r, n) => {
      const s = e.filterModels.length > n ? e.filterModels[n] : null, a = t(r, s).then(() => {
        this.updateActiveList(n);
      });
      i.push(a);
    }), Qe.all(i).then(() => {
    });
  }
  applyModel(e = "api") {
    let t = !1;
    return this.filters.forEach((i) => {
      i instanceof Pr && (t = i.applyModel(e) || t);
    }), t;
  }
  getChildFilterInstance(e) {
    return this.filters[e];
  }
  afterGuiAttached(e) {
    e ? (this.hidePopup = e.hidePopup, this.refreshGui(e.container)) : this.hidePopup = void 0;
    const { filters: t } = this.params, i = t && t.some((s) => s.display && s.display !== "inline");
    this.executeFunctionIfExists("afterGuiAttached", Object.assign(Object.assign({}, e || {}), { suppressFocus: i }));
    const r = this.gridOptionsService.getDocument(), n = r.activeElement;
    i && (n === r.body || this.getGui().contains(n)) && this.forceFocusOutOfContainer(!0);
  }
  afterGuiDetached() {
    this.executeFunctionIfExists("afterGuiDetached");
  }
  onAnyFilterChanged() {
    this.executeFunctionIfExists("onAnyFilterChanged");
  }
  onNewRowsLoaded() {
    this.executeFunctionIfExists("onNewRowsLoaded");
  }
  destroy() {
    this.filters.forEach((e) => {
      e.setModel(null), this.destroyBean(e);
    }), this.filters.length = 0, this.destroyChildren(), this.hidePopup = void 0, super.destroy();
  }
  executeFunctionIfExists(e, ...t) {
    x.forEachReverse(this.filters, (i) => {
      const r = i[e];
      typeof r == "function" && r.apply(i, t);
    });
  }
  createFilter(e, t) {
    const { filterModifiedCallback: i, doesRowPassOtherFilter: r } = this.params;
    let n;
    const s = Object.assign(Object.assign({}, this.filterManager.createFilterParams(this.column, this.column.getColDef())), { filterModifiedCallback: i, filterChangedCallback: (c) => {
      this.executeWhenAllFiltersReady(() => this.filterChanged(t, c));
    }, doesRowPassOtherFilter: (c) => r(c) && this.doesFilterPass({ node: c, data: c.data }, n) }), a = this.userComponentFactory.getFilterDetails(e, s, "agTextColumnFilter");
    if (!a)
      return null;
    const l = a.newAgStackInstance();
    return l && l.then((c) => n = c), l;
  }
  executeWhenAllFiltersReady(e) {
    this.filters && this.filters.length > 0 ? e() : this.afterFiltersReadyFuncs.push(e);
  }
  updateActiveList(e) {
    const t = this.filters[e];
    x.removeFromArray(this.activeFilterIndices, e), t.isFilterActive() && this.activeFilterIndices.push(e);
  }
  filterChanged(e, t) {
    this.updateActiveList(e), this.filterChangedCallback(t);
    const i = this.filters[e];
    this.filters.forEach((r) => {
      r !== i && typeof r.onAnyFilterChanged == "function" && r.onAnyFilterChanged();
    });
  }
  onFocusIn(e) {
    return this.lastActivatedMenuItem != null && !this.lastActivatedMenuItem.getGui().contains(e.target) && (this.lastActivatedMenuItem.deactivate(), this.lastActivatedMenuItem = null), !0;
  }
  getModelAsString(e) {
    var t, i, r, n;
    if (!this.filters || !(!((t = e == null ? void 0 : e.filterModels) === null || t === void 0) && t.length))
      return "";
    const s = (i = this.getLastActiveFilterIndex()) !== null && i !== void 0 ? i : 0, a = this.filters[s];
    return (n = (r = a.getModelAsString) === null || r === void 0 ? void 0 : r.call(a, e.filterModels[s])) !== null && n !== void 0 ? n : "";
  }
}
Dw([
  S("filterManager")
], Da.prototype, "filterManager", void 0);
Dw([
  S("userComponentFactory")
], Da.prototype, "userComponentFactory", void 0);
Dw([
  B
], Da.prototype, "postConstruct", null);
var dP = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Ow extends X {
  constructor() {
    super(
      /* html */
      '<div class="ag-multi-floating-filter ag-floating-filter-input"></div>'
    ), this.floatingFilters = [];
  }
  init(e) {
    this.params = e;
    const t = e.filterParams, i = [];
    return Da.getFilterDefs(t).forEach((r, n) => {
      const s = Object.assign(Object.assign({}, e), {
        // set the parent filter instance for each floating filter to the relevant child filter instance
        parentFilterInstance: (l) => {
          this.parentMultiFilterInstance((c) => {
            const d = c.getChildFilterInstance(n);
            d != null && l(d);
          });
        }
      });
      x.mergeDeep(s.filterParams, r.filterParams);
      const a = this.createFloatingFilter(r, s);
      a != null && i.push(a);
    }), Qe.all(i).then((r) => {
      r.forEach((n, s) => {
        this.floatingFilters.push(n);
        const a = n.getGui();
        this.appendChild(a), s > 0 && x.setDisplayed(a, !1);
      });
    });
  }
  onParentModelChanged(e, t) {
    t && t.afterFloatingFilter || this.parentMultiFilterInstance((i) => {
      if (e == null)
        this.floatingFilters.forEach((r, n) => {
          r.onParentModelChanged(null, t), x.setDisplayed(r.getGui(), n === 0);
        });
      else {
        const r = i.getLastActiveFilterIndex();
        this.floatingFilters.forEach((n, s) => {
          const a = e.filterModels.length > s ? e.filterModels[s] : null;
          n.onParentModelChanged(a, t);
          const l = r == null ? s === 0 : s === r;
          x.setDisplayed(n.getGui(), l);
        });
      }
    });
  }
  destroy() {
    this.destroyBeans(this.floatingFilters), this.floatingFilters.length = 0, super.destroy();
  }
  createFloatingFilter(e, t) {
    var i;
    let r = (i = this.userComponentFactory.getDefaultFloatingFilterType(e, () => this.filterManager.getDefaultFloatingFilter(this.params.column))) !== null && i !== void 0 ? i : "agReadOnlyFloatingFilter";
    const n = this.userComponentFactory.getFloatingFilterCompDetails(e, t, r);
    return n ? n.newAgStackInstance() : null;
  }
  parentMultiFilterInstance(e) {
    this.params.parentFilterInstance((t) => {
      if (!(t instanceof Da))
        throw new Error("AG Grid - MultiFloatingFilterComp expects MultiFilter as its parent");
      e(t);
    });
  }
}
dP([
  S("userComponentFactory")
], Ow.prototype, "userComponentFactory", void 0);
dP([
  S("filterManager")
], Ow.prototype, "filterManager", void 0);
const Xz = "30.0.5", qz = {
  version: Xz,
  moduleName: Q.MultiFilterModule,
  beans: [],
  userComponents: [
    { componentName: "agMultiColumnFilter", componentClass: Da },
    { componentName: "agMultiColumnFloatingFilter", componentClass: Ow }
  ],
  dependantModules: [
    Pi
  ]
};
function uP(o, e) {
  o.then((t) => {
    const i = t.getGui();
    i != null && (typeof i == "object" ? e.appendChild(i) : e.innerHTML = i);
  });
}
var Zz = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class hP extends X {
  constructor(e) {
    super(
      /* html */
      '<div class="ag-rich-select-row" role="presentation"></div>'
    ), this.params = e;
  }
  setState(e, t, i) {
    this.populateWithRenderer(e, t) || this.populateWithoutRenderer(e, t), this.updateSelected(i);
  }
  updateSelected(e) {
    this.addOrRemoveCssClass("ag-rich-select-row-selected", e);
  }
  populateWithoutRenderer(e, t) {
    const r = t != null ? t : e;
    x.exists(r) && r !== "" ? this.getGui().textContent = r.toString() : this.getGui().innerHTML = "&nbsp;";
  }
  populateWithRenderer(e, t) {
    const i = {
      value: e,
      valueFormatted: t,
      api: this.gridOptionsService.api
    }, r = this.userComponentFactory.getCellRendererDetails(this.params, i), n = r ? r.newAgStackInstance() : void 0;
    return n != null ? uP(n, this.getGui()) : this.getGui().innerText = i.valueFormatted != null ? i.valueFormatted : i.value, n ? (n.then((s) => {
      this.addDestroyFunc(() => {
        this.getContext().destroyBean(s);
      });
    }), !0) : !1;
  }
}
Zz([
  S("userComponentFactory")
], hP.prototype, "userComponentFactory", void 0);
var Pw = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Oa extends rc {
  constructor() {
    super(Oa.TEMPLATE), this.selectionConfirmed = !1, this.searchString = "";
  }
  init(e) {
    var t;
    this.params = e, this.selectedValue = e.value, this.originalSelectedValue = e.value, this.focusAfterAttached = e.cellStartedEdit;
    const i = x.createIconNoSpan("smallDown", this.gridOptionsService);
    if (i.classList.add("ag-rich-select-value-icon"), this.eValue.appendChild(i), this.virtualList = this.createManagedBean(new Ls("rich-select")), this.virtualList.setComponentCreator(this.createRowComponent.bind(this)), this.eList.appendChild(this.virtualList.getGui()), x.exists(this.params.cellHeight) && this.virtualList.setRowHeight(this.params.cellHeight), this.renderSelectedValue(), x.missing(e.values)) {
      console.warn("AG Grid: richSelectCellEditor requires values for it to work");
      return;
    }
    const r = e.values;
    this.virtualList.setModel({
      getRowCount: () => r.length,
      getRow: (a) => r[a]
    }), this.addGuiEventListener("keydown", this.onKeyDown.bind(this));
    const n = this.virtualList.getGui();
    this.addManagedListener(n, "click", this.onClick.bind(this)), this.addManagedListener(n, "mousemove", this.onMouseMove.bind(this));
    const s = x.exists(e.searchDebounceDelay) ? e.searchDebounceDelay : 300;
    this.clearSearchString = x.debounce(this.clearSearchString, s), ((t = e.eventKey) === null || t === void 0 ? void 0 : t.length) === 1 && this.searchText(e.eventKey);
  }
  onKeyDown(e) {
    const t = e.key;
    switch (e.preventDefault(), t) {
      case V.ENTER:
        this.onEnterKeyDown();
        break;
      case V.TAB:
        this.confirmSelection();
        break;
      case V.DOWN:
      case V.UP:
        this.onNavigationKeyDown(e, t);
        break;
      default:
        this.searchText(e);
    }
  }
  confirmSelection() {
    this.selectionConfirmed = !0;
  }
  onEnterKeyDown() {
    this.confirmSelection(), this.params.stopEditing();
  }
  onNavigationKeyDown(e, t) {
    e.preventDefault();
    const i = this.params.values.indexOf(this.selectedValue), r = t === V.UP ? i - 1 : i + 1;
    if (r >= 0 && r < this.params.values.length) {
      const n = this.params.values[r];
      this.setSelectedValue(n);
    }
  }
  searchText(e) {
    if (typeof e != "string") {
      let t = e.key;
      if (t === V.BACKSPACE)
        this.searchString = this.searchString.slice(0, -1), t = "";
      else if (!x.isEventFromPrintableCharacter(e))
        return;
      this.searchText(t);
      return;
    }
    this.searchString += e, this.runSearch(), this.clearSearchString();
  }
  runSearch() {
    const e = this.params.values;
    let t;
    if ((typeof e[0] == "number" || typeof e[0] == "string") && (t = e.map((s) => this.params.formatValue(s))), typeof e[0] == "object" && this.params.colDef.keyCreator && (t = e.map((s) => {
      const a = {
        value: s,
        colDef: this.params.colDef,
        column: this.params.column,
        node: this.params.node,
        data: this.params.data,
        api: this.gridOptionsService.api,
        columnApi: this.gridOptionsService.columnApi,
        context: this.gridOptionsService.context
      };
      return this.params.colDef.keyCreator(a);
    })), !t)
      return;
    const i = x.fuzzySuggestions(this.searchString, t, !0)[0];
    if (!i)
      return;
    const r = t.indexOf(i), n = e[r];
    this.setSelectedValue(n);
  }
  clearSearchString() {
    this.searchString = "";
  }
  renderSelectedValue() {
    const e = this.params.formatValue(this.selectedValue), t = this.eValue, i = {
      value: this.selectedValue,
      valueFormatted: e,
      api: this.gridOptionsService.api
    }, r = this.userComponentFactory.getCellRendererDetails(this.params, i), n = r ? r.newAgStackInstance() : void 0;
    n ? (uP(n, t), n.then((s) => {
      this.addDestroyFunc(() => this.getContext().destroyBean(s));
    })) : x.exists(this.selectedValue) ? t.innerText = e : x.clearElement(t);
  }
  setSelectedValue(e) {
    if (this.selectedValue === e)
      return;
    const t = this.params.values.indexOf(e);
    t !== -1 && (this.selectedValue = e, this.virtualList.ensureIndexVisible(t), this.virtualList.forEachRenderedRow((i, r) => {
      i.updateSelected(t === r);
    }), this.virtualList.focusRow(t));
  }
  createRowComponent(e) {
    const t = this.params.formatValue(e), i = new hP(this.params);
    return this.getContext().createBean(i), i.setState(e, t, e === this.selectedValue), i;
  }
  onMouseMove(e) {
    const t = this.virtualList.getGui().getBoundingClientRect(), i = this.virtualList.getScrollTop(), r = e.clientY - t.top + i, n = Math.floor(r / this.virtualList.getRowHeight()), s = this.params.values[n];
    s !== void 0 && this.setSelectedValue(s);
  }
  onClick() {
    this.confirmSelection(), this.params.stopEditing();
  }
  // we need to have the gui attached before we can draw the virtual rows, as the
  // virtual row logic needs info about the gui state
  afterGuiAttached() {
    const e = this.params.values.indexOf(this.selectedValue);
    if (this.virtualList.refresh(), e >= 0 && this.virtualList.ensureIndexVisible(e), this.virtualList.refresh(), this.focusAfterAttached) {
      const t = e !== -1 ? e : 0;
      this.params.values.length ? this.virtualList.focusRow(t) : this.getGui().focus();
    }
  }
  getValue() {
    return this.selectionConfirmed ? this.selectedValue : this.originalSelectedValue;
  }
}
Oa.TEMPLATE = `<div class="ag-rich-select" tabindex="-1">
            <div ref="eValue" class="ag-rich-select-value"></div>
            <div ref="eList" class="ag-rich-select-list"></div>
        </div>`;
Pw([
  S("userComponentFactory")
], Oa.prototype, "userComponentFactory", void 0);
Pw([
  L("eValue")
], Oa.prototype, "eValue", void 0);
Pw([
  L("eList")
], Oa.prototype, "eList", void 0);
const Qz = "30.0.5", Jz = {
  version: Qz,
  moduleName: Q.RichSelectModule,
  beans: [],
  userComponents: [
    { componentName: "agRichSelect", componentClass: Oa },
    { componentName: "agRichSelectCellEditor", componentClass: Oa }
  ],
  dependantModules: [
    Pi
  ]
};
var En = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class hr extends Gt {
  constructor(e, t, i) {
    super(0), this.nodeIdSequence = new Ei(), this.info = {}, this.ssrmParams = e, this.parentRowNode = i, this.level = i.level + 1, this.groupLevel = e.rowGroupCols ? this.level < e.rowGroupCols.length : void 0, this.leafGroup = e.rowGroupCols ? this.level === e.rowGroupCols.length - 1 : !1;
  }
  postConstruct() {
    if (this.usingTreeData = this.gridOptionsService.isTreeData(), this.nodeIdPrefix = this.blockUtils.createNodeIdPrefix(this.parentRowNode), !this.usingTreeData && this.groupLevel) {
      const r = this.ssrmParams.rowGroupCols[this.level];
      this.groupField = r.field, this.rowGroupColumn = this.columnModel.getRowGroupColumns()[this.level];
    }
    let e = 1;
    const t = this.parentRowNode.level === -1, i = this.storeUtils.getServerSideInitialRowCount();
    t && i !== void 0 && (e = i), this.initialiseRowNodes(e), this.rowNodeBlockLoader.addBlock(this), this.addDestroyFunc(() => this.rowNodeBlockLoader.removeBlock(this));
  }
  destroyRowNodes() {
    this.blockUtils.destroyRowNodes(this.allRowNodes), this.allRowNodes = [], this.nodesAfterSort = [], this.nodesAfterFilter = [], this.allNodesMap = {};
  }
  initialiseRowNodes(e, t = !1) {
    this.destroyRowNodes();
    for (let i = 0; i < e; i++) {
      const r = this.blockUtils.createRowNode({
        field: this.groupField,
        group: this.groupLevel,
        leafGroup: this.leafGroup,
        level: this.level,
        parent: this.parentRowNode,
        rowGroupColumn: this.rowGroupColumn
      });
      t && (r.failedLoad = !0), this.allRowNodes.push(r), this.nodesAfterFilter.push(r), this.nodesAfterSort.push(r);
    }
  }
  getBlockStateJson() {
    return {
      id: this.nodeIdPrefix ? this.nodeIdPrefix : "",
      state: this.getState()
    };
  }
  loadFromDatasource() {
    this.storeUtils.loadFromDatasource({
      startRow: void 0,
      endRow: void 0,
      parentBlock: this,
      parentNode: this.parentRowNode,
      storeParams: this.ssrmParams,
      successCallback: this.pageLoaded.bind(this, this.getVersion()),
      success: this.success.bind(this, this.getVersion()),
      failCallback: this.pageLoadFailed.bind(this, this.getVersion()),
      fail: this.pageLoadFailed.bind(this, this.getVersion())
    });
  }
  getStartRow() {
    return 0;
  }
  getEndRow() {
    return this.nodesAfterSort.length;
  }
  createDataNode(e, t) {
    const i = this.blockUtils.createRowNode({
      field: this.groupField,
      group: this.groupLevel,
      leafGroup: this.leafGroup,
      level: this.level,
      parent: this.parentRowNode,
      rowGroupColumn: this.rowGroupColumn
    });
    t != null ? x.insertIntoArray(this.allRowNodes, i, t) : this.allRowNodes.push(i);
    const r = this.prefixId(this.nodeIdSequence.next());
    return this.blockUtils.setDataIntoRowNode(i, e, r, void 0), this.nodeManager.addRowNode(i), this.blockUtils.checkOpenByDefault(i), this.allNodesMap[i.id] = i, i;
  }
  prefixId(e) {
    return this.nodeIdPrefix ? this.nodeIdPrefix + "-" + e : e.toString();
  }
  processServerFail() {
    this.initialiseRowNodes(1, !0), this.fireStoreUpdatedEvent(), this.flushAsyncTransactions();
  }
  processServerResult(e) {
    if (!this.isAlive())
      return;
    const t = e.storeInfo || e.groupLevelInfo;
    t && Object.assign(this.info, t);
    const i = this.allRowNodes.length > 0 ? this.allNodesMap : void 0;
    if (this.allRowNodes = [], this.nodesAfterSort = [], this.nodesAfterFilter = [], this.allNodesMap = {}, !e.rowData) {
      const r = 'AG Grid: "params.data" is missing from Server-Side Row Model success() callback. Please use the "data" attribute. If no data is returned, set an empty list.';
      x.doOnce(() => console.warn(r, e), "FullStore.noData");
    }
    this.createOrRecycleNodes(i, e.rowData), i && this.blockUtils.destroyRowNodes(x.getAllValuesInObject(i)), this.filterAndSortNodes(), this.fireStoreUpdatedEvent(), this.flushAsyncTransactions();
  }
  createOrRecycleNodes(e, t) {
    if (!t)
      return;
    const i = (n) => {
      if (!e)
        return;
      const s = this.gridOptionsService.getCallback("getRowId");
      if (!s)
        return;
      const a = this.parentRowNode.getGroupKeys(), l = this.level, c = s({
        data: n,
        parentKeys: a.length > 0 ? a : void 0,
        level: l
      }), d = e[c];
      if (d)
        return delete e[c], d;
    }, r = (n, s) => {
      this.allNodesMap[n.id] = n, this.blockUtils.updateDataIntoRowNode(n, s), this.allRowNodes.push(n);
    };
    t.forEach((n) => {
      const s = i(n);
      s ? r(s, n) : this.createDataNode(n);
    });
  }
  flushAsyncTransactions() {
    window.setTimeout(() => this.transactionManager.flushAsyncTransactions(), 0);
  }
  filterAndSortNodes() {
    this.filterRowNodes(), this.sortRowNodes();
  }
  sortRowNodes() {
    const e = this.storeUtils.isServerSideSortAllLevels() || this.storeUtils.isServerSideSortOnServer(), t = this.sortController.getSortOptions(), i = !t || t.length == 0;
    if (e || i) {
      this.nodesAfterSort = this.nodesAfterFilter;
      return;
    }
    this.nodesAfterSort = this.rowNodeSorter.doFullSort(this.nodesAfterFilter, t);
  }
  filterRowNodes() {
    const e = !this.storeUtils.isServerSideOnlyRefreshFilteredGroups() || this.storeUtils.isServerSideFilterOnServer(), t = this.groupLevel;
    if (e || t) {
      this.nodesAfterFilter = this.allRowNodes;
      return;
    }
    this.nodesAfterFilter = this.allRowNodes.filter((i) => this.filterManager.doesRowPassFilter({ rowNode: i }));
  }
  clearDisplayIndexes() {
    this.displayIndexStart = void 0, this.displayIndexEnd = void 0, this.allRowNodes.forEach((e) => this.blockUtils.clearDisplayIndex(e));
  }
  getDisplayIndexEnd() {
    return this.displayIndexEnd;
  }
  isDisplayIndexInStore(e) {
    return this.getRowCount() === 0 ? !1 : e >= this.displayIndexStart && e < this.displayIndexEnd;
  }
  setDisplayIndexes(e, t) {
    this.displayIndexStart = e.peek(), this.topPx = t.value;
    const i = {};
    this.nodesAfterSort.forEach((r) => {
      this.blockUtils.setDisplayIndex(r, e, t), i[r.id] = !0;
    }), this.allRowNodes.forEach((r) => {
      i[r.id] || this.blockUtils.clearDisplayIndex(r);
    }), this.displayIndexEnd = e.peek(), this.heightPx = t.value - this.topPx;
  }
  forEachStoreDeep(e, t = new Ei()) {
    e(this, t.next()), this.allRowNodes.forEach((i) => {
      const r = i.childStore;
      r && r.forEachStoreDeep(e, t);
    });
  }
  forEachNodeDeep(e, t = new Ei()) {
    this.allRowNodes.forEach((i) => {
      e(i, t.next());
      const r = i.childStore;
      r && r.forEachNodeDeep(e, t);
    });
  }
  forEachNodeDeepAfterFilterAndSort(e, t = new Ei()) {
    this.nodesAfterSort.forEach((i) => {
      e(i, t.next());
      const r = i.childStore;
      r && r.forEachNodeDeepAfterFilterAndSort(e, t);
    });
  }
  getRowUsingDisplayIndex(e) {
    return this.isDisplayIndexInStore(e) ? this.blockUtils.binarySearchForDisplayIndex(e, this.nodesAfterSort) : void 0;
  }
  getRowBounds(e) {
    for (let t = 0; t < this.nodesAfterSort.length; t++) {
      const i = this.nodesAfterSort[t], r = this.blockUtils.extractRowBounds(i, e);
      if (r)
        return r;
    }
    return null;
  }
  isPixelInRange(e) {
    return e >= this.topPx && e < this.topPx + this.heightPx;
  }
  getRowIndexAtPixel(e) {
    if (e <= this.topPx)
      return this.nodesAfterSort[0].rowIndex;
    if (e >= this.topPx + this.heightPx) {
      const s = this.nodesAfterSort[this.nodesAfterSort.length - 1], a = s.rowTop + s.rowHeight;
      if (e >= a && s.expanded) {
        if (s.childStore && s.childStore.getRowCount() > 0)
          return s.childStore.getRowIndexAtPixel(e);
        if (s.detailNode)
          return s.detailNode.rowIndex;
      }
      return s.rowIndex;
    }
    let r = null;
    return this.nodesAfterSort.forEach((s) => {
      const a = this.blockUtils.getIndexAtPixel(s, e);
      a != null && (r = a);
    }), r == null ? this.displayIndexEnd - 1 : r;
  }
  getChildStore(e) {
    return this.storeUtils.getChildStore(e, this, (t) => this.allRowNodes.find((r) => r.key == t));
  }
  forEachChildStoreShallow(e) {
    this.allRowNodes.forEach((t) => {
      const i = t.childStore;
      i && e(i);
    });
  }
  refreshAfterFilter(e) {
    const t = this.storeUtils.isServerSideFilterOnServer(), i = this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, e);
    if (!this.storeUtils.isServerSideOnlyRefreshFilteredGroups() || t && i) {
      this.refreshStore(!0), this.sortRowNodes();
      return;
    }
    this.filterRowNodes(), this.sortRowNodes(), this.forEachChildStoreShallow((n) => n.refreshAfterFilter(e));
  }
  refreshAfterSort(e) {
    const t = this.storeUtils.isServerSideSortOnServer(), i = this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, e);
    if (this.storeUtils.isServerSideSortAllLevels() || t && i) {
      this.refreshStore(!0), this.filterRowNodes();
      return;
    }
    this.filterRowNodes(), this.sortRowNodes(), this.forEachChildStoreShallow((n) => n.refreshAfterSort(e));
  }
  applyTransaction(e) {
    switch (this.getState()) {
      case Gt.STATE_FAILED:
        return { status: tr.StoreLoadingFailed };
      case Gt.STATE_LOADING:
        return { status: tr.StoreLoading };
      case Gt.STATE_WAITING_TO_LOAD:
        return { status: tr.StoreWaitingToLoad };
    }
    const t = this.gridOptionsService.getCallback("isApplyServerSideTransaction");
    if (t) {
      const n = {
        transaction: e,
        parentNode: this.parentRowNode,
        storeInfo: this.info,
        groupLevelInfo: this.info
      };
      if (!t(n))
        return { status: tr.Cancelled };
    }
    const i = {
      status: tr.Applied,
      remove: [],
      update: [],
      add: []
    }, r = [];
    return this.executeAdd(e, i), this.executeRemove(e, i, r), this.executeUpdate(e, i, r), this.filterAndSortNodes(), this.updateSelection(r), i;
  }
  updateSelection(e) {
    if (e.length > 0) {
      this.selectionService.setNodesSelected({
        newValue: !1,
        nodes: e,
        suppressFinishActions: !0,
        clearSelection: !1,
        source: "rowDataChanged"
      });
      const i = {
        type: w.EVENT_SELECTION_CHANGED,
        source: "rowDataChanged"
      };
      this.eventService.dispatchEvent(i);
    }
  }
  executeAdd(e, t) {
    const { add: i, addIndex: r } = e;
    if (x.missingOrEmpty(i))
      return;
    typeof r == "number" && r >= 0 ? i.reverse().forEach((s) => {
      const a = this.createDataNode(s, r);
      t.add.push(a);
    }) : i.forEach((s) => {
      const a = this.createDataNode(s);
      t.add.push(a);
    });
  }
  executeRemove(e, t, i) {
    const { remove: r } = e;
    if (r == null)
      return;
    const n = {};
    r.forEach((s) => {
      const a = this.lookupRowNode(s);
      a && (a.isSelected() && i.push(a), a.clearRowTopAndRowIndex(), n[a.id] = !0, delete this.allNodesMap[a.id], t.remove.push(a), this.nodeManager.removeNode(a));
    }), this.allRowNodes = this.allRowNodes.filter((s) => !n[s.id]);
  }
  executeUpdate(e, t, i) {
    const { update: r } = e;
    r != null && r.forEach((n) => {
      const s = this.lookupRowNode(n);
      s && (this.blockUtils.updateDataIntoRowNode(s, n), !s.selectable && s.isSelected() && i.push(s), t.update.push(s));
    });
  }
  lookupRowNode(e) {
    const t = this.gridOptionsService.getCallback("getRowId");
    let i;
    if (t != null) {
      const r = this.level, n = this.parentRowNode.getGroupKeys(), s = t({
        data: e,
        parentKeys: n.length > 0 ? n : void 0,
        level: r
      });
      if (i = this.allNodesMap[s], !i)
        return console.error(`AG Grid: could not find row id=${s}, data item was not found for this id`), null;
    } else if (i = this.allRowNodes.find((r) => r.data === e), !i)
      return console.error("AG Grid: could not find data item as object was not found", e), null;
    return i;
  }
  addStoreStates(e) {
    e.push({
      suppressInfiniteScroll: !0,
      route: this.parentRowNode.getGroupKeys(),
      rowCount: this.allRowNodes.length,
      info: this.info
    }), this.forEachChildStoreShallow((t) => t.addStoreStates(e));
  }
  refreshStore(e) {
    if (e) {
      const t = this.nodesAfterSort ? this.nodesAfterSort.length : 1;
      this.initialiseRowNodes(t);
    }
    this.scheduleLoad(), this.fireStoreUpdatedEvent();
  }
  retryLoads() {
    this.getState() === Gt.STATE_FAILED && (this.initialiseRowNodes(1), this.scheduleLoad()), this.forEachChildStoreShallow((e) => e.retryLoads());
  }
  scheduleLoad() {
    this.setStateWaitingToLoad(), this.rowNodeBlockLoader.checkBlockToLoad();
  }
  // gets called 1) row count changed 2) cache purged 3) items inserted
  fireStoreUpdatedEvent() {
    const e = {
      type: w.EVENT_STORE_UPDATED
    };
    this.eventService.dispatchEvent(e);
  }
  getRowCount() {
    return this.nodesAfterSort.length;
  }
  getTopLevelRowDisplayedIndex(e) {
    return this.nodesAfterSort[e].rowIndex;
  }
  isLastRowIndexKnown() {
    return this.getState() == Gt.STATE_LOADED;
  }
  getRowNodesInRange(e, t) {
    const i = [];
    let r = !1;
    return x.missing(e) && (r = !0), this.nodesAfterSort.forEach((s) => {
      const a = s === e || s === t;
      (r || a) && i.push(s), a && (r = !r);
    }), r ? [] : i;
  }
  getStoreBounds() {
    return {
      topPx: this.topPx,
      heightPx: this.heightPx
    };
  }
}
En([
  S("ssrmStoreUtils")
], hr.prototype, "storeUtils", void 0);
En([
  S("ssrmBlockUtils")
], hr.prototype, "blockUtils", void 0);
En([
  S("columnModel")
], hr.prototype, "columnModel", void 0);
En([
  S("rowNodeBlockLoader")
], hr.prototype, "rowNodeBlockLoader", void 0);
En([
  S("rowNodeSorter")
], hr.prototype, "rowNodeSorter", void 0);
En([
  S("sortController")
], hr.prototype, "sortController", void 0);
En([
  S("selectionService")
], hr.prototype, "selectionService", void 0);
En([
  S("ssrmNodeManager")
], hr.prototype, "nodeManager", void 0);
En([
  S("filterManager")
], hr.prototype, "filterManager", void 0);
En([
  S("ssrmTransactionManager")
], hr.prototype, "transactionManager", void 0);
En([
  B
], hr.prototype, "postConstruct", null);
En([
  dt
], hr.prototype, "destroyRowNodes", null);
var oy = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class ll extends H {
  constructor(e, t, i) {
    super(), this.loadingNodes = /* @__PURE__ */ new Set(), this.checkForLoadQueued = !1, this.loaderTimeout = void 0, this.nextBlockToLoad = void 0, this.parentNode = t, this.cache = e, this.storeParams = i;
  }
  init() {
    this.addManagedListener(this.rowNodeBlockLoader, Es.BLOCK_LOADED_EVENT, () => this.queueLoadAction());
  }
  isRowLoading(e) {
    return this.loadingNodes.has(e);
  }
  getBlockToLoad() {
    var e;
    const t = this.api.getFirstDisplayedRow(), i = this.api.getLastDisplayedRow();
    for (let l = t; l <= i; l++) {
      const c = this.cache.getNodeCachedByDisplayIndex(l);
      if (!c)
        continue;
      const d = this.cache.getNodes().getBy("node", c);
      if (d && !this.isRowLoading(d.index) && (c.__needsRefreshWhenVisible || c.stub && !c.failedLoad))
        return this.getBlockStartIndexForIndex(d.index);
    }
    const r = this.cache.getNodesToRefresh();
    let n = null, s = Number.MAX_SAFE_INTEGER;
    r.forEach((l) => {
      if (l.rowIndex == null) {
        n = l;
        return;
      }
      const c = Math.abs(t - l.rowIndex), d = Math.abs(l.rowIndex - i);
      c < s && (n = l, s = c), d < s && (n = l, s = d);
    });
    const a = (e = this.cache.getNodes().getBy("node", n)) === null || e === void 0 ? void 0 : e.index;
    return a == null ? void 0 : this.getBlockStartIndexForIndex(a);
  }
  reset() {
    this.loadingNodes.clear(), clearTimeout(this.loaderTimeout), this.loaderTimeout = void 0;
  }
  executeLoad(e, t) {
    var i;
    const r = this.cache.getSsrmParams(), n = {
      startRow: e,
      endRow: t,
      rowGroupCols: r.rowGroupCols,
      valueCols: r.valueCols,
      pivotCols: r.pivotCols,
      pivotMode: r.pivotMode,
      groupKeys: this.parentNode.getGroupKeys(),
      filterModel: r.filterModel,
      sortModel: r.sortModel
    }, s = () => {
      for (let u = 0; u < t - e; u++)
        this.loadingNodes.delete(e + u);
    }, a = () => {
      for (let u = 0; u < t - e; u++)
        this.loadingNodes.add(e + u);
    }, l = (u) => {
      this.rowNodeBlockLoader.loadComplete(), this.cache.onLoadSuccess(e, t - e, u), s(), this.queueLoadAction();
    }, c = () => {
      this.rowNodeBlockLoader.loadComplete(), this.cache.onLoadFailed(e, t - e), s(), this.queueLoadAction();
    }, d = {
      request: n,
      successCallback: (u, h) => l({ rowData: u, rowCount: h }),
      success: l,
      failCallback: c,
      fail: c,
      parentNode: this.parentNode,
      api: this.api,
      columnApi: this.columnApi,
      context: this.gridOptionsService.context
    };
    a(), (i = this.cache.getSsrmParams().datasource) === null || i === void 0 || i.getRows(d);
  }
  getNextBlockToLoad() {
    const e = this.getBlockToLoad();
    return e != null && e < 0 && this.getBlockToLoad(), e != null ? [String(e), e + this.getBlockSize()] : null;
  }
  queueLoadCheck() {
    this.checkForLoadQueued || (this.checkForLoadQueued = !0, window.queueMicrotask(() => {
      this.checkForLoadQueued = !1, this.queueLoadAction();
    }));
  }
  queueLoadAction() {
    var e;
    const t = this.getNextBlockToLoad();
    if (!t) {
      window.clearTimeout(this.loaderTimeout), this.loaderTimeout = void 0, this.nextBlockToLoad = void 0;
      return;
    }
    if (!this.nextBlockToLoad || this.nextBlockToLoad[0] !== t[0] && this.nextBlockToLoad[1] !== t[1]) {
      this.nextBlockToLoad = t, window.clearTimeout(this.loaderTimeout);
      const [i, r] = this.nextBlockToLoad, n = Number(i);
      this.loaderTimeout = window.setTimeout(() => {
        this.cache.isAlive() && (this.loaderTimeout = void 0, this.attemptLoad(n, r), this.nextBlockToLoad = void 0);
      }, (e = this.gridOptionsService.getNum("blockLoadDebounceMillis")) !== null && e !== void 0 ? e : 0);
    }
  }
  attemptLoad(e, t) {
    const i = this.rowNodeBlockLoader.getAvailableLoadingCount();
    i != null && i === 0 || (this.rowNodeBlockLoader.registerLoads(1), this.executeLoad(e, t), this.queueLoadAction());
  }
  getBlockSize() {
    return this.storeParams.cacheBlockSize || ll.DEFAULT_BLOCK_SIZE;
  }
  getBlockStartIndexForIndex(e) {
    const t = this.getBlockSize();
    return e - e % t;
  }
  getBlockBoundsForIndex(e) {
    const t = this.getBlockStartIndexForIndex(e), i = this.getBlockSize();
    return [t, t + i];
  }
}
ll.DEFAULT_BLOCK_SIZE = 100;
oy([
  S("gridApi")
], ll.prototype, "api", void 0);
oy([
  S("columnApi")
], ll.prototype, "columnApi", void 0);
oy([
  S("rowNodeBlockLoader")
], ll.prototype, "rowNodeBlockLoader", void 0);
oy([
  B
], ll.prototype, "init", null);
class e2 {
  constructor(...e) {
    if (e.length < 1)
      throw new Error("AG Grid: At least one index must be provided.");
    this.indexes = e, this.maps = new Map(this.indexes.map((t) => [t, /* @__PURE__ */ new Map()]));
  }
  getBy(e, t) {
    const i = this.maps.get(e);
    if (!i)
      throw new Error(`AG Grid: ${String(e)} not found`);
    return i.get(t);
  }
  set(e) {
    this.indexes.forEach((t) => {
      const i = this.maps.get(t);
      if (!i)
        throw new Error(`AG Grid: ${String(t)} not found`);
      i.set(e[t], e);
    });
  }
  delete(e) {
    this.indexes.forEach((t) => {
      const i = this.maps.get(t);
      if (!i)
        throw new Error(`AG Grid: ${String(t)} not found`);
      i.delete(e[t]);
    });
  }
  clear() {
    this.maps.forEach((e) => e.clear());
  }
  getIterator(e) {
    const t = this.maps.get(e);
    if (!t)
      throw new Error(`AG Grid: ${String(e)} not found`);
    return t.values();
  }
  forEach(e) {
    const t = this.getIterator(this.indexes[0]);
    let i;
    for (; (i = t.next()) && !i.done; )
      e(i.value);
  }
  find(e) {
    const t = this.getIterator(this.indexes[0]);
    let i;
    for (; (i = t.next()) && !i.done; )
      if (e(i.value))
        return i.value;
  }
  filter(e) {
    const t = this.getIterator(this.indexes[0]);
    let i;
    const r = [];
    for (; (i = t.next()) && !i.done; )
      e(i.value) && r.push(i.value);
    return r;
  }
}
var Uu = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class ys extends H {
  constructor(e, t, i) {
    super(), this.live = !0, this.removedNodeCache = /* @__PURE__ */ new Map(), this.store = e, this.numberOfRows = t, this.isLastRowKnown = !1, this.storeParams = i;
  }
  init() {
    this.nodeMap = new e2("index", "id", "node"), this.nodeDisplayIndexMap = /* @__PURE__ */ new Map(), this.nodesToRefresh = /* @__PURE__ */ new Set(), this.defaultNodeIdPrefix = this.blockUtils.createNodeIdPrefix(this.store.getParentNode()), this.rowLoader = this.createManagedBean(new ll(this, this.store.getParentNode(), this.storeParams)), this.getRowIdFunc = this.gridOptionsService.getCallback("getRowId"), this.isMasterDetail = this.gridOptionsService.isMasterDetail();
  }
  destroyRowNodes() {
    this.numberOfRows = 0, this.nodeMap.forEach((e) => this.blockUtils.destroyRowNode(e.node)), this.nodeMap.clear(), this.nodeDisplayIndexMap.clear(), this.nodesToRefresh.clear(), this.live = !1;
  }
  /**
   * Get the row node for a specific display index from this store
   * @param displayIndex the display index of the node to find
   * @returns undefined if the node is not in the store bounds, otherwise will always return a node
   */
  getRowByDisplayIndex(e) {
    var t, i, r, n;
    if (!this.store.isDisplayIndexInStore(e))
      return;
    const s = this.nodeDisplayIndexMap.get(e);
    if (s)
      return (s.stub || s.__needsRefreshWhenVisible) && this.rowLoader.queueLoadCheck(), s;
    if (e === this.store.getDisplayIndexStart())
      return this.createStubNode(0, e);
    const a = this.nodeDisplayIndexMap.get(e - 1);
    if (a) {
      if (this.isMasterDetail && a.master && a.expanded)
        return a.detailNode;
      if (a.expanded && (!((t = a.childStore) === null || t === void 0) && t.isDisplayIndexInStore(e)))
        return (i = a.childStore) === null || i === void 0 ? void 0 : i.getRowUsingDisplayIndex(e);
      const h = this.nodeMap.getBy("node", a);
      return this.createStubNode(h.index + 1, e);
    }
    const l = this.getSurroundingNodesByDisplayIndex(e);
    if (l == null) {
      const h = this.store.getRowCount() - (this.store.getDisplayIndexEnd() - e);
      return this.createStubNode(h, e);
    }
    const { previousNode: c, nextNode: d } = l;
    if (c && c.node.expanded && (!((r = c.node.childStore) === null || r === void 0) && r.isDisplayIndexInStore(e)))
      return (n = c.node.childStore) === null || n === void 0 ? void 0 : n.getRowUsingDisplayIndex(e);
    if (d) {
      const h = d.node.rowIndex - e, p = d.index - h;
      return this.createStubNode(p, e);
    }
    const u = this.store.getRowCount() - (this.store.getDisplayIndexEnd() - e);
    return this.createStubNode(u, e);
  }
  /**
   * Used for creating and positioning a stub node without firing a store updated event
   */
  createStubNode(e, t) {
    const i = this.store.getRowBounds(t), r = this.createRowAtIndex(e, null, (n) => {
      n.setRowIndex(t), n.setRowTop(i.rowTop), this.nodeDisplayIndexMap.set(t, n);
    });
    return this.rowLoader.queueLoadCheck(), r;
  }
  /**
   * @param index The row index relative to this store
   * @returns A rowNode at the given store index
   */
  getRowByStoreIndex(e) {
    var t;
    return (t = this.nodeMap.getBy("index", e)) === null || t === void 0 ? void 0 : t.node;
  }
  /**
   * Given a number of rows, skips through the given sequence & row top reference (using default row height)
   * @param numberOfRowsToSkip number of rows to skip over in the given sequence
   * @param displayIndexSeq the sequence in which to skip
   * @param nextRowTop the row top reference in which to skip
   */
  skipDisplayIndexes(e, t, i) {
    if (e === 0)
      return;
    const r = this.gridOptionsService.getRowHeightAsNumber();
    t.skip(e), i.value += e * r;
  }
  /**
   * @param displayIndexSeq the number sequence for generating the display index of each row
   * @param nextRowTop an object containing the next row top value intended to be modified by ref per row
   */
  setDisplayIndexes(e, t) {
    this.nodeDisplayIndexMap.clear();
    const i = {};
    this.nodeMap.forEach((s) => {
      i[s.index] = s.node;
    });
    let r = -1;
    for (const s in i) {
      const a = i[s], l = Number(s), c = l - 1 - r;
      this.skipDisplayIndexes(c, e, t), this.blockUtils.setDisplayIndex(a, e, t), this.nodeDisplayIndexMap.set(a.rowIndex, a), r = l;
    }
    const n = this.numberOfRows - 1 - r;
    this.skipDisplayIndexes(n, e, t), this.purgeExcessRows();
  }
  getRowCount() {
    return this.numberOfRows;
  }
  setRowCount(e, t) {
    if (e < 0)
      throw new Error("AG Grid: setRowCount can only accept a positive row count.");
    this.numberOfRows = e, t != null && (this.isLastRowKnown = t, t === !1 && (this.numberOfRows += 1)), this.fireStoreUpdatedEvent();
  }
  getNodes() {
    return this.nodeMap;
  }
  getNodeCachedByDisplayIndex(e) {
    var t;
    return (t = this.nodeDisplayIndexMap.get(e)) !== null && t !== void 0 ? t : null;
  }
  getNodesToRefresh() {
    return this.nodesToRefresh;
  }
  /**
   * @returns the previous and next loaded row nodes surrounding the given display index
   */
  getSurroundingNodesByDisplayIndex(e) {
    let t, i;
    return this.nodeMap.forEach((r) => {
      if (e > r.node.rowIndex) {
        (i == null || i.node.rowIndex < r.node.rowIndex) && (i = r);
        return;
      }
      if (t == null || t.node.rowIndex > r.node.rowIndex) {
        t = r;
        return;
      }
    }), !i && !t ? null : { previousNode: i, nextNode: t };
  }
  /**
   * Get or calculate the display index for a given store index
   * @param storeIndex the rows index within this store
   * @returns the rows visible display index relative to the grid
   */
  getDisplayIndexFromStoreIndex(e) {
    var t, i;
    const r = this.nodeMap.getBy("index", e);
    if (r)
      return r.node.rowIndex;
    let n, s;
    if (this.nodeMap.forEach((c) => {
      if (e > c.index) {
        (s == null || s.index < c.index) && (s = c);
        return;
      }
      if (n == null || n.index > c.index) {
        n = c;
        return;
      }
    }), !n)
      return this.store.getDisplayIndexEnd() - (this.numberOfRows - e);
    if (!s)
      return this.store.getDisplayIndexStart() + e;
    const a = e - s.index;
    return ((i = (t = s.node.childStore) === null || t === void 0 ? void 0 : t.getDisplayIndexEnd()) !== null && i !== void 0 ? i : s.node.rowIndex) + a;
  }
  /**
   * Creates a new row and inserts it at the given index
   * @param atStoreIndex the node index relative to this store
   * @param data the data object to populate the node with
   * @returns the new row node
   */
  createRowAtIndex(e, t, i) {
    var r, n;
    const s = this.nodeMap.getBy("index", e);
    if (s) {
      const { node: l } = s;
      if (this.nodesToRefresh.delete(l), l.__needsRefreshWhenVisible = !1, this.doesNodeMatch(t, l))
        return this.blockUtils.updateDataIntoRowNode(l, t), l;
      if (this.getRowIdFunc == null && l.group && l.expanded)
        return l;
      this.destroyRowAtIndex(e);
    }
    if (t && this.getRowIdFunc != null) {
      const l = this.getRowId(t), c = l && ((r = this.removedNodeCache) === null || r === void 0 ? void 0 : r.get(l));
      if (c)
        return (n = this.removedNodeCache) === null || n === void 0 || n.delete(l), this.blockUtils.updateDataIntoRowNode(c, t), this.nodeMap.set({
          id: c.id,
          node: c,
          index: e
        }), c;
      const d = this.nodeMap.getBy("id", l);
      if (d) {
        this.nodeMap.delete(d);
        const { node: u, index: h } = d;
        return this.blockUtils.updateDataIntoRowNode(u, t), this.nodeMap.set({
          id: u.id,
          node: u,
          index: e
        }), this.nodesToRefresh.delete(u), this.rowLoader.getBlockStartIndexForIndex(h) === this.rowLoader.getBlockStartIndexForIndex(e) || this.markBlockForVerify(h), u;
      }
    }
    const a = this.blockUtils.createRowNode(this.store.getRowDetails());
    if (t != null) {
      const l = this.getPrefixedId(this.store.getIdSequence().next());
      this.blockUtils.setDataIntoRowNode(a, t, l, void 0), this.blockUtils.checkOpenByDefault(a), this.nodeManager.addRowNode(a);
    }
    return this.nodeMap.set({
      id: a.id,
      node: a,
      index: e
    }), i && i(a), a;
  }
  getBlockStates() {
    const e = {}, t = {};
    this.nodeMap.forEach(({ node: s, index: a }) => {
      var l;
      const c = this.rowLoader.getBlockStartIndexForIndex(a);
      !s.stub && !s.failedLoad && (e[c] = ((l = e[c]) !== null && l !== void 0 ? l : 0) + 1);
      let d = "loaded";
      s.failedLoad ? d = "failed" : this.rowLoader.isRowLoading(c) ? d = "loading" : (this.nodesToRefresh.has(s) || s.stub) && (d = "needsLoading"), t[c] || (t[c] = /* @__PURE__ */ new Set()), t[c].add(d);
    });
    const i = {
      loading: 4,
      failed: 3,
      needsLoading: 2,
      loaded: 1
    }, r = this.blockUtils.createNodeIdPrefix(this.store.getParentNode()), n = {};
    return Object.entries(t).forEach(([s, a]) => {
      var l;
      const d = [...a].sort((p, f) => {
        var g, v;
        return ((g = i[p]) !== null && g !== void 0 ? g : 0) - ((v = i[f]) !== null && v !== void 0 ? v : 0);
      })[0], u = Number(s) / this.rowLoader.getBlockSize(), h = r ? `${r}-${u}` : String(u);
      n[h] = {
        blockNumber: u,
        startRow: Number(s),
        endRow: Number(s) + this.rowLoader.getBlockSize(),
        pageStatus: d,
        loadedRowCount: (l = e[s]) !== null && l !== void 0 ? l : 0
      };
    }), n;
  }
  destroyRowAtIndex(e) {
    const t = this.nodeMap.getBy("index", e);
    t && (this.nodeMap.delete(t), this.nodeDisplayIndexMap.delete(t.node.rowIndex), this.nodesToRefresh.delete(t.node), t.node.group && this.nodesToRefresh.size > 0 ? this.removedNodeCache.set(t.node.id, t.node) : this.blockUtils.destroyRowNode(t.node));
  }
  getSsrmParams() {
    return this.store.getSsrmParams();
  }
  /**
   * @param id the base id to be prefixed
   * @returns a node id with prefix if required
   */
  getPrefixedId(e) {
    return this.defaultNodeIdPrefix ? this.defaultNodeIdPrefix + "-" + e : e.toString();
  }
  markBlockForVerify(e) {
    const [t, i] = this.rowLoader.getBlockBoundsForIndex(e);
    this.nodeMap.filter((n) => n.index >= t && n.index < i).forEach(({ node: n }) => {
      n.__needsRefreshWhenVisible = !0;
    });
  }
  doesNodeMatch(e, t) {
    if (t.stub)
      return !1;
    if (this.getRowIdFunc != null) {
      const i = this.getRowId(e);
      return t.id === i;
    }
    return t.data === e;
  }
  /**
   * Deletes any stub nodes not within the given range
   */
  purgeStubsOutsideOfViewport() {
    const e = this.api.getFirstDisplayedRow(), t = this.api.getLastDisplayedRow(), i = this.rowLoader.getBlockStartIndexForIndex(e), [r, n] = this.rowLoader.getBlockBoundsForIndex(t);
    this.nodeMap.forEach((s) => {
      this.rowLoader.isRowLoading(s.index) || s.node.failedLoad || s.node.stub && (s.index < i || s.index > n) && this.destroyRowAtIndex(s.index);
    });
  }
  getBlocksDistanceFromRow(e, t) {
    const i = {};
    return e.forEach(({ node: r, index: n }) => {
      const [s, a] = this.rowLoader.getBlockBoundsForIndex(n);
      if (s in i)
        return;
      const l = Math.abs(r.rowIndex - t);
      let c;
      const d = this.nodeMap.getBy("index", [a - 1]);
      d && (c = Math.abs(d.node.rowIndex - t));
      const u = c == null || l < c ? l : c;
      i[s] = u;
    }), Object.entries(i);
  }
  purgeExcessRows() {
    var e;
    if (this.purgeStubsOutsideOfViewport(), this.store.getDisplayIndexEnd() == null || this.storeParams.maxBlocksInCache == null)
      return;
    const t = this.api.getFirstDisplayedRow(), i = this.api.getLastDisplayedRow(), r = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
    this.nodeMap.forEach(({ index: g, node: v }) => {
      const y = this.rowLoader.getBlockStartIndexForIndex(g);
      r.add(y), v.rowIndex >= t && v.rowIndex <= i && n.add(y);
    });
    const s = Math.max(n.size, (e = this.storeParams.maxBlocksInCache) !== null && e !== void 0 ? e : 0), l = r.size - s;
    if (l <= 0)
      return;
    let c = Number.MAX_SAFE_INTEGER, d = Number.MIN_SAFE_INTEGER;
    n.forEach((g) => {
      c > g && (c = g), d < g && (d = g);
    });
    const u = this.nodeMap.filter(({ node: g, index: v }) => {
      const y = this.rowLoader.getBlockStartIndexForIndex(v);
      return !(y >= c && y <= d) && !this.isNodeCached(g);
    });
    if (u.length === 0)
      return;
    const h = t + (i - t) / 2, p = this.getBlocksDistanceFromRow(u, h), f = this.rowLoader.getBlockSize();
    p.sort((g, v) => Math.sign(v[1] - g[1]));
    for (let g = 0; g < Math.min(l, p.length); g++) {
      const v = Number(p[g][0]);
      for (let y = v; y < v + f; y++) {
        const m = this.nodeMap.getBy("index", y);
        !m || this.isNodeCached(m.node) || this.destroyRowAtIndex(y);
      }
    }
  }
  isNodeFocused(e) {
    const t = this.focusService.getFocusCellToUseAfterRefresh();
    return !t || t.rowPinned != null ? !1 : t.rowIndex === e.rowIndex;
  }
  isNodeCached(e) {
    return e.isExpandable() && e.expanded || this.isNodeFocused(e);
  }
  extractDuplicateIds(e) {
    if (!this.getRowIdFunc == null)
      return [];
    const t = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
    return e.forEach((r) => {
      const n = this.getRowId(r);
      if (t.has(n)) {
        i.add(n);
        return;
      }
      t.add(n);
    }), [...i];
  }
  onLoadSuccess(e, t, i) {
    var r;
    if (!this.live)
      return;
    const n = (r = i.groupLevelInfo) !== null && r !== void 0 ? r : i.storeInfo;
    if (this.store.setStoreInfo(n), this.getRowIdFunc != null) {
      const l = this.extractDuplicateIds(i.rowData);
      if (l.length > 0) {
        const c = l.join(", ");
        console.warn(`AG Grid: Unable to display rows as duplicate row ids (${c}) were returned by the getRowId callback. Please modify the getRowId callback to provide unique ids.`), this.onLoadFailed(e, t);
        return;
      }
    }
    const s = this.nodesToRefresh.size > 0;
    i.rowData.forEach((l, c) => {
      var d;
      const u = e + c, h = this.nodeMap.getBy("index", u);
      if (!((d = h == null ? void 0 : h.node) === null || d === void 0) && d.stub) {
        this.createRowAtIndex(u, l);
        return;
      }
      if (h && this.doesNodeMatch(l, h.node)) {
        this.blockUtils.updateDataIntoRowNode(h.node, l), this.nodesToRefresh.delete(h.node), h.node.__needsRefreshWhenVisible = !1;
        return;
      }
      this.createRowAtIndex(u, l);
    });
    const a = this.nodesToRefresh.size === 0;
    if (s && a && this.fireRefreshFinishedEvent(), i.rowCount != null && i.rowCount !== -1)
      this.numberOfRows = i.rowCount, this.isLastRowKnown = !0;
    else if (t > i.rowData.length)
      this.numberOfRows = e + i.rowData.length, this.isLastRowKnown = !0;
    else if (!this.isLastRowKnown) {
      const l = e + i.rowData.length + 1;
      l > this.numberOfRows && (this.numberOfRows = l);
    }
    this.isLastRowKnown && this.nodeMap.filter((c) => c.index >= this.numberOfRows).forEach((c) => this.destroyRowAtIndex(c.index)), this.fireStoreUpdatedEvent();
  }
  fireRefreshFinishedEvent() {
    this.nodesToRefresh.size === 0 && (this.removedNodeCache.forEach((t) => {
      this.blockUtils.destroyRowNode(t);
    }), this.removedNodeCache = /* @__PURE__ */ new Map(), this.store.fireRefreshFinishedEvent());
  }
  isLastRowIndexKnown() {
    return this.isLastRowKnown;
  }
  onLoadFailed(e, t) {
    var i;
    if (!this.live)
      return;
    const r = this.nodesToRefresh.size > 0;
    for (let s = e; s < e + t && s < this.getRowCount(); s++) {
      let { node: a } = (i = this.nodeMap.getBy("index", s)) !== null && i !== void 0 ? i : {};
      a && this.nodesToRefresh.delete(a), (!a || !a.stub) && (a && !a.stub && this.destroyRowAtIndex(s), a = this.createRowAtIndex(s)), a.__needsRefreshWhenVisible = !1, a.failedLoad = !0;
    }
    const n = this.nodesToRefresh.size === 0;
    r && n && this.fireRefreshFinishedEvent(), this.fireStoreUpdatedEvent();
  }
  markNodesForRefresh() {
    this.nodeMap.forEach((e) => {
      e.node.stub && !e.node.failedLoad || this.nodesToRefresh.add(e.node);
    }), this.rowLoader.queueLoadCheck(), this.isLastRowKnown && this.numberOfRows === 0 && (this.numberOfRows = 1, this.isLastRowKnown = !1, this.fireStoreUpdatedEvent());
  }
  isNodeInCache(e) {
    return !!this.nodeMap.getBy("id", e);
  }
  // gets called 1) row count changed 2) cache purged 3) items inserted
  fireStoreUpdatedEvent() {
    this.live && this.store.fireStoreUpdatedEvent();
  }
  getRowId(e) {
    if (this.getRowIdFunc == null)
      return null;
    const { level: t } = this.store.getRowDetails(), i = this.store.getParentNode().getGroupKeys(), r = this.getRowIdFunc({
      data: e,
      parentKeys: i.length > 0 ? i : void 0,
      level: t
    });
    return String(r);
  }
  updateRowNodes(e) {
    if (this.getRowIdFunc == null)
      throw new Error("AG Grid: Insert transactions can only be applied when row ids are supplied.");
    const t = [];
    return e.forEach((i) => {
      const r = this.getRowId(i), n = this.nodeMap.getBy("id", r);
      n && (this.blockUtils.updateDataIntoRowNode(n.node, i), t.push(n.node));
    }), t;
  }
  insertRowNodes(e, t) {
    const i = t == null && this.isLastRowKnown ? this.store.getRowCount() : t;
    if (i == null || this.store.getRowCount() < i)
      return [];
    if (this.getRowIdFunc == null)
      throw new Error("AG Grid: Insert transactions can only be applied when row ids are supplied.");
    const r = {};
    e.forEach((l) => {
      const c = this.getRowId(l);
      c && this.isNodeInCache(c) || (r[c] = l);
    });
    const n = Object.values(r);
    let s = n.length;
    if (s === 0)
      return [];
    const a = this.nodeMap.filter((l) => l.index >= i);
    return a.forEach((l) => this.nodeMap.delete(l)), a.forEach((l) => {
      this.nodeMap.set({
        node: l.node,
        index: l.index + s,
        id: l.id
      });
    }), this.numberOfRows += s, n.map((l, c) => this.createRowAtIndex(i + c, l));
  }
  getOrderedNodeMap() {
    const e = {};
    return this.nodeMap.forEach((t) => e[t.index] = t), e;
  }
  clearDisplayIndexes() {
    this.nodeDisplayIndexMap.clear();
  }
  removeRowNodes(e) {
    if (this.getRowIdFunc == null)
      throw new Error("AG Grid: Insert transactions can only be applied when row ids are supplied.");
    const t = [], i = [];
    let r = 0;
    const n = [...e], s = this.getOrderedNodeMap();
    let a = -1;
    for (let l in s) {
      a += 1;
      const c = s[l], d = n.findIndex((h) => h === c.id);
      if (d !== -1) {
        n.splice(d, 1), this.destroyRowAtIndex(Number(l)), t.push(c.node), r += 1;
        continue;
      }
      if (r === 0)
        continue;
      const u = Number(l);
      a !== u && i.push(c.node), this.nodeMap.delete(s[l]), this.nodeMap.set({
        id: c.id,
        node: c.node,
        index: u - r
      });
    }
    return this.numberOfRows -= this.isLastRowIndexKnown() ? e.length : r, n.length > 0 && i.length > 0 && (i.forEach((l) => l.__needsRefreshWhenVisible = !0), this.rowLoader.queueLoadCheck()), t;
  }
}
Uu([
  S("gridApi")
], ys.prototype, "api", void 0);
Uu([
  S("ssrmBlockUtils")
], ys.prototype, "blockUtils", void 0);
Uu([
  S("focusService")
], ys.prototype, "focusService", void 0);
Uu([
  S("ssrmNodeManager")
], ys.prototype, "nodeManager", void 0);
Uu([
  B
], ys.prototype, "init", null);
Uu([
  dt
], ys.prototype, "destroyRowNodes", null);
var $u = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Ps extends H {
  constructor(e, t, i) {
    super(), this.idSequence = new Ei(), this.ssrmParams = e, this.parentRowNode = i, this.storeParams = t, this.level = i.level + 1, this.group = e.rowGroupCols ? this.level < e.rowGroupCols.length : !1, this.leafGroup = e.rowGroupCols ? this.level === e.rowGroupCols.length - 1 : !1, this.info = {};
  }
  init() {
    let e = 1;
    if (this.level === 0 && (e = this.storeUtils.getServerSideInitialRowCount()), this.cache = this.createManagedBean(new ys(this, e, this.storeParams)), !this.gridOptionsService.isTreeData() && this.group) {
      const i = this.ssrmParams.rowGroupCols[this.level];
      this.groupField = i.field, this.rowGroupColumn = this.columnModel.getRowGroupColumns()[this.level];
    }
  }
  destroyRowNodes() {
    this.displayIndexStart = void 0, this.displayIndexEnd = void 0, this.destroyBean(this.cache);
  }
  /**
   * Applies a given transaction to the data set within this store
   *
   * @param transaction an object containing delta instructions determining the changes to apply to this store
   * @returns an object determining the status of this transaction and effected nodes
   */
  applyTransaction(e) {
    var t, i, r;
    const n = this.gridOptionsService.getCallback("getRowId");
    if (!n)
      return console.warn("AG Grid: getRowId callback must be implemented for transactions to work. Transaction was ignored."), {
        status: tr.Cancelled
      };
    const s = this.gridOptionsService.getCallback("isApplyServerSideTransaction");
    if (s) {
      const d = {
        transaction: e,
        parentNode: this.parentRowNode,
        storeInfo: this.info,
        groupLevelInfo: this.info
      };
      if (!s(d))
        return { status: tr.Cancelled };
    }
    let a;
    !((t = e.update) === null || t === void 0) && t.length && (a = this.cache.updateRowNodes(e.update));
    let l;
    if (!((i = e.add) === null || i === void 0) && i.length) {
      let d = e.addIndex;
      d != null && d < 0 && (d = void 0), l = this.cache.insertRowNodes(e.add, d);
    }
    let c;
    if (!((r = e.remove) === null || r === void 0) && r.length) {
      const d = e.remove.map((h) => n({ level: this.level, parentKeys: this.parentRowNode.getGroupKeys(), data: h })), u = [...new Set(d)];
      c = this.cache.removeRowNodes(u);
    }
    return this.updateSelectionAfterTransaction(a, c), {
      status: tr.Applied,
      update: a,
      add: l,
      remove: c
    };
  }
  updateSelectionAfterTransaction(e, t) {
    const i = [];
    e == null || e.forEach((r) => {
      r.isSelected() && !r.selectable && i.push(r);
    }), t == null || t.forEach((r) => {
      r.isSelected() && i.push(r);
    }), i.length && this.selectionService.setNodesSelected({
      newValue: !1,
      clearSelection: !1,
      nodes: i,
      source: "rowDataChanged"
    });
  }
  /**
   * Clear the display indexes, used for fading rows out when stores are not being destroyed
   */
  clearDisplayIndexes() {
    this.displayIndexStart = void 0, this.displayIndexEnd = void 0, this.cache.getNodes().forEach((e) => this.blockUtils.clearDisplayIndex(e.node)), this.parentRowNode.sibling && this.blockUtils.clearDisplayIndex(this.parentRowNode.sibling), this.cache.clearDisplayIndexes();
  }
  /**
   * @returns an index representing the last sequentially displayed row in the grid for this store
   */
  getDisplayIndexStart() {
    return this.displayIndexStart;
  }
  /**
   * @returns the index representing one after the last sequentially displayed row in the grid for this store
   */
  getDisplayIndexEnd() {
    return this.displayIndexEnd;
  }
  /**
   * @returns the virtual size of this store
   */
  getRowCount() {
    return this.parentRowNode.sibling ? this.cache.getRowCount() + 1 : this.cache.getRowCount();
  }
  /**
   * Sets the current row count of the store, and whether the last row index is known
   */
  setRowCount(e, t) {
    this.cache.setRowCount(e, t);
  }
  /**
   * Given a display index, returns whether that row is within this store or a child store of this store
   *
   * @param displayIndex the visible index of a row
   * @returns whether or not the row exists within this store
   */
  isDisplayIndexInStore(e) {
    return this.cache.getRowCount() === 0 ? !1 : this.displayIndexStart <= e && e < this.getDisplayIndexEnd();
  }
  /**
   * Recursively sets up the display indexes and top position of every node belonging to this store.
   *
   * Called after a row height changes, or a store updated event.
   *
   * @param displayIndexSeq the number sequence for generating the display index of each row
   * @param nextRowTop an object containing the next row top value intended to be modified by ref per row
   */
  setDisplayIndexes(e, t) {
    this.displayIndexStart = e.peek(), this.topPx = t.value, this.cache.setDisplayIndexes(e, t), this.parentRowNode.sibling && this.blockUtils.setDisplayIndex(this.parentRowNode.sibling, e, t), this.displayIndexEnd = e.peek(), this.heightPx = t.value - this.topPx;
  }
  /**
   * Recursively applies a provided function to every node
   *
   * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeepAfterFilterAndSort
   */
  forEachStoreDeep(e, t = new Ei()) {
    e(this, t.next()), this.cache.getNodes().forEach((i) => {
      const r = i.node.childStore;
      r && r.forEachStoreDeep(e, t);
    });
  }
  /**
   * Recursively applies a provided function to every node
   *
   * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeepAfterFilterAndSort
   */
  forEachNodeDeep(e, t = new Ei()) {
    this.cache.getNodes().forEach((i) => {
      e(i.node, t.next());
      const r = i.node.childStore;
      r && r.forEachNodeDeep(e, t);
    });
  }
  /**
   * Recursively applies a provided function to every node
   *
   * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeep
   */
  forEachNodeDeepAfterFilterAndSort(e, t = new Ei()) {
    const i = this.cache.getOrderedNodeMap();
    for (let r in i) {
      const n = i[r];
      e(n.node, t.next());
      const s = n.node.childStore;
      s && s.forEachNodeDeepAfterFilterAndSort(e, t);
    }
  }
  /**
   * Removes the failed status from all nodes, and marks them as stub to encourage reloading
   */
  retryLoads() {
    this.cache.getNodes().forEach(({ node: e }) => {
      e.failedLoad && (e.failedLoad = !1, e.__needsRefreshWhenVisible = !0, e.stub = !0);
    }), this.forEachChildStoreShallow((e) => e.retryLoads()), this.fireStoreUpdatedEvent();
  }
  /**
   * Given a display index, returns the row at that location.
   *
   * @param displayRowIndex the displayed index within the grid to search for
   * @returns the row node if the display index falls within the store, if it didn't exist this will create a new stub to return
   */
  getRowUsingDisplayIndex(e) {
    return this.parentRowNode.sibling && e === this.parentRowNode.sibling.rowIndex ? this.parentRowNode.sibling : this.cache.getRowByDisplayIndex(e);
  }
  /**
   * Given a display index, returns the row top and height for the row at that index.
   *
   * @param displayIndex the display index of the node
   * @returns an object containing the rowTop and rowHeight of the node at the given displayIndex
   */
  getRowBounds(e) {
    var t;
    if (!this.isDisplayIndexInStore(e))
      return null;
    const i = this.cache.getNodeCachedByDisplayIndex(e);
    if (i) {
      const c = this.blockUtils.extractRowBounds(i, e);
      if (c)
        return c;
    }
    const { previousNode: r, nextNode: n } = (t = this.cache.getSurroundingNodesByDisplayIndex(e)) !== null && t !== void 0 ? t : {};
    if (r) {
      const c = this.blockUtils.extractRowBounds(r.node, e);
      if (c != null)
        return c;
    }
    const s = this.gridOptionsService.getRowHeightAsNumber();
    if (n) {
      const c = (n.node.rowIndex - e) * s;
      return {
        rowTop: n.node.rowTop - c,
        rowHeight: s
      };
    }
    const a = this.topPx + this.heightPx, l = (this.getDisplayIndexEnd() - e) * s;
    return {
      rowTop: a - l,
      rowHeight: s
    };
  }
  /**
   * Given a vertical pixel, determines whether this store contains a row at that pixel
   *
   * @param pixel a vertical pixel position from the grid
   * @returns whether that pixel points to a virtual space belonging to this store
   */
  isPixelInRange(e) {
    return e >= this.topPx && e < this.topPx + this.heightPx;
  }
  /**
   * Given a vertical pixel, returns the row existing at that pixel location
   *
   * @param pixel a vertical pixel position from the grid
   * @returns the display index at the given pixel location
   */
  getRowIndexAtPixel(e) {
    if (e < this.topPx)
      return this.getDisplayIndexStart();
    if (e >= this.topPx + this.heightPx)
      return this.getDisplayIndexEnd() - 1;
    let t = Number.MAX_SAFE_INTEGER, i = null, r = Number.MAX_SAFE_INTEGER, n = null;
    if (this.cache.getNodes().forEach(({ node: c }) => {
      const d = Math.abs(e - c.rowTop);
      if (c.rowTop < e) {
        d < t && (t = d, i = c);
        return;
      }
      d < r && (r = d, n = c);
    }), i = i, n = n, i) {
      const c = this.blockUtils.getIndexAtPixel(i, e);
      if (c != null)
        return c;
    }
    const s = this.gridOptionsService.getRowHeightAsNumber();
    if (n) {
      const c = n.rowTop, d = Math.ceil((c - e) / s);
      return n.rowIndex - d;
    }
    const a = this.topPx + this.heightPx, l = Math.floor((a - e) / s);
    return this.getDisplayIndexEnd() - l;
  }
  /**
   * Given a path of group keys, returns the child store for that group.
   *
   * @param keys the grouping path to the desired store
   * @returns the child store for the given keys, or null if not found
   */
  getChildStore(e) {
    return this.storeUtils.getChildStore(e, this, (t) => {
      const i = this.cache.getNodes().find((r) => r.node.key == t);
      return i ? i.node : null;
    });
  }
  /**
   * Executes a provided callback on each child store belonging to this store
   *
   * @param cb the callback to execute
   */
  forEachChildStoreShallow(e) {
    this.cache.getNodes().forEach(({ node: t }) => {
      t.childStore && e(t.childStore);
    });
  }
  /**
   * Executes after a change to sorting, determines recursively whether this store or a child requires refreshed.
   *
   * If a purge refresh occurs, the row count is preserved.
   *
   * @param params a set of properties pertaining to the sort changes
   */
  refreshAfterSort(e) {
    if (this.storeUtils.isServerSideSortAllLevels() || this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, e)) {
      const i = this.cache.getRowCount();
      this.destroyBean(this.cache), this.cache = this.createManagedBean(new ys(this, i, this.storeParams)), this.fireStoreUpdatedEvent();
      return;
    }
    this.forEachChildStoreShallow((i) => i.refreshAfterSort(e));
  }
  /**
   * Executes after a change to filtering, determines recursively whether this store or a child requires refreshed.
   *
   * If a refresh occurs, the row count is reset.
   *
   * @param params a set of properties pertaining to the filter changes
   */
  refreshAfterFilter(e) {
    if (!this.storeUtils.isServerSideOnlyRefreshFilteredGroups() || this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, e)) {
      this.refreshStore(!0);
      return;
    }
    this.forEachChildStoreShallow((i) => i.refreshAfterFilter(e));
  }
  /**
   * Marks all existing nodes as requiring reloaded, and triggers a load check
   *
   * @param purge whether to remove all nodes and data in favour of stub nodes
   */
  refreshStore(e) {
    if (e) {
      this.destroyBean(this.cache), this.cache = this.createManagedBean(new ys(this, 1, this.storeParams)), this.fireStoreUpdatedEvent();
      return;
    }
    this.cache.markNodesForRefresh();
  }
  /**
   * Used for pagination, given a local/store index, returns the display index of that row
   *
   * @param topLevelIndex the store index of a row
   * @returns the display index for the given store index
   */
  getTopLevelRowDisplayedIndex(e) {
    const t = this.cache.getDisplayIndexFromStoreIndex(e);
    return t != null ? t : e;
  }
  /**
   * Used for pagination to determine if the last page is known, and for aria to determine if the last grid row is known
   *
   * @returns whether the last index of this store is known, or if lazy loading still required
   */
  isLastRowIndexKnown() {
    return this.cache.isLastRowIndexKnown();
  }
  /**
   * Used by the selection service to select a range of nodes
   *
   * @param firstInRange the first node in the range to find
   * @param lastInRange the last node in the range to find
   * @returns a range of nodes between firstInRange and lastInRange inclusive
   */
  getRowNodesInRange(e, t) {
    return x.missing(e), this.cache.getNodes().filter(({ node: i }) => i.rowIndex >= e.rowIndex && i.rowIndex <= t.rowIndex).map(({ node: i }) => i);
  }
  /**
   * Mutates a given array to add this stores state, and recursively add all the children store states.
   *
   * @param result a mutable results array
   */
  addStoreStates(e) {
    e.push({
      suppressInfiniteScroll: !1,
      route: this.parentRowNode.getGroupKeys(),
      rowCount: this.getRowCount(),
      lastRowIndexKnown: this.isLastRowIndexKnown(),
      info: this.info,
      maxBlocksInCache: this.storeParams.maxBlocksInCache,
      cacheBlockSize: this.storeParams.cacheBlockSize
    }), this.forEachChildStoreShallow((t) => t.addStoreStates(e));
  }
  getIdSequence() {
    return this.idSequence;
  }
  getParentNode() {
    return this.parentRowNode;
  }
  getRowDetails() {
    return {
      field: this.groupField,
      group: this.group,
      leafGroup: this.leafGroup,
      level: this.level,
      parent: this.parentRowNode,
      rowGroupColumn: this.rowGroupColumn
    };
  }
  getSsrmParams() {
    return this.ssrmParams;
  }
  setStoreInfo(e) {
    e && Object.assign(this.info, e);
  }
  // gets called 1) row count changed 2) cache purged
  fireStoreUpdatedEvent() {
    const e = {
      type: w.EVENT_STORE_UPDATED
    };
    this.eventService.dispatchEvent(e);
  }
  // gets called when row data updated, and no more refreshing needed
  fireRefreshFinishedEvent() {
    const e = {
      type: w.EVENT_STORE_REFRESHED,
      route: this.parentRowNode.getRoute()
    };
    this.eventService.dispatchEvent(e);
  }
  getBlockStates() {
    return this.cache.getBlockStates();
  }
  getStoreBounds() {
    return {
      topPx: this.topPx,
      heightPx: this.heightPx
    };
  }
}
$u([
  S("ssrmBlockUtils")
], Ps.prototype, "blockUtils", void 0);
$u([
  S("ssrmStoreUtils")
], Ps.prototype, "storeUtils", void 0);
$u([
  S("columnModel")
], Ps.prototype, "columnModel", void 0);
$u([
  S("selectionService")
], Ps.prototype, "selectionService", void 0);
$u([
  B
], Ps.prototype, "init", null);
$u([
  dt
], Ps.prototype, "destroyRowNodes", null);
var io = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Nr = class extends H {
  constructor() {
    super(...arguments), this.onRowHeightChanged_debounced = x.debounce(this.onRowHeightChanged.bind(this), 100), this.pauseStoreUpdateListening = !1, this.started = !1;
  }
  // we don't implement as lazy row heights is not supported in this row model
  ensureRowHeightsValid() {
    return !1;
  }
  start() {
    this.started = !0;
    const e = this.gridOptionsService.get("serverSideDatasource");
    e && this.setDatasource(e);
  }
  destroyDatasource() {
    this.datasource && (this.datasource.destroy && this.datasource.destroy(), this.rowRenderer.datasourceChanged(), this.datasource = void 0);
  }
  addEventListeners() {
    this.addManagedListener(this.eventService, w.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverything.bind(this)), this.addManagedListener(this.eventService, w.EVENT_STORE_UPDATED, this.onStoreUpdated.bind(this));
    const e = this.resetRootStore.bind(this);
    this.addManagedListener(this.eventService, w.EVENT_COLUMN_VALUE_CHANGED, e), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_CHANGED, e), this.addManagedListener(this.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, e), this.addManagedListener(this.eventService, w.EVENT_COLUMN_PIVOT_MODE_CHANGED, e), this.verifyProps();
  }
  verifyProps() {
    if (this.gridOptionsService.exists("initialGroupOrderComparator")) {
      const e = "AG Grid: initialGroupOrderComparator cannot be used with Server Side Row Model. If using Full Store, then provide the rows to the grid in the desired sort order. If using Infinite Scroll, then sorting is done on the server side, nothing to do with the client.";
      x.doOnce(() => console.warn(e), "SSRM.InitialGroupOrderComparator");
    }
    if (this.gridOptionsService.isRowSelection() && !this.gridOptionsService.exists("getRowId")) {
      const e = "AG Grid: getRowId callback must be provided for Server Side Row Model selection to work correctly.";
      x.doOnce(() => console.warn(e), "SSRM.SelectionNeedsRowNodeIdFunc");
    }
  }
  setDatasource(e) {
    this.started && (this.destroyDatasource(), this.datasource = e, this.resetRootStore());
  }
  isLastRowIndexKnown() {
    const e = this.getRootStore();
    return e ? e.isLastRowIndexKnown() : !1;
  }
  onColumnEverything() {
    if (!this.storeParams) {
      this.resetRootStore();
      return;
    }
    const e = this.columnsToValueObjects(this.columnModel.getRowGroupColumns()), t = this.columnsToValueObjects(this.columnModel.getValueColumns()), i = this.columnsToValueObjects(this.columnModel.getPivotColumns()), r = (d) => {
      const u = {};
      d.oldCols.forEach((f) => u[f.id] = f);
      const h = d.newCols.every((f) => {
        const g = u[f.id];
        return g && delete u[f.id], g && g.field === f.field && g.aggFunc === f.aggFunc;
      }), p = !d.allowRemovedColumns && !!Object.values(u).length;
      return h && !p;
    }, n = !x.jsonEquals(this.storeParams.sortModel, this.sortListener.extractSortModel()), s = !r({
      oldCols: this.storeParams.rowGroupCols,
      newCols: e
    }), a = !r({
      oldCols: this.storeParams.pivotCols,
      newCols: i
    }), l = !!(e != null && e.length) && !r({
      oldCols: this.storeParams.valueCols,
      newCols: t,
      allowRemovedColumns: !0
    });
    if (n || s || a || l)
      this.resetRootStore();
    else {
      const d = this.createStoreParams();
      this.storeParams.rowGroupCols = d.rowGroupCols, this.storeParams.pivotCols = d.pivotCols, this.storeParams.valueCols = d.valueCols;
    }
  }
  destroyRootStore() {
    !this.rootNode || !this.rootNode.childStore || (this.rootNode.childStore = this.destroyBean(this.rootNode.childStore), this.nodeManager.clear());
  }
  refreshAfterSort(e, t) {
    this.storeParams && (this.storeParams.sortModel = e);
    const i = this.getRootStore();
    i && (i.refreshAfterSort(t), this.onStoreUpdated());
  }
  resetRootStore() {
    this.destroyRootStore(), this.rootNode = new re(this.beans), this.rootNode.group = !0, this.rootNode.level = -1, this.datasource && (this.storeParams = this.createStoreParams(), this.rootNode.childStore = this.createBean(this.storeFactory.createStore(this.storeParams, this.rootNode)), this.updateRowIndexesAndBounds());
    const e = {
      type: w.EVENT_ROW_DATA_UPDATED
    };
    this.eventService.dispatchEvent(e), this.dispatchModelUpdated(!0);
  }
  columnsToValueObjects(e) {
    return e.map((t) => ({
      id: t.getId(),
      aggFunc: t.getAggFunc(),
      displayName: this.columnModel.getDisplayNameForColumn(t, "model"),
      field: t.getColDef().field
    }));
  }
  createStoreParams() {
    const e = this.columnsToValueObjects(this.columnModel.getRowGroupColumns()), t = this.columnsToValueObjects(this.columnModel.getValueColumns()), i = this.columnsToValueObjects(this.columnModel.getPivotColumns()), r = this.gridOptionsService.isGetRowHeightFunction();
    return {
      // the columns the user has grouped and aggregated by
      valueCols: t,
      rowGroupCols: e,
      pivotCols: i,
      pivotMode: this.columnModel.isPivotMode(),
      // sort and filter model
      filterModel: this.filterManager.getFilterModel(),
      sortModel: this.sortListener.extractSortModel(),
      datasource: this.datasource,
      lastAccessedSequence: new Ei(),
      // blockSize: blockSize == null ? 100 : blockSize,
      dynamicRowHeight: r
    };
  }
  getParams() {
    return this.storeParams;
  }
  dispatchModelUpdated(e = !1) {
    const t = {
      type: w.EVENT_MODEL_UPDATED,
      animate: !e,
      keepRenderedRows: !e,
      newPage: !1,
      newData: !1
    };
    this.eventService.dispatchEvent(t);
  }
  onStoreUpdated() {
    this.pauseStoreUpdateListening || (this.updateRowIndexesAndBounds(), this.dispatchModelUpdated());
  }
  /** This method is debounced. It is used for row auto-height. If we don't debounce,
   * then the Row Models will end up recalculating each row position
   * for each row height change and result in the Row Renderer laying out rows.
   * This is particularly bad if using print layout, and showing eg 1,000 rows,
   * each row will change it's height, causing Row Model to update 1,000 times.
   */
  onRowHeightChangedDebounced() {
    this.onRowHeightChanged_debounced();
  }
  onRowHeightChanged() {
    this.updateRowIndexesAndBounds(), this.dispatchModelUpdated();
  }
  updateRowIndexesAndBounds() {
    const e = this.getRootStore();
    e && e.setDisplayIndexes(new Ei(), { value: 0 });
  }
  retryLoads() {
    const e = this.getRootStore();
    e && (e.retryLoads(), this.onStoreUpdated());
  }
  getRow(e) {
    const t = this.getRootStore();
    if (t)
      return t.getRowUsingDisplayIndex(e);
  }
  expandAll(e) {
    this.pauseStoreUpdateListening = !0, this.forEachNode((t) => {
      t.stub || t.hasChildren() && t.setExpanded(e);
    }), this.pauseStoreUpdateListening = !1, this.onStoreUpdated();
  }
  refreshAfterFilter(e, t) {
    this.storeParams && (this.storeParams.filterModel = e);
    const i = this.getRootStore();
    i && (i.refreshAfterFilter(t), this.onStoreUpdated());
  }
  getRootStore() {
    if (this.rootNode && this.rootNode.childStore)
      return this.rootNode.childStore;
  }
  getRowCount() {
    const e = this.getRootStore();
    return e ? e.getDisplayIndexEnd() : 0;
  }
  getTopLevelRowCount() {
    const e = this.getRootStore();
    return e ? e.getRowCount() : 1;
  }
  getTopLevelRowDisplayedIndex(e) {
    const t = this.getRootStore();
    return t ? t.getTopLevelRowDisplayedIndex(e) : e;
  }
  getRowBounds(e) {
    const t = this.getRootStore();
    return t ? t.getRowBounds(e) : {
      rowTop: 0,
      rowHeight: this.gridOptionsService.getRowHeightAsNumber()
    };
  }
  getBlockStates() {
    const e = this.getRootStore();
    if (!e)
      return;
    const t = {};
    return e.forEachStoreDeep((i) => {
      if (i instanceof hr) {
        const { id: r, state: n } = i.getBlockStateJson();
        t[r] = n;
      } else if (i instanceof Ps)
        Object.entries(i.getBlockStates()).forEach(([r, n]) => {
          t[r] = n;
        });
      else
        throw new Error("AG Grid: Unsupported store type");
    }), t;
  }
  getRowIndexAtPixel(e) {
    const t = this.getRootStore();
    return e <= 0 || !t ? 0 : t.getRowIndexAtPixel(e);
  }
  isEmpty() {
    return !1;
  }
  isRowsToRender() {
    return this.getRootStore() != null && this.getRowCount() > 0;
  }
  getType() {
    return "serverSide";
  }
  forEachNode(e) {
    const t = this.getRootStore();
    t && t.forEachNodeDeep(e);
  }
  forEachNodeAfterFilterAndSort(e) {
    const t = this.getRootStore();
    t && t.forEachNodeDeepAfterFilterAndSort(e);
  }
  executeOnStore(e, t) {
    const i = this.getRootStore();
    if (!i)
      return;
    const r = i.getChildStore(e);
    r && t(r);
  }
  refreshStore(e = {}) {
    const t = e.route ? e.route : [];
    this.executeOnStore(t, (i) => i.refreshStore(e.purge == !0));
  }
  getStoreState() {
    const e = [], t = this.getRootStore();
    return t && t.addStoreStates(e), e;
  }
  getNodesInRangeForSelection(e, t) {
    if (!x.exists(e))
      return [];
    if (!t)
      return [e];
    const i = e.rowIndex, r = t.rowIndex;
    if (i === null || r === null)
      return [e];
    const n = [], [s, a] = [i, r].sort((l, c) => l - c);
    return this.forEachNode((l) => {
      const c = l.rowIndex;
      c == null || l.stub || c >= s && c <= a && n.push(l);
    }), n.length !== a - s + 1 ? [e] : n;
  }
  getRowNode(e) {
    let t;
    return this.forEachNode((i) => {
      i.id === e && (t = i), i.detailNode && i.detailNode.id === e && (t = i.detailNode);
    }), t;
  }
  isRowPresent(e) {
    return !!this.getRowNode(e.id);
  }
  setRowCount(e, t) {
    const i = this.getRootStore();
    if (i) {
      if (i instanceof Ps) {
        i.setRowCount(e, t);
        return;
      }
      console.error("AG Grid: Infinite scrolling must be enabled in order to set the row count.");
    }
  }
};
io([
  S("columnModel")
], Nr.prototype, "columnModel", void 0);
io([
  S("filterManager")
], Nr.prototype, "filterManager", void 0);
io([
  S("rowRenderer")
], Nr.prototype, "rowRenderer", void 0);
io([
  S("ssrmSortService")
], Nr.prototype, "sortListener", void 0);
io([
  S("ssrmNodeManager")
], Nr.prototype, "nodeManager", void 0);
io([
  S("ssrmStoreFactory")
], Nr.prototype, "storeFactory", void 0);
io([
  S("beans")
], Nr.prototype, "beans", void 0);
io([
  dt
], Nr.prototype, "destroyDatasource", null);
io([
  B
], Nr.prototype, "addEventListeners", null);
io([
  dt
], Nr.prototype, "destroyRootStore", null);
Nr = io([
  q("rowModel")
], Nr);
var sy = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let ru = class extends H {
  loadFromDatasource(e) {
    const { storeParams: t, parentBlock: i, parentNode: r } = e, n = r.getGroupKeys();
    if (!t.datasource)
      return;
    const s = {
      startRow: e.startRow,
      endRow: e.endRow,
      rowGroupCols: t.rowGroupCols,
      valueCols: t.valueCols,
      pivotCols: t.pivotCols,
      pivotMode: t.pivotMode,
      groupKeys: n,
      filterModel: t.filterModel,
      sortModel: t.sortModel
    }, a = {
      successCallback: e.successCallback,
      success: e.success,
      failCallback: e.failCallback,
      fail: e.fail,
      request: s,
      parentNode: e.parentNode,
      api: this.gridApi,
      columnApi: this.columnApi,
      context: this.gridOptionsService.context
    };
    window.setTimeout(() => {
      if (!t.datasource || !i.isAlive()) {
        e.failCallback();
        return;
      }
      t.datasource.getRows(a);
    }, 0);
  }
  getChildStore(e, t, i) {
    if (x.missingOrEmpty(e))
      return t;
    const r = e[0], n = i(r);
    if (n) {
      const s = e.slice(1, e.length), a = n.childStore;
      return a ? a.getChildStore(s) : null;
    }
    return null;
  }
  isServerRefreshNeeded(e, t, i) {
    if (i.valueColChanged || i.secondaryColChanged)
      return !0;
    const r = e.level + 1;
    if (!(r < t.length))
      return !0;
    const a = t[r].id;
    return i.changedColumns.indexOf(a) > -1 ? !0 : this.columnModel.getAllGridColumns().filter((u) => u.getColDef().showRowGroup && i.changedColumns.includes(u.getId())).map((u) => u.getColDef().showRowGroup).some((u) => u === !0 || u === a);
  }
  getServerSideInitialRowCount() {
    const e = this.gridOptionsService.getNum("serverSideInitialRowCount");
    return typeof e == "number" && e > 0 ? e : 1;
  }
  assertRowModelIsServerSide(e) {
    return this.gridOptionsService.isRowModelType("serverSide") ? !0 : (x.doOnce(() => console.warn(`AG Grid: The '${e}' property can only be used with the Server Side Row Model.`), e), !1);
  }
  assertNotTreeData(e) {
    return this.gridOptionsService.is("treeData") ? (x.doOnce(() => console.warn(`AG Grid: The '${e}' property cannot be used while using tree data.`), e + "_TreeData"), !1) : !0;
  }
  isServerSideSortAllLevels() {
    return this.gridOptionsService.is("serverSideSortAllLevels") && this.assertRowModelIsServerSide("serverSideSortAllLevels");
  }
  isServerSideOnlyRefreshFilteredGroups() {
    return this.gridOptionsService.is("serverSideOnlyRefreshFilteredGroups") && this.assertRowModelIsServerSide("serverSideOnlyRefreshFilteredGroups");
  }
  isServerSideSortOnServer() {
    return this.gridOptionsService.is("serverSideSortOnServer") && this.assertRowModelIsServerSide("serverSideSortOnServer") && this.assertNotTreeData("serverSideSortOnServer");
  }
  isServerSideFilterOnServer() {
    return this.gridOptionsService.is("serverSideFilterOnServer") && this.assertRowModelIsServerSide("serverSideFilterOnServer") && this.assertNotTreeData("serverSideFilterOnServer");
  }
};
sy([
  S("columnApi")
], ru.prototype, "columnApi", void 0);
sy([
  S("columnModel")
], ru.prototype, "columnModel", void 0);
sy([
  S("gridApi")
], ru.prototype, "gridApi", void 0);
ru = sy([
  q("ssrmStoreUtils")
], ru);
var zu = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const t2 = "ag-Grid-MissingKey";
let Pa = class extends H {
  postConstruct() {
    this.rowHeight = this.gridOptionsService.getRowHeightAsNumber(), this.usingTreeData = this.gridOptionsService.isTreeData(), this.usingMasterDetail = this.gridOptionsService.isMasterDetail();
  }
  createRowNode(e) {
    const t = new re(this.beans), i = e.rowHeight != null ? e.rowHeight : this.rowHeight;
    return t.setRowHeight(i), t.group = e.group, t.leafGroup = e.leafGroup, t.level = e.level, t.uiLevel = e.level, t.parent = e.parent, t.stub = !0, t.__needsRefreshWhenVisible = !1, t.group && (t.expanded = !1, t.field = e.field, t.rowGroupColumn = e.rowGroupColumn), t;
  }
  destroyRowNodes(e) {
    e && e.forEach((t) => this.destroyRowNode(t));
  }
  destroyRowNode(e, t = !1) {
    e.childStore && !t && (this.destroyBean(e.childStore), e.childStore = null), e.sibling && this.destroyRowNode(e.sibling, !1), e.clearRowTopAndRowIndex(), e.id != null && this.nodeManager.removeNode(e);
  }
  setTreeGroupInfo(e) {
    e.updateHasChildren();
    const t = this.gridOptionsService.get("getServerSideGroupKey");
    e.hasChildren() && t != null && (e.key = t(e.data)), !e.hasChildren() && e.childStore != null && (this.destroyBean(e.childStore), e.childStore = null, e.expanded = !1);
  }
  setRowGroupInfo(e) {
    e.key = this.valueService.getValue(e.rowGroupColumn, e), (e.key === null || e.key === void 0) && x.doOnce(() => {
      console.warn("AG Grid: null and undefined values are not allowed for server side row model keys"), e.rowGroupColumn && console.warn(`column = ${e.rowGroupColumn.getId()}`), console.warn("data is ", e.data);
    }, "ServerSideBlock-CannotHaveNullOrUndefinedForKey"), this.beans.gridOptionsService.is("groupIncludeFooter") && (e.createFooter(), e.sibling && (e.sibling.uiLevel = e.uiLevel + 1));
  }
  setMasterDetailInfo(e) {
    const t = this.gridOptionsService.get("isRowMaster");
    t != null ? e.master = t(e.data) : e.master = !0;
  }
  updateDataIntoRowNode(e, t) {
    e.updateData(t), this.usingTreeData ? (this.setTreeGroupInfo(e), this.setChildCountIntoRowNode(e)) : e.group ? this.setChildCountIntoRowNode(e) : this.usingMasterDetail;
  }
  setDataIntoRowNode(e, t, i, r) {
    var n;
    e.stub = !1, x.exists(t) ? (e.setDataAndId(t, i), this.usingTreeData ? this.setTreeGroupInfo(e) : e.group ? this.setRowGroupInfo(e) : this.usingMasterDetail && this.setMasterDetailInfo(e)) : (e.setDataAndId(void 0, void 0), e.key = null), (this.usingTreeData || e.group) && (this.setGroupDataIntoRowNode(e), this.setChildCountIntoRowNode(e)), x.exists(t) && (e.setRowHeight(this.gridOptionsService.getRowHeightForNode(e, !1, r).height), (n = e.sibling) === null || n === void 0 || n.setRowHeight(this.gridOptionsService.getRowHeightForNode(e.sibling, !1, r).height));
  }
  setChildCountIntoRowNode(e) {
    const t = this.gridOptionsService.get("getChildCount");
    t && e.setAllChildrenCount(t(e.data));
  }
  setGroupDataIntoRowNode(e) {
    const t = this.columnModel.getGroupDisplayColumns(), i = this.gridOptionsService.isTreeData();
    t.forEach((r) => {
      if (e.groupData == null && (e.groupData = {}), i)
        e.groupData[r.getColId()] = e.key;
      else if (r.isRowGroupDisplayed(e.rowGroupColumn.getId())) {
        const n = this.valueService.getValue(e.rowGroupColumn, e);
        e.groupData[r.getColId()] = n;
      }
    });
  }
  clearDisplayIndex(e) {
    e.clearRowTopAndRowIndex(), e.hasChildren() && x.exists(e.childStore) && e.childStore.clearDisplayIndexes(), e.master && e.detailNode && e.detailNode.clearRowTopAndRowIndex();
  }
  setDisplayIndex(e, t, i) {
    if (e.setRowIndex(t.next()), e.setRowTop(i.value), i.value += e.rowHeight, e.master && (e.expanded && e.detailNode ? (e.detailNode.setRowIndex(t.next()), e.detailNode.setRowTop(i.value), i.value += e.detailNode.rowHeight) : e.detailNode && e.detailNode.clearRowTopAndRowIndex()), e.hasChildren() && x.exists(e.childStore)) {
      const s = e.childStore;
      e.expanded ? s.setDisplayIndexes(t, i) : s.clearDisplayIndexes();
    }
  }
  binarySearchForDisplayIndex(e, t) {
    let i = 0, r = t.length - 1;
    if (x.missing(r) || x.missing(i)) {
      console.warn(`AG Grid: error: topPointer = ${r}, bottomPointer = ${i}`);
      return;
    }
    for (; ; ) {
      const n = Math.floor((i + r) / 2), s = t[n];
      if (s.rowIndex === e)
        return s;
      const a = s.master && s.expanded, l = s.detailNode;
      if (a && l && l.rowIndex === e)
        return s.detailNode;
      const c = s.childStore;
      if (s.expanded && c && c.isDisplayIndexInStore(e))
        return c.getRowUsingDisplayIndex(e);
      if (s.rowIndex < e)
        i = n + 1;
      else if (s.rowIndex > e)
        r = n - 1;
      else {
        console.warn(`AG Grid: error: unable to locate rowIndex = ${e} in cache`);
        return;
      }
    }
  }
  extractRowBounds(e, t) {
    const i = (r) => ({
      rowHeight: r.rowHeight,
      rowTop: r.rowTop
    });
    if (e.rowIndex === t)
      return i(e);
    if (e.hasChildren() && e.expanded && x.exists(e.childStore)) {
      const r = e.childStore;
      if (r.isDisplayIndexInStore(t))
        return r.getRowBounds(t);
    } else if (e.master && e.expanded && x.exists(e.detailNode) && e.detailNode.rowIndex === t)
      return i(e.detailNode);
  }
  getIndexAtPixel(e, t) {
    if (e.isPixelInRange(t))
      return e.rowIndex;
    const i = e.master && e.expanded, r = e.detailNode;
    if (i && r && r.isPixelInRange(t))
      return e.detailNode.rowIndex;
    if (e.hasChildren() && e.expanded && x.exists(e.childStore)) {
      const n = e.childStore;
      if (n.isPixelInRange(t))
        return n.getRowIndexAtPixel(t);
    }
    return null;
  }
  createNodeIdPrefix(e) {
    const t = [];
    let i = e;
    for (; i && i.level >= 0; )
      i.key === "" ? t.push(t2) : t.push(i.key), i = i.parent;
    if (t.length > 0)
      return t.reverse().join("-");
  }
  checkOpenByDefault(e) {
    if (!e.isExpandable())
      return;
    const t = this.gridOptionsService.getCallback("isServerSideGroupOpenByDefault");
    if (!t)
      return;
    const i = {
      data: e.data,
      rowNode: e
    };
    t(i) && window.setTimeout(() => e.setExpanded(!0), 0);
  }
};
zu([
  S("valueService")
], Pa.prototype, "valueService", void 0);
zu([
  S("columnModel")
], Pa.prototype, "columnModel", void 0);
zu([
  S("ssrmNodeManager")
], Pa.prototype, "nodeManager", void 0);
zu([
  S("beans")
], Pa.prototype, "beans", void 0);
zu([
  B
], Pa.prototype, "postConstruct", null);
Pa = zu([
  q("ssrmBlockUtils")
], Pa);
var pP = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let wv = class {
  constructor() {
    this.rowNodes = {};
  }
  addRowNode(e) {
    const t = e.id;
    this.rowNodes[t] && (console.warn(`AG Grid: Duplicate node id ${e.id}. Row ID's are provided via the getRowId() callback. Please modify the getRowId() callback code to provide unique row id values.`), console.warn("first instance", this.rowNodes[t].data), console.warn("second instance", e.data)), this.rowNodes[t] = e;
  }
  removeNode(e) {
    const t = e.id;
    this.rowNodes[t] && (this.rowNodes[t] = void 0);
  }
  clear() {
    this.rowNodes = {};
  }
};
pP([
  dt
], wv.prototype, "clear", null);
wv = pP([
  q("ssrmNodeManager")
], wv);
var Oc = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let As = class extends H {
  constructor() {
    super(...arguments), this.asyncTransactions = [];
  }
  postConstruct() {
    this.gridOptionsService.isRowModelType("serverSide");
  }
  applyTransactionAsync(e, t) {
    this.asyncTransactionsTimeout == null && this.scheduleExecuteAsync(), this.asyncTransactions.push({ transaction: e, callback: t });
  }
  scheduleExecuteAsync() {
    const e = this.gridOptionsService.getAsyncTransactionWaitMillis();
    this.asyncTransactionsTimeout = window.setTimeout(() => {
      this.executeAsyncTransactions();
    }, e);
  }
  executeAsyncTransactions() {
    if (!this.asyncTransactions)
      return;
    const e = [], t = [], i = [];
    let r = !1;
    if (this.asyncTransactions.forEach((n) => {
      let s;
      if (this.serverSideRowModel.executeOnStore(n.transaction.route, (l) => {
        s = l.applyTransaction(n.transaction);
      }), s == null && (s = { status: tr.StoreNotFound }), t.push(s), s.status == tr.StoreLoading) {
        i.push(n);
        return;
      }
      n.callback && e.push(() => n.callback(s)), s.status === tr.Applied && (r = !0);
    }), e.length > 0 && window.setTimeout(() => {
      e.forEach((n) => n());
    }, 0), this.asyncTransactionsTimeout = void 0, this.asyncTransactions = i, r && (this.valueCache.onDataChanged(), this.eventService.dispatchEvent({ type: w.EVENT_STORE_UPDATED })), t.length > 0) {
      const n = {
        type: w.EVENT_ASYNC_TRANSACTIONS_FLUSHED,
        results: t
      };
      this.eventService.dispatchEvent(n);
    }
  }
  flushAsyncTransactions() {
    this.asyncTransactionsTimeout != null && clearTimeout(this.asyncTransactionsTimeout), this.executeAsyncTransactions();
  }
  applyTransaction(e) {
    let t;
    if (this.serverSideRowModel.executeOnStore(e.route, (i) => {
      t = i.applyTransaction(e);
    }), t) {
      if (this.valueCache.onDataChanged(), t.remove) {
        const i = t.remove.map((r) => r.id);
        this.selectionService.deleteSelectionStateFromParent(e.route || [], i);
      }
      return this.eventService.dispatchEvent({ type: w.EVENT_STORE_UPDATED }), t;
    } else
      return { status: tr.StoreNotFound };
  }
};
Oc([
  S("rowNodeBlockLoader")
], As.prototype, "rowNodeBlockLoader", void 0);
Oc([
  S("valueCache")
], As.prototype, "valueCache", void 0);
Oc([
  S("rowModel")
], As.prototype, "serverSideRowModel", void 0);
Oc([
  S("rowRenderer")
], As.prototype, "rowRenderer", void 0);
Oc([
  S("selectionService")
], As.prototype, "selectionService", void 0);
Oc([
  B
], As.prototype, "postConstruct", null);
As = Oc([
  q("ssrmTransactionManager")
], As);
var Lf = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Yl = class extends H {
  postConstruct() {
    this.gridOptionsService.isRowModelType("serverSide") && this.addManagedListener(this.eventService, w.EVENT_ROW_GROUP_OPENED, this.onRowGroupOpened.bind(this));
  }
  onRowGroupOpened(e) {
    const t = e.node;
    if (t.expanded) {
      if (t.master)
        this.createDetailNode(t);
      else if (x.missing(t.childStore)) {
        const r = this.serverSideRowModel.getParams();
        t.childStore = this.createBean(this.storeFactory.createStore(r, t));
      }
    } else
      this.gridOptionsService.is("purgeClosedRowNodes") && x.exists(t.childStore) && (t.childStore = this.destroyBean(t.childStore));
    const i = { type: w.EVENT_STORE_UPDATED };
    this.eventService.dispatchEvent(i);
  }
  createDetailNode(e) {
    if (x.exists(e.detailNode))
      return e.detailNode;
    const t = new re(this.beans);
    t.detail = !0, t.selectable = !1, t.parent = e, x.exists(e.id) && (t.id = "detail_" + e.id), t.data = e.data, t.level = e.level + 1;
    const i = 200, r = this.gridOptionsService.getRowHeightForNode(t).height;
    return t.rowHeight = r || i, e.detailNode = t, t;
  }
};
Lf([
  S("rowModel")
], Yl.prototype, "serverSideRowModel", void 0);
Lf([
  S("ssrmStoreFactory")
], Yl.prototype, "storeFactory", void 0);
Lf([
  S("beans")
], Yl.prototype, "beans", void 0);
Lf([
  B
], Yl.prototype, "postConstruct", null);
Yl = Lf([
  q("ssrmExpandListener")
], Yl);
var Ku = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Aa = class extends H {
  postConstruct() {
    this.gridOptionsService.isRowModelType("serverSide") && this.addManagedListener(this.eventService, w.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));
  }
  extractSortModel() {
    const e = this.sortController.getSortModel();
    return this.gridOptionsService.isTreeData() || (this.replaceAutoGroupColumnWithActualRowGroupColumns(e), this.removeMultiColumnPrefixOnColumnIds(e)), e;
  }
  removeMultiColumnPrefixOnColumnIds(e) {
    if (this.gridOptionsService.isGroupMultiAutoColumn()) {
      const t = bs + "-";
      for (let i = 0; i < e.length; ++i)
        e[i].colId.indexOf(t) > -1 && (e[i].colId = e[i].colId.substr(t.length));
    }
  }
  replaceAutoGroupColumnWithActualRowGroupColumns(e) {
    const t = e.find((i) => i.colId == bs);
    if (t) {
      const i = e.indexOf(t);
      x.removeFromArray(e, t);
      const r = (a) => e.filter((l) => l.colId === a.getColId()).length == 0, n = (a) => ({ colId: a.getId(), sort: t.sort }), s = this.columnModel.getRowGroupColumns().filter(r).map(n);
      x.insertArrayIntoArray(e, s, i);
    }
  }
  onSortChanged() {
    const e = this.serverSideRowModel.getParams();
    if (!e)
      return;
    const t = this.extractSortModel(), i = e.sortModel, r = this.findChangedColumnsInSort(t, i), n = this.listenerUtils.isSortingWithValueColumn(r), s = this.listenerUtils.isSortingWithSecondaryColumn(r), a = {
      valueColChanged: n,
      secondaryColChanged: s,
      changedColumns: r
    };
    this.serverSideRowModel.refreshAfterSort(t, a);
  }
  // returns back all the cols that were effected by the sorting. eg if we were sorting by col A,
  // and now we are sorting by col B, the list of impacted cols should be A and B. so if a cache
  // is impacted by sorting on A or B then it needs to be refreshed. this includes where the cache
  // was previously sorted by A and then the A sort now needs to be cleared.
  findChangedColumnsInSort(e, t) {
    let i = [];
    [e, t].forEach((s) => {
      if (s) {
        const a = s.map((l) => l.colId);
        i = i.concat(a);
      }
    });
    const r = (s, a) => {
      const l = s ? s.sort : null, c = a ? a.sort : null;
      return l !== c;
    }, n = (s, a) => {
      const l = s ? t.indexOf(s) : -1, c = a ? e.indexOf(a) : -1;
      return l !== c;
    };
    return i.filter((s) => {
      const a = t.find((c) => c.colId === s), l = e.find((c) => c.colId === s);
      return r(a, l) || n(a, l);
    });
  }
};
Ku([
  S("sortController")
], Aa.prototype, "sortController", void 0);
Ku([
  S("columnModel")
], Aa.prototype, "columnModel", void 0);
Ku([
  S("rowModel")
], Aa.prototype, "serverSideRowModel", void 0);
Ku([
  S("ssrmListenerUtils")
], Aa.prototype, "listenerUtils", void 0);
Ku([
  B
], Aa.prototype, "postConstruct", null);
Aa = Ku([
  q("ssrmSortService")
], Aa);
var Nf = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Xl = class extends H {
  postConstruct() {
    this.gridOptionsService.isRowModelType("serverSide") && this.addManagedListener(this.eventService, w.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));
  }
  onFilterChanged() {
    const e = this.serverSideRowModel.getParams();
    if (!e)
      return;
    const t = this.filterManager.getFilterModel(), i = e ? e.filterModel : {}, r = this.findChangedColumns(t, i), n = this.listenerUtils.isSortingWithValueColumn(r), s = this.listenerUtils.isSortingWithSecondaryColumn(r), a = {
      valueColChanged: n,
      secondaryColChanged: s,
      changedColumns: r
    };
    this.serverSideRowModel.refreshAfterFilter(t, a);
  }
  findChangedColumns(e, t) {
    const i = {};
    Object.keys(e).forEach((n) => i[n] = !0), Object.keys(t).forEach((n) => i[n] = !0);
    const r = [];
    return Object.keys(i).forEach((n) => {
      const s = JSON.stringify(e[n]), a = JSON.stringify(t[n]);
      s != a && r.push(n);
    }), r;
  }
};
Nf([
  S("rowModel")
], Xl.prototype, "serverSideRowModel", void 0);
Nf([
  S("filterManager")
], Xl.prototype, "filterManager", void 0);
Nf([
  S("ssrmListenerUtils")
], Xl.prototype, "listenerUtils", void 0);
Nf([
  B
], Xl.prototype, "postConstruct", null);
Xl = Nf([
  q("ssrmFilterListener")
], Xl);
var Aw = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Cp = class {
  createStore(e, t) {
    const i = this.getStoreParams(e, t), r = i.suppressInfiniteScroll ? hr : Ps;
    return new r(e, i, t);
  }
  getStoreParams(e, t) {
    const i = this.getLevelSpecificParams(t), r = this.isInfiniteScroll(i), n = this.getBlockSize(r, i), s = this.getMaxBlocksInCache(r, e, i);
    return {
      suppressInfiniteScroll: !r,
      cacheBlockSize: n,
      maxBlocksInCache: s
    };
  }
  getMaxBlocksInCache(e, t, i) {
    if (!e)
      return;
    const r = i && i.maxBlocksInCache != null ? i.maxBlocksInCache : this.gridOptionsService.getNum("maxBlocksInCache");
    if (r != null && r >= 0) {
      if (t.dynamicRowHeight) {
        const s = "AG Grid: Server Side Row Model does not support Dynamic Row Height and Cache Purging. Either a) remove getRowHeight() callback or b) remove maxBlocksInCache property. Purging has been disabled.";
        x.doOnce(() => console.warn(s), "storeFactory.maxBlocksInCache.dynamicRowHeight");
        return;
      }
      if (this.columnModel.isAutoRowHeightActive()) {
        const s = "AG Grid: Server Side Row Model does not support Auto Row Height and Cache Purging. Either a) remove colDef.autoHeight or b) remove maxBlocksInCache property. Purging has been disabled.";
        x.doOnce(() => console.warn(s), "storeFactory.maxBlocksInCache.autoRowHeightActive");
        return;
      }
      return r;
    }
  }
  getBlockSize(e, t) {
    if (!e)
      return;
    const i = t && t.cacheBlockSize != null ? t.cacheBlockSize : this.gridOptionsService.getNum("cacheBlockSize");
    return i != null && i > 0 ? i : 100;
  }
  getLevelSpecificParams(e) {
    const t = this.gridOptionsService.getCallback("getServerSideGroupLevelParams");
    if (!t)
      return;
    const i = {
      level: e.level + 1,
      parentRowNode: e.level >= 0 ? e : void 0,
      rowGroupColumns: this.columnModel.getRowGroupColumns(),
      pivotColumns: this.columnModel.getPivotColumns(),
      pivotMode: this.columnModel.isPivotMode()
    }, r = t(i);
    return r.storeType != null && (r.suppressInfiniteScroll = r.storeType !== "partial"), r;
  }
  isInfiniteScroll(e) {
    return !(e && e.suppressInfiniteScroll != null ? e.suppressInfiniteScroll : this.isSuppressServerSideInfiniteScroll());
  }
  isSuppressServerSideInfiniteScroll() {
    return this.gridOptionsService.is("suppressServerSideInfiniteScroll");
  }
};
Aw([
  S("gridOptionsService")
], Cp.prototype, "gridOptionsService", void 0);
Aw([
  S("columnModel")
], Cp.prototype, "columnModel", void 0);
Cp = Aw([
  q("ssrmStoreFactory")
], Cp);
var fP = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Ev = class {
  isSortingWithValueColumn(e) {
    const t = this.columnModel.getValueColumns().map((i) => i.getColId());
    for (let i = 0; i < e.length; i++)
      if (t.indexOf(e[i]) > -1)
        return !0;
    return !1;
  }
  isSortingWithSecondaryColumn(e) {
    if (!this.columnModel.getSecondaryColumns())
      return !1;
    const t = this.columnModel.getSecondaryColumns().map((i) => i.getColId());
    for (let i = 0; i < e.length; i++)
      if (t.indexOf(e[i]) > -1)
        return !0;
    return !1;
  }
};
fP([
  S("columnModel")
], Ev.prototype, "columnModel", void 0);
Ev = fP([
  q("ssrmListenerUtils")
], Ev);
var gP = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Rv extends H {
  constructor() {
    super(...arguments), this.selectedState = { selectAll: !1, toggledNodes: /* @__PURE__ */ new Set() }, this.lastSelected = null, this.selectAllUsed = !1, this.selectedNodes = {};
  }
  init() {
    this.rowSelection = this.gridOptionsService.get("rowSelection"), this.addManagedPropertyListener("rowSelection", (e) => {
      this.rowSelection = e.currentValue;
    });
  }
  getSelectedState() {
    return {
      selectAll: this.selectedState.selectAll,
      toggledNodes: [...this.selectedState.toggledNodes]
    };
  }
  setSelectedState(e) {
    const t = {
      selectAll: !1,
      toggledNodes: /* @__PURE__ */ new Set()
    };
    if (typeof e != "object") {
      console.error("AG Grid: The provided selection state should be an object.");
      return;
    }
    if ("selectAll" in e && typeof e.selectAll == "boolean")
      t.selectAll = e.selectAll;
    else {
      console.error("AG Grid: Select all status should be of boolean type.");
      return;
    }
    if ("toggledNodes" in e && Array.isArray(e.toggledNodes))
      e.toggledNodes.forEach((i) => {
        typeof i == "string" ? t.toggledNodes.add(i) : console.warn(`AG Grid: Provided ids must be of string type. Invalid id provided: ${i}`);
      });
    else {
      console.error("AG Grid: `toggledNodes` must be an array of string ids.");
      return;
    }
    this.selectedState = t;
  }
  deleteSelectionStateFromParent(e, t) {
    if (this.selectedState.toggledNodes.size === 0)
      return !1;
    let i = !1;
    return t.forEach((r) => {
      this.selectedState.toggledNodes.delete(r) && (i = !0);
    }), i;
  }
  setNodesSelected(e) {
    if (e.nodes.length === 0)
      return 0;
    const t = e.clearSelection && e.newValue && !e.rangeSelect;
    if (this.rowSelection !== "multiple" || t) {
      if (e.nodes.length > 1)
        throw new Error("AG Grid: cannot select multiple rows when rowSelection is set to 'single'");
      const r = e.nodes[0];
      return e.newValue ? (this.selectedNodes = { [r.id]: r }, this.selectedState = {
        selectAll: !1,
        toggledNodes: /* @__PURE__ */ new Set([r.id])
      }) : (this.selectedNodes = {}, this.selectedState = {
        selectAll: !1,
        toggledNodes: /* @__PURE__ */ new Set()
      }), this.lastSelected = r.id, 1;
    }
    const i = (r) => {
      if (e.newValue ? this.selectedNodes[r.id] = r : delete this.selectedNodes[r.id], e.newValue === this.selectedState.selectAll) {
        this.selectedState.toggledNodes.delete(r.id);
        return;
      }
      this.selectedState.toggledNodes.add(r.id);
    };
    if (e.rangeSelect && this.lastSelected) {
      if (e.nodes.length > 1)
        throw new Error("AG Grid: cannot select multiple rows when using rangeSelect");
      const r = e.nodes[0], n = this.rowModel.getRowNode(this.lastSelected);
      return this.rowModel.getNodesInRangeForSelection(r, n != null ? n : null).forEach(i), this.lastSelected = r.id, 1;
    }
    return e.nodes.forEach(i), this.lastSelected = e.nodes[e.nodes.length - 1].id, 1;
  }
  processNewRow(e) {
    this.selectedNodes[e.id] && (this.selectedNodes[e.id] = e);
  }
  isNodeSelected(e) {
    const t = this.selectedState.toggledNodes.has(e.id);
    return this.selectedState.selectAll ? !t : t;
  }
  getSelectedNodes() {
    return this.selectAllUsed && console.warn("AG Grid: getSelectedNodes and getSelectedRows functions cannot be used with select all functionality with the server-side row model.\n                Use `api.getServerSideSelectionState()` instead."), Object.values(this.selectedNodes);
  }
  getSelectedRows() {
    return this.getSelectedNodes().map((e) => e.data);
  }
  getSelectionCount() {
    return this.selectedState.selectAll ? -1 : this.selectedState.toggledNodes.size;
  }
  clearOtherNodes(e, t) {
    const i = this.selectedState.selectAll ? 1 : this.selectedState.toggledNodes.size - 1;
    this.selectedState = {
      selectAll: !1,
      toggledNodes: /* @__PURE__ */ new Set([e.id])
    }, this.rowModel.forEachNode((n) => {
      n !== e && n.selectThisNode(!1, void 0, t);
    });
    const r = {
      type: w.EVENT_SELECTION_CHANGED,
      source: t
    };
    return this.eventService.dispatchEvent(r), i;
  }
  isEmpty() {
    var e;
    return !this.selectedState.selectAll && !(!((e = this.selectedState.toggledNodes) === null || e === void 0) && e.size);
  }
  selectAllRowNodes(e) {
    this.selectedState = { selectAll: !0, toggledNodes: /* @__PURE__ */ new Set() }, this.selectedNodes = {}, this.selectAllUsed = !0;
  }
  deselectAllRowNodes(e) {
    this.selectedState = { selectAll: !1, toggledNodes: /* @__PURE__ */ new Set() }, this.selectedNodes = {};
  }
  getSelectAllState(e, t) {
    return this.selectedState.selectAll ? this.selectedState.toggledNodes.size > 0 ? null : !0 : this.selectedState.toggledNodes.size > 0 ? null : !1;
  }
}
gP([
  S("rowModel")
], Rv.prototype, "rowModel", void 0);
gP([
  B
], Rv.prototype, "init", null);
var Yu = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
}, i2 = function(o, e) {
  var t = {};
  for (var i in o)
    Object.prototype.hasOwnProperty.call(o, i) && e.indexOf(i) < 0 && (t[i] = o[i]);
  if (o != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(o); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(o, i[r]) && (t[i[r]] = o[i[r]]);
  return t;
};
class Ma extends H {
  constructor() {
    super(...arguments), this.selectedState = { selectAllChildren: !1, toggledNodes: /* @__PURE__ */ new Map() }, this.lastSelected = null;
  }
  init() {
    this.addManagedListener(this.eventService, w.EVENT_MODEL_UPDATED, () => this.removeRedundantState()), this.addManagedListener(this.eventService, w.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.selectionService.reset());
  }
  getSelectedState() {
    const e = (t, i, r) => {
      const n = {
        nodeId: r
      };
      if (i <= this.columnModel.getRowGroupColumns().length && (n.selectAllChildren = t.selectAllChildren), t.toggledNodes.size) {
        const s = [];
        t.toggledNodes.forEach((a, l) => {
          const c = e(a, i + 1, l);
          s.push(c);
        }), n.toggledNodes = s;
      }
      return n;
    };
    return e(this.selectedState, 0);
  }
  setSelectedState(e) {
    const t = (i, r) => {
      var n, s;
      if (typeof i != "object")
        throw new Error("AG Grid: Each provided state object must be an object.");
      if ("selectAllChildren" in i && typeof i.selectAllChildren != "boolean")
        throw new Error("AG Grid: `selectAllChildren` must be a boolean value or undefined.");
      if ("toggledNodes" in i) {
        if (!Array.isArray(i.toggledNodes))
          throw new Error("AG Grid: `toggledNodes` must be an array.");
        if (!i.toggledNodes.every((u) => typeof u == "object" && "nodeId" in u && typeof u.nodeId == "string"))
          throw new Error("AG Grid: Every `toggledNode` requires an associated string id.");
      }
      const a = (n = i.selectAllChildren) !== null && n !== void 0 ? n : !r, l = (s = i.toggledNodes) === null || s === void 0 ? void 0 : s.map((d) => [d.nodeId, t(d, a)]);
      if (l == null ? void 0 : l.some(([d, u]) => a === u.selectAllChildren && u.toggledNodes.size === 0))
        throw new Error(`
                    AG Grid: AG Grid: Row selection state could not be parsed due to invalid data. Ensure all child state has toggledNodes or does not conform with the parent rule.
                    Please rebuild the selection state and reapply it.
                `);
      return {
        selectAllChildren: a,
        toggledNodes: new Map(l)
      };
    };
    try {
      this.selectedState = t(e, !!e.selectAllChildren);
    } catch (i) {
      console.error(i.message);
    }
  }
  deleteSelectionStateFromParent(e, t) {
    let i = this.selectedState;
    const r = [...e];
    for (; i && r.length; )
      i = i.toggledNodes.get(r.pop());
    if (!i)
      return !1;
    let n = !1;
    return t.forEach((s) => {
      i != null && i.toggledNodes.delete(s) && (n = !0);
    }), n && this.removeRedundantState(), n;
  }
  setNodesSelected(e) {
    const { nodes: t } = e, i = i2(e, ["nodes"]);
    if (t.length === 0)
      return 0;
    if (e.rangeSelect) {
      if (t.length > 1)
        throw new Error("AG Grid: cannot select multiple rows when using rangeSelect");
      const r = t[0], s = this.rowModel.getNodesInRangeForSelection(r, this.lastSelected).map(this.getRouteToNode).sort((l, c) => c.length - l.length), a = /* @__PURE__ */ new Set();
      return s.forEach((l) => {
        a.has(l[l.length - 1]) || (l.forEach((c) => a.add(c)), this.recursivelySelectNode(l, this.selectedState, Object.assign({ node: r }, i)));
      }), this.removeRedundantState(), this.lastSelected = r, 1;
    }
    return e.nodes.forEach((r) => {
      const n = this.getRouteToNode(r);
      this.recursivelySelectNode(n, this.selectedState, Object.assign(Object.assign({}, i), { node: r }));
    }), this.removeRedundantState(), this.lastSelected = e.nodes[e.nodes.length - 1], 1;
  }
  isNodeSelected(e) {
    const t = this.getRouteToNode(e);
    return this.isNodePathSelected(t, this.selectedState);
  }
  isNodePathSelected([e, ...t], i) {
    if (t.length === 0) {
      const r = i.toggledNodes.has(e.id);
      if (e.hasChildren()) {
        const n = i.toggledNodes.get(e.id);
        if (n && n.toggledNodes.size)
          return;
      }
      return i.selectAllChildren ? !r : r;
    }
    if (i.toggledNodes.has(e.id)) {
      const r = i.toggledNodes.get(e.id);
      if (r)
        return this.isNodePathSelected(t, r);
    }
    return !!i.selectAllChildren;
  }
  getRouteToNode(e) {
    const t = [];
    let i = e;
    for (; i.parent; )
      t.push(i), i = i.parent;
    return t.reverse();
  }
  removeRedundantState() {
    if (this.filterManager.isAnyFilterPresent())
      return;
    const e = (t = this.selectedState, i = this.serverSideRowModel.getRootStore(), r) => {
      let n = !0, s = !0;
      return t.toggledNodes.forEach((a, l) => {
        const c = this.rowModel.getRowNode(l);
        c || (n = !1);
        const d = c == null ? void 0 : c.childStore;
        if (!d) {
          a.toggledNodes.size > 0 && (s = !1);
          return;
        }
        e(a, d, c) && t.selectAllChildren === a.selectAllChildren && t.toggledNodes.delete(l), a.toggledNodes.size > 0 && (s = !1);
      }), !i || !i.isLastRowIndexKnown() || i.getRowCount() !== t.toggledNodes.size ? !1 : s && n ? (t.toggledNodes.clear(), t.selectAllChildren = !t.selectAllChildren, r && (r == null ? void 0 : r.isSelected()) !== t.selectAllChildren && r.selectThisNode(t.selectAllChildren, void 0, "api"), !0) : !1;
    };
    e();
  }
  recursivelySelectNode([e, ...t], i, r) {
    if (!e)
      return;
    if (!t.length) {
      if (i.selectAllChildren === r.newValue) {
        i.toggledNodes.delete(e.id);
        return;
      }
      const c = {
        selectAllChildren: r.newValue,
        toggledNodes: /* @__PURE__ */ new Map()
      };
      i.toggledNodes.set(e.id, c);
      return;
    }
    const s = i.toggledNodes.has(e.id), a = s ? i.toggledNodes.get(e.id) : {
      selectAllChildren: i.selectAllChildren,
      toggledNodes: /* @__PURE__ */ new Map()
    };
    s || i.toggledNodes.set(e.id, a), this.recursivelySelectNode(t, a, r), i.selectAllChildren === a.selectAllChildren && a.toggledNodes.size === 0 && i.toggledNodes.delete(e.id);
  }
  getSelectedNodes() {
    console.warn("AG Grid: `getSelectedNodes` and `getSelectedRows` functions cannot be used with `groupSelectsChildren` and the server-side row model.\n            Use `api.getServerSideSelectionState()` instead.");
    const e = [];
    return this.rowModel.forEachNode((t) => {
      t.isSelected() && e.push(t);
    }), e;
  }
  processNewRow(e) {
  }
  getSelectedRows() {
    return this.getSelectedNodes().map((e) => e.data);
  }
  getSelectionCount() {
    return -1;
  }
  isEmpty() {
    var e;
    return !this.selectedState.selectAllChildren && !(!((e = this.selectedState.toggledNodes) === null || e === void 0) && e.size);
  }
  selectAllRowNodes(e) {
    this.selectedState = { selectAllChildren: !0, toggledNodes: /* @__PURE__ */ new Map() };
  }
  deselectAllRowNodes(e) {
    this.selectedState = { selectAllChildren: !1, toggledNodes: /* @__PURE__ */ new Map() };
  }
  getSelectAllState(e, t) {
    return this.selectedState.selectAllChildren ? this.selectedState.toggledNodes.size > 0 ? null : !0 : this.selectedState.toggledNodes.size > 0 ? null : !1;
  }
}
Yu([
  S("rowModel")
], Ma.prototype, "rowModel", void 0);
Yu([
  S("columnModel")
], Ma.prototype, "columnModel", void 0);
Yu([
  S("filterManager")
], Ma.prototype, "filterManager", void 0);
Yu([
  S("rowModel")
], Ma.prototype, "serverSideRowModel", void 0);
Yu([
  S("selectionService")
], Ma.prototype, "selectionService", void 0);
Yu([
  B
], Ma.prototype, "init", null);
var Mw = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let Sp = class extends H {
  init() {
    const e = this.gridOptionsService.is("groupSelectsChildren");
    this.addManagedPropertyListener("groupSelectsChildren", (i) => {
      this.destroyBean(this.selectionStrategy);
      const r = i.currentValue ? Ma : Rv;
      this.selectionStrategy = this.createManagedBean(new r()), this.shotgunResetNodeSelectionState();
      const n = {
        type: w.EVENT_SELECTION_CHANGED,
        source: "api"
      };
      this.eventService.dispatchEvent(n);
    }), this.rowSelection = this.gridOptionsService.get("rowSelection"), this.addManagedPropertyListener("rowSelection", (i) => this.rowSelection = i.currentValue);
    const t = e ? Ma : Rv;
    this.selectionStrategy = this.createManagedBean(new t());
  }
  getServerSideSelectionState() {
    return this.selectionStrategy.getSelectedState();
  }
  setServerSideSelectionState(e) {
    this.selectionStrategy.setSelectedState(e), this.shotgunResetNodeSelectionState();
    const t = {
      type: w.EVENT_SELECTION_CHANGED,
      source: "api"
    };
    this.eventService.dispatchEvent(t);
  }
  setNodesSelected(e) {
    if (e.nodes.length > 1 && this.rowSelection !== "multiple")
      return console.warn("AG Grid: cannot multi select while rowSelection='single'"), 0;
    if (e.nodes.length > 1 && e.rangeSelect)
      return console.warn("AG Grid: cannot use range selection when multi selecting rows"), 0;
    const t = this.selectionStrategy.setNodesSelected(e);
    this.shotgunResetNodeSelectionState(e.source);
    const i = {
      type: w.EVENT_SELECTION_CHANGED,
      source: e.source
    };
    return this.eventService.dispatchEvent(i), t;
  }
  /**
   * Deletes the selection state for a set of nodes, for use after deleting nodes via
   * transaction. As this is designed for transactions, all nodes should belong to the same group.
   */
  deleteSelectionStateFromParent(e, t) {
    if (!this.selectionStrategy.deleteSelectionStateFromParent(e, t))
      return;
    this.shotgunResetNodeSelectionState();
    const r = {
      type: w.EVENT_SELECTION_CHANGED,
      source: "api"
    };
    this.eventService.dispatchEvent(r);
  }
  shotgunResetNodeSelectionState(e) {
    this.rowModel.forEachNode((t) => {
      if (t.stub)
        return;
      const i = this.selectionStrategy.isNodeSelected(t);
      i !== t.isSelected() && t.selectThisNode(i, void 0, e);
    });
  }
  getSelectedNodes() {
    return this.selectionStrategy.getSelectedNodes();
  }
  getSelectedRows() {
    return this.selectionStrategy.getSelectedRows();
  }
  getSelectionCount() {
    return this.selectionStrategy.getSelectionCount();
  }
  syncInRowNode(e, t) {
    this.selectionStrategy.processNewRow(e);
    const i = this.selectionStrategy.isNodeSelected(e);
    e.setSelectedInitialValue(i);
  }
  reset() {
    this.selectionStrategy.deselectAllRowNodes({ source: "api" });
  }
  isEmpty() {
    return this.selectionStrategy.isEmpty();
  }
  selectAllRowNodes(e) {
    (e.justCurrentPage || e.justFiltered) && console.warn("AG Grid: selecting just filtered only works when gridOptions.rowModelType='clientSide'"), this.selectionStrategy.selectAllRowNodes(e), this.rowModel.forEachNode((i) => {
      i.stub || i.selectThisNode(!0, void 0, e.source);
    });
    const t = {
      type: w.EVENT_SELECTION_CHANGED,
      source: e.source
    };
    this.eventService.dispatchEvent(t);
  }
  deselectAllRowNodes(e) {
    (e.justCurrentPage || e.justFiltered) && console.warn("AG Grid: selecting just filtered only works when gridOptions.rowModelType='clientSide'"), this.selectionStrategy.deselectAllRowNodes(e), this.rowModel.forEachNode((i) => {
      i.stub || i.selectThisNode(!1, void 0, e.source);
    });
    const t = {
      type: w.EVENT_SELECTION_CHANGED,
      source: e.source
    };
    this.eventService.dispatchEvent(t);
  }
  getSelectAllState(e, t) {
    return this.selectionStrategy.getSelectAllState(e, t);
  }
  // used by CSRM
  updateGroupsFromChildrenSelections(e, t) {
    return !1;
  }
  // used by CSRM
  getBestCostNodeSelection() {
    console.warn("AG Grid: calling gridApi.getBestCostNodeSelection() is only possible when using rowModelType=`clientSide`.");
  }
  // used by CSRM
  filterFromSelection() {
  }
};
Mw([
  S("rowModel")
], Sp.prototype, "rowModel", void 0);
Mw([
  B
], Sp.prototype, "init", null);
Sp = Mw([
  q("selectionService")
], Sp);
const r2 = "30.0.5", n2 = {
  version: r2,
  moduleName: Q.ServerSideRowModelModule,
  rowModel: "serverSide",
  beans: [
    Nr,
    Yl,
    Aa,
    ru,
    Pa,
    wv,
    As,
    Xl,
    Cp,
    Ev,
    Sp
  ],
  dependantModules: [
    Pi
  ]
};
class o2 {
  constructor(e, t, i, r, n, s, a, l, c) {
    this.rowModel = e, this.filterParams = t, this.createKey = i, this.caseFormat = r, this.columnModel = n, this.valueService = s, this.treeDataOrGrouping = a, this.treeData = l, this.getDataPath = c;
  }
  extractUniqueValues(e, t) {
    const i = /* @__PURE__ */ new Map(), r = this.extractExistingFormattedKeys(t), n = /* @__PURE__ */ new Set(), s = this.treeData && !!this.getDataPath, a = this.columnModel.getRowGroupColumns(), l = (c, d) => {
      const u = this.caseFormat(c);
      if (!n.has(u)) {
        n.add(u);
        let h = c, p = x.makeNull(d);
        const f = r == null ? void 0 : r.get(u);
        f != null && (h = f, p = t.get(f)), i.set(h, p);
      }
    };
    return this.rowModel.forEachLeafNode((c) => {
      if (!c.data || !e(c))
        return;
      if (this.treeDataOrGrouping) {
        this.addValueForTreeDataOrGrouping(c, s, a, l);
        return;
      }
      let d = this.getValue(c);
      if (this.filterParams.convertValuesToStrings) {
        this.addValueForConvertValuesToString(c, d, l);
        return;
      }
      d != null && Array.isArray(d) ? (d.forEach((u) => {
        l(this.createKey(u, c), u);
      }), d.length === 0 && l(null, null)) : l(this.createKey(d, c), d);
    }), i;
  }
  addValueForConvertValuesToString(e, t, i) {
    const r = this.createKey(t, e);
    r != null && Array.isArray(r) ? (r.forEach((n) => {
      const s = x.toStringOrNull(x.makeNull(n));
      i(s, s);
    }), r.length === 0 && i(null, null)) : i(r, r);
  }
  addValueForTreeDataOrGrouping(e, t, i, r) {
    var n;
    let s;
    if (t) {
      if (!((n = e.childrenAfterGroup) === null || n === void 0) && n.length)
        return;
      s = this.getDataPath(e.data);
    } else
      s = i.map((a) => this.valueService.getKeyForNode(a, e)), s.push(this.getValue(e));
    s && (s = s.map((a) => x.toStringOrNull(x.makeNull(a)))), s != null && s.some((a) => a == null) && (s = null), r(this.createKey(s), s);
  }
  getValue(e) {
    const { api: t, colDef: i, column: r, columnApi: n, context: s } = this.filterParams;
    return this.filterParams.valueGetter({
      api: t,
      colDef: i,
      column: r,
      columnApi: n,
      context: s,
      data: e.data,
      getValue: (a) => e.data[a],
      node: e
    });
  }
  extractExistingFormattedKeys(e) {
    if (!e)
      return null;
    const t = /* @__PURE__ */ new Map();
    return e.forEach((i, r) => {
      t.set(this.caseFormat(r), r);
    }), t;
  }
}
class la {
}
la.SELECT_ALL = "__AG_SELECT_ALL__";
class s2 {
  constructor(e, t, i, r) {
    this.valueFormatterService = e, this.valueFormatter = t, this.formatter = i, this.column = r, this.displayedKeys = [];
  }
  updateDisplayedValuesToAllAvailable(e, t, i) {
    this.displayedKeys = Array.from(i);
  }
  updateDisplayedValuesToMatchMiniFilter(e, t, i, r, n) {
    this.displayedKeys = [];
    for (let s of i)
      if (s == null)
        n && this.displayedKeys.push(s);
      else {
        const a = e(s), l = this.valueFormatterService.formatValue(this.column, null, a, this.valueFormatter, !1), c = this.formatter(l);
        r(c) && this.displayedKeys.push(s);
      }
  }
  getDisplayedValueCount() {
    return this.displayedKeys.length;
  }
  getDisplayedItem(e) {
    return this.displayedKeys[e];
  }
  getSelectAllItem() {
    return la.SELECT_ALL;
  }
  getDisplayedKeys() {
    return this.displayedKeys;
  }
  forEachDisplayedKey(e) {
    this.displayedKeys.forEach(e);
  }
  someDisplayedKey(e) {
    return this.displayedKeys.some(e);
  }
  hasGroups() {
    return !1;
  }
  refresh() {
  }
}
class ay {
  constructor(e, t, i, r) {
    this.formatter = e, this.treeListPathGetter = t, this.treeListFormatter = i, this.treeDataOrGrouping = r, this.allDisplayedItemsTree = [], this.activeDisplayedItemsFlat = [], this.selectAllItem = {
      depth: 0,
      filterPasses: !0,
      available: !0,
      treeKey: la.SELECT_ALL,
      children: this.allDisplayedItemsTree,
      expanded: !0,
      key: la.SELECT_ALL,
      parentTreeKeys: []
    };
  }
  updateDisplayedValuesToAllAvailable(e, t, i, r) {
    r === "reload" ? this.generateItemTree(e, t, i) : r === "otherFilter" ? (this.updateAvailable(i), this.updateExpandAll()) : r === "miniFilter" && (this.resetFilter(), this.updateExpandAll()), this.flattenItems();
  }
  updateDisplayedValuesToMatchMiniFilter(e, t, i, r, n, s) {
    s === "reload" ? this.generateItemTree(e, t, i) : s === "otherFilter" && this.updateAvailable(i), this.updateFilter(r, n), this.updateExpandAll(), this.flattenItems();
  }
  generateItemTree(e, t, i) {
    var r;
    this.allDisplayedItemsTree = [], this.groupsExist = !1;
    const n = this.getTreeListPathGetter(e, i);
    for (let s of t) {
      const a = e(s), l = (r = n(a)) !== null && r !== void 0 ? r : [null];
      l.length > 1 && (this.groupsExist = !0);
      const c = i.has(s);
      let d = this.allDisplayedItemsTree, u, h = [];
      l.forEach((p, f) => {
        d || (d = [], u.children = d), u = d.find((g) => {
          var v;
          return ((v = g.treeKey) === null || v === void 0 ? void 0 : v.toUpperCase()) === (p == null ? void 0 : p.toUpperCase());
        }), u || (u = { treeKey: p, depth: f, filterPasses: !0, expanded: !1, available: c, parentTreeKeys: h }, f === l.length - 1 && (u.key = s), d.push(u)), d = u.children, h = [...h, p];
      });
    }
    this.updateAvailable(i), this.selectAllItem.children = this.allDisplayedItemsTree, this.selectAllItem.expanded = !1;
  }
  getTreeListPathGetter(e, t) {
    if (this.treeListPathGetter)
      return this.treeListPathGetter;
    if (this.treeDataOrGrouping)
      return (r) => r;
    let i = !1;
    for (const r of t) {
      const n = e(r);
      if (n instanceof Date) {
        i = !0;
        break;
      } else if (n != null)
        break;
    }
    return i ? ay.DATE_TREE_LIST_PATH_GETTER : (x.doOnce(() => console.warn("AG Grid: property treeList=true for Set Filter params, but you did not provide a treeListPathGetter or values of type Date."), "getTreeListPathGetter"), (r) => [String(r)]);
  }
  flattenItems() {
    this.activeDisplayedItemsFlat = [];
    const e = (t) => {
      t.forEach((i) => {
        !i.filterPasses || !i.available || (this.activeDisplayedItemsFlat.push(i), i.children && i.expanded && e(i.children));
      });
    };
    e(this.allDisplayedItemsTree);
  }
  resetFilter() {
    const e = (t) => {
      t.children && t.children.forEach((i) => {
        e(i);
      }), t.filterPasses = !0;
    };
    this.allDisplayedItemsTree.forEach((t) => e(t));
  }
  updateFilter(e, t) {
    const i = (r) => r.available ? r.treeKey == null ? t : e(this.formatter(this.treeListFormatter ? this.treeListFormatter(r.treeKey, r.depth, r.parentTreeKeys) : r.treeKey)) : !1;
    this.allDisplayedItemsTree.forEach((r) => this.recursiveItemCheck(r, !1, i, "filterPasses"));
  }
  getDisplayedValueCount() {
    return this.activeDisplayedItemsFlat.length;
  }
  getDisplayedItem(e) {
    return this.activeDisplayedItemsFlat[e];
  }
  getSelectAllItem() {
    return this.selectAllItem;
  }
  getDisplayedKeys() {
    const e = [];
    return this.forEachDisplayedKey((t) => e.push(t)), e;
  }
  forEachDisplayedKey(e) {
    const t = (i, r) => {
      i.children ? (!i.expanded || !r) && i.children.forEach((n) => {
        n.filterPasses && t(n, !1);
      }) : e(i.key);
    };
    this.activeDisplayedItemsFlat.forEach((i) => t(i, !0));
  }
  someDisplayedKey(e) {
    const t = (i, r) => {
      if (i.children) {
        if (!i.expanded || !r)
          return i.children.some((n) => n.filterPasses ? t(n, !1) : !1);
      } else
        return e(i.key);
      return !1;
    };
    return this.activeDisplayedItemsFlat.some((i) => t(i, !0));
  }
  hasGroups() {
    return this.groupsExist;
  }
  refresh() {
    this.updateExpandAll(), this.flattenItems();
  }
  updateExpandAll() {
    const e = (i, r, n) => {
      for (const s of i) {
        if (!s.filterPasses || !s.available || !s.children)
          continue;
        if (r = r || !!s.expanded, n = n || !s.expanded, r && n)
          return;
        const a = e(s.children, r, n);
        if (a === void 0)
          return;
        a ? r = !0 : n = !0;
      }
      return r && n ? void 0 : r;
    }, t = this.getSelectAllItem();
    t.expanded = e(t.children, !1, !1);
  }
  recursiveItemCheck(e, t, i, r) {
    let n = !1;
    e.children && e.children.forEach((a) => {
      const l = this.recursiveItemCheck(a, t || i(e), i, r);
      n = n || l;
    });
    const s = t || n || i(e);
    return e[r] = s, s;
  }
  updateAvailable(e) {
    const t = (i) => e.has(i.key);
    this.allDisplayedItemsTree.forEach((i) => this.recursiveItemCheck(i, !1, t, "available"));
  }
}
ay.DATE_TREE_LIST_PATH_GETTER = (o) => o ? [String(o.getFullYear()), String(o.getMonth() + 1), String(o.getDate())] : null;
var yr;
(function(o) {
  o[o.PROVIDED_LIST = 0] = "PROVIDED_LIST", o[o.PROVIDED_CALLBACK = 1] = "PROVIDED_CALLBACK", o[o.TAKEN_FROM_GRID_VALUES = 2] = "TAKEN_FROM_GRID_VALUES";
})(yr || (yr = {}));
class Gf {
  constructor(e) {
    var t;
    this.localEventService = new _r(), this.miniFilterText = null, this.providedValues = null, this.allValues = /* @__PURE__ */ new Map(), this.availableKeys = /* @__PURE__ */ new Set(), this.selectedKeys = /* @__PURE__ */ new Set(), this.initialised = !1;
    const { usingComplexObjects: i, columnModel: r, valueService: n, treeDataTreeList: s, groupingTreeList: a, filterParams: l, gridOptionsService: c, valueFormatterService: d, valueFormatter: u } = e, { column: h, colDef: p, textFormatter: f, doesRowPassOtherFilter: g, suppressSorting: v, comparator: y, rowModel: m, values: C, caseSensitive: R, convertValuesToStrings: E, treeList: b, treeListPathGetter: T, treeListFormatter: D } = l;
    this.filterParams = l, this.setIsLoading = e.setIsLoading, this.translate = e.translate, this.caseFormat = e.caseFormat, this.createKey = e.createKey, this.usingComplexObjects = !!e.usingComplexObjects, this.formatter = f || $t.DEFAULT_FORMATTER, this.doesRowPassOtherFilters = g, this.suppressSorting = v || !1, this.convertValuesToStrings = !!E;
    const P = y != null ? y : p.comparator, O = !!s || !!a;
    this.compareByValue = !!(i && P || O || b && !T), O && !P ? this.entryComparator = this.createTreeDataOrGroupingComparator() : b && !T && !P ? this.entryComparator = ([_, F], [I, G]) => x.defaultComparator(F, G) : this.entryComparator = ([_, F], [I, G]) => P(F, G), this.keyComparator = (t = P) !== null && t !== void 0 ? t : x.defaultComparator, this.caseSensitive = !!R;
    const M = c.get("getDataPath");
    m.getType() === "clientSide" && (this.clientSideValuesExtractor = new o2(m, this.filterParams, this.createKey, this.caseFormat, r, n, O, !!s, M)), C == null ? this.valuesType = yr.TAKEN_FROM_GRID_VALUES : (this.valuesType = Array.isArray(C) ? yr.PROVIDED_LIST : yr.PROVIDED_CALLBACK, this.providedValues = C), this.displayValueModel = b ? new ay(this.formatter, T, D, s || a) : new s2(d, u, this.formatter, h), this.updateAllValues().then((_) => this.resetSelectionState(_ || []));
  }
  addEventListener(e, t, i) {
    this.localEventService.addEventListener(e, t, i);
  }
  removeEventListener(e, t, i) {
    this.localEventService.removeEventListener(e, t, i);
  }
  /**
   * Re-fetches the values used in the filter from the value source.
   * If keepSelection is false, the filter selection will be reset to everything selected,
   * otherwise the current selection will be preserved.
   */
  refreshValues() {
    const e = this.getModel();
    return this.updateAllValues(), this.setModel(e);
  }
  /**
   * Overrides the current values being used for the set filter.
   * If keepSelection is false, the filter selection will be reset to everything selected,
   * otherwise the current selection will be preserved.
   */
  overrideValues(e) {
    return new Qe((t) => {
      this.allValuesPromise.then(() => {
        this.valuesType = yr.PROVIDED_LIST, this.providedValues = e, this.refreshValues().then(() => t());
      });
    });
  }
  /** @return has anything been updated */
  refreshAfterAnyFilterChanged() {
    return this.showAvailableOnly() ? this.allValuesPromise.then((e) => (this.updateAvailableKeys(e != null ? e : [], "otherFilter"), !0)) : Qe.resolve(!1);
  }
  isInitialised() {
    return this.initialised;
  }
  updateAllValues() {
    return this.allValuesPromise = new Qe((e) => {
      switch (this.valuesType) {
        case yr.TAKEN_FROM_GRID_VALUES:
        case yr.PROVIDED_LIST: {
          e(this.processAllKeys(this.valuesType === yr.TAKEN_FROM_GRID_VALUES, this.providedValues));
          break;
        }
        case yr.PROVIDED_CALLBACK: {
          this.setIsLoading(!0);
          const t = this.providedValues, { columnApi: i, api: r, context: n, column: s, colDef: a } = this.filterParams, l = {
            success: (c) => {
              this.setIsLoading(!1), e(this.processAllKeys(!1, c));
            },
            colDef: a,
            column: s,
            columnApi: i,
            api: r,
            context: n
          };
          window.setTimeout(() => t(l), 0);
          break;
        }
        default:
          throw new Error("Unrecognised valuesType");
      }
    }), this.allValuesPromise.then((e) => this.updateAvailableKeys(e || [], "reload")).then(() => this.initialised = !0), this.allValuesPromise;
  }
  processAllKeys(e, t) {
    const i = e ? this.getValuesFromRows(!1) : this.uniqueValues(this.validateProvidedValues(t)), r = this.sortKeys(i);
    return this.allValues = i != null ? i : /* @__PURE__ */ new Map(), r;
  }
  validateProvidedValues(e) {
    if (this.usingComplexObjects && (e != null && e.length)) {
      const t = e[0];
      t && typeof t != "object" && typeof t != "function" && (this.createKey(t) == null ? x.doOnce(() => console.warn("Set Filter Key Creator is returning null for provided values and provided values are primitives. Please provide complex objects or set convertValuesToStrings=true in the filterParams. See https://www.ag-grid.com/javascript-data-grid/filter-set-filter-list/#filter-value-types"), "setFilterComplexObjectsProvidedNull") : x.doOnce(() => console.warn("AG Grid: Set Filter has a Key Creator, but provided values are primitives. Did you mean to provide complex objects or enable convertValuesToStrings?"), "setFilterComplexObjectsProvidedPrimitive"));
    }
    return e;
  }
  setValuesType(e) {
    this.valuesType = e;
  }
  getValuesType() {
    return this.valuesType;
  }
  isKeyAvailable(e) {
    return this.availableKeys.has(e);
  }
  showAvailableOnly() {
    return this.valuesType === yr.TAKEN_FROM_GRID_VALUES;
  }
  updateAvailableKeys(e, t) {
    const i = this.showAvailableOnly() ? this.sortKeys(this.getValuesFromRows(!0)) : e;
    this.availableKeys = new Set(i), this.localEventService.dispatchEvent({ type: Gf.EVENT_AVAILABLE_VALUES_CHANGED }), this.updateDisplayedValues(t, e);
  }
  sortKeys(e) {
    const t = e != null ? e : /* @__PURE__ */ new Map();
    if (this.suppressSorting)
      return Array.from(t.keys());
    let i;
    return this.compareByValue ? i = Array.from(t.entries()).sort(this.entryComparator).map(([r]) => r) : i = Array.from(t.keys()).sort(this.keyComparator), this.filterParams.excelMode && t.has(null) && (i = i.filter((r) => r != null), i.push(null)), i;
  }
  getValuesFromRows(e = !1) {
    if (!this.clientSideValuesExtractor)
      return console.error("AG Grid: Set Filter cannot initialise because you are using a row model that does not contain all rows in the browser. Either use a different filter type, or configure Set Filter such that you provide it with values"), null;
    const t = (i) => !e || this.doesRowPassOtherFilters(i);
    return this.clientSideValuesExtractor.extractUniqueValues(t, e && !this.caseSensitive ? this.allValues : void 0);
  }
  /** Sets mini filter value. Returns true if it changed from last value, otherwise false. */
  setMiniFilter(e) {
    return e = x.makeNull(e), this.miniFilterText === e ? !1 : (this.miniFilterText = e, this.updateDisplayedValues("miniFilter"), !0);
  }
  getMiniFilter() {
    return this.miniFilterText;
  }
  updateDisplayedValues(e, t) {
    if (e === "expansion") {
      this.displayValueModel.refresh();
      return;
    }
    if (this.miniFilterText == null) {
      this.displayValueModel.updateDisplayedValuesToAllAvailable((s) => this.getValue(s), t, this.availableKeys, e);
      return;
    }
    const i = this.caseFormat(this.formatter(this.miniFilterText) || ""), r = (s) => s != null && this.caseFormat(s).indexOf(i) >= 0, n = !!this.filterParams.excelMode && r(this.translate("blanks"));
    this.displayValueModel.updateDisplayedValuesToMatchMiniFilter((s) => this.getValue(s), t, this.availableKeys, r, n, e);
  }
  getDisplayedValueCount() {
    return this.displayValueModel.getDisplayedValueCount();
  }
  getDisplayedItem(e) {
    return this.displayValueModel.getDisplayedItem(e);
  }
  getSelectAllItem() {
    return this.displayValueModel.getSelectAllItem();
  }
  hasSelections() {
    return this.filterParams.defaultToNothingSelected ? this.selectedKeys.size > 0 : this.allValues.size !== this.selectedKeys.size;
  }
  getKeys() {
    return Array.from(this.allValues.keys());
  }
  getValues() {
    return Array.from(this.allValues.values());
  }
  getValue(e) {
    return this.allValues.get(e);
  }
  selectAllMatchingMiniFilter(e = !1) {
    this.miniFilterText == null ? this.selectedKeys = new Set(this.allValues.keys()) : (e && this.selectedKeys.clear(), this.displayValueModel.forEachDisplayedKey((t) => this.selectedKeys.add(t)));
  }
  deselectAllMatchingMiniFilter() {
    this.miniFilterText == null ? this.selectedKeys.clear() : this.displayValueModel.forEachDisplayedKey((e) => this.selectedKeys.delete(e));
  }
  selectKey(e) {
    this.selectedKeys.add(e);
  }
  deselectKey(e) {
    this.filterParams.excelMode && this.isEverythingVisibleSelected() && this.resetSelectionState(this.displayValueModel.getDisplayedKeys()), this.selectedKeys.delete(e);
  }
  isKeySelected(e) {
    return this.selectedKeys.has(e);
  }
  isEverythingVisibleSelected() {
    return !this.displayValueModel.someDisplayedKey((e) => !this.isKeySelected(e));
  }
  isNothingVisibleSelected() {
    return !this.displayValueModel.someDisplayedKey((e) => this.isKeySelected(e));
  }
  getModel() {
    return this.hasSelections() ? Array.from(this.selectedKeys) : null;
  }
  setModel(e) {
    return this.allValuesPromise.then((t) => {
      if (e == null)
        this.resetSelectionState(t != null ? t : []);
      else {
        this.selectedKeys.clear();
        const i = /* @__PURE__ */ new Map();
        this.allValues.forEach((r, n) => {
          i.set(this.caseFormat(n), n);
        }), e.forEach((r) => {
          const n = this.caseFormat(r), s = i.get(n);
          s !== void 0 && this.selectKey(s);
        });
      }
    });
  }
  uniqueValues(e) {
    const t = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set();
    return (e != null ? e : []).forEach((r) => {
      const n = x.makeNull(r), s = this.convertAndGetKey(n), a = this.caseFormat(s);
      i.has(a) || (i.add(a), t.set(s, n));
    }), t;
  }
  convertAndGetKey(e) {
    return this.convertValuesToStrings ? e : this.createKey(e);
  }
  resetSelectionState(e) {
    this.filterParams.defaultToNothingSelected ? this.selectedKeys.clear() : this.selectedKeys = new Set(e);
  }
  hasGroups() {
    return this.displayValueModel.hasGroups();
  }
  createTreeDataOrGroupingComparator() {
    return ([e, t], [i, r]) => {
      if (t == null)
        return r == null ? 0 : -1;
      if (r == null)
        return 1;
      for (let n = 0; n < t.length; n++) {
        if (n >= r.length)
          return 1;
        const s = x.defaultComparator(t[n], r[n]);
        if (s !== 0)
          return s;
      }
      return 0;
    };
  }
}
Gf.EVENT_AVAILABLE_VALUES_CHANGED = "availableValuesChanged";
var Pc = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Jt extends X {
  constructor(e) {
    var t;
    super(e.isGroup ? Jt.GROUP_TEMPLATE : Jt.TEMPLATE), this.focusWrapper = e.focusWrapper, this.value = e.value, this.params = e.params, this.translate = e.translate, this.valueFormatter = e.valueFormatter, this.item = e.item, this.isSelected = e.isSelected, this.isTree = e.isTree, this.depth = (t = e.depth) !== null && t !== void 0 ? t : 0, this.isGroup = e.isGroup, this.groupsExist = e.groupsExist, this.isExpanded = e.isExpanded, this.hasIndeterminateExpandState = e.hasIndeterminateExpandState;
  }
  init() {
    this.addDestroyFunc(() => {
      var e;
      return (e = this.destroyCellRendererComponent) === null || e === void 0 ? void 0 : e.call(this);
    }), this.render(), this.eCheckbox.setLabelEllipsis(!0), this.eCheckbox.setValue(this.isSelected, !0), this.eCheckbox.setDisabled(!!this.params.readOnly), this.eCheckbox.getInputElement().setAttribute("tabindex", "-1"), this.refreshVariableAriaLabels(), this.isTree && (this.depth > 0 && this.addCssClass("ag-set-filter-indent-" + this.depth), this.isGroup ? this.setupExpansion() : this.groupsExist && this.addCssClass("ag-set-filter-add-group-indent"), x.setAriaLevel(this.focusWrapper, this.depth + 1)), !this.params.readOnly && this.eCheckbox.onValueChange((e) => this.onCheckboxChanged(!!e));
  }
  setupExpansion() {
    this.eGroupClosedIcon.appendChild(x.createIcon("setFilterGroupClosed", this.gridOptionsService, null)), this.eGroupOpenedIcon.appendChild(x.createIcon("setFilterGroupOpen", this.gridOptionsService, null)), this.addManagedListener(this.eGroupClosedIcon, "click", this.onExpandOrContractClicked.bind(this)), this.addManagedListener(this.eGroupOpenedIcon, "click", this.onExpandOrContractClicked.bind(this)), this.hasIndeterminateExpandState && (this.eGroupIndeterminateIcon.appendChild(x.createIcon("setFilterGroupIndeterminate", this.gridOptionsService, null)), this.addManagedListener(this.eGroupIndeterminateIcon, "click", this.onExpandOrContractClicked.bind(this))), this.setExpandedIcons(), this.refreshAriaExpanded();
  }
  onExpandOrContractClicked() {
    this.setExpanded(!this.isExpanded);
  }
  setExpanded(e, t) {
    if (this.isGroup && e !== this.isExpanded) {
      this.isExpanded = e;
      const i = {
        type: Jt.EVENT_EXPANDED_CHANGED,
        isExpanded: !!e,
        item: this.item
      };
      t || this.dispatchEvent(i), this.setExpandedIcons(), this.refreshAriaExpanded();
    }
  }
  refreshAriaExpanded() {
    x.setAriaExpanded(this.focusWrapper, !!this.isExpanded);
  }
  setExpandedIcons() {
    x.setDisplayed(this.eGroupClosedIcon, this.hasIndeterminateExpandState ? this.isExpanded === !1 : !this.isExpanded), x.setDisplayed(this.eGroupOpenedIcon, this.isExpanded === !0), this.hasIndeterminateExpandState && x.setDisplayed(this.eGroupIndeterminateIcon, this.isExpanded === void 0);
  }
  onCheckboxChanged(e) {
    this.isSelected = e;
    const t = {
      type: Jt.EVENT_SELECTION_CHANGED,
      isSelected: e,
      item: this.item
    };
    this.dispatchEvent(t), this.refreshVariableAriaLabels();
  }
  toggleSelected() {
    this.params.readOnly || this.setSelected(!this.isSelected);
  }
  setSelected(e, t) {
    this.isSelected = e, this.eCheckbox.setValue(this.isSelected, t);
  }
  refreshVariableAriaLabels() {
    if (!this.isTree)
      return;
    const e = this.localeService.getLocaleTextFunc(), t = this.eCheckbox.getValue(), i = t === void 0 ? e("ariaIndeterminate", "indeterminate") : t ? e("ariaVisible", "visible") : e("ariaHidden", "hidden"), r = e("ariaToggleVisibility", "Press SPACE to toggle visibility");
    x.setAriaLabelledBy(this.eCheckbox.getInputElement(), void 0), this.eCheckbox.setInputAriaLabel(`${r} (${i})`);
  }
  setupFixedAriaLabels(e) {
    if (!this.isTree)
      return;
    const i = this.localeService.getLocaleTextFunc()("ariaFilterValue", "Filter Value");
    x.setAriaLabel(this.focusWrapper, `${e} ${i}`), x.setAriaDescribedBy(this.focusWrapper, this.eCheckbox.getInputElement().id);
  }
  refresh(e, t, i) {
    var r, n;
    if (this.item = e, t !== this.isSelected && this.setSelected(t, !0), this.setExpanded(i, !0), this.valueFunction) {
      const s = this.valueFunction();
      this.setTooltipAndCellRendererParams(s, s), this.cellRendererComponent || this.renderCellWithoutCellRenderer();
    }
    if (this.cellRendererComponent && !((n = (r = this.cellRendererComponent).refresh) === null || n === void 0 ? void 0 : n.call(r, this.cellRendererParams))) {
      const a = this.cellRendererComponent;
      this.renderCell(), this.destroyBean(a);
    }
  }
  render() {
    const { params: { column: e } } = this;
    let { value: t } = this, i = null;
    typeof t == "function" ? (this.valueFunction = t, i = this.valueFunction(), t = i) : this.isTree ? i = x.toStringOrNull(t) : i = this.getFormattedValue(e, t), this.setTooltipAndCellRendererParams(t, i), this.renderCell();
  }
  setTooltipAndCellRendererParams(e, t) {
    if (this.params.showTooltips) {
      const i = t != null ? t : x.toStringOrNull(e);
      this.setTooltip(i);
    }
    this.cellRendererParams = {
      value: e,
      valueFormatted: t,
      api: this.gridOptionsService.api,
      columnApi: this.gridOptionsService.columnApi,
      context: this.gridOptionsService.context,
      colDef: this.params.colDef,
      column: this.params.column
    };
  }
  getTooltipParams() {
    const e = super.getTooltipParams();
    return e.location = "setFilterValue", e.colDef = this.getComponentHolder(), this.isTree && (e.level = this.depth), e;
  }
  getFormattedValue(e, t) {
    return this.valueFormatterService.formatValue(e, null, t, this.valueFormatter, !1);
  }
  renderCell() {
    const e = this.userComponentFactory.getSetFilterCellRendererDetails(this.params, this.cellRendererParams), t = e ? e.newAgStackInstance() : void 0;
    if (t == null) {
      this.renderCellWithoutCellRenderer();
      return;
    }
    t.then((i) => {
      i && (this.cellRendererComponent = i, this.eCheckbox.setLabel(i.getGui()), this.destroyCellRendererComponent = () => this.destroyBean(i));
    });
  }
  renderCellWithoutCellRenderer() {
    var e;
    let t = (e = this.cellRendererParams.valueFormatted == null ? this.cellRendererParams.value : this.cellRendererParams.valueFormatted) !== null && e !== void 0 ? e : this.translate("blanks");
    typeof t != "string" && (x.doOnce(() => console.warn("AG Grid: Set Filter Value Formatter must return string values. Please ensure the Set Filter Value Formatter returns string values for complex objects, or set convertValuesToStrings=true in the filterParams. See https://www.ag-grid.com/javascript-data-grid/filter-set-filter-list/#filter-value-types"), "setFilterComplexObjectsValueFormatter"), t = ""), this.eCheckbox.setLabel(t), this.setupFixedAriaLabels(t);
  }
  getComponentHolder() {
    return this.params.column.getColDef();
  }
}
Jt.EVENT_SELECTION_CHANGED = "selectionChanged";
Jt.EVENT_EXPANDED_CHANGED = "expandedChanged";
Jt.GROUP_TEMPLATE = `
        <div class="ag-set-filter-item" aria-hidden="true">
            <span class="ag-set-filter-group-icons">
                <span class="ag-set-filter-group-closed-icon" ref="eGroupClosedIcon"></span>
                <span class="ag-set-filter-group-opened-icon" ref="eGroupOpenedIcon"></span>
                <span class="ag-set-filter-group-indeterminate-icon" ref="eGroupIndeterminateIcon"></span>
            </span>
            <ag-checkbox ref="eCheckbox" class="ag-set-filter-item-checkbox"></ag-checkbox>
        </div>`;
Jt.TEMPLATE = `
        <div class="ag-set-filter-item">
            <ag-checkbox ref="eCheckbox" class="ag-set-filter-item-checkbox"></ag-checkbox>
        </div>`;
Pc([
  S("valueFormatterService")
], Jt.prototype, "valueFormatterService", void 0);
Pc([
  S("userComponentFactory")
], Jt.prototype, "userComponentFactory", void 0);
Pc([
  L("eCheckbox")
], Jt.prototype, "eCheckbox", void 0);
Pc([
  L("eGroupOpenedIcon")
], Jt.prototype, "eGroupOpenedIcon", void 0);
Pc([
  L("eGroupClosedIcon")
], Jt.prototype, "eGroupClosedIcon", void 0);
Pc([
  L("eGroupIndeterminateIcon")
], Jt.prototype, "eGroupIndeterminateIcon", void 0);
Pc([
  B
], Jt.prototype, "init", null);
const a2 = {
  loadingOoo: "Loading...",
  blanks: "(Blanks)",
  searchOoo: "Search...",
  selectAll: "(Select All)",
  selectAllSearchResults: "(Select All Search Results)",
  noMatches: "No matches."
};
class vP {
  getModelAsString(e, t) {
    const { values: i } = e || t.getModel() || {}, r = t.getValueModel();
    if (i == null || r == null)
      return "";
    const n = i.filter((l) => r.isKeyAvailable(l)), s = n.length, a = n.slice(0, 10).map((l) => t.getFormattedValue(l));
    return `(${s}) ${a.join(",")}${s > 10 ? ",..." : ""}`;
  }
}
var Ac = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Us extends Pr {
  constructor() {
    super("setFilter"), this.valueModel = null, this.setFilterParams = null, this.virtualList = null, this.caseSensitive = !1, this.convertValuesToStrings = !1, this.treeDataTreeList = !1, this.groupingTreeList = !1, this.hardRefreshVirtualList = !1, this.noValueFormatterSupplied = !1, this.appliedModelKeys = null, this.noAppliedModelKeys = !1, this.filterModelFormatter = new vP();
  }
  postConstruct() {
    super.postConstruct();
  }
  // unlike the simple filters, nothing in the set filter UI shows/hides.
  // maybe this method belongs in abstractSimpleFilter???
  updateUiVisibility() {
  }
  createBodyTemplate() {
    return (
      /* html */
      `
            <div class="ag-set-filter">
                <div ref="eFilterLoading" class="ag-filter-loading ag-hidden">${this.translateForSetFilter("loadingOoo")}</div>
                <ag-input-text-field class="ag-mini-filter" ref="eMiniFilter"></ag-input-text-field>
                <div ref="eFilterNoMatches" class="ag-filter-no-matches ag-hidden">${this.translateForSetFilter("noMatches")}</div>
                <div ref="eSetFilterList" class="ag-set-filter-list" role="presentation"></div>
            </div>`
    );
  }
  handleKeyDown(e) {
    if (super.handleKeyDown(e), !e.defaultPrevented)
      switch (e.key) {
        case V.SPACE:
          this.handleKeySpace(e);
          break;
        case V.ENTER:
          this.handleKeyEnter(e);
          break;
        case V.LEFT:
          this.handleKeyLeft(e);
          break;
        case V.RIGHT:
          this.handleKeyRight(e);
          break;
      }
  }
  handleKeySpace(e) {
    var t;
    (t = this.getComponentForKeyEvent(e)) === null || t === void 0 || t.toggleSelected();
  }
  handleKeyEnter(e) {
    if (!this.setFilterParams)
      return;
    const { excelMode: t, readOnly: i } = this.setFilterParams || {};
    !t || i || (e.preventDefault(), this.onBtApply(!1, !1, e), this.setFilterParams.excelMode === "mac" && this.eMiniFilter.getInputElement().select());
  }
  handleKeyLeft(e) {
    var t;
    (t = this.getComponentForKeyEvent(e)) === null || t === void 0 || t.setExpanded(!1);
  }
  handleKeyRight(e) {
    var t;
    (t = this.getComponentForKeyEvent(e)) === null || t === void 0 || t.setExpanded(!0);
  }
  getComponentForKeyEvent(e) {
    var t;
    const i = this.gridOptionsService.getDocument();
    if (!this.eSetFilterList.contains(i.activeElement) || !this.virtualList)
      return;
    const r = this.virtualList.getLastFocusedRow();
    if (r == null)
      return;
    const n = this.virtualList.getComponentAt(r);
    if (n == null)
      return;
    e.preventDefault();
    const { readOnly: s } = (t = this.setFilterParams) !== null && t !== void 0 ? t : {};
    if (!s)
      return n;
  }
  getCssIdentifier() {
    return "set-filter";
  }
  setModel(e) {
    var t;
    return e == null && ((t = this.valueModel) === null || t === void 0 ? void 0 : t.getModel()) == null ? (this.setMiniFilter(null), Qe.resolve()) : super.setModel(e);
  }
  setModelAndRefresh(e) {
    return this.valueModel ? this.valueModel.setModel(e).then(() => this.refresh()) : Qe.resolve();
  }
  resetUiToDefaults() {
    return this.setMiniFilter(null), this.setModelAndRefresh(null);
  }
  setModelIntoUi(e) {
    this.setMiniFilter(null);
    const t = e == null ? null : e.values;
    return this.setModelAndRefresh(t);
  }
  getModelFromUi() {
    if (!this.valueModel)
      throw new Error("Value model has not been created.");
    const e = this.valueModel.getModel();
    return e ? { values: e, filterType: this.getFilterType() } : null;
  }
  getFilterType() {
    return "set";
  }
  getValueModel() {
    return this.valueModel;
  }
  areModelsEqual(e, t) {
    return e == null && t == null ? !0 : e != null && t != null && x.areEqual(e.values, t.values);
  }
  setParams(e) {
    var t;
    this.applyExcelModeOptions(e), super.setParams(e), this.setFilterParams = e, this.convertValuesToStrings = !!e.convertValuesToStrings, this.caseSensitive = !!e.caseSensitive;
    let i = (t = e.keyCreator) !== null && t !== void 0 ? t : e.colDef.keyCreator;
    this.setValueFormatter(e.valueFormatter, i, this.convertValuesToStrings, !!e.treeList, !!e.colDef.refData);
    const r = e.column.getId().startsWith(bs);
    this.treeDataTreeList = this.gridOptionsService.is("treeData") && !!e.treeList && r, this.getDataPath = this.gridOptionsService.get("getDataPath"), this.groupingTreeList = !!this.columnModel.getRowGroupColumns().length && !!e.treeList && r, this.createKey = this.generateCreateKey(i, this.convertValuesToStrings, this.treeDataTreeList || this.groupingTreeList), this.valueModel = new Gf({
      filterParams: e,
      setIsLoading: (n) => this.setIsLoading(n),
      valueFormatterService: this.valueFormatterService,
      translate: (n) => this.translateForSetFilter(n),
      caseFormat: (n) => this.caseFormat(n),
      createKey: this.createKey,
      valueFormatter: this.valueFormatter,
      usingComplexObjects: !!i,
      gridOptionsService: this.gridOptionsService,
      columnModel: this.columnModel,
      valueService: this.valueService,
      treeDataTreeList: this.treeDataTreeList,
      groupingTreeList: this.groupingTreeList
    }), this.initialiseFilterBodyUi(), this.addEventListenersForDataChanges();
  }
  setValueFormatter(e, t, i, r, n) {
    let s = e;
    if (!s) {
      if (t && !i && !r)
        throw new Error("AG Grid: Must supply a Value Formatter in Set Filter params when using a Key Creator unless convertValuesToStrings is enabled");
      this.noValueFormatterSupplied = !0, n || (s = (a) => x.toStringOrNull(a.value));
    }
    this.valueFormatter = s;
  }
  generateCreateKey(e, t, i) {
    if (i && !e)
      throw new Error("AG Grid: Must supply a Key Creator in Set Filter params when `treeList = true` on a group column, and Tree Data or Row Grouping is enabled.");
    return e ? (r, n = null) => {
      const s = this.getKeyCreatorParams(r, n);
      return x.makeNull(e(s));
    } : t ? (r) => Array.isArray(r) ? r : x.makeNull(x.toStringOrNull(r)) : (r) => x.makeNull(x.toStringOrNull(r));
  }
  getFormattedValue(e) {
    var t;
    let i = this.valueModel.getValue(e);
    this.noValueFormatterSupplied && (this.treeDataTreeList || this.groupingTreeList) && Array.isArray(i) && (i = x.last(i));
    const r = this.valueFormatterService.formatValue(this.setFilterParams.column, null, i, this.valueFormatter, !1);
    return (t = r == null ? x.toStringOrNull(i) : r) !== null && t !== void 0 ? t : this.translateForSetFilter("blanks");
  }
  applyExcelModeOptions(e) {
    e.excelMode === "windows" ? (e.buttons || (e.buttons = ["apply", "cancel"]), e.closeOnApply == null && (e.closeOnApply = !0)) : e.excelMode === "mac" && (e.buttons || (e.buttons = ["reset"]), e.applyMiniFilterWhileTyping == null && (e.applyMiniFilterWhileTyping = !0), e.debounceMs == null && (e.debounceMs = 500)), e.excelMode && e.defaultToNothingSelected && (e.defaultToNothingSelected = !1, x.doOnce(() => console.warn('AG Grid: The Set Filter Parameter "defaultToNothingSelected" value was ignored because it does not work when "excelMode" is used.'), "setFilterExcelModeDefaultToNothingSelect"));
  }
  addEventListenersForDataChanges() {
    this.isValuesTakenFromGrid() && this.addManagedListener(this.eventService, w.EVENT_CELL_VALUE_CHANGED, (e) => {
      this.setFilterParams && e.column === this.setFilterParams.column && this.syncAfterDataChange();
    });
  }
  syncAfterDataChange() {
    if (!this.valueModel)
      throw new Error("Value model has not been created.");
    return this.valueModel.refreshValues().then(() => {
      this.refresh(), this.onBtApply(!1, !0);
    });
  }
  setIsLoading(e) {
    x.setDisplayed(this.eFilterLoading, e), e || (this.hardRefreshVirtualList = !0);
  }
  initialiseFilterBodyUi() {
    this.initVirtualList(), this.initMiniFilter();
  }
  initVirtualList() {
    if (!this.setFilterParams)
      throw new Error("Set filter params have not been provided.");
    if (!this.valueModel)
      throw new Error("Value model has not been created.");
    const t = this.localeService.getLocaleTextFunc()("ariaFilterList", "Filter List"), i = !!this.setFilterParams.treeList, r = this.virtualList = this.createBean(new Ls("filter", i ? "tree" : "listbox", t)), n = this.getRefElement("eSetFilterList");
    i && n.classList.add("ag-set-filter-tree-list"), n && n.appendChild(r.getGui());
    const { cellHeight: s } = this.setFilterParams;
    s != null && r.setRowHeight(s);
    const a = (d, u) => this.createSetListItem(d, i, u);
    r.setComponentCreator(a);
    const l = (d, u) => this.updateSetListItem(d, u);
    r.setComponentUpdater(l);
    let c;
    this.setFilterParams.suppressSelectAll ? c = new l2(this.valueModel) : c = new c2(this.valueModel, () => this.isSelectAllSelected()), i && (c = new d2(c)), r.setModel(c);
  }
  getSelectAllLabel() {
    if (!this.setFilterParams)
      throw new Error("Set filter params have not been provided.");
    if (!this.valueModel)
      throw new Error("Value model has not been created.");
    const e = this.valueModel.getMiniFilter() == null || !this.setFilterParams.excelMode ? "selectAll" : "selectAllSearchResults";
    return this.translateForSetFilter(e);
  }
  createSetListItem(e, t, i) {
    var r, n, s, a, l, c;
    if (!this.setFilterParams)
      throw new Error("Set filter params have not been provided.");
    if (!this.valueModel)
      throw new Error("Value model has not been created.");
    const d = this.valueModel.hasGroups();
    let u, h, p, f, g, v;
    this.isSetFilterModelTreeItem(e) ? (h = e.depth, e.key === la.SELECT_ALL ? (u = () => this.getSelectAllLabel(), p = d, f = !0, g = (E) => this.onSelectAll(E.isSelected), v = (E) => this.onExpandAll(E.item, E.isExpanded)) : e.children ? (u = (s = (n = (r = this.setFilterParams).treeListFormatter) === null || n === void 0 ? void 0 : n.call(r, e.treeKey, e.depth, e.parentTreeKeys)) !== null && s !== void 0 ? s : e.treeKey, p = !0, g = (E) => this.onGroupItemSelected(E.item, E.isSelected), v = (E) => this.onExpandedChanged(E.item, E.isExpanded)) : (u = (c = (l = (a = this.setFilterParams).treeListFormatter) === null || l === void 0 ? void 0 : l.call(a, e.treeKey, e.depth, e.parentTreeKeys)) !== null && c !== void 0 ? c : e.treeKey, g = (E) => this.onItemSelected(E.item.key, E.isSelected))) : e === la.SELECT_ALL ? (u = () => this.getSelectAllLabel(), g = (E) => this.onSelectAll(E.isSelected)) : (u = this.valueModel.getValue(e), g = (E) => this.onItemSelected(E.item, E.isSelected));
    const { isSelected: y, isExpanded: m } = this.isSelectedExpanded(e), C = {
      focusWrapper: i,
      value: u,
      params: this.setFilterParams,
      translate: (E) => this.translateForSetFilter(E),
      valueFormatter: this.valueFormatter,
      item: e,
      isSelected: y,
      isTree: t,
      depth: h,
      groupsExist: d,
      isGroup: p,
      isExpanded: m,
      hasIndeterminateExpandState: f
    }, R = this.createBean(new Jt(C));
    return R.addEventListener(Jt.EVENT_SELECTION_CHANGED, g), v && R.addEventListener(Jt.EVENT_EXPANDED_CHANGED, v), R;
  }
  updateSetListItem(e, t) {
    const { isSelected: i, isExpanded: r } = this.isSelectedExpanded(e);
    t.refresh(e, i, r);
  }
  isSelectedExpanded(e) {
    let t, i;
    return this.isSetFilterModelTreeItem(e) ? (i = e.expanded, e.key === la.SELECT_ALL ? t = this.isSelectAllSelected() : e.children ? t = this.areAllChildrenSelected(e) : t = this.valueModel.isKeySelected(e.key)) : e === la.SELECT_ALL ? t = this.isSelectAllSelected() : t = this.valueModel.isKeySelected(e), { isSelected: t, isExpanded: i };
  }
  isSetFilterModelTreeItem(e) {
    return (e == null ? void 0 : e.treeKey) !== void 0;
  }
  initMiniFilter() {
    if (!this.setFilterParams)
      throw new Error("Set filter params have not been provided.");
    if (!this.valueModel)
      throw new Error("Value model has not been created.");
    const { eMiniFilter: e, localeService: t } = this, i = t.getLocaleTextFunc();
    e.setDisplayed(!this.setFilterParams.suppressMiniFilter), e.setValue(this.valueModel.getMiniFilter()), e.onValueChange(() => this.onMiniFilterInput()), e.setInputAriaLabel(i("ariaSearchFilterValues", "Search filter values")), this.addManagedListener(e.getInputElement(), "keydown", (r) => this.onMiniFilterKeyDown(r));
  }
  // we need to have the GUI attached before we can draw the virtual rows, as the
  // virtual row logic needs info about the GUI state
  afterGuiAttached(e) {
    if (!this.setFilterParams)
      throw new Error("Set filter params have not been provided.");
    super.afterGuiAttached(e), this.resetExpansion(), this.refreshVirtualList();
    const { eMiniFilter: t } = this;
    t.setInputPlaceholder(this.translateForSetFilter("searchOoo")), (!e || !e.suppressFocus) && t.getFocusableElement().focus();
  }
  afterGuiDetached() {
    var e, t;
    super.afterGuiDetached(), !((e = this.setFilterParams) === null || e === void 0) && e.excelMode && this.resetMiniFilter();
    const i = this.getModel();
    (!((t = this.setFilterParams) === null || t === void 0) && t.excelMode || !this.areModelsEqual(i, this.getModelFromUi())) && (this.resetUiToActiveModel(i), this.showOrHideResults());
  }
  applyModel(e = "api") {
    if (!this.setFilterParams)
      throw new Error("Set filter params have not been provided.");
    if (!this.valueModel)
      throw new Error("Value model has not been created.");
    this.setFilterParams.excelMode && e !== "rowDataUpdated" && this.valueModel.isEverythingVisibleSelected() && this.valueModel.selectAllMatchingMiniFilter();
    const t = super.applyModel(e), i = this.getModel();
    return i ? (this.appliedModelKeys = /* @__PURE__ */ new Set(), i.values.forEach((r) => {
      this.appliedModelKeys.add(this.caseFormat(r));
    })) : this.appliedModelKeys = null, this.noAppliedModelKeys = (i == null ? void 0 : i.values.length) === 0, t;
  }
  isModelValid(e) {
    return this.setFilterParams && this.setFilterParams.excelMode ? e == null || e.values.length > 0 : !0;
  }
  doesFilterPass(e) {
    if (!this.setFilterParams || !this.valueModel || !this.appliedModelKeys)
      return !0;
    if (this.noAppliedModelKeys)
      return !1;
    const { node: t, data: i } = e;
    if (this.treeDataTreeList)
      return this.doesFilterPassForTreeData(t, i);
    if (this.groupingTreeList)
      return this.doesFilterPassForGrouping(t, i);
    let r = this.getValueFromNode(t, i);
    return this.convertValuesToStrings ? this.doesFilterPassForConvertValuesToString(t, r) : r != null && Array.isArray(r) ? r.length === 0 ? this.appliedModelKeys.has(null) : r.some((n) => this.isInAppliedModel(this.createKey(n, t))) : this.isInAppliedModel(this.createKey(r, t));
  }
  doesFilterPassForConvertValuesToString(e, t) {
    const i = this.createKey(t, e);
    return i != null && Array.isArray(i) ? i.length === 0 ? this.appliedModelKeys.has(null) : i.some((r) => this.isInAppliedModel(r)) : this.isInAppliedModel(i);
  }
  doesFilterPassForTreeData(e, t) {
    var i;
    return !((i = e.childrenAfterGroup) === null || i === void 0) && i.length ? !1 : this.isInAppliedModel(this.createKey(this.checkMakeNullDataPath(this.getDataPath(t))));
  }
  doesFilterPassForGrouping(e, t) {
    const i = this.columnModel.getRowGroupColumns().map((r) => this.valueService.getKeyForNode(r, e));
    return i.push(this.getValueFromNode(e, t)), this.isInAppliedModel(this.createKey(this.checkMakeNullDataPath(i)));
  }
  checkMakeNullDataPath(e) {
    return e && (e = e.map((t) => x.toStringOrNull(x.makeNull(t)))), e != null && e.some((t) => t == null) ? null : e;
  }
  isInAppliedModel(e) {
    return this.appliedModelKeys.has(this.caseFormat(e));
  }
  getValueFromNode(e, t) {
    const { valueGetter: i, api: r, colDef: n, column: s, columnApi: a, context: l } = this.setFilterParams;
    return i({
      api: r,
      colDef: n,
      column: s,
      columnApi: a,
      context: l,
      data: t,
      getValue: (c) => t[c],
      node: e
    });
  }
  getKeyCreatorParams(e, t = null) {
    return {
      value: e,
      colDef: this.setFilterParams.colDef,
      column: this.setFilterParams.column,
      node: t,
      data: t == null ? void 0 : t.data,
      api: this.setFilterParams.api,
      columnApi: this.setFilterParams.columnApi,
      context: this.setFilterParams.context
    };
  }
  onNewRowsLoaded() {
    this.isValuesTakenFromGrid() && this.syncAfterDataChange();
  }
  isValuesTakenFromGrid() {
    return this.valueModel ? this.valueModel.getValuesType() === yr.TAKEN_FROM_GRID_VALUES : !1;
  }
  //noinspection JSUnusedGlobalSymbols
  /**
   * Public method provided so the user can change the value of the filter once
   * the filter has been already started
   * @param values The values to use.
   */
  setFilterValues(e) {
    if (!this.valueModel)
      throw new Error("Value model has not been created.");
    this.valueModel.overrideValues(e).then(() => {
      this.refresh(), this.onUiChanged();
    });
  }
  //noinspection JSUnusedGlobalSymbols
  /**
   * Public method provided so the user can reset the values of the filter once that it has started.
   */
  resetFilterValues() {
    if (!this.valueModel)
      throw new Error("Value model has not been created.");
    this.valueModel.setValuesType(yr.TAKEN_FROM_GRID_VALUES), this.syncAfterDataChange();
  }
  refreshFilterValues() {
    if (!this.valueModel)
      throw new Error("Value model has not been created.");
    this.valueModel.isInitialised() && this.valueModel.refreshValues().then(() => {
      this.refresh(), this.onUiChanged();
    });
  }
  onAnyFilterChanged() {
    setTimeout(() => {
      if (this.isAlive()) {
        if (!this.valueModel)
          throw new Error("Value model has not been created.");
        this.valueModel.refreshAfterAnyFilterChanged().then((e) => {
          e && (this.refresh(), this.showOrHideResults());
        });
      }
    }, 0);
  }
  onMiniFilterInput() {
    if (!this.setFilterParams)
      throw new Error("Set filter params have not been provided.");
    if (!this.valueModel)
      throw new Error("Value model has not been created.");
    if (!this.valueModel.setMiniFilter(this.eMiniFilter.getValue()))
      return;
    const { applyMiniFilterWhileTyping: e, readOnly: t } = this.setFilterParams || {};
    !t && e ? this.filterOnAllVisibleValues(!1) : this.updateUiAfterMiniFilterChange();
  }
  updateUiAfterMiniFilterChange() {
    if (!this.setFilterParams)
      throw new Error("Set filter params have not been provided.");
    if (!this.valueModel)
      throw new Error("Value model has not been created.");
    const { excelMode: e, readOnly: t } = this.setFilterParams || {};
    e == null || t ? this.refresh() : this.valueModel.getMiniFilter() == null ? this.resetUiToActiveModel(this.getModel()) : (this.valueModel.selectAllMatchingMiniFilter(!0), this.refresh(), this.onUiChanged()), this.showOrHideResults();
  }
  showOrHideResults() {
    if (!this.valueModel)
      throw new Error("Value model has not been created.");
    const e = this.valueModel.getMiniFilter() != null && this.valueModel.getDisplayedValueCount() < 1;
    x.setDisplayed(this.eNoMatches, e), x.setDisplayed(this.eSetFilterList, !e);
  }
  resetMiniFilter() {
    var e;
    this.eMiniFilter.setValue(null, !0), (e = this.valueModel) === null || e === void 0 || e.setMiniFilter(null);
  }
  resetUiToActiveModel(e, t) {
    this.setModelAndRefresh(e == null ? null : e.values).then(() => {
      this.onUiChanged(!1, "prevent"), t == null || t();
    });
  }
  handleCancelEnd(e) {
    this.setMiniFilter(null), super.handleCancelEnd(e);
  }
  onMiniFilterKeyDown(e) {
    const { excelMode: t, readOnly: i } = this.setFilterParams || {};
    e.key === V.ENTER && !t && !i && this.filterOnAllVisibleValues();
  }
  filterOnAllVisibleValues(e = !0) {
    const { readOnly: t } = this.setFilterParams || {};
    if (!this.valueModel)
      throw new Error("Value model has not been created.");
    if (t)
      throw new Error("Unable to filter in readOnly mode.");
    this.valueModel.selectAllMatchingMiniFilter(!0), this.refresh(), this.onUiChanged(!1, e ? "immediately" : "debounce"), this.showOrHideResults();
  }
  focusRowIfAlive(e) {
    e != null && window.setTimeout(() => {
      if (!this.virtualList)
        throw new Error("Virtual list has not been created.");
      this.isAlive() && this.virtualList.focusRow(e);
    }, 0);
  }
  onSelectAll(e) {
    if (!this.valueModel)
      throw new Error("Value model has not been created.");
    if (!this.virtualList)
      throw new Error("Virtual list has not been created.");
    e ? this.valueModel.selectAllMatchingMiniFilter() : this.valueModel.deselectAllMatchingMiniFilter(), this.refreshAfterSelection();
  }
  onGroupItemSelected(e, t) {
    const i = (r) => {
      r.children ? r.children.forEach((n) => i(n)) : this.selectItem(r.key, t);
    };
    i(e), this.refreshAfterSelection();
  }
  onItemSelected(e, t) {
    if (!this.valueModel)
      throw new Error("Value model has not been created.");
    if (!this.virtualList)
      throw new Error("Virtual list has not been created.");
    this.selectItem(e, t), this.refreshAfterSelection();
  }
  selectItem(e, t) {
    t ? this.valueModel.selectKey(e) : this.valueModel.deselectKey(e);
  }
  onExpandAll(e, t) {
    const i = (r) => {
      r.filterPasses && r.available && r.children && (r.children.forEach((n) => i(n)), r.expanded = t);
    };
    i(e), this.refreshAfterExpansion();
  }
  onExpandedChanged(e, t) {
    e.expanded = t, this.refreshAfterExpansion();
  }
  refreshAfterExpansion() {
    const e = this.virtualList.getLastFocusedRow();
    this.valueModel.updateDisplayedValues("expansion"), this.refresh(), this.focusRowIfAlive(e);
  }
  refreshAfterSelection() {
    const e = this.virtualList.getLastFocusedRow();
    this.refresh(), this.onUiChanged(), this.focusRowIfAlive(e);
  }
  setMiniFilter(e) {
    this.eMiniFilter.setValue(e), this.onMiniFilterInput();
  }
  getMiniFilter() {
    return this.valueModel ? this.valueModel.getMiniFilter() : null;
  }
  refresh() {
    if (!this.virtualList)
      throw new Error("Virtual list has not been created.");
    this.virtualList.refresh(!this.hardRefreshVirtualList), this.hardRefreshVirtualList && (this.hardRefreshVirtualList = !1);
  }
  getFilterKeys() {
    return this.valueModel ? this.valueModel.getKeys() : [];
  }
  getFilterValues() {
    return this.valueModel ? this.valueModel.getValues() : [];
  }
  getValues() {
    return this.getFilterKeys();
  }
  refreshVirtualList() {
    this.setFilterParams && this.setFilterParams.refreshValuesOnOpen ? this.refreshFilterValues() : this.refresh();
  }
  translateForSetFilter(e) {
    return this.localeService.getLocaleTextFunc()(e, a2[e]);
  }
  isSelectAllSelected() {
    if (!this.setFilterParams || !this.valueModel)
      return !1;
    if (this.setFilterParams.defaultToNothingSelected) {
      if (this.valueModel.hasSelections() && this.valueModel.isEverythingVisibleSelected())
        return !0;
      if (this.valueModel.isNothingVisibleSelected())
        return !1;
    } else {
      if (this.valueModel.hasSelections() && this.valueModel.isNothingVisibleSelected())
        return !1;
      if (this.valueModel.isEverythingVisibleSelected())
        return !0;
    }
  }
  areAllChildrenSelected(e) {
    const t = (i) => {
      if (i.children) {
        let r = !1, n = !1;
        return i.children.some((a) => {
          if (!a.filterPasses || !a.available)
            return !1;
          const l = t(a);
          return l === void 0 ? !0 : (l ? r = !0 : n = !0, r && n);
        }) ? void 0 : r;
      } else
        return this.valueModel.isKeySelected(i.key);
    };
    return this.setFilterParams.defaultToNothingSelected ? this.valueModel.hasSelections() && t(e) : t(e);
  }
  destroy() {
    this.virtualList != null && (this.virtualList.destroy(), this.virtualList = null), super.destroy();
  }
  caseFormat(e) {
    return e == null || typeof e != "string" || this.caseSensitive ? e : e.toUpperCase();
  }
  resetExpansion() {
    var e, t;
    if (!(!((e = this.setFilterParams) === null || e === void 0) && e.treeList))
      return;
    const i = (t = this.valueModel) === null || t === void 0 ? void 0 : t.getSelectAllItem();
    if (this.isSetFilterModelTreeItem(i)) {
      const r = (n) => {
        n.children && (n.children.forEach((s) => r(s)), n.expanded = !1);
      };
      r(i), this.valueModel.updateDisplayedValues("expansion");
    }
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e, this);
  }
  getPositionableElement() {
    return this.eSetFilterList;
  }
}
Ac([
  L("eMiniFilter")
], Us.prototype, "eMiniFilter", void 0);
Ac([
  L("eFilterLoading")
], Us.prototype, "eFilterLoading", void 0);
Ac([
  L("eSetFilterList")
], Us.prototype, "eSetFilterList", void 0);
Ac([
  L("eFilterNoMatches")
], Us.prototype, "eNoMatches", void 0);
Ac([
  S("valueFormatterService")
], Us.prototype, "valueFormatterService", void 0);
Ac([
  S("columnModel")
], Us.prototype, "columnModel", void 0);
Ac([
  S("valueService")
], Us.prototype, "valueService", void 0);
class l2 {
  constructor(e) {
    this.model = e;
  }
  getRowCount() {
    return this.model.getDisplayedValueCount();
  }
  getRow(e) {
    return this.model.getDisplayedItem(e);
  }
  isRowSelected(e) {
    return this.model.isKeySelected(this.getRow(e));
  }
  areRowsEqual(e, t) {
    return e === t;
  }
}
class c2 {
  constructor(e, t) {
    this.model = e, this.isSelectAllSelected = t;
  }
  getRowCount() {
    return this.model.getDisplayedValueCount() + 1;
  }
  getRow(e) {
    return e === 0 ? this.model.getSelectAllItem() : this.model.getDisplayedItem(e - 1);
  }
  isRowSelected(e) {
    return e === 0 ? this.isSelectAllSelected() : this.model.isKeySelected(this.getRow(e));
  }
  areRowsEqual(e, t) {
    return e === t;
  }
}
class d2 {
  constructor(e) {
    this.model = e;
  }
  getRowCount() {
    return this.model.getRowCount();
  }
  getRow(e) {
    return this.model.getRow(e);
  }
  areRowsEqual(e, t) {
    return e == null && t == null ? !0 : e != null && t != null && e.treeKey === t.treeKey && e.depth === t.depth;
  }
}
var mP = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class _w extends X {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-floating-filter-input ag-set-floating-filter-input" role="presentation">
                <ag-input-text-field ref="eFloatingFilterText"></ag-input-text-field>
            </div>`
    ), this.availableValuesListenerAdded = !1, this.filterModelFormatter = new vP();
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    const t = this.columnModel.getDisplayNameForColumn(e.column, "header", !0), i = this.localeService.getLocaleTextFunc();
    this.eFloatingFilterText.setDisabled(!0).setInputAriaLabel(`${t} ${i("ariaFilterInput", "Filter Input")}`).addGuiEventListener("click", () => e.showParentFilter()), this.params = e;
  }
  onParentModelChanged(e) {
    this.updateFloatingFilterText(e);
  }
  parentSetFilterInstance(e) {
    this.params.parentFilterInstance((t) => {
      if (!(t instanceof Us))
        throw new Error("AG Grid - SetFloatingFilter expects SetFilter as its parent");
      e(t);
    });
  }
  addAvailableValuesListener() {
    this.parentSetFilterInstance((e) => {
      const t = e.getValueModel();
      t && this.addManagedListener(t, Gf.EVENT_AVAILABLE_VALUES_CHANGED, () => this.updateFloatingFilterText());
    }), this.availableValuesListenerAdded = !0;
  }
  updateFloatingFilterText(e) {
    this.availableValuesListenerAdded || this.addAvailableValuesListener(), this.parentSetFilterInstance((t) => {
      this.eFloatingFilterText.setValue(this.filterModelFormatter.getModelAsString(e, t));
    });
  }
}
mP([
  L("eFloatingFilterText")
], _w.prototype, "eFloatingFilterText", void 0);
mP([
  S("columnModel")
], _w.prototype, "columnModel", void 0);
const u2 = "30.0.5", h2 = {
  version: u2,
  moduleName: Q.SetFilterModule,
  beans: [],
  userComponents: [
    { componentName: "agSetColumnFilter", componentClass: Us },
    { componentName: "agSetColumnFloatingFilter", componentClass: _w }
  ],
  dependantModules: [
    Pi
  ]
};
var p2 = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let lS = class extends H {
  // tslint:disable-next-line
  constructor() {
    super(), this.allComponents = {};
  }
  registerStatusPanel(e, t) {
    this.allComponents[e] = t;
  }
  getStatusPanel(e) {
    return this.allComponents[e];
  }
};
lS = p2([
  q("statusBarService")
], lS);
var Xu = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Qo extends X {
  constructor() {
    super(Qo.TEMPLATE);
  }
  postConstruct() {
    var e;
    const t = (e = this.gridOptionsService.get("statusBar")) === null || e === void 0 ? void 0 : e.statusPanels;
    if (t) {
      const i = t.filter((s) => s.align === "left");
      this.createAndRenderComponents(i, this.eStatusBarLeft);
      const r = t.filter((s) => s.align === "center");
      this.createAndRenderComponents(r, this.eStatusBarCenter);
      const n = t.filter((s) => !s.align || s.align === "right");
      this.createAndRenderComponents(n, this.eStatusBarRight);
    } else
      this.setDisplayed(!1);
  }
  createAndRenderComponents(e, t) {
    const i = [];
    e.forEach((r) => {
      const n = {}, a = this.userComponentFactory.getStatusPanelCompDetails(r, n).newAgStackInstance();
      a && i.push({
        // default to the component name if no key supplied
        key: r.key || r.statusPanel,
        promise: a
      });
    }), Qe.all(i.map((r) => r.promise)).then(() => {
      i.forEach((r) => {
        r.promise.then((n) => {
          const s = () => {
            this.getContext().destroyBean(n);
          };
          this.isAlive() ? (this.statusBarService.registerStatusPanel(r.key, n), t.appendChild(n.getGui()), this.addDestroyFunc(s)) : s();
        });
      });
    });
  }
}
Qo.TEMPLATE = `<div class="ag-status-bar">
            <div ref="eStatusBarLeft" class="ag-status-bar-left" role="status"></div>
            <div ref="eStatusBarCenter" class="ag-status-bar-center" role="status"></div>
            <div ref="eStatusBarRight" class="ag-status-bar-right" role="status"></div>
        </div>`;
Xu([
  S("userComponentFactory")
], Qo.prototype, "userComponentFactory", void 0);
Xu([
  S("statusBarService")
], Qo.prototype, "statusBarService", void 0);
Xu([
  L("eStatusBarLeft")
], Qo.prototype, "eStatusBarLeft", void 0);
Xu([
  L("eStatusBarCenter")
], Qo.prototype, "eStatusBarCenter", void 0);
Xu([
  L("eStatusBarRight")
], Qo.prototype, "eStatusBarRight", void 0);
Xu([
  B
], Qo.prototype, "postConstruct", null);
var yP = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Jo extends X {
  constructor() {
    super(Jo.TEMPLATE);
  }
  setLabel(e, t) {
    this.setDisplayed(!1);
    const i = this.localeService.getLocaleTextFunc();
    this.eLabel.innerHTML = i(e, t);
  }
  setValue(e) {
    this.eValue.innerHTML = e;
  }
}
Jo.TEMPLATE = `<div class="ag-status-name-value">
            <span ref="eLabel"></span>:&nbsp;
            <span ref="eValue" class="ag-status-name-value-value"></span>
        </div>`;
yP([
  L("eLabel")
], Jo.prototype, "eLabel", void 0);
yP([
  L("eValue")
], Jo.prototype, "eValue", void 0);
var CP = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Iw extends Jo {
  postConstruct() {
    if (this.gridApi.getModel().getType() !== "clientSide") {
      console.warn("AG Grid: agTotalAndFilteredRowCountComponent should only be used with the client side row model.");
      return;
    }
    this.setLabel("totalAndFilteredRows", "Rows"), this.addCssClass("ag-status-panel"), this.addCssClass("ag-status-panel-total-and-filtered-row-count"), this.setDisplayed(!0), this.addManagedListener(this.eventService, w.EVENT_MODEL_UPDATED, this.onDataChanged.bind(this)), this.onDataChanged();
  }
  onDataChanged() {
    const e = this.localeService.getLocaleTextFunc(), t = e("thousandSeparator", ","), i = e("decimalSeparator", "."), r = x.formatNumberCommas(this.getFilteredRowCountValue(), t, i), n = x.formatNumberCommas(this.getTotalRowCount(), t, i);
    if (r === n)
      this.setValue(r);
    else {
      const s = this.localeService.getLocaleTextFunc();
      this.setValue(`${r} ${s("of", "of")} ${n}`);
    }
  }
  getFilteredRowCountValue() {
    let e = 0;
    return this.gridApi.forEachNodeAfterFilter((t) => {
      t.group || e++;
    }), e;
  }
  getTotalRowCount() {
    let e = 0;
    return this.gridApi.forEachNode((t) => {
      t.group || e++;
    }), e;
  }
  init() {
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
}
CP([
  S("gridApi")
], Iw.prototype, "gridApi", void 0);
CP([
  B
], Iw.prototype, "postConstruct", null);
var SP = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Fw extends Jo {
  postConstruct() {
    if (this.setLabel("filteredRows", "Filtered"), this.gridApi.getModel().getType() !== "clientSide") {
      console.warn("AG Grid: agFilteredRowCountComponent should only be used with the client side row model.");
      return;
    }
    this.addCssClass("ag-status-panel"), this.addCssClass("ag-status-panel-filtered-row-count"), this.setDisplayed(!0);
    const e = this.onDataChanged.bind(this);
    this.addManagedListener(this.eventService, w.EVENT_MODEL_UPDATED, e), e();
  }
  onDataChanged() {
    const e = this.getTotalRowCountValue(), t = this.getFilteredRowCountValue(), i = this.localeService.getLocaleTextFunc(), r = i("thousandSeparator", ","), n = i("decimalSeparator", ".");
    this.setValue(x.formatNumberCommas(t, r, n)), this.setDisplayed(e !== t);
  }
  getTotalRowCountValue() {
    let e = 0;
    return this.gridApi.forEachNode((t) => e += 1), e;
  }
  getFilteredRowCountValue() {
    let e = 0;
    return this.gridApi.forEachNodeAfterFilter((t) => {
      t.group || (e += 1);
    }), e;
  }
  init() {
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
}
SP([
  S("gridApi")
], Fw.prototype, "gridApi", void 0);
SP([
  B
], Fw.prototype, "postConstruct", null);
var bP = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Lw extends Jo {
  postConstruct() {
    if (this.setLabel("totalRows", "Total Rows"), this.gridApi.getModel().getType() !== "clientSide") {
      console.warn("AG Grid: agTotalRowCountComponent should only be used with the client side row model.");
      return;
    }
    this.addCssClass("ag-status-panel"), this.addCssClass("ag-status-panel-total-row-count"), this.setDisplayed(!0), this.addManagedListener(this.eventService, w.EVENT_MODEL_UPDATED, this.onDataChanged.bind(this)), this.onDataChanged();
  }
  onDataChanged() {
    const e = this.localeService.getLocaleTextFunc(), t = e("thousandSeparator", ","), i = e("decimalSeparator", ".");
    this.setValue(x.formatNumberCommas(this.getRowCountValue(), t, i));
  }
  getRowCountValue() {
    let e = 0;
    return this.gridApi.forEachLeafNode((t) => e += 1), e;
  }
  init() {
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
}
bP([
  S("gridApi")
], Lw.prototype, "gridApi", void 0);
bP([
  B
], Lw.prototype, "postConstruct", null);
var Nw = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class ly extends Jo {
  postConstruct() {
    if (!this.isValidRowModel()) {
      console.warn("AG Grid: agSelectedRowCountComponent should only be used with the client and server side row model.");
      return;
    }
    this.setLabel("selectedRows", "Selected"), this.addCssClass("ag-status-panel"), this.addCssClass("ag-status-panel-selected-row-count"), this.onRowSelectionChanged();
    const e = this.onRowSelectionChanged.bind(this);
    this.addManagedListener(this.eventService, w.EVENT_MODEL_UPDATED, e), this.addManagedListener(this.eventService, w.EVENT_SELECTION_CHANGED, e);
  }
  isValidRowModel() {
    const e = this.gridApi.getModel().getType();
    return e === "clientSide" || e === "serverSide";
  }
  onRowSelectionChanged() {
    const e = this.selectionService.getSelectionCount();
    if (e < 0) {
      this.setValue("?"), this.setDisplayed(!0);
      return;
    }
    const t = this.localeService.getLocaleTextFunc(), i = t("thousandSeparator", ","), r = t("decimalSeparator", ".");
    this.setValue(x.formatNumberCommas(e, i, r)), this.setDisplayed(e > 0);
  }
  init() {
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
}
Nw([
  S("gridApi")
], ly.prototype, "gridApi", void 0);
Nw([
  S("selectionService")
], ly.prototype, "selectionService", void 0);
Nw([
  B
], ly.prototype, "postConstruct", null);
var Kr = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Mi extends X {
  constructor() {
    super(Mi.TEMPLATE);
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  postConstruct() {
    if (!this.isValidRowModel()) {
      console.warn("AG Grid: agAggregationComponent should only be used with the client and server side row model.");
      return;
    }
    this.avgAggregationComp.setLabel("avg", "Average"), this.countAggregationComp.setLabel("count", "Count"), this.minAggregationComp.setLabel("min", "Min"), this.maxAggregationComp.setLabel("max", "Max"), this.sumAggregationComp.setLabel("sum", "Sum"), this.addManagedListener(this.eventService, w.EVENT_RANGE_SELECTION_CHANGED, this.onRangeSelectionChanged.bind(this)), this.addManagedListener(this.eventService, w.EVENT_MODEL_UPDATED, this.onRangeSelectionChanged.bind(this));
  }
  isValidRowModel() {
    const e = this.gridApi.getModel().getType();
    return e === "clientSide" || e === "serverSide";
  }
  init() {
  }
  setAggregationComponentValue(e, t, i) {
    const r = this.getAggregationValueComponent(e);
    if (x.exists(r) && r) {
      const n = this.localeService.getLocaleTextFunc(), s = n("thousandSeparator", ","), a = n("decimalSeparator", ".");
      r.setValue(x.formatNumberTwoDecimalPlacesAndCommas(t, s, a)), r.setDisplayed(i);
    }
  }
  getAggregationValueComponent(e) {
    const t = `${e}AggregationComp`;
    let i = null;
    const r = this.gridOptionsService.get("statusBar"), n = x.exists(r) && r ? r.statusPanels.find((s) => s.statusPanel === "agAggregationComponent") : null;
    return x.exists(n) && n ? (!x.exists(n.statusPanelParams) || x.exists(n.statusPanelParams) && x.exists(n.statusPanelParams.aggFuncs) && x.exists(n.statusPanelParams.aggFuncs.find((s) => s === e))) && (i = this[t]) : i = this[t], i;
  }
  onRangeSelectionChanged() {
    const e = this.rangeService ? this.rangeService.getCellRanges() : void 0;
    let t = 0, i = 0, r = 0, n = null, s = null;
    const a = {};
    e && !x.missingOrEmpty(e) && e.forEach((d) => {
      let u = this.rangeService.getRangeStartRow(d);
      const h = this.rangeService.getRangeEndRow(d);
      for (; !(x.missing(u) || !u || this.rowPositionUtils.before(h, u) || !u || !d.columns); )
        d.columns.forEach((f) => {
          if (u === null)
            return;
          const g = this.cellPositionUtils.createId({
            rowPinned: u.rowPinned,
            column: f,
            rowIndex: u.rowIndex
          });
          if (a[g])
            return;
          a[g] = !0;
          const v = this.rowRenderer.getRowNode(u);
          if (x.missing(v))
            return;
          let y = this.valueService.getValue(f, v);
          x.missing(y) || y === "" || (i++, !(typeof y == "object" && "value" in y && (y = y.value, y === "")) && (typeof y == "string" && (y = Number(y)), typeof y == "number" && !isNaN(y) && (t += y, (s === null || y > s) && (s = y), (n === null || y < n) && (n = y), r++)));
        }), u = this.cellNavigationService.getRowBelow(u);
    });
    const l = i > 1, c = r > 1;
    this.setAggregationComponentValue("count", i, l), this.setAggregationComponentValue("sum", t, c), this.setAggregationComponentValue("min", n, c), this.setAggregationComponentValue("max", s, c), this.setAggregationComponentValue("avg", t / r, c);
  }
}
Mi.TEMPLATE = `<div class="ag-status-panel ag-status-panel-aggregations">
            <ag-name-value ref="avgAggregationComp"></ag-name-value>
            <ag-name-value ref="countAggregationComp"></ag-name-value>
            <ag-name-value ref="minAggregationComp"></ag-name-value>
            <ag-name-value ref="maxAggregationComp"></ag-name-value>
            <ag-name-value ref="sumAggregationComp"></ag-name-value>
        </div>`;
Kr([
  Ve("rangeService")
], Mi.prototype, "rangeService", void 0);
Kr([
  S("valueService")
], Mi.prototype, "valueService", void 0);
Kr([
  S("cellNavigationService")
], Mi.prototype, "cellNavigationService", void 0);
Kr([
  S("rowRenderer")
], Mi.prototype, "rowRenderer", void 0);
Kr([
  S("gridApi")
], Mi.prototype, "gridApi", void 0);
Kr([
  S("cellPositionUtils")
], Mi.prototype, "cellPositionUtils", void 0);
Kr([
  S("rowPositionUtils")
], Mi.prototype, "rowPositionUtils", void 0);
Kr([
  L("sumAggregationComp")
], Mi.prototype, "sumAggregationComp", void 0);
Kr([
  L("countAggregationComp")
], Mi.prototype, "countAggregationComp", void 0);
Kr([
  L("minAggregationComp")
], Mi.prototype, "minAggregationComp", void 0);
Kr([
  L("maxAggregationComp")
], Mi.prototype, "maxAggregationComp", void 0);
Kr([
  L("avgAggregationComp")
], Mi.prototype, "avgAggregationComp", void 0);
Kr([
  B
], Mi.prototype, "postConstruct", null);
const f2 = "30.0.5", g2 = {
  version: f2,
  moduleName: Q.StatusBarModule,
  beans: [lS],
  agStackComponents: [
    { componentName: "AgStatusBar", componentClass: Qo },
    { componentName: "AgNameValue", componentClass: Jo }
  ],
  userComponents: [
    { componentName: "agAggregationComponent", componentClass: Mi },
    { componentName: "agSelectedRowCountComponent", componentClass: ly },
    { componentName: "agTotalRowCountComponent", componentClass: Lw },
    { componentName: "agFilteredRowCountComponent", componentClass: Fw },
    { componentName: "agTotalAndFilteredRowCountComponent", componentClass: Iw }
  ],
  dependantModules: [
    Pi
  ]
}, v2 = "30.0.5";
var qu = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
const m2 = 5, y2 = 5;
let _a = class extends H {
  constructor() {
    super(...arguments), this.firstRow = -1, this.lastRow = -1, this.rowCount = -1, this.rowNodesByIndex = {};
  }
  // we don't implement as lazy row heights is not supported in this row model
  ensureRowHeightsValid(e, t, i, r) {
    return !1;
  }
  init() {
    this.rowHeight = this.gridOptionsService.getRowHeightAsNumber(), this.addManagedListener(this.eventService, w.EVENT_VIEWPORT_CHANGED, this.onViewportChanged.bind(this));
  }
  start() {
    this.gridOptionsService.get("viewportDatasource") && this.setViewportDatasource(this.gridOptionsService.get("viewportDatasource"));
  }
  isLastRowIndexKnown() {
    return !0;
  }
  destroyDatasource() {
    this.viewportDatasource && (this.viewportDatasource.destroy && this.viewportDatasource.destroy(), this.rowRenderer.datasourceChanged(), this.firstRow = -1, this.lastRow = -1);
  }
  getViewportRowModelPageSize() {
    return x.oneOrGreater(this.gridOptionsService.getNum("viewportRowModelPageSize"), m2);
  }
  getViewportRowModelBufferSize() {
    return x.zeroOrGreater(this.gridOptionsService.getNum("viewportRowModelBufferSize"), y2);
  }
  calculateFirstRow(e) {
    const t = this.getViewportRowModelBufferSize(), i = this.getViewportRowModelPageSize(), r = e - t;
    return r < 0 ? 0 : Math.floor(r / i) * i;
  }
  calculateLastRow(e) {
    if (e === -1)
      return e;
    const t = this.getViewportRowModelBufferSize(), i = this.getViewportRowModelPageSize(), r = e + t, n = Math.ceil(r / i) * i, s = this.rowCount - 1;
    return Math.min(n, s);
  }
  onViewportChanged(e) {
    const t = this.calculateFirstRow(e.firstRow), i = this.calculateLastRow(e.lastRow);
    (this.firstRow !== t || this.lastRow !== i) && (this.firstRow = t, this.lastRow = i, this.purgeRowsNotInViewport(), this.viewportDatasource && this.viewportDatasource.setViewportRange(this.firstRow, this.lastRow));
  }
  purgeRowsNotInViewport() {
    Object.keys(this.rowNodesByIndex).forEach((e) => {
      const t = parseInt(e, 10);
      if (t < this.firstRow || t > this.lastRow) {
        if (this.isRowFocused(t))
          return;
        delete this.rowNodesByIndex[t];
      }
    });
  }
  isRowFocused(e) {
    const t = this.focusService.getFocusCellToUseAfterRefresh();
    return !t || t.rowPinned != null ? !1 : t.rowIndex === e;
  }
  setViewportDatasource(e) {
    this.destroyDatasource(), this.viewportDatasource = e, this.rowCount = -1, e.init ? e.init({
      setRowCount: this.setRowCount.bind(this),
      setRowData: this.setRowData.bind(this),
      getRow: this.getRow.bind(this)
    }) : console.warn("AG Grid: viewport is missing init method.");
  }
  getType() {
    return "viewport";
  }
  getRow(e) {
    return this.rowNodesByIndex[e] || (this.rowNodesByIndex[e] = this.createBlankRowNode(e)), this.rowNodesByIndex[e];
  }
  getRowNode(e) {
    let t;
    return this.forEachNode((i) => {
      i.id === e && (t = i);
    }), t;
  }
  getRowCount() {
    return this.rowCount === -1 ? 0 : this.rowCount;
  }
  getRowIndexAtPixel(e) {
    return this.rowHeight !== 0 ? Math.floor(e / this.rowHeight) : 0;
  }
  getRowBounds(e) {
    return {
      rowHeight: this.rowHeight,
      rowTop: this.rowHeight * e
    };
  }
  getTopLevelRowCount() {
    return this.getRowCount();
  }
  getTopLevelRowDisplayedIndex(e) {
    return e;
  }
  isEmpty() {
    return this.rowCount > 0;
  }
  isRowsToRender() {
    return this.rowCount > 0;
  }
  getNodesInRangeForSelection(e, t) {
    const i = x.missing(e) ? 0 : e.rowIndex, r = t.rowIndex, n = i < this.firstRow || i > this.lastRow, s = r < this.firstRow || r > this.lastRow;
    if (n || s)
      return [];
    const a = [], l = i <= r ? i : r, c = i <= r ? r : i;
    for (let d = l; d <= c; d++)
      a.push(this.rowNodesByIndex[d]);
    return a;
  }
  forEachNode(e) {
    let t = 0;
    Object.keys(this.rowNodesByIndex).forEach((i) => {
      const r = parseInt(i, 10), n = this.rowNodesByIndex[r];
      e(n, t), t++;
    });
  }
  setRowData(e) {
    x.iterateObject(e, (t, i) => {
      const r = parseInt(t, 10);
      if (r >= this.firstRow && r <= this.lastRow) {
        let n = this.rowNodesByIndex[r];
        x.missing(n) && (n = this.createBlankRowNode(r), this.rowNodesByIndex[r] = n), n.setDataAndId(i, r.toString());
      }
    });
  }
  createBlankRowNode(e) {
    const t = new re(this.beans);
    return t.setRowHeight(this.rowHeight), t.setRowTop(this.rowHeight * e), t.setRowIndex(e), t;
  }
  setRowCount(e, t = !1) {
    if (e === this.rowCount)
      return;
    this.rowCount = e;
    const i = {
      type: w.EVENT_MODEL_UPDATED,
      newData: !1,
      newPage: !1,
      keepRenderedRows: t,
      animate: !1
    };
    this.eventService.dispatchEvent(i);
  }
  isRowPresent(e) {
    return !!this.getRowNode(e.id);
  }
};
qu([
  S("rowRenderer")
], _a.prototype, "rowRenderer", void 0);
qu([
  S("focusService")
], _a.prototype, "focusService", void 0);
qu([
  S("beans")
], _a.prototype, "beans", void 0);
qu([
  B
], _a.prototype, "init", null);
qu([
  dt
], _a.prototype, "destroyDatasource", null);
_a = qu([
  q("rowModel")
], _a);
const C2 = {
  version: v2,
  moduleName: Q.ViewportRowModelModule,
  rowModel: "viewport",
  beans: [_a],
  dependantModules: [
    Pi
  ]
}, S2 = `
.ag-sparkline-tooltip-wrapper {
    position: absolute;
    user-select: none;
    pointer-events: none;
}

.ag-sparkline-tooltip {
    position: relative;
    font: 12px arial,sans-serif;
    border-radius: 2px;
    box-shadow: 0 1px 3px rgb(0 0 0 / 20%), 0 1px 1px rgb(0 0 0 / 14%);
    line-height: 1.7em;
    overflow: hidden;
    white-space: nowrap;
    z-index: 99999;
    background-color: rgb(255, 255, 255);
    color: rgba(0,0,0, 0.67);
}

.ag-sparkline-tooltip-content {
    padding: 0 7px;
    opacity: 1;
}

.ag-sparkline-tooltip-title {
    padding-left: 7px;
    opacity: 1;
}

.ag-sparkline-tooltip-wrapper-hidden {
    top: -10000px !important;
}

.ag-sparkline-wrapper {
    box-sizing: border-box;
    overflow: hidden;
}
`, { extent: b2, isNumber: ph, isString: w2, isStringObject: E2, isDate: JE, createId: R2, Padding: T2 } = yc, { LinearScale: aC, BandScale: x2, TimeScale: eR } = Sf;
var Xi;
(function(o) {
  o[o.SERIES_FILL_ZINDEX = 50] = "SERIES_FILL_ZINDEX", o[o.AXIS_LINE_ZINDEX = 500] = "AXIS_LINE_ZINDEX", o[o.SERIES_STROKE_ZINDEX = 1e3] = "SERIES_STROKE_ZINDEX", o[o.SERIES_LABEL_ZINDEX = 1500] = "SERIES_LABEL_ZINDEX", o[o.CROSSHAIR_ZINDEX = 2e3] = "CROSSHAIR_ZINDEX", o[o.SERIES_MARKERS_ZINDEX = 2500] = "SERIES_MARKERS_ZINDEX";
})(Xi || (Xi = {}));
class D2 {
  constructor() {
    this.type = "category", this.stroke = "rgb(204, 214, 235)", this.strokeWidth = 1;
  }
}
class ql {
  constructor() {
    this.id = R2(this), this.seriesRect = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }, this._context = void 0, this._container = void 0, this._data = void 0, this.padding = new T2(3), this.xKey = "x", this.yKey = "y", this.dataType = void 0, this.xData = [], this.yData = [], this.min = void 0, this.max = void 0, this.yScale = new aC(), this.axis = new D2(), this.highlightStyle = {
      size: 6,
      fill: "yellow",
      stroke: "silver",
      strokeWidth: 1
    }, this._width = 100, this._height = 100, this.smallestInterval = void 0, this.layoutId = 0, this.defaultDateFormatter = new Intl.DateTimeFormat("en-US", {
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: !1
    }), this._onMouseMove = this.onMouseMove.bind(this), this._onMouseOut = this.onMouseOut.bind(this);
    const e = new we();
    this.rootGroup = e;
    const t = document.createElement("div");
    t.setAttribute("class", "ag-sparkline-wrapper");
    const i = new zb({ document });
    if (this.scene = i, this.canvasElement = i.canvas.element, i.root = e, i.container = t, i.resize(this.width, this.height), this.seriesRect.width = this.width, this.seriesRect.height = this.height, ql.tooltipDocuments.indexOf(document) === -1) {
      const r = document.createElement("style");
      r.innerHTML = S2, document.head.insertBefore(r, document.head.querySelector("style")), ql.tooltipDocuments.push(document);
    }
    this.setupDomEventListeners(this.scene.canvas.element);
  }
  set context(e) {
    this._context !== e && (this._context = e);
  }
  get context() {
    return this._context;
  }
  set container(e) {
    if (this._container !== e) {
      const { parentNode: t } = this.canvasElement;
      t != null && t.removeChild(this.canvasElement), e && e.appendChild(this.canvasElement), this._container = e;
    }
  }
  get container() {
    return this._container;
  }
  set data(e) {
    this._data !== e && (this._data = e, this.processData(), this.mouseMoveEvent && this.highlightedDatum && this.updateHitPoint(this.mouseMoveEvent));
  }
  get data() {
    return this._data;
  }
  set width(e) {
    this._width !== e && (this._width = e, this.scene.resize(e, this.height), this.scheduleLayout());
  }
  get width() {
    return this._width;
  }
  set height(e) {
    this._height !== e && (this._height = e, this.scene.resize(this.width, e), this.scheduleLayout());
  }
  get height() {
    return this._height;
  }
  /**
   * Generate node data from processed data.
   * Produce data joins.
   * Update selection's nodes using node data.
   */
  update() {
  }
  // Update y scale based on processed data.
  updateYScale() {
    this.updateYScaleRange(), this.updateYScaleDomain();
  }
  // Update y scale domain based on processed data.
  updateYScaleDomain() {
  }
  // Update y scale range based on height and padding (seriesRect).
  updateYScaleRange() {
    const { yScale: e, seriesRect: t } = this;
    e.range = [t.height, 0];
  }
  // Update x scale based on processed data.
  updateXScale() {
    const { type: e } = this.axis;
    this.xScale = this.getXScale(e), this.updateXScaleRange(), this.updateXScaleDomain();
  }
  // Update x scale range based on width and padding (seriesRect).
  updateXScaleRange() {
    this.xScale.range = [0, this.seriesRect.width];
  }
  // Update x scale domain based on processed data and type of scale.
  updateXScaleDomain() {
    const { xData: e, xScale: t } = this;
    let i;
    (t instanceof aC || t instanceof eR) && (i = b2(e)), this.xScale.domain = i ? i.slice() : e;
  }
  /**
   * Return xScale instance based on the provided type or return a `BandScale` by default.
   * The default type is `category`.
   * @param type
   */
  getXScale(e = "category") {
    switch (e) {
      case "number":
        return new aC();
      case "time":
        return new eR();
      case "category":
      default:
        return new x2();
    }
  }
  // Update axis line.
  updateAxisLine() {
  }
  // Update X and Y scales and the axis line.
  updateAxes() {
    this.updateYScale(), this.updateXScale(), this.updateAxisLine();
  }
  // Update horizontal and vertical crosshair lines.
  updateCrosshairs() {
    this.updateXCrosshairLine(), this.updateYCrosshairLine();
  }
  // Using processed data, generate data that backs visible nodes.
  generateNodeData() {
    return [];
  }
  // Returns persisted node data associated with the sparkline's data.
  getNodeData() {
    return [];
  }
  // Update the selection's nodes.
  updateNodes() {
  }
  // Update the vertical crosshair line.
  updateXCrosshairLine() {
  }
  // Update the horizontal crosshair line.
  updateYCrosshairLine() {
  }
  highlightDatum(e) {
    this.updateNodes();
  }
  dehighlightDatum() {
    this.highlightedDatum = void 0, this.updateNodes(), this.updateCrosshairs();
  }
  /**
   * Highlight closest datum and display tooltip if enabled.
   * Only update if necessary, i.e. only update if the highlighted datum is different from previously highlighted datum,
   * or if there is no previously highlighted datum.
   * @param event
   */
  onMouseMove(e) {
    this.mouseMoveEvent = e, this.updateHitPoint(e);
  }
  updateHitPoint(e) {
    var t, i, r;
    const n = this.pickClosestSeriesNodeDatum(e.offsetX, e.offsetY);
    if (!n)
      return;
    const s = this.highlightedDatum;
    this.highlightedDatum = n, (this.highlightedDatum && !s || this.highlightedDatum && s && this.highlightedDatum !== s) && (this.highlightDatum(n), this.updateCrosshairs(), this.scene.render().catch((l) => console.error("AG Grid - chart rendering failed", l))), ((r = (i = (t = this.processedOptions) === null || t === void 0 ? void 0 : t.tooltip) === null || i === void 0 ? void 0 : i.enabled) !== null && r !== void 0 ? r : !0) && this.handleTooltip(e, n);
  }
  /**
   * Dehighlight all nodes and remove tooltip.
   * @param event
   */
  onMouseOut(e) {
    this.dehighlightDatum(), this.tooltip.toggle(!1), this.scene.render().catch((t) => console.error("AG Grid - chart rendering failed", t));
  }
  // Fetch required values from the data object and process them.
  processData() {
    const { data: e, yData: t, xData: i } = this;
    if (!e || this.invalidData(this.data))
      return;
    t.length = 0, i.length = 0;
    const r = e.length, n = this.getDataType(e);
    this.dataType = n;
    const { type: s } = this.axis, a = s !== "number" && s !== "time" ? "category" : s, l = a === "number" || a === "time", c = (u, h) => {
      this.smallestInterval == null && (this.smallestInterval = { x: 1 / 0, y: 1 / 0 });
      const { x: p } = this.smallestInterval, f = Math.abs(u - h);
      f > 0 && f < p && (this.smallestInterval.x = f);
    };
    let d;
    if (n === "number")
      for (let u = 0; u < r; u++) {
        const h = u, p = e[u], f = this.getDatum(h, a), g = this.getDatum(p, "number");
        l && c(f, d), i.push(f), t.push(g), d = f;
      }
    else if (n === "array")
      for (let u = 0; u < r; u++) {
        const h = e[u];
        if (Array.isArray(h)) {
          const p = h[0], f = h[1], g = this.getDatum(p, a), v = this.getDatum(f, "number");
          if (g == null)
            continue;
          l && c(g, d), i.push(g), t.push(v), d = g;
        }
      }
    else if (n === "object") {
      const { yKey: u, xKey: h } = this;
      for (let p = 0; p < r; p++) {
        const f = e[p];
        if (typeof f == "object" && !Array.isArray(f)) {
          const g = f[h], v = f[u], y = this.getDatum(g, a), m = this.getDatum(v, "number");
          if (y == null)
            continue;
          l && c(y, d), i.push(y), t.push(m), d = y;
        }
      }
    }
    this.updateAxes(), this.immediateLayout();
  }
  /**
   * Return the type of data provided to the sparkline based on the first truthy value in the data array.
   * If the value is not a number, array or object, return `undefined`.
   * @param data
   */
  getDataType(e) {
    for (const t of e)
      if (t != null) {
        if (ph(t))
          return "number";
        if (Array.isArray(t))
          return "array";
        if (typeof t == "object")
          return "object";
      }
  }
  /**
   * Return the given value depending on the type of axis.
   * Return `undefined` if the value is invalid for the given axis type.
   * @param value
   */
  getDatum(e, t) {
    if (t === "number" && ph(e) || t === "time" && (ph(e) || JE(e)))
      return e;
    if (t === "category") {
      if (w2(e) || JE(e) || ph(e))
        return { toString: () => String(e) };
      if (E2(e))
        return e;
    }
  }
  /**
   * Only `true` while we are waiting for the layout to start.
   * This will be `false` if the layout has already started and is ongoing.
   */
  get layoutScheduled() {
    return !!this.layoutId;
  }
  /**
   * Execute update method on the next available screen repaint to make changes to the canvas.
   * If we are waiting for a layout to start and a new layout is requested,
   * cancel the previous layout using the non 0 integer (this.layoutId) returned from requestAnimationFrame.
   */
  scheduleLayout() {
    this.layoutId && cancelAnimationFrame(this.layoutId), this.layoutId = requestAnimationFrame(() => {
      this.immediateLayout(), this.layoutId = 0;
    });
  }
  immediateLayout() {
    this.setSparklineDimensions(), !this.invalidData(this.data) && (this.updateXScaleRange(), this.updateYScaleRange(), this.updateAxisLine(), this.update(), this.scene.render().catch((e) => console.error("AG Grid - chart rendering failed", e)));
  }
  setSparklineDimensions() {
    const { width: e, height: t, padding: i, seriesRect: r, rootGroup: n } = this, s = e - i.left - i.right, a = t - i.top - i.bottom;
    r.width = s, r.height = a, r.x = i.left, r.y = i.top, n.translationX = r.x, n.translationY = r.y;
  }
  /**
   * Return the closest data point to x/y canvas coordinates.
   * @param x
   * @param y
   */
  pickClosestSeriesNodeDatum(e, t) {
    let i = 1 / 0, r;
    const n = this.rootGroup.transformPoint(e, t), s = this.getNodeData();
    for (let a = 0; a < s.length; a++) {
      const l = s[a];
      if (!l.point)
        return;
      const c = this.getDistance(n, l.point);
      c <= i && (i = c, r = l);
    }
    return r;
  }
  /**
   * Return the relevant distance between two points.
   * The distance will be calculated based on the x value of the points for all sparklines except bar sparkline, where the distance is based on the y values.
   * @param x
   * @param y
   */
  getDistance(e, t) {
    return Math.abs(e.x - t.x);
  }
  /**
   * calculate x/y coordinates for tooltip based on coordinates of highlighted datum, position of canvas and page offset.
   * @param datum
   */
  handleTooltip(e, t) {
    var i, r;
    const { seriesDatum: n } = t, { canvasElement: s } = this, { clientX: a, clientY: l } = e, c = (i = this.processedOptions) === null || i === void 0 ? void 0 : i.tooltip, d = {
      pageX: a,
      pageY: l,
      position: {
        xOffset: c == null ? void 0 : c.xOffset,
        yOffset: c == null ? void 0 : c.yOffset
      },
      container: c == null ? void 0 : c.container
    };
    d.container == null && (d.container = s);
    const u = n.y, h = n.x;
    let p = (r = c == null ? void 0 : c.enabled) !== null && r !== void 0 ? r : !0;
    const f = c == null ? void 0 : c.renderer;
    if (f) {
      const v = f({
        context: this.context,
        datum: n,
        yValue: u,
        xValue: h
      });
      p = typeof v != "string" && v.enabled !== void 0 ? v.enabled : p;
    }
    const g = p && n.y !== void 0 && this.getTooltipHtml(t);
    g && this.tooltip.show(d, g);
  }
  formatNumericDatum(e) {
    return String(Math.round(e * 10) / 10);
  }
  // locale.format('%m/%d/%y, %H:%M:%S');
  formatDatum(e) {
    const t = this.axis.type || "category";
    return t === "number" && typeof e == "number" ? this.formatNumericDatum(e) : t === "time" && (e instanceof Date || ph(e)) ? this.defaultDateFormatter.format(e) : String(e);
  }
  setupDomEventListeners(e) {
    e.addEventListener("mousemove", this._onMouseMove), e.addEventListener("mouseout", this._onMouseOut);
  }
  cleanupDomEventListeners(e) {
    e.removeEventListener("mousemove", this._onMouseMove), e.removeEventListener("mouseout", this._onMouseOut);
  }
  invalidData(e) {
    return !e || !Array.isArray(e) || e.length === 0;
  }
  /**
   * Cleanup and remove canvas element from the DOM.
   */
  destroy() {
    this.scene.container = void 0, this.container = void 0, this.cleanupDomEventListeners(this.scene.canvas.element);
  }
}
ql.tooltipDocuments = [];
function nu(o, e) {
  var t, i, r;
  if (typeof o == "string")
    return o;
  e = e != null ? e : {};
  const { content: n = (t = e.content) !== null && t !== void 0 ? t : "", title: s = (i = e.title) !== null && i !== void 0 ? i : void 0, color: a = e.color, backgroundColor: l = e.backgroundColor, opacity: c = (r = e.opacity) !== null && r !== void 0 ? r : 1 } = o;
  let d, u;
  a ? (d = s ? `<span class="${on.class}-title"; style="color: ${a}">${s}</span>` : "", u = `<span class="${on.class}-content" style="color: ${a}">${n}</span>`) : (d = s ? `<span class="${on.class}-title">${s}</span>` : "", u = `<span class="${on.class}-content">${n}</span>`);
  let h = `opacity: ${c}`;
  return l && (h += `; background-color: ${l.toLowerCase()}`), `<div class="${on.class}" style="${h}">
                ${d}
                ${u}
            </div>`;
}
class on {
  constructor() {
    this.element = document.createElement("div"), document.body.appendChild(this.element);
  }
  isVisible() {
    const { element: e } = this;
    if (e.classList)
      return !e.classList.contains(`${on.class}-wrapper-hidden`);
    const t = e.getAttribute("class");
    return t ? t.split(" ").indexOf(`${on.class}-wrapper-hidden`) < 0 : !1;
  }
  updateClass(e) {
    const t = [`${on.class}-wrapper`];
    e !== !0 && t.push(`${on.class}-wrapper-hidden`), this.element.setAttribute("class", t.join(" "));
  }
  show(e, t) {
    var i, r, n, s;
    this.toggle(!1);
    const { element: a } = this;
    if (t !== void 0)
      a.innerHTML = t;
    else if (!a.innerHTML)
      return;
    const l = (r = (i = e.position) === null || i === void 0 ? void 0 : i.xOffset) !== null && r !== void 0 ? r : 10, c = (s = (n = e.position) === null || n === void 0 ? void 0 : n.yOffset) !== null && s !== void 0 ? s : 0;
    let d = e.pageX + l, u = e.pageY + c;
    const h = a.getBoundingClientRect();
    let p = window.innerWidth - h.width;
    if (e.container) {
      const f = e.container.getBoundingClientRect();
      p = f.left + (f.width - h.width);
    }
    d > p && (d = e.pageX - a.clientWidth - l), typeof scrollX != "undefined" && (d += scrollX), typeof scrollY != "undefined" && (u += scrollY), a.style.left = `${Math.round(d)}px`, a.style.top = `${Math.round(u)}px`, this.toggle(!0);
  }
  toggle(e) {
    this.updateClass(e);
  }
  destroy() {
    const { parentNode: e } = this.element;
    e && e.removeChild(this.element);
  }
}
on.class = "ag-sparkline-tooltip";
function wP(o) {
  switch (o) {
    case "circle":
      return pp;
    case "square":
      return Dh;
    case "diamond":
      return LD;
    default:
      return pp;
  }
}
function Tv(o, e = "solid") {
  const t = {
    solid: [],
    dash: [4, 3],
    dot: [1, 3],
    dashDot: [4, 3, 1, 3],
    dashDotDot: [4, 3, 1, 3, 1, 3],
    shortDot: [1, 1],
    shortDash: [3, 1],
    shortDashDot: [3, 1, 1, 1],
    shortDashDotDot: [3, 1, 1, 1, 1, 1],
    longDash: [8, 3],
    longDashDot: [8, 3, 1, 3],
    longDashDotDot: [8, 3, 1, 3, 1, 3]
  }, i = {
    solid: [],
    dash: [3, 3],
    dot: [0, 3],
    dashDot: [3, 3, 0, 3],
    dashDotDot: [3, 3, 0, 3, 0, 3],
    shortDot: [0, 2],
    shortDash: [2, 2],
    shortDashDot: [2, 2, 0, 2],
    shortDashDotDot: [2, 2, 0, 2, 0, 2],
    longDash: [7, 3],
    longDashDot: [7, 3, 0, 3],
    longDashDotDot: [7, 3, 0, 3, 0, 3]
  };
  return o === "round" || o === "square" ? i[e] == null ? (console.warn(`'${e}' is not a valid 'lineDash' option.`), i.solid) : i[e] : t[e] == null ? (console.warn(`'${e}' is not a valid 'lineDash' option.`), t.solid) : t[e];
}
const { extent: O2 } = yc, { BandScale: P2 } = Sf;
class A2 {
  constructor() {
    this.enabled = !0, this.shape = "circle", this.size = 0, this.fill = "rgb(124, 181, 236)", this.stroke = "rgb(124, 181, 236)", this.strokeWidth = 1, this.formatter = void 0;
  }
}
class M2 {
  constructor() {
    this.stroke = "rgb(124, 181, 236)", this.strokeWidth = 1;
  }
}
class _2 {
  constructor() {
    this.xLine = {
      enabled: !0,
      stroke: "rgba(0,0,0, 0.54)",
      strokeWidth: 1,
      lineDash: "solid",
      lineCap: void 0
    }, this.yLine = {
      enabled: !1,
      stroke: "rgba(0,0,0, 0.54)",
      strokeWidth: 1,
      lineDash: "solid",
      lineCap: void 0
    };
  }
}
class EP extends ql {
  constructor() {
    super(), this.fill = "rgba(124, 181, 236, 0.25)", this.strokePath = new Zi(), this.fillPath = new Zi(), this.xCrosshairLine = new Qt(), this.yCrosshairLine = new Qt(), this.areaSparklineGroup = new we(), this.xAxisLine = new Qt(), this.markers = new we(), this.markerSelection = Et.select(this.markers, () => this.markerFactory()), this.markerSelectionData = [], this.marker = new A2(), this.line = new M2(), this.crosshairs = new _2(), this.rootGroup.append(this.areaSparklineGroup), this.xAxisLine.zIndex = Xi.AXIS_LINE_ZINDEX, this.fillPath.zIndex = Xi.SERIES_FILL_ZINDEX, this.strokePath.zIndex = Xi.SERIES_STROKE_ZINDEX, this.xCrosshairLine.zIndex = Xi.CROSSHAIR_ZINDEX, this.yCrosshairLine.zIndex = Xi.CROSSHAIR_ZINDEX, this.markers.zIndex = Xi.SERIES_MARKERS_ZINDEX, this.areaSparklineGroup.append([
      this.fillPath,
      this.xAxisLine,
      this.strokePath,
      this.xCrosshairLine,
      this.yCrosshairLine,
      this.markers
    ]);
  }
  markerFactory() {
    const { shape: e } = this.marker, t = wP(e);
    return new t();
  }
  getNodeData() {
    return this.markerSelectionData;
  }
  update() {
    const e = this.generateNodeData();
    if (!e)
      return;
    const { nodeData: t, fillData: i, strokeData: r } = e;
    this.markerSelectionData = t, this.updateSelection(t), this.updateNodes(), this.updateStroke(r), this.updateFill(i);
  }
  updateYScaleDomain() {
    const { yData: e, yScale: t } = this, i = O2(e);
    let r = 0, n = 1;
    i !== void 0 && (r = this.min = i[0], n = this.max = i[1]), r = r < 0 ? r : 0, n = n < 0 ? 0 : n, t.domain = [r, n];
  }
  generateNodeData() {
    const { data: e, yData: t, xData: i, xScale: r, yScale: n } = this;
    if (!e)
      return;
    const s = !(r instanceof P2), a = s ? 0 : r.bandwidth / 2, l = t.length, c = [], d = [], u = [];
    let h, p, f, g;
    const v = n.convert(0);
    for (let y = 0; y < l; y++) {
      const m = t[y], C = i[y], R = r.convert(s ? r.toDomain(C) : C) + a, E = m === void 0 ? NaN : n.convert(m);
      y + 1 < l && (g = r.convert(s ? r.toDomain(i[y + 1]) : i[y + 1]) + a), u.push({
        seriesDatum: { x: C, y: m },
        point: { x: R, y: E }
      }), m === void 0 && f !== void 0 ? (d.push({ seriesDatum: void 0, point: { x: f, y: v } }), g !== void 0 && d.push({ seriesDatum: void 0, point: { x: g, y: v } })) : m !== void 0 && (d.push({
        seriesDatum: { x: C, y: m },
        point: { x: R, y: E }
      }), c.push({
        seriesDatum: { x: C, y: m },
        point: { x: R, y: E }
      }), h = h !== void 0 ? h : R, p = R), f = R;
    }
    return d.push({ seriesDatum: void 0, point: { x: p, y: v } }, { seriesDatum: void 0, point: { x: h, y: v } }), { nodeData: c, fillData: d, strokeData: u };
  }
  updateAxisLine() {
    const { xScale: e, yScale: t, axis: i, xAxisLine: r } = this;
    r.x1 = e.range[0], r.x2 = e.range[1], r.y1 = r.y2 = 0, r.stroke = i.stroke, r.strokeWidth = i.strokeWidth;
    const n = t.convert(0);
    r.translationY = n;
  }
  updateSelection(e) {
    this.markerSelection.update(e);
  }
  updateNodes() {
    const { highlightedDatum: e, highlightStyle: t, marker: i } = this, { size: r, fill: n, stroke: s, strokeWidth: a } = t, l = i.formatter;
    this.markerSelection.each((c, d, u) => {
      const { point: h, seriesDatum: p } = d;
      if (!h)
        return;
      const f = d === e, g = f && n !== void 0 ? n : i.fill, v = f && s !== void 0 ? s : i.stroke, y = f && a !== void 0 ? a : i.strokeWidth, m = f && r !== void 0 ? r : i.size;
      let C;
      if (l) {
        const R = u === 0, E = u === this.markerSelectionData.length - 1, b = p.y === this.min, T = p.y === this.max;
        C = l({
          datum: d,
          xValue: p.x,
          yValue: p.y,
          min: b,
          max: T,
          first: R,
          last: E,
          fill: g,
          stroke: v,
          strokeWidth: y,
          size: m,
          highlighted: f
        });
      }
      c.size = C && C.size != null ? C.size : m, c.fill = C && C.fill != null ? C.fill : g, c.stroke = C && C.stroke != null ? C.stroke : v, c.strokeWidth = C && C.strokeWidth != null ? C.strokeWidth : y, c.translationX = h.x, c.translationY = h.y, c.visible = C && C.enabled != null ? C.enabled : i.enabled && c.size > 0;
    });
  }
  updateStroke(e) {
    const { strokePath: t, yData: i, line: r } = this;
    if (i.length < 2)
      return;
    const n = t.path, s = e.length;
    let a = !0;
    n.clear();
    for (let l = 0; l < s; l++) {
      const { point: c, seriesDatum: d } = e[l], u = c.x, h = c.y;
      d.y == null ? a = !0 : a ? (n.moveTo(u, h), a = !1) : n.lineTo(u, h);
    }
    t.lineJoin = t.lineCap = "round", t.fill = void 0, t.stroke = r.stroke, t.strokeWidth = r.strokeWidth;
  }
  updateFill(e) {
    const { fillPath: t, yData: i, fill: r } = this, n = t.path, s = e.length;
    if (n.clear(), !(i.length < 2)) {
      for (let a = 0; a < s; a++) {
        const { point: l } = e[a], c = l.x, d = l.y;
        a > 0 ? n.lineTo(c, d) : n.moveTo(c, d);
      }
      n.closePath(), t.lineJoin = "round", t.stroke = void 0, t.fill = r;
    }
  }
  updateXCrosshairLine() {
    var e;
    const { yScale: t, xCrosshairLine: i, highlightedDatum: r, crosshairs: { xLine: n } } = this;
    if (!n.enabled || r == null) {
      i.strokeWidth = 0;
      return;
    }
    i.y1 = t.range[0], i.y2 = t.range[1], i.x1 = i.x2 = 0, i.stroke = n.stroke, i.strokeWidth = (e = n.strokeWidth) !== null && e !== void 0 ? e : 1, i.lineCap = n.lineCap === "round" || n.lineCap === "square" ? n.lineCap : void 0;
    const { lineDash: s } = n;
    i.lineDash = Array.isArray(s) ? s : Tv(i.lineCap, n.lineDash), i.translationX = r.point.x;
  }
  updateYCrosshairLine() {
    var e;
    const { xScale: t, yCrosshairLine: i, highlightedDatum: r, crosshairs: { yLine: n } } = this;
    if (!n.enabled || r == null) {
      i.strokeWidth = 0;
      return;
    }
    i.x1 = t.range[0], i.x2 = t.range[1], i.y1 = i.y2 = 0, i.stroke = n.stroke, i.strokeWidth = (e = n.strokeWidth) !== null && e !== void 0 ? e : 1, i.lineCap = n.lineCap === "round" || n.lineCap === "square" ? n.lineCap : void 0;
    const { lineDash: s } = n;
    i.lineDash = Array.isArray(s) ? s : Tv(i.lineCap, n.lineDash), i.translationY = r.point.y;
  }
  getTooltipHtml(e) {
    var t, i;
    const { dataType: r } = this, { seriesDatum: n } = e, s = n.y, a = n.x, l = this.formatNumericDatum(s), c = r === "array" || r === "object" ? this.formatDatum(a) : void 0, d = {
      content: l,
      title: c
    }, u = (i = (t = this.processedOptions) === null || t === void 0 ? void 0 : t.tooltip) === null || i === void 0 ? void 0 : i.renderer;
    return u ? nu(u({
      context: this.context,
      datum: n,
      yValue: s,
      xValue: a
    }), d) : nu(d);
  }
}
EP.className = "AreaSparkline";
const { extent: I2 } = yc, { BandScale: tR } = Sf;
class F2 {
  constructor() {
    this.enabled = !0, this.shape = "circle", this.size = 0, this.fill = "rgb(124, 181, 236)", this.stroke = "rgb(124, 181, 236)", this.strokeWidth = 1, this.formatter = void 0;
  }
}
class L2 {
  constructor() {
    this.stroke = "rgb(124, 181, 236)", this.strokeWidth = 1;
  }
}
class N2 {
  constructor() {
    this.xLine = {
      enabled: !0,
      stroke: "rgba(0,0,0, 0.54)",
      strokeWidth: 1,
      lineDash: "solid",
      lineCap: void 0
    }, this.yLine = {
      enabled: !1,
      stroke: "rgba(0,0,0, 0.54)",
      strokeWidth: 1,
      lineDash: "solid",
      lineCap: void 0
    };
  }
}
class RP extends ql {
  constructor() {
    super(), this.linePath = new Zi(), this.xCrosshairLine = new Qt(), this.yCrosshairLine = new Qt(), this.lineSparklineGroup = new we(), this.markers = new we(), this.markerSelection = Et.select(this.markers, () => this.markerFactory()), this.markerSelectionData = [], this.marker = new F2(), this.line = new L2(), this.crosshairs = new N2(), this.rootGroup.append(this.lineSparklineGroup), this.linePath.zIndex = Xi.SERIES_STROKE_ZINDEX, this.xCrosshairLine.zIndex = Xi.CROSSHAIR_ZINDEX, this.yCrosshairLine.zIndex = Xi.CROSSHAIR_ZINDEX, this.markers.zIndex = Xi.SERIES_MARKERS_ZINDEX, this.lineSparklineGroup.append([this.linePath, this.xCrosshairLine, this.yCrosshairLine, this.markers]);
  }
  getNodeData() {
    return this.markerSelectionData;
  }
  markerFactory() {
    const { shape: e } = this.marker, t = wP(e);
    return new t();
  }
  /**
   * If marker shape is changed, this method should be called to remove the previous marker nodes selection.
   */
  onMarkerShapeChange() {
    this.markerSelection = this.markerSelection.clear(), this.scheduleLayout();
  }
  update() {
    const e = this.generateNodeData();
    e && (this.markerSelectionData = e, this.updateSelection(e), this.updateNodes(), this.updateLine());
  }
  updateYScaleDomain() {
    const { yData: e, yScale: t } = this, i = I2(e);
    let r = 0, n = 1;
    if (i !== void 0 && (r = this.min = i[0], n = this.max = i[1]), r === n) {
      const s = Math.abs(r * 0.01);
      r -= s, n += s;
    }
    t.domain = [r, n];
  }
  generateNodeData() {
    const { data: e, yData: t, xData: i, xScale: r, yScale: n } = this;
    if (!e)
      return;
    const s = !(r instanceof tR), a = s ? 0 : r.bandwidth / 2, l = [];
    for (let c = 0; c < t.length; c++) {
      const d = t[c], u = i[c];
      if (d == null)
        continue;
      const h = r.convert(s ? r.toDomain(u) : u) + a, p = d === void 0 ? NaN : n.convert(d);
      l.push({
        seriesDatum: { x: u, y: d },
        point: { x: h, y: p }
      });
    }
    return l;
  }
  updateSelection(e) {
    this.markerSelection.update(e);
  }
  updateNodes() {
    const { highlightedDatum: e, highlightStyle: t, marker: i } = this, { size: r, fill: n, stroke: s, strokeWidth: a } = t, l = i.formatter;
    this.markerSelection.each((c, d, u) => {
      const h = d === e, p = h && n !== void 0 ? n : i.fill, f = h && s !== void 0 ? s : i.stroke, g = h && a !== void 0 ? a : i.strokeWidth, v = h && r !== void 0 ? r : i.size;
      let y;
      const { seriesDatum: m, point: C } = d;
      if (l) {
        const R = u === 0, E = u === this.markerSelectionData.length - 1, b = m.y === this.min, T = m.y === this.max;
        y = l({
          datum: d,
          xValue: m.x,
          yValue: m.y,
          min: b,
          max: T,
          first: R,
          last: E,
          fill: p,
          stroke: f,
          strokeWidth: g,
          size: v,
          highlighted: h
        });
      }
      c.size = y && y.size != null ? y.size : v, c.fill = y && y.fill != null ? y.fill : p, c.stroke = y && y.stroke != null ? y.stroke : f, c.strokeWidth = y && y.strokeWidth != null ? y.strokeWidth : g, c.translationX = C.x, c.translationY = C.y, c.visible = y && y.enabled != null ? y.enabled : i.enabled && c.size > 0;
    });
  }
  updateLine() {
    const { linePath: e, yData: t, xData: i, xScale: r, yScale: n, line: s } = this;
    if (t.length < 2)
      return;
    const a = !(r instanceof tR), l = e.path, c = t.length, d = a ? 0 : r.bandwidth / 2;
    let u = !0;
    l.clear();
    for (let h = 0; h < c; h++) {
      const p = i[h], f = t[h], g = r.convert(a ? r.toDomain(p) : p) + d, v = f === void 0 ? NaN : n.convert(f);
      f == null ? u = !0 : u ? (l.moveTo(g, v), u = !1) : l.lineTo(g, v);
    }
    e.fill = void 0, e.stroke = s.stroke, e.strokeWidth = s.strokeWidth;
  }
  updateXCrosshairLine() {
    var e;
    const { yScale: t, xCrosshairLine: i, highlightedDatum: r, crosshairs: { xLine: n } } = this;
    if (!n.enabled || r == null) {
      i.strokeWidth = 0;
      return;
    }
    i.y1 = t.range[0], i.y2 = t.range[1], i.x1 = i.x2 = 0, i.stroke = n.stroke, i.strokeWidth = (e = n.strokeWidth) !== null && e !== void 0 ? e : 1, i.lineCap = n.lineCap === "round" || n.lineCap === "square" ? n.lineCap : void 0;
    const { lineDash: s } = n;
    i.lineDash = Array.isArray(s) ? s : Tv(i.lineCap, n.lineDash), i.translationX = r.point.x;
  }
  updateYCrosshairLine() {
    var e;
    const { xScale: t, yCrosshairLine: i, highlightedDatum: r, crosshairs: { yLine: n } } = this;
    if (!n.enabled || r == null) {
      i.strokeWidth = 0;
      return;
    }
    i.x1 = t.range[0], i.x2 = t.range[1], i.y1 = i.y2 = 0, i.stroke = n.stroke, i.strokeWidth = (e = n.strokeWidth) !== null && e !== void 0 ? e : 1, i.lineCap = n.lineCap === "round" || n.lineCap === "square" ? n.lineCap : void 0;
    const { lineDash: s } = n;
    i.lineDash = Array.isArray(s) ? s : Tv(i.lineCap, n.lineDash), i.translationY = r.point.y;
  }
  getTooltipHtml(e) {
    var t, i;
    const { dataType: r } = this, { seriesDatum: n } = e, s = n.y, a = n.x, l = this.formatNumericDatum(s), c = r === "array" || r === "object" ? this.formatDatum(a) : void 0, d = {
      content: l,
      title: c
    }, u = (i = (t = this.processedOptions) === null || t === void 0 ? void 0 : t.tooltip) === null || i === void 0 ? void 0 : i.renderer;
    return u ? nu(u({
      context: this.context,
      datum: n,
      yValue: s,
      xValue: a
    }), d) : nu(d);
  }
}
RP.className = "LineSparkline";
class G2 {
  constructor() {
    this.enabled = !0, this.fontSize = 8, this.fontFamily = "Verdana, sans-serif", this.fontStyle = void 0, this.fontWeight = void 0, this.color = "rgba(70, 70, 70, 1)";
  }
}
const { extent: k2 } = yc;
var cS;
(function(o) {
  o[o.Rect = 0] = "Rect", o[o.Label = 1] = "Label";
})(cS || (cS = {}));
var Cs;
(function(o) {
  o.InsideBase = "insideBase", o.InsideEnd = "insideEnd", o.Center = "center", o.OutsideEnd = "outsideEnd";
})(Cs || (Cs = {}));
class V2 extends G2 {
  constructor() {
    super(...arguments), this.formatter = void 0, this.placement = Cs.InsideEnd;
  }
}
class TP extends ql {
  constructor() {
    super(), this.fill = "rgb(124, 181, 236)", this.stroke = "silver", this.strokeWidth = 0, this.paddingInner = 0.1, this.paddingOuter = 0.2, this.valueAxisDomain = void 0, this.formatter = void 0, this.axisLine = new Qt(), this.bandWidth = 0, this.sparklineGroup = new we(), this.rectGroup = new we(), this.labelGroup = new we(), this.rectSelection = Et.select(this.rectGroup, kn), this.labelSelection = Et.select(this.labelGroup, ut), this.nodeSelectionData = [], this.label = new V2(), this.rootGroup.append(this.sparklineGroup), this.rectGroup.zIndex = Xi.SERIES_FILL_ZINDEX, this.axisLine.zIndex = Xi.AXIS_LINE_ZINDEX, this.labelGroup.zIndex = Xi.SERIES_LABEL_ZINDEX, this.sparklineGroup.append([this.rectGroup, this.axisLine, this.labelGroup]), this.axisLine.lineCap = "round", this.label.enabled = !1;
  }
  getNodeData() {
    return this.nodeSelectionData;
  }
  update() {
    this.updateSelections(), this.updateNodes();
  }
  updateSelections() {
    const e = this.generateNodeData();
    e && (this.nodeSelectionData = e, this.updateRectSelection(e), this.updateLabelSelection(e));
  }
  updateNodes() {
    this.updateRectNodes(), this.updateLabelNodes();
  }
  calculateStep(e) {
    var t;
    const { xScale: i, paddingInner: r, paddingOuter: n, smallestInterval: s } = this;
    let l = (i.domain[1] - i.domain[0]) / ((t = s == null ? void 0 : s.x) !== null && t !== void 0 ? t : 1) + 1;
    const d = Math.min(l, 50), u = d - 1;
    return e / Math.max(1, 2 * n + u * r + d);
  }
  updateYScaleDomain() {
    const { yScale: e, yData: t, valueAxisDomain: i } = this, r = k2(t);
    let n = 0, s = 1;
    r !== void 0 && (n = this.min = r[0], s = this.max = r[1]), n = n < 0 ? n : 0, s = s < 0 ? 0 : s, i && (i[1] < s && (i[1] = s), i[0] > n && (i[0] = n)), e.domain = i || [n, s];
  }
  updateRectSelection(e) {
    this.rectSelection.update(e);
  }
  updateRectNodes() {
    const { highlightedDatum: e, formatter: t, fill: i, stroke: r, strokeWidth: n } = this, { fill: s, stroke: a, strokeWidth: l } = this.highlightStyle;
    this.rectSelection.each((c, d, u) => {
      const h = d === e, p = h && s !== void 0 ? s : i, f = h && a !== void 0 ? a : r, g = h && l !== void 0 ? l : n;
      let v;
      const { x: y, y: m, width: C, height: R, seriesDatum: E } = d;
      if (t) {
        const b = u === 0, T = u === this.nodeSelectionData.length - 1, D = E.y === this.min, P = E.y === this.max;
        v = t({
          datum: d,
          xValue: E.x,
          yValue: E.y,
          width: C,
          height: R,
          min: D,
          max: P,
          first: b,
          last: T,
          fill: p,
          stroke: f,
          strokeWidth: g,
          highlighted: h
        });
      }
      c.fill = v && v.fill || p, c.stroke = v && v.stroke || f, c.strokeWidth = v && v.strokeWidth || g, c.x = c.y = 0, c.width = C, c.height = R, c.visible = c.height > 0, c.translationX = y, c.translationY = m;
    });
  }
  updateLabelSelection(e) {
    this.labelSelection.update(e, (t) => {
      t.tag = cS.Label, t.pointerEvents = ki.None;
    });
  }
  updateLabelNodes() {
    const { label: { enabled: e, fontStyle: t, fontWeight: i, fontSize: r, fontFamily: n, color: s } } = this;
    this.labelSelection.each((a, l) => {
      const c = l.label;
      c && e ? (a.fontStyle = t, a.fontWeight = i, a.fontSize = r, a.fontFamily = n, a.textAlign = c.textAlign, a.textBaseline = c.textBaseline, a.text = c.text, a.x = c.x, a.y = c.y, a.fill = s, a.visible = !0) : a.visible = !1;
    });
  }
  getTooltipHtml(e) {
    var t, i;
    const { dataType: r } = this, { seriesDatum: n } = e, s = n.y, a = n.x, l = this.formatNumericDatum(s), c = r === "array" || r === "object" ? this.formatDatum(a) : void 0, d = {
      content: l,
      title: c
    }, u = (i = (t = this.processedOptions) === null || t === void 0 ? void 0 : t.tooltip) === null || i === void 0 ? void 0 : i.renderer;
    return u ? nu(u({
      context: this.context,
      datum: n,
      yValue: s,
      xValue: a
    }), d) : nu(d);
  }
  formatLabelValue(e) {
    return e % 1 !== 0 ? e.toFixed(1) : e.toFixed(0);
  }
}
const { isNumber: B2 } = yc, { BandScale: iR } = Sf;
class xP extends TP {
  updateYScaleRange() {
    const { seriesRect: e, yScale: t } = this;
    t.range = [0, e.width];
  }
  updateXScaleRange() {
    const { xScale: e, seriesRect: t, paddingOuter: i, paddingInner: r } = this;
    if (e instanceof iR)
      e.range = [0, t.height], e.paddingInner = r, e.paddingOuter = i;
    else {
      const n = this.calculateStep(t.height), s = n * i;
      this.bandWidth = n * (1 - r), e.range = [s, t.height - s - this.bandWidth];
    }
  }
  updateAxisLine() {
    const { yScale: e, axis: t, axisLine: i, seriesRect: r } = this, { strokeWidth: n } = t;
    i.x1 = 0, i.x2 = 0, i.y1 = 0, i.y2 = r.height, i.stroke = t.stroke, i.strokeWidth = n + (n % 2 === 1 ? 1 : 0);
    const s = e.convert(0);
    i.translationX = s;
  }
  generateNodeData() {
    const { data: e, yData: t, xData: i, xScale: r, yScale: n, fill: s, stroke: a, strokeWidth: l, label: c } = this;
    if (!e)
      return;
    const { fontStyle: d, fontWeight: u, fontSize: h, fontFamily: p, color: f, formatter: g, placement: v } = c, y = [], m = n.convert(0), C = !(r instanceof iR);
    for (let R = 0, E = t.length; R < E; R++) {
      let b = t[R];
      const T = i[R], D = b === void 0;
      D && (b = 0);
      const P = r.convert(C ? r.toDomain(T) : T), O = Math.min(b === void 0 ? NaN : n.convert(b), m), M = Math.max(b === void 0 ? NaN : n.convert(b), m), _ = C ? this.bandWidth : r.bandwidth, F = M - O, I = {
        x: m,
        y: P
      };
      let G;
      g ? G = g({ value: b }) : G = b !== void 0 && B2(b) ? this.formatLabelValue(b) : "";
      const k = P + _ / 2;
      let N;
      const W = "middle";
      let j;
      const K = b !== void 0 && b >= 0, $ = 4;
      if (v === Cs.Center)
        N = O + F / 2, j = "center";
      else if (v === Cs.OutsideEnd)
        N = O + (K ? F + $ : -$), j = K ? "start" : "end";
      else if (v === Cs.InsideEnd) {
        N = O + (K ? F - $ : $), j = K ? "end" : "start";
        const ee = It.getTextSize(G, p).width || 20, ne = m + ee, Y = m - ee;
        (K && N < ne || !K && N > Y) && (N = m + $ * (K ? 1 : -1), j = K ? "start" : "end");
      } else
        N = m + $ * (K ? 1 : -1), j = K ? "start" : "end";
      y.push({
        x: O,
        y: P,
        width: F,
        height: _,
        fill: s,
        stroke: a,
        strokeWidth: l,
        seriesDatum: { x: T, y: D ? void 0 : b },
        point: I,
        label: {
          x: N,
          y: k,
          text: G,
          fontStyle: d,
          fontWeight: u,
          fontSize: h,
          fontFamily: p,
          textAlign: j,
          textBaseline: W,
          fill: f
        }
      });
    }
    return y;
  }
  getDistance(e, t) {
    return Math.abs(e.y - t.y);
  }
}
xP.className = "BarSparkline";
const { isNumber: H2 } = yc, { BandScale: rR } = Sf;
class DP extends TP {
  updateYScaleRange() {
    const { seriesRect: e, yScale: t } = this;
    t.range = [e.height, 0];
  }
  updateXScaleRange() {
    const { xScale: e, seriesRect: t, paddingOuter: i, paddingInner: r } = this;
    if (e instanceof rR)
      e.range = [0, t.width], e.paddingInner = r, e.paddingOuter = i;
    else {
      const n = this.calculateStep(t.width), s = n * i;
      this.bandWidth = n * (1 - r), e.range = [s, t.width - s - this.bandWidth];
    }
  }
  updateAxisLine() {
    const { yScale: e, axis: t, axisLine: i, seriesRect: r } = this, { strokeWidth: n } = t;
    i.x1 = 0, i.x2 = r.width, i.y1 = 0, i.y2 = 0, i.stroke = t.stroke, i.strokeWidth = n + (n % 2 === 1 ? 1 : 0);
    const s = e.convert(0);
    i.translationY = s;
  }
  generateNodeData() {
    const { data: e, yData: t, xData: i, xScale: r, yScale: n, fill: s, stroke: a, strokeWidth: l, label: c } = this;
    if (!e)
      return;
    const { fontStyle: d, fontWeight: u, fontSize: h, fontFamily: p, color: f, formatter: g, placement: v } = c, y = [], m = n.convert(0), C = !(r instanceof rR);
    for (let R = 0, E = t.length; R < E; R++) {
      let b = t[R];
      const T = i[R], D = b === void 0;
      D && (b = 0);
      const P = Math.min(b === void 0 ? NaN : n.convert(b), m), O = r.convert(C ? r.toDomain(T) : T), M = Math.max(b === void 0 ? NaN : n.convert(b), m), _ = C ? this.bandWidth : r.bandwidth, F = M - P, I = {
        x: O + _ / 2,
        y: m
      };
      let G;
      g ? G = g({ value: b }) : G = b !== void 0 && H2(b) ? this.formatLabelValue(b) : "";
      const k = O + _ / 2;
      let N;
      const W = "center";
      let j;
      const K = b !== void 0 && b >= 0, $ = 2;
      if (v === Cs.Center)
        N = P + F / 2, j = "middle";
      else if (v === Cs.OutsideEnd)
        N = P + (K ? -$ : F + $), j = K ? "bottom" : "top";
      else if (v === Cs.InsideEnd) {
        N = P + (K ? $ : F - $), j = K ? "top" : "bottom";
        const ee = It.getTextSize(G, p).height || 10, ne = m - ee, Y = m + ee;
        (K && N > ne || !K && N < Y) && (N = m + $ * (K ? -1 : 1), j = K ? "bottom" : "top");
      } else
        N = m + $ * (K ? -1 : 1), j = K ? "bottom" : "top";
      y.push({
        x: O,
        y: P,
        width: _,
        height: F,
        fill: s,
        stroke: a,
        strokeWidth: l,
        seriesDatum: { x: T, y: D ? void 0 : b },
        point: I,
        label: {
          x: k,
          y: N,
          text: G,
          fontStyle: d,
          fontWeight: u,
          fontSize: h,
          fontFamily: p,
          textAlign: W,
          textBaseline: j,
          fill: f
        }
      });
    }
    return y;
  }
}
DP.className = "ColumnSparkline";
const { isNumber: W2 } = yc;
class j2 {
  static create(e, t) {
    e = Ft([e]);
    const i = U2(e.type);
    return t && (i.tooltip = t), z2(i, e), $2(i, e), e.data && (i.data = e.data), i.processedOptions = e, i;
  }
}
function U2(o = "line") {
  switch (o) {
    case "column":
      return new DP();
    case "bar":
      return new xP();
    case "area":
      return new EP();
    case "line":
    default:
      return new RP();
  }
}
function $2(o, e) {
  switch (e.type) {
    case "bar":
      nR(o, e);
      break;
    case "column":
      nR(o, e);
      break;
    case "area":
      Y2(o, e);
      break;
    case "line":
    default:
      K2(o, e);
      break;
  }
}
function z2(o, e) {
  Pe(o, "context", e.context, e), Pe(o, "width", e.width, e), Pe(o, "height", e.height, e), Pe(o, "container", e.container, e), Pe(o, "xKey", e.xKey, e), Pe(o, "yKey", e.yKey, e), e.padding && X2(o.padding, e.padding), e.axis && Z2(o.axis, e.axis), e.highlightStyle && Q2(o.highlightStyle, e.highlightStyle);
}
function K2(o, e) {
  e.marker && OP(o.marker, e.marker), e.line && PP(o.line, e.line), e.crosshairs && AP(o.crosshairs, e.crosshairs);
}
function Y2(o, e) {
  Pe(o, "fill", e.fill, e), e.marker && OP(o.marker, e.marker), e.line && PP(o.line, e.line), e.crosshairs && AP(o.crosshairs, e.crosshairs);
}
function nR(o, e) {
  Pe(o, "valueAxisDomain", e.valueAxisDomain, e), Pe(o, "fill", e.fill, e), Pe(o, "stroke", e.stroke, e), Pe(o, "strokeWidth", e.strokeWidth, e), Pe(o, "paddingInner", e.paddingInner, e), Pe(o, "paddingOuter", e.paddingOuter, e), Pe(o, "formatter", e.formatter, e), e.label && q2(o.label, e.label);
}
function X2(o, e) {
  Pe(o, "top", e.top, e), Pe(o, "right", e.right, e), Pe(o, "bottom", e.bottom, e), Pe(o, "left", e.left, e);
}
function OP(o, e) {
  Pe(o, "enabled", e.enabled, e), Pe(o, "size", e.size, e), Pe(o, "shape", e.shape, e), Pe(o, "fill", e.fill, e), Pe(o, "stroke", e.stroke, e), Pe(o, "strokeWidth", e.strokeWidth, e), Pe(o, "formatter", e.formatter, e);
}
function q2(o, e) {
  Pe(o, "enabled", e.enabled, e), Pe(o, "fontStyle", e.fontStyle, e), Pe(o, "fontWeight", e.fontWeight, e), Pe(o, "fontSize", e.fontSize, e), Pe(o, "fontFamily", e.fontFamily, e), Pe(o, "textAlign", e.textAlign, e), Pe(o, "textBaseline", e.textBaseline, e), Pe(o, "color", e.color, e), Pe(o, "formatter", e.formatter, e), Pe(o, "placement", e.placement, e);
}
function PP(o, e) {
  Pe(o, "stroke", e.stroke, e), Pe(o, "strokeWidth", e.strokeWidth, e);
}
function Z2(o, e) {
  Pe(o, "type", e.type, e), Pe(o, "stroke", e.stroke, e), Pe(o, "strokeWidth", e.strokeWidth, e);
}
function Q2(o, e) {
  Pe(o, "fill", e.fill, e), Pe(o, "size", e.size, e), Pe(o, "stroke", e.stroke, e), Pe(o, "strokeWidth", e.strokeWidth, e);
}
function AP(o, e) {
  o.xLine && e.xLine && oR(o.xLine, e.xLine), o.yLine && e.yLine && oR(o.yLine, e.yLine);
}
function oR(o, e) {
  Pe(o, "enabled", e.enabled, e), Pe(o, "stroke", e.stroke, e), Pe(o, "strokeWidth", e.strokeWidth, e), Pe(o, "lineDash", e.lineDash, e), Pe(o, "lineCap", e.lineCap, e);
}
const sR = {};
function J2(o, e) {
  sR[e] || (o(), sR[e] = !0);
}
const aR = (o, e, t) => {
  if (W2(e))
    return !0;
  const i = `AG Charts: ${o} must be a number, the value you provided is not a valid number. Using the default of ${t}px.`;
  return J2(() => console.warn(i), `${o} not a number`), !1;
}, eK = {
  xOffset: aR,
  yOffset: aR
};
function Pe(o, e, t, i) {
  if (e in i)
    if (e in o) {
      const r = eK[e];
      (r ? r(e, t, o[e]) : !0) && o[e] !== t && (o[e] = t);
    } else
      console.warn(`Property ${e} does not exist on the target object.`);
}
var Gw = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
class Mc extends X {
  constructor() {
    super(Mc.TEMPLATE);
  }
  init(e) {
    let t = !0;
    const i = () => {
      const { clientWidth: n, clientHeight: s } = this.getGui();
      if (!(n === 0 || s === 0))
        if (t) {
          const a = Object.assign({ data: e.value, width: n, height: s, context: {
            data: e.data
          } }, e.sparklineOptions);
          this.sparkline = j2.create(a, this.sparklineTooltipSingleton.getSparklineTooltip()), this.eSparkline.appendChild(this.sparkline.canvasElement), t = !1;
        } else
          this.sparkline.width = n, this.sparkline.height = s;
    }, r = this.resizeObserverService.observeResize(this.getGui(), i);
    this.addDestroyFunc(() => r());
  }
  refresh(e) {
    return this.sparkline ? (this.sparkline.data = e.value, !0) : !1;
  }
  destroy() {
    this.sparkline && this.sparkline.destroy(), super.destroy();
  }
}
Mc.TEMPLATE = `<div class="ag-sparkline-wrapper">
            <span ref="eSparkline"></span>
        </div>`;
Gw([
  L("eSparkline")
], Mc.prototype, "eSparkline", void 0);
Gw([
  S("resizeObserverService")
], Mc.prototype, "resizeObserverService", void 0);
Gw([
  S("sparklineTooltipSingleton")
], Mc.prototype, "sparklineTooltipSingleton", void 0);
var kw = function(o, e, t, i) {
  var r = arguments.length, n = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n = Reflect.decorate(o, e, t, i);
  else
    for (var a = o.length - 1; a >= 0; a--)
      (s = o[a]) && (n = (r < 3 ? s(n) : r > 3 ? s(e, t, n) : s(e, t)) || n);
  return r > 3 && n && Object.defineProperty(e, t, n), n;
};
let bp = class extends H {
  postConstruct() {
    this.tooltip = new on();
  }
  getSparklineTooltip() {
    return this.tooltip;
  }
  destroyTooltip() {
    this.tooltip && this.tooltip.destroy();
  }
};
kw([
  B
], bp.prototype, "postConstruct", null);
kw([
  dt
], bp.prototype, "destroyTooltip", null);
bp = kw([
  q("sparklineTooltipSingleton")
], bp);
const tK = "30.0.5", iK = {
  version: tK,
  moduleName: Q.SparklinesModule,
  beans: [bp],
  userComponents: [{ componentName: "agSparklineCellRenderer", componentClass: Mc }],
  dependantModules: [Pi]
}, MP = [
  pG,
  DG,
  AV,
  _V,
  Bz,
  jz,
  Yz,
  qz,
  oP,
  Jz,
  jx,
  n2,
  h2,
  Ub,
  g2,
  C2,
  iK
];
Gx.concat(MP);
Z.registerModules(MP);
process.env.NODE_ENV !== "production" && Object.freeze({});
process.env.NODE_ENV !== "production" && Object.freeze([]);
const rK = (o) => typeof o == "symbol", nK = (o, e, t) => {
  Object.defineProperty(o, e, {
    configurable: !0,
    enumerable: !1,
    value: t
  });
};
Symbol(process.env.NODE_ENV !== "production" ? "iterate" : "");
Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((o) => o !== "arguments" && o !== "caller").map((o) => Symbol[o]).filter(rK)
);
function wg(o) {
  const e = o && o.__v_raw;
  return e ? wg(e) : o;
}
function lC(o) {
  return nK(o, "__v_skip", !0), o;
}
class wp {
  static getComponentDefinition(e, t) {
    let i;
    return typeof e == "string" ? i = this.searchForComponentInstance(t, e) : i = { extends: Fe(Object.assign({}, e)) }, i || console.error(`Could not find component with name of ${e}. Is it in Vue.components?`), i.extends ? (i.extends.setup && (i.setup = i.extends.setup), i.extends.props = this.addParamsToProps(i.extends.props)) : i.props = this.addParamsToProps(i.props), i;
  }
  static addParamsToProps(e) {
    return !e || Array.isArray(e) && e.indexOf("params") === -1 ? e = ["params", ...e || []] : typeof e == "object" && !e.params && (e.params = {
      type: Object
    }), e;
  }
  static createAndMountComponent(e, t, i, r) {
    const n = wp.getComponentDefinition(e, i);
    if (!n)
      return;
    const { vNode: s, destroy: a, el: l } = this.mount(n, { params: Object.freeze(t) }, i, r || {});
    return {
      componentInstance: s.component.proxy,
      element: l,
      destroy: a
    };
  }
  static mount(e, t, i, r) {
    let n = Ce(e, t);
    n.appContext = i.$.appContext, n.appContext.provides = Object.assign(Object.assign(Object.assign({}, r), n.appContext.provides ? n.appContext.provides : {}), i.$parent.$options.provide ? i.$parent.$options.provide : {});
    let s = document.createElement("div");
    return Ww(n, s), { vNode: n, destroy: () => {
      s && Ww(null, s), s = null, n = null;
    }, el: s };
  }
  static searchForComponentInstance(e, t, i = 10, r = !1) {
    let n = null, s = e.$parent, a = 0;
    for (; !n && s && s.$options && ++a < i; ) {
      const l = s;
      n = l.$options && l.$options.components ? l.$options.components[t] : null, s = s.$parent;
    }
    if (!n) {
      const l = e.$.appContext.components;
      l && l[t] && (n = l[t]);
    }
    return !n && !r ? (console.error(`Could not find component with name of ${t}. Is it in Vue.components?`), null) : n;
  }
}
class Ih extends JN {
  constructor(e, t) {
    super(), this.parent = e, Ih.provides || (Ih.provides = t);
  }
  createWrapper(e) {
    const t = this;
    class i extends oK {
      init(s) {
        super.init(s);
      }
      hasMethod(s) {
        return r.getFrameworkComponentInstance()[s] != null;
      }
      callMethod(s, a) {
        const l = this.getFrameworkComponentInstance();
        return r.getFrameworkComponentInstance()[s].apply(l, a);
      }
      addMethod(s, a) {
        r[s] = a;
      }
      overrideProcessing(s) {
        return t.parent.autoParamsRefresh && s === "refresh";
      }
      processMethod(s, a) {
        return s === "refresh" && (this.getFrameworkComponentInstance().params = a[0]), this.hasMethod(s) ? this.callMethod(s, a) : s === "refresh";
      }
      createComponent(s) {
        return t.createComponent(e, s);
      }
    }
    const r = new i();
    return r;
  }
  createComponent(e, t) {
    return wp.createAndMountComponent(e, t, this.parent, Ih.provides);
  }
  createMethodProxy(e, t, i) {
    return function() {
      return e.overrideProcessing(t) ? e.processMethod(t, arguments) : e.hasMethod(t) ? e.callMethod(t, arguments) : (i && console.warn("AG Grid: Framework component is missing the method " + t + "()"), null);
    };
  }
  destroy() {
    this.parent = null;
  }
}
class oK {
  getGui() {
    return this.element;
  }
  destroy() {
    this.getFrameworkComponentInstance() && typeof this.getFrameworkComponentInstance().destroy == "function" && this.getFrameworkComponentInstance().destroy(), this.unmount();
  }
  getFrameworkComponentInstance() {
    return this.componentInstance;
  }
  init(e) {
    const { componentInstance: t, element: i, destroy: r } = this.createComponent(e);
    this.componentInstance = t, this.unmount = r, this.element = i.firstElementChild;
  }
}
const sK = (o) => o.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), aK = (o) => `on${o.charAt(0).toUpperCase()}${o.substring(1, o.length)}`, lK = () => {
  const o = {};
  ke.PUBLIC_EVENTS.map((i) => aK(sK(i))).forEach((i) => o[i] = void 0);
  const t = {};
  return ke.ALL_PROPERTIES.filter((i) => i != "gridOptions").forEach((i) => {
    o[i] = {}, t[i] = {
      handler(r, n) {
        this.processChanges(i, r, n);
      },
      deep: i !== "popupParent" && i !== "context"
    };
  }), [o, t];
};
class cK extends Rx {
  constructor(e) {
    super(), this.parent = e;
  }
  /*
   * vue components are specified in the "components" part of the vue component - as such we need a way to determine
   * if a given component is within that context - this method provides this
   * Note: This is only really used/necessary with cellRendererSelectors
   */
  frameworkComponent(e, t) {
    let i = wp.searchForComponentInstance(this.parent, e, 10, !0) ? e : null;
    if (!i && t && t[e]) {
      const r = t[e];
      i = wp.searchForComponentInstance(this.parent, r, 10, !0) ? r : null;
    }
    return i;
  }
  isFrameworkComponent(e) {
    return typeof e == "object";
  }
}
const dK = ["rowDataChanged", "rowDataUpdated", "cellValueChanged", "rowValueChanged"], lR = "onUpdate:modelValue", uK = "update:modelValue", [hK, pK] = lK(), fK = Fe({
  render() {
    return kP("div");
  },
  props: Object.assign({ gridOptions: {
    type: Object,
    default: () => ({})
  }, autoParamsRefresh: {
    type: Boolean,
    default: () => !1
  }, componentDependencies: {
    type: Array,
    default: () => []
  }, plugins: [], modules: {
    type: Array,
    default: () => []
  }, modelValue: {
    type: Array,
    default: void 0,
    required: !1
  } }, hK),
  data() {
    return {
      gridCreated: !1,
      isDestroyed: !1,
      gridReadyFired: !1,
      emitRowModel: void 0
    };
  },
  watch: Object.assign({ modelValue: {
    handler(o, e) {
      this.processChanges("rowData", o, e);
    },
    deep: !0
  } }, pK),
  methods: {
    globalEventListener(o, e) {
      this.isDestroyed || (o === "gridReady" && (this.gridReadyFired = !0), this.updateModelIfUsed(o));
    },
    processChanges(o, e, t) {
      if (this.gridCreated) {
        if (this.skipChange(o, e, t))
          return;
        const i = {};
        i[o] = {
          // decouple the row data - if we don't when the grid changes row data directly that'll trigger this component to react to rowData changes,
          // which can reset grid state (ie row selection)
          currentValue: o === "rowData" ? Object.isFrozen(e) ? e : lC(wg(e)) : e,
          previousValue: t
        }, ke.processOnChange(i, this.gridOptions.api);
      }
    },
    checkForBindingConflicts() {
      const o = this;
      (o.rowData || this.gridOptions.rowData) && o.modelValue && console.warn("AG Grid: Using both rowData and v-model. rowData will be ignored.");
    },
    getRowData() {
      const o = [];
      return this.gridOptions.api.forEachNode((e) => {
        o.push(e.data);
      }), o;
    },
    updateModelIfUsed(o) {
      this.gridReadyFired && this.$attrs[lR] && dK.indexOf(o) !== -1 && this.emitRowModel && this.emitRowModel();
    },
    getRowDataBasedOnBindings() {
      const o = this, e = o.modelValue;
      return e || (o.rowData ? o.rowData : o.gridOptions.rowData);
    },
    getProvides() {
      let o = VP(), e = {};
      for (; o; )
        o && o.provides && (e = Object.assign(Object.assign({}, e), o.provides)), o = o.parent;
      return e;
    },
    /*
    * Prevents an infinite loop when using v-model for the rowData
    */
    skipChange(o, e, t) {
      if (this.gridReadyFired && o === "rowData" && this.$attrs[lR]) {
        if (e === t)
          return !0;
        if (e && t) {
          const i = e, r = t;
          if (i.length === r.length) {
            for (let n = 0; n < i.length; n++)
              if (i[n] !== r[n])
                return !1;
            return !0;
          }
        }
      }
      return !1;
    },
    debounce(o, e) {
      let t;
      return () => {
        const i = function() {
          o();
        };
        window.clearTimeout(t), t = window.setTimeout(i, e);
      };
    }
  },
  mounted() {
    this.emitRowModel = this.debounce(() => {
      this.$emit(uK, Object.freeze(this.getRowData()));
    }, 20);
    const o = this.getProvides(), e = new Ih(this, o), t = lC(ke.copyAttributesToGridOptions(wg(this.gridOptions), this, !0));
    this.checkForBindingConflicts();
    const i = this.getRowDataBasedOnBindings();
    t.rowData = i && (Object.isFrozen(i) ? i : lC(wg(i)));
    const r = {
      globalEventListener: this.globalEventListener.bind(this),
      frameworkOverrides: new cK(this),
      providedBeanInstances: {
        frameworkComponentWrapper: e
      },
      modules: this.modules
    };
    new _x(this.$el, t, r), this.gridCreated = !0;
  },
  unmounted() {
    this.gridCreated && (this.gridOptions.api && this.gridOptions.api.destroy(), this.isDestroyed = !0);
  }
});
const gK = {
  data() {
    return {
      QIcon: Lo,
      QItem: gR,
      QMenu: fR,
      QList: mR,
      QItemSection: vR,
      ClosePopup: yR,
      mdiSortAscending: Eg,
      mdiSortDescending: Rg,
      mdiChevronDown: SR,
      mdiMagnify: Pv,
      ascSort: null,
      descSort: null,
      noSort: "active"
    };
  },
  beforeUnmount() {
    this.params.column.removeEventListener(
      "sortChanged",
      this.onSortChanged
    );
  },
  computed: {
    sortColIcon() {
      return this.descSort === "active" ? Eg : Rg;
    },
    sortText() {
      return this.descSort === "active" ? "descending" : "ascending";
    }
  },
  methods: {
    searchColumn() {
      this.params.showColumnMenu(this.$refs.menuButton);
    },
    onSortChanged() {
      this.ascSort = this.descSort = this.noSort = "inactive", this.params.column.isSortAscending() ? this.ascSort = "active" : this.params.column.isSortDescending() ? this.descSort = "active" : this.noSort = "active";
    },
    onSortRequested(o) {
      let e = this.noSort === "active" ? "asc" : this.ascSort === "active" ? "desc" : "";
      this.params.setSort(e, o.shiftKey);
    }
  },
  mounted() {
    this.params.column.addEventListener("sortChanged", this.onSortChanged), this.onSortChanged();
  }
}, vK = (o) => (Zl("data-v-152745a7"), o = o(), Ql(), o), mK = { class: "bs-grid-header-container" }, yK = { class: "bs-grid-col-header-title-container" }, CK = { class: "bs-grid-col-header-title" }, SK = {
  key: 0,
  class: "bs-grid-col-header-title-icon",
  ref: "menuButton"
}, bK = /* @__PURE__ */ vK(() => /* @__PURE__ */ Re("div", null, "Search", -1)), wK = {
  key: 0,
  class: "bs-grid-col-header-data-type"
};
function EK(o, e, t, i, r, n) {
  const s = ue("q-icon"), a = ue("q-item-section"), l = ue("q-item"), c = ue("q-list"), d = ue("q-menu"), u = dS("close-popup");
  return ce(), je("div", mK, [
    Re("div", yK, [
      Re("div", CK, Bt(o.params.displayName), 1),
      o.params.enableMenu ? (ce(), je("div", SK, [
        Ce(s, {
          name: r.mdiChevronDown,
          size: "1rem"
        }, {
          default: fe(() => [
            Ce(d, {
              anchor: "bottom middle",
              self: "top middle",
              "transition-show": "scale",
              "transition-hide": "scale",
              offset: [0, 10]
            }, {
              default: fe(() => [
                Ce(c, {
                  ref: "BsGridColHeaderActions",
                  class: "bs-grid-col-header-actions q-py-xs q-px-sm rounded-borders"
                }, {
                  default: fe(() => [
                    o.params.enableSorting ? (ce(), _e(l, { key: 0 }, {
                      default: fe(() => [
                        Ce(a, null, {
                          default: fe(() => [
                            Re("div", {
                              class: "bs-grid-col-header-action-section cursor-pointer",
                              onClick: e[0] || (e[0] = (...h) => n.onSortRequested && n.onSortRequested(...h))
                            }, [
                              Ce(s, {
                                name: n.sortColIcon,
                                size: "0.8rem",
                                class: Rr(["sort-icon", {
                                  sorted: r.noSort === "inactive"
                                }])
                              }, null, 8, ["name", "class"]),
                              Re("div", null, "Sort " + Bt(n.sortText), 1)
                            ])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })) : Ne("", !0),
                    pa((ce(), _e(l, null, {
                      default: fe(() => [
                        Ce(a, null, {
                          default: fe(() => [
                            Re("div", {
                              class: "bs-grid-col-header-action-section cursor-pointer",
                              onClick: e[1] || (e[1] = (...h) => n.searchColumn && n.searchColumn(...h))
                            }, [
                              Ce(s, {
                                name: r.mdiMagnify,
                                size: "0.8rem"
                              }, null, 8, ["name"]),
                              bK
                            ])
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })), [
                      [u]
                    ])
                  ]),
                  _: 1
                }, 512)
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["name"])
      ], 512)) : Ne("", !0)
    ]),
    o.params.column.colDef.dataType ? (ce(), je("div", wK, Bt(o.params.column.colDef.dataType), 1)) : Ne("", !0)
  ]);
}
const RK = /* @__PURE__ */ He(gK, [["render", EK], ["__scopeId", "data-v-152745a7"]]), TK = Fe({
  components: { QInput: Ov, QIcon: Lo },
  props: {
    params: { required: !0, type: Object }
  },
  data() {
    return {
      currentValue: null,
      mdiTrashCanOutline: bR
    };
  },
  mounted() {
    console.log("hello i am filter mounted", this.params);
  },
  methods: {
    onInputBoxChanged(o) {
      if (this.currentValue = o, this.currentValue === "") {
        this.params.parentFilterInstance((e) => {
          e.onFloatingFilterChanged(null, null);
        });
        return;
      }
      this.params.parentFilterInstance((e) => {
        e.onFloatingFilterChanged("contains", this.currentValue);
      });
    },
    onParentModelChanged(o) {
      o ? this.currentValue = o.filter : this.currentValue = "";
    },
    clearField() {
      this.onInputBoxChanged(""), this.params.column.colDef.floatingFilter = !1, setTimeout(() => {
        this.params.columnApi.resetColumnState();
      }, 0), console.log(this.params.column);
    }
  }
});
const xK = { class: "bs-search-grid-col-search-box" };
function DK(o, e, t, i, r, n) {
  const s = ue("q-icon"), a = ue("QInput");
  return ce(), je("div", xK, [
    Ce(a, {
      class: "bs-search-grid-col-input",
      "model-value": o.currentValue,
      "onUpdate:modelValue": o.onInputBoxChanged,
      clearable: "",
      "clear-icon": "close",
      borderless: "",
      dense: "",
      "format-input": "",
      autofocus: ""
    }, {
      prepend: fe(() => [
        Ce(s, {
          name: "search",
          size: "1rem"
        })
      ]),
      _: 1
    }, 8, ["model-value", "onUpdate:modelValue"]),
    Re("div", null, [
      Ce(s, {
        name: o.mdiTrashCanOutline,
        onClick: o.clearField,
        size: "1rem",
        class: "cursor-pointer"
      }, null, 8, ["name", "onClick"])
    ])
  ]);
}
const OK = /* @__PURE__ */ He(TK, [["render", DK]]), cR = /* @__PURE__ */ new Map([
  ["string", "text"],
  ["int", "number"],
  ["bigint", "number"],
  ["smallint", "number"],
  ["tinyint", "number"],
  ["float", "number"],
  ["double", "number"],
  ["boolean", "boolean"],
  ["date", "datestring"],
  ["object", "object"],
  ["map", "object"],
  ["array", "object"],
  ["default", "text"]
]), dR = /* @__PURE__ */ new Map([
  ["text", "agTextColumnFilter"],
  ["number", "agNumberColumnFilter"],
  ["date", "agDateColumnFilter"],
  ["default", "agTextColumnFilter"]
]), PK = /* @__PURE__ */ new Map([
  ["number", "numericColumn"],
  ["right", "rightAligned"],
  ["left", "leftAligned"]
]);
var Ch = /* @__PURE__ */ ((o) => (o.clientSide = "clientSide", o.serverSide = "serverSide", o))(Ch || {});
const cC = "dss-index", AK = Fe({
  name: "BsGrid",
  components: {
    AgGridVue: fK,
    agColumnHeader: RK,
    BsGridSearchColVue: OK,
    QInput: Ov,
    QIcon: Lo
  },
  props: {
    columns: {
      type: Array,
      required: !1
    },
    rows: {
      type: Array,
      required: !1
    },
    isLoading: {
      type: Boolean,
      default: !1
    },
    virtualScroll: {
      type: Boolean,
      default: !1
    },
    pageSize: {
      type: Number,
      default: 100
    },
    cacheBlockSize: {
      type: Number,
      default: 100
    },
    rowId: {
      type: String,
      default: cC
    },
    dssTableName: String,
    title: String,
    filters: Object,
    rowSelection: String,
    groupKey: String,
    saveSelectionState: Boolean
  },
  emits: [
    "update:rows",
    "update:columns",
    "update:loading",
    "update:selection-state",
    "error"
  ],
  data() {
    return {
      rowHeight: 36,
      headerHeight: 51,
      columnDefs: [],
      filterGridText: "",
      datasetColumns: void 0,
      datasetRows: void 0,
      params: void 0,
      gridApi: void 0,
      autoGroupColumnDef: void 0,
      loading: !1,
      rowModelType: this.dssTableName ? Ch.serverSide : Ch.clientSide,
      rowData: void 0,
      dataSource: void 0,
      selectionState: {
        selectAllChildren: !1,
        toggledNodes: []
      }
    };
  },
  methods: {
    onGridReady(o) {
      this.params = o, this.gridApi = o.api, this.autoSizeColumns(), this.loading = !1;
    },
    autoSizeColumns() {
      var e;
      const o = [];
      (e = this.params.columnApi.getColumns()) == null || e.forEach((t) => {
        o.push(t.getId());
      }), this.params.columnApi.autoSizeColumns(o, !1);
    },
    createBsGridCol(o) {
      const e = cR.get(o.dataType) || cR.get("default"), t = PK.get(e) || [], i = dR.get(e) || dR.get("default");
      return {
        headerName: o.name,
        field: o.name,
        sortable: !0,
        type: t,
        filter: i,
        dataType: o.dataType,
        rowGroup: o.name === this.groupKey,
        hide: o.name === this.groupKey
      };
    },
    fetchDatasetColumns() {
      this.loading = !0, xl.getDatasetGenericData(this.dssTableName).then(({ schema: o }) => {
        this.datasetColumns = o.columns.map(
          (e) => this.createBsGridCol({
            name: e.name,
            dataType: e.type
          })
        ), this.columnDefs = this.datasetColumns, this.autoSizeColumns();
      }).catch(
        (o) => this.handleError("Failed to fetch columns :" + o)
      ).finally(() => {
        this.loading = !1;
      });
    },
    transformDatasetRowsToGridRows(o, e) {
      var n;
      let t = [];
      if (o === "None")
        return t;
      const i = Object.entries(o);
      if (!(i != null && i.length))
        return t;
      const r = Object.keys(o[i[0][0]]);
      for (let s of r) {
        let a = {};
        (n = this.datasetColumns) == null || n.forEach((l) => {
          const c = e && l.field === this.groupKey;
          a[l.field] = c ? o[l.field][s] : null, a[cC] = s;
        }), t.push(a);
      }
      return t;
    },
    handleError(o) {
      console.log("got error:", o), this.$emit("error", o);
    },
    refreshData() {
      this.gridApi.refreshServerSide({ route: void 0, purge: !0 });
    },
    isDoingGrouping(o) {
      return o.rowGroupCols.length > o.groupKeys.length;
    },
    currentPageIndex(o) {
      return o.startRow && this.pageSize > 0 ? o.startRow / this.pageSize : void 0;
    },
    createDataSource() {
      return {
        // called by the grid when more rows are required
        getRows: (o) => {
          this.loading = !0;
          const e = o.request, t = this.currentPageIndex(e);
          console.log("request:", e), xl.getFilteredDataset(
            this.dssTableName,
            this.pageSize,
            t,
            this.filters,
            this.groupKey,
            e.groupKeys[0]
          ).then((i) => {
            this.datasetRows = this.transformDatasetRowsToGridRows(
              i,
              this.isDoingGrouping(e)
            ), o.success({
              rowData: this.datasetRows
            }), this.autoSizeColumns();
          }).catch((i) => {
            this.handleError("Failed to fetch rows :" + i), o.fail();
          }).finally(() => {
            this.loading = !1;
          });
        }
      };
    },
    getRowId(o) {
      return o.level > 0 ? "leaf" + o.level + "-" + o.data[this.rowId] : o.data[this.rowId];
    },
    prepareGridColStyle() {
      this.$refs.agGrid.gridOptions.defaultColDef = {
        flex: 1,
        headerComponentParams: { enableMenu: !0 },
        menuTabs: ["filterMenuTab"]
        //if not specified default is : ['generalMenuTab', 'filterMenuTab', 'columnsMenuTab']
      }, this.autoGroupColumnDef = {
        headerName: this.groupKey,
        field: this.groupKey,
        hide: !0,
        minWidth: 250,
        cellRenderer: "agGroupCellRenderer",
        cellRendererParams: {
          checkbox: !0
        },
        headerCheckboxSelection: this.rowSelection === "multiple",
        headerCheckboxSelectionCurrentPageOnly: !0
      };
    }
  },
  watch: {
    datasetColumns(o) {
      this.$emit("update:columns", o);
    },
    datasetRows(o) {
      this.$emit("update:rows", o);
    },
    loading(o) {
      this.$emit("update:loading", o);
    },
    dssTableName() {
      this.fetchDatasetColumns(), this.rowModelType = Ch.serverSide;
    },
    filters() {
      this.dssTableName && this.refreshData();
    },
    saveSelectionState() {
      var o;
      this.selectionState = (o = this.gridApi) == null ? void 0 : o.getServerSideSelectionState(), this.$emit("update:selection-state", this.selectionState);
    }
  },
  computed: {
    isDataClientSide() {
      return this.rowModelType === Ch.clientSide;
    }
  },
  mounted() {
    var o;
    this.dssTableName ? (this.fetchDatasetColumns(), this.dataSource = this.createDataSource()) : (this.columnDefs = this.columns, this.rowData = (o = this.rows) == null ? void 0 : o.map(
      (e, t) => cl(ui({}, e), { [cC]: t })
    )), this.prepareGridColStyle();
  }
});
const MK = {
  class: "bs-grid ag-theme-alpine",
  style: { height: "100%" }
}, _K = { class: "ag-root-wrapper bs-grid-title" }, IK = { class: "ag-root-wrapper bs-grid-header" }, FK = {
  key: 0,
  class: "bs-grid-search-grid-row"
};
function LK(o, e, t, i, r, n) {
  const s = ue("q-icon"), a = ue("QInput"), l = ue("ag-grid-vue");
  return ce(), je("div", MK, [
    Re("div", _K, Bt(o.title || o.dssTableName), 1),
    Re("div", IK, [
      o.isDataClientSide ? (ce(), je("div", FK, [
        Ce(a, {
          class: "bs-grid-search",
          type: "text",
          modelValue: o.filterGridText,
          "onUpdate:modelValue": e[0] || (e[0] = (c) => o.filterGridText = c),
          placeholder: "Search Items...",
          clearable: ""
        }, {
          prepend: fe(() => [
            Ce(s, {
              name: "search",
              size: "1rem"
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ])) : Ne("", !0)
    ]),
    Ce(l, {
      style: { height: "85%", "max-height": "100%", width: "100%" },
      ref: "agGrid",
      columnDefs: o.columnDefs,
      rowData: o.dssTableName ? null : o.rowData,
      quickFilterText: o.isDataClientSide ? o.filterGridText : null,
      rowHeight: o.rowHeight,
      rowSelection: o.rowSelection,
      rowModelType: o.rowModelType,
      getRowId: o.getRowId,
      pagination: !o.virtualScroll,
      paginationPageSize: o.pageSize,
      cacheBlockSize: o.cacheBlockSize,
      headerHeight: o.headerHeight,
      groupSelectsChildren: o.rowSelection === "multiple",
      autoGroupColumnDef: o.autoGroupColumnDef,
      onGridReady: o.onGridReady,
      serverSideDatasource: o.dataSource,
      paginateChildRows: "true"
    }, null, 8, ["columnDefs", "rowData", "quickFilterText", "rowHeight", "rowSelection", "rowModelType", "getRowId", "pagination", "paginationPageSize", "cacheBlockSize", "headerHeight", "groupSelectsChildren", "autoGroupColumnDef", "onGridReady", "serverSideDatasource"])
  ]);
}
const NK = /* @__PURE__ */ He(AK, [["render", LK], ["__scopeId", "data-v-0c0b0c0a"]]);
const GK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BsButton: wM,
  BsCheckbox: pI,
  BsContent: dC,
  BsDateRange: yI,
  BsDocumentation: uC,
  BsDrawer: Sh,
  BsDrawerBtn: DR,
  BsGrid: NK,
  BsHeader: bh,
  BsIcon: cI,
  BsImg: sI,
  BsLayoutDefault: sM,
  BsLayoutDrawer: OR,
  BsLayoutHeader: PR,
  BsMenuTab: AR,
  BsMenuTabs: MR,
  BsRange: IM,
  BsSelect: CM,
  BsSlider: AM,
  BsSpinner: NM,
  BsTab: IR,
  BsTabChild: Rp,
  BsTabIcon: dg,
  BsTabPageChildWrapper: gS,
  BsTabTitle: vS,
  BsTable: rI,
  BsToggle: gM,
  BsTooltip: TM,
  CheckSlotComponentsMixin: fS,
  ProvideMixin: pS
}, Symbol.toStringTag, { value: "Module" })), Y5 = {
  version: "1.4.1",
  install(o) {
    pA(o, { components: GK });
  }
}, X5 = "1.4.1";
export {
  wM as BsButton,
  pI as BsCheckbox,
  dC as BsContent,
  yI as BsDateRange,
  uC as BsDocumentation,
  Sh as BsDrawer,
  DR as BsDrawerBtn,
  NK as BsGrid,
  bh as BsHeader,
  cI as BsIcon,
  sI as BsImg,
  sM as BsLayoutDefault,
  OR as BsLayoutDrawer,
  PR as BsLayoutHeader,
  AR as BsMenuTab,
  MR as BsMenuTabs,
  IM as BsRange,
  CM as BsSelect,
  AM as BsSlider,
  NM as BsSpinner,
  IR as BsTab,
  Rp as BsTabChild,
  dg as BsTabIcon,
  gS as BsTabPageChildWrapper,
  vS as BsTabTitle,
  rI as BsTable,
  gM as BsToggle,
  TM as BsTooltip,
  fS as CheckSlotComponentsMixin,
  pS as ProvideMixin,
  Y5 as QuasarBs,
  xl as ServerApi,
  X5 as version
};
